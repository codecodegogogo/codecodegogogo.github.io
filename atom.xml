<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sunny</title>
  
  
  <link href="https://codecodegogogo.github.io/atom.xml" rel="self"/>
  
  <link href="https://codecodegogogo.github.io/"/>
  <updated>2024-06-05T03:30:36.000Z</updated>
  <id>https://codecodegogogo.github.io/</id>
  
  <author>
    <name>Sunny</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://codecodegogogo.github.io/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-ppt/"/>
    <id>https://codecodegogogo.github.io/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-ppt/</id>
    <published>2024-06-10T02:05:08.833Z</published>
    <updated>2024-06-05T03:30:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h5 id="ppt"><a href="#ppt" class="headerlink" title="ppt"></a>ppt</h5><ul><li><p>设计-》自定义-》设置背景格式-》【隐藏背景图形】用于隐藏母版添加的背景图形，如图片、形状、文字等等</p></li><li><p>主题和背景默认应用于全部幻灯片，切换用于当前选中幻灯片</p></li><li><p>smart art图形设置动画</p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-ppt/image-20240604163225423.png" alt="image-20240604163225423"></p></li><li><p>执行动画时执行完第一行按顺序执行第二行，播放时按照时间轴进行</p></li><li><p>触发器控制动画的触发</p></li><li><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-ppt/image-20240604200221234.png" alt="image-20240604200221234"></p></li><li><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-ppt/image-20240604200705330.png" alt="image-20240604200705330"></p></li><li><p>模板是主题和用于特定用途的一些内容，提供了演示文稿的格式，配色方案，母版样式以及产生特效的字体样式。</p></li><li><p>主题是演示文稿的颜色搭配，字体格式化以及一些特效的命令</p></li><li><p>母板定义文稿中幻灯片的格式，包括文本和对象在幻灯片中的位置，文本和对象占位符的大小，文本样式，效果，主题颜色，背景</p></li><li><p>在幻灯片中按Shift＋Enter组合键就可插人—张新的幻灯片。</p></li></ul><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-ppt/image-20240605083949126.png" alt="image-20240605083949126"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-ppt/image-20240605084222029.png" alt="image-20240605084222029"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://codecodegogogo.github.io/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://codecodegogogo.github.io/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2024-06-10T02:05:08.833Z</published>
    <updated>2024-06-06T08:05:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h3><ul><li><p>Access中’字段名称的长度最大为64个字符,文本字段大小255，数字、自动编号默认长整型</p></li><li><p>查询的数据来源可以是表’也可以是其他查询</p></li><li><p>设置为主键的字段系统自动设置索引</p></li><li><p>accdt 数据库模板</p></li><li><p>窗体对象中显示的字段为表对象或者查询对象中的字段</p></li><li><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604084208993.png" alt="image-20240604084208993"></p></li><li><p>查询：</p><p>选择查询：单表查询，多表连接查询</p><p>交叉表查询</p><p>操作查询：更新查询，生成表查询，追加查询，删除查询</p><p>参数查询</p><p>SQL查询</p></li></ul><h5 id="报表"><a href="#报表" class="headerlink" title="报表"></a>报表</h5><p>7个部分：报表页眉，页脚；页面页眉，页脚；组页眉，页脚；主体。</p><p>报表主体节中可以设置多个工具按钮</p><p>报表是只读的，只用于输出</p><h5 id="窗体"><a href="#窗体" class="headerlink" title="窗体"></a>窗体</h5><p>窗体页眉   主体   窗体页脚</p><h6 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h6><p>文本框、标签、按钮，选项卡，超链接，Web 浏览器控件和导航控件、组、分页符、组合框，图表、线条、切换按钮、列表框、矩形、复选框、未绑定对象框架、附件、选项按钮、子表单和子报表、绑定对象框架，甚至在表单上放置图像。</p><h5 id="表"><a href="#表" class="headerlink" title="表"></a>表</h5><h6 id="字段的命名规则"><a href="#字段的命名规则" class="headerlink" title="字段的命名规则:"></a>字段的命名规则:</h6><ul><li>长度为1~64个字符</li><li>可以含字母、汉字、数字、空格和其他字符</li><li>不能以空格开头， 不能仑含句号(. )、惊叹号(! )、方括号([]) 、单引号(’)</li><li>不能使用ASCII码为0~32的ASCII字符</li></ul><h6 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h6><p>文本:最多可以存储255个字符<br>备注:最多可以存储65 535个字符，不能对备注型字段进行排序和建立索引，所以在数据检索中速度要比文本型慢</p><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603210953293.png" alt="image-20240603210953293"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603212804707.png" alt="image-20240603212804707"><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603212939347.png" alt="image-20240603212939347"><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603213252126.png" alt="image-20240603213252126"><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603213619904.png" alt="image-20240603213619904"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603213749377.png" alt="image-20240603213749377"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603213846750.png" alt="image-20240603213846750"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603213918569.png" alt="image-20240603213918569"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603213953871.png" alt="image-20240603213953871"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603214022843.png" alt="image-20240603214022843"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603214105869.png" alt="image-20240603214105869"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603214136466.png" alt="image-20240603214136466"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603214213053.png" alt="image-20240603214213053"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603214231136.png" alt="image-20240603214231136"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603214459719.png" alt="image-20240603214300711"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604093731537.png" alt="image-20240604093731537"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604084645791.png" alt="image-20240604084645791"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604084750034.png" alt="image-20240604084750034"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604085116717.png" alt="image-20240604085116717"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604090325502.png" alt="image-20240604090325502"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604090622098.png" alt="image-20240604090622098"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604091914580.png" alt="image-20240604091914580"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604094520428.png" alt="image-20240604094520428"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604100431976.png" alt="image-20240604100431976"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604100501527.png" alt="image-20240604100501527"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604100526728.png" alt="image-20240604100526728"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604100550034.png" alt="image-20240604100550034"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240606160418969.png" alt="image-20240606160418969"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240606160436614.png" alt="image-20240606160436614"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240606160447488.png" alt="image-20240606160447488"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240606160459936.png" alt="image-20240606160459936"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240606160509378.png" alt="image-20240606160509378"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240606160530029.png" alt="image-20240606160530029"></p><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240606160541786.png" alt="image-20240606160541786"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机文化基础-excel</title>
    <link href="https://codecodegogogo.github.io/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/"/>
    <id>https://codecodegogogo.github.io/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/</id>
    <published>2024-05-23T00:30:47.000Z</published>
    <updated>2024-05-30T11:29:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="Excel2016"><a href="#Excel2016" class="headerlink" title="Excel2016"></a>Excel2016</h4><ul><li><p>主要功能有:</p><p>(1)表格制作;(2)图表功能;(3)数据处理和数据分析;(4)数据清单功能。</p></li><li><p>word2016新建工作簿只有1个工作表，工作簿缺省名叫工作簿1，只有1张工作表时不能删除工作表。</p></li><li><p>合并后的单元格和合并前的区域左上角的内容相同，其他省略。</p></li><li><p>模板名称.xltx  文件名 .xlsx</p></li><li><p>文本型数据左对齐，数字型数据和日期和时间型数据右对齐</p></li><li><p>直接左键拖动填充柄不能产生复制效果：时间，日期，数字字符串</p></li><li><p>直接左键拖动填充柄能产生复制效果：文本，数值</p></li><li><p>excel视图：普通视图，</p><p>分页预览，<img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527111947092.png" alt="image-20240527111947092">页面布局</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527112003814.png" alt="image-20240527112003814"></p></li><li><p>可以清除  批注 内容 格式 超链接</p></li><li><p>分页预览视图可以移动分页符</p></li><li><p>被打印的工作表最小缩放为10%，最大400%</p></li><li><p>一维数组的创建： 在上方的编辑栏内输入数组公式“={1,2,3,4,5}”，接着按Ctrl+shift+enter组合键来执行计算</p></li><li><p>输人“1   1／5”表示五分之六</p></li><li><p>Excel和WOrd之间共享信息的方式有两种’即对象的链接和对象的嵌人。</p></li><li><p>数据清单的第一列必须是文本类型</p></li><li><p>能够表现个体与整体之间关系的图表类型是饼图</p></li><li><p>汉字排序有笔划和字母</p></li><li><p>excel默认度量值11</p></li><li><p>Excel20l0提供了与假设前提相关的三种简单的数据分析方法:方案管理器｀单变量求解和模拟运算表</p></li><li><p>保护工作簿：审阅-》更改   可以组织添加删除隐藏表</p></li><li><p>保护工作表：审阅-》更改   可以阻止单元格，行，列一些操作</p></li><li><p>保护一些区域：选中允许操作的一些单元格，设置单元格格式-》保护，取消锁定，然后打开保护工作表</p></li><li><p>增加小数位数和百分比都会四舍五入</p></li></ul><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><ul><li>同时在多个单元格中输入相同的信息 ctrl+enter</li><li>按下&lt;Shift+F11&gt;组合键，可快速在当前工作表的前面插入一张新工作表。</li><li>双击输入有公式的单元格或者选择单元格再按f2，单元格显示公式</li><li>输入当天日期:&lt;Ctl +;&gt;键。输入当前时间:&lt;Ctl + Shift +;&gt;键。</li><li>alt+; 选择当前分类汇总屏幕内容</li><li>alt+I+H 插入图表</li><li>alt+f1 插入嵌入式图表   f11插入独立图表</li><li>f4可以切换引用方式</li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526165920913.png" alt="image-20240526165920913"></li><li>单元格内分段 alt+enter</li><li>打开单元格格式   ctrl+shift+f</li><li>移动到下一张工作表  ctrl+pagedown</li><li>shift+f2 插入批注</li><li>按住ctrl+任意方向键 跳转到该方向最近的有内容单元格</li></ul><h4 id="工作簿、工作表、单元格和单元格区域"><a href="#工作簿、工作表、单元格和单元格区域" class="headerlink" title="工作簿、工作表、单元格和单元格区域"></a>工作簿、工作表、单元格和单元格区域</h4><p>(1)工作簿(Book):是存储数据、进行数据运算以及数据格式化的文件。扩展名为.xlsx,工作簿可含有多个工作表(Sheet)(至少1个，无上限)。</p><p>(2)工作表:新建一个工作簿时，Excel2016自动创建1个工作表(系统默认，可修改)名为Sheet1。工作表的名字是可以改变的。工作表不是一个独立的文件,因此不能单独存盘的,直接删除，而不是删除到回收站中。</p><p><strong>1个工作表有16384列、1048576行。编号从A开始，最后一列为XFD:行编号从1开始最后一行为 1048576。</strong></p><p>同时选中多个工作表:使用 Ctrl或 shift 键结合鼠标操作。</p><p><strong>同时在多个工作表中输入信息（按ctrl选中多个工作簿后，输入），也可以同时在多个单元格中输入相同的信息 ctrl+enter（按ctrl选中多个单元格后，输入后ctrl+enter）</strong></p><p>移动:选中工作表，按住鼠标左键，拖动至目的地即可。<br>复制:选中工作表，按住Ctrl键，然后按住鼠标左键，拖动至目的地即可。</p><p>新建一个工作簿文件时，系统默认生成1个工作表。可以通过设置“文件”“选项”“常规”选项卡中的“包含的工作表数”修改新建工作簿文件含有的工作表数。最小数目是1,最大数目是 255。注:这个最大255 仅限于初始新建工作簿包含的工作表数。工作簿建立后,句含的工作表数最多没有限制，最少1个。</p><p>(3)单元格:工作表中行、列交叉的位置称为单元格，是工作表最基本的数据单元，是<strong>电子表格软件中处理数据的最小单位</strong>。单元格名称:也称为单元格地址，由单元格所处的列名(在前)和行名(在后)组成。在同一时刻只有一个单元格处于活动状态。每个单元格内容长度的最大限制是32767个字符。</p><p><strong>一个工作表最多有1048576*16384个单元格，一个单元格长度最大32767</strong></p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524110256693.png" alt="image-20240524110256693" style="zoom:200%;"><h4 id="工作表的管理"><a href="#工作表的管理" class="headerlink" title="工作表的管理"></a>工作表的管理</h4><h5 id="单元格区域命名"><a href="#单元格区域命名" class="headerlink" title="单元格区域命名"></a>单元格区域命名</h5><p>用户可以为所选择的某个单元格区域定义一个名称。名称的定义和管理可通过<strong>“公式”选项卡中的“定义的名称”</strong>来实现。</p><ul><li>(1)新建名称:切换至“公式”选项卡在“定义的名称”组中单击“定义名称”按钮,打开“新建名称”对话框。</li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524111312375.png" alt="image-20240524111312375"></li><li>(2)根据所选内容创建:<br>根据所选内容创建是指在所选单元格区域中选择某一单元格中的数据作为名称,可以是首行、末行中的值,也可以是最左列、最右列中的值。</li><li>(3)除了运用上述方法外,用户还可利用名称框直接定义名称。具体方法是:选择需要定义的单元格区域,如E2:E11,在名称框中输人需要定义的名称,如“英语”,然后按 Enter 键即可。</li><li>重命名不能取消</li></ul><p>单击名称框右边的下拉箭头,即可看到以上述方法定义的两个单元格区域名称,选择“所有成绩”后,显示该名称对应的单元格区域。</p><h5 id="移动或复制工作表"><a href="#移动或复制工作表" class="headerlink" title="移动或复制工作表"></a>移动或复制工作表</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524112430215.png" alt="image-20240524112430215"></p><p>开始-&gt;单元格-&gt;格式-&gt;移动或复制工作表</p><p><strong>勾选建立副本则为复制</strong></p><p>通过拖动鼠标的方式移动或复制工作表:打开要进行操作的两个工作簿,在“视图”选项卡的“窗口”组中,选择“全部重排”命令,打开“重排窗口”对话框,这里选择“垂直并排”,然后单击“确定”按钮。</p><p>拖动工作表标签即可在不同的工作簿之间实现移动或复制操作。</p><h5 id="插入表"><a href="#插入表" class="headerlink" title="插入表"></a>插入表</h5><ul><li>(1)单击工作表标签右侧的“插入工作表”按钮，可快速插入新工作表。</li><li>(2)按下&lt;Shift+F11&gt;组合键，可快速在当前工作表的前面插入一张新工作表。</li><li>(3)在“开始”选项卡的“单元格”组中，单击“插人”按钮右侧的下拉按钮，在弹出的下拉列表中单击“插入工作表”选项。</li><li>(4)使用鼠标右键单击某个工作表标签,在弹出的快捷菜单中单击“插入”命令,打开“插入”对话框。在“常用”选项卡的列表框中选择“工作表”，然后单击“确定”按钮，即可在当前工作表的前面插入一张新工作表。<strong>如果要添加多个工作表，可以同时选定与待添加工作表数目相同的工作表标签。</strong></li></ul><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523095221791.png" alt="image-20240523095221791"></p><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><ul><li>(1)右击需要删除的工作表标签，在弹出的快捷菜单中单击“删除”命令。</li><li>(2)选中需要删除的工作表，在“开始”选项卡的“单元格”组中，单击“删除”按钮右侧的下拉按钮，在弹出的下拉列表中单击“删除工作表”选项。删除工作表是永久删除无法撤消删除操作，其右侧的工作表将成为当前工作表。</li></ul><h5 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h5><ul><li>(1)右击要重命名的工作表标签，在弹出的快捷菜单中单击“重命名”命令。</li><li>(2)双击相应的工作表标签，输入新名称覆盖原有名称即可。</li><li>(3)在“开始”选项卡的“单元格”选项组中，从“格式”按钮中选择“重命名工作表命令。</li></ul><h5 id="保护工作表"><a href="#保护工作表" class="headerlink" title="保护工作表"></a>保护工作表</h5><ul><li>选中需要保护的工作表,单击“文件”选项卡,在左侧窗格中单击“信息”命令,在右侧单击“保护工作簿”按钮,在打开的下拉列表中单击“保护当前工作表”选项;</li><li>或者单击“开始”选项卡“单元格”组中的“格式”按钮,选择下拉列表中的“保护工作表”命令;</li><li>或者单击“审阅”选项卡“更改”组中的“保护工作表”</li></ul><h5 id="隐藏工作表和取消隐藏"><a href="#隐藏工作表和取消隐藏" class="headerlink" title="隐藏工作表和取消隐藏"></a>隐藏工作表和取消隐藏</h5><p>选中要隐藏的工作表，在“开始”选项卡的“单元格”组中单击“格式”按钮，在弹出的下拉列表的“可见性”栏中，依次单击“隐藏和取消隐藏”→“隐藏工作表”选项。</p><p><strong>工作簿，工作表，行，列，单元格都可以被隐藏</strong>？</p><p>工作簿隐藏在视图选项卡窗口组</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523100830378.png" alt="image-20240523100830378"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523100635580.png" alt="image-20240523100635580"></p><h4 id="行，列。单元格"><a href="#行，列。单元格" class="headerlink" title="行，列。单元格"></a>行，列。单元格</h4><h5 id="单元格，单元区域重命名"><a href="#单元格，单元区域重命名" class="headerlink" title="单元格，单元区域重命名"></a>单元格，单元区域重命名</h5><p>选中要命名的单元格或单元格区域后</p><ul><li>1)右击鼠标，从快捷菜单中选择“定义名称”命令，在弹出的“新建名称”对话框中输入新的名称。</li><li>2)在名称框中输入新的名称</li><li>3)“公式”→“定义名称”</li><li>4)“公式”→“根据所选内容创建’</li></ul><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526165738544.png" alt="image-20240526165738544"></p><p>注:单元格重命名时应遵循以下规则:<br>不能以数字开头，可以以下划线、字母或汉字开头<br>不能包含空格<br>不能与Excel系统的默认名称重名。</p><h5 id="插入行，列，单元格"><a href="#插入行，列，单元格" class="headerlink" title="插入行，列，单元格"></a>插入行，列，单元格</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524152727565.png" alt="image-20240524152727565"></p><p>插入单元格时,会打开“插入”对话框</p><ul><li>活动单元格右移:在当前单元格的左侧插入一个或多个单元格</li><li>活动单元格下移:在当前单元格的上方插人一个或多个单元格,</li><li>整行:在当前单元格的上方插入一行或多行。</li><li>整列:在当前单元格的左侧插人一列或多列。</li></ul><h5 id="删除行，列，单元格"><a href="#删除行，列，单元格" class="headerlink" title="删除行，列，单元格"></a>删除行，列，单元格</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524152810563.png" alt="image-20240524152810563"></p><h5 id="行列的隐藏和取消隐藏"><a href="#行列的隐藏和取消隐藏" class="headerlink" title="行列的隐藏和取消隐藏"></a>行列的隐藏和取消隐藏</h5><p>选中要隐藏的行或列,右击,在打开的快捷菜单中选择“隐藏”命令;或按Cul+9把选中的行隐藏,按 Ctrl+0 把选中的列隐藏。</p><p>取消隐藏时选中隐藏行列的上下行列，快捷菜单取消隐藏</p><h5 id="单元格的合并"><a href="#单元格的合并" class="headerlink" title="单元格的合并"></a>单元格的合并</h5><p>可以取消合并，但是不能拆分单元格</p><p>合并后居中:将多个单元格合并成一个,且内容在合并后单元格的对齐方式是居中对齐</p><p>跨越合并:行与行之间相互合并,而上下单元格之间不参与合并。<br>合并单元格:将选择的多个单元格合并成一个较大的单元格。</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524153523091.png" alt="image-20240524153523091"></p><h5 id="单元格的引用"><a href="#单元格的引用" class="headerlink" title="单元格的引用"></a>单元格的引用</h5><p>单元格的引用:分为相对引用和绝对引用，系统默认是相对引用。</p><p>相对引用:单元格引用是随着公式的位置的改变而改变。公式的值将会随更改后的单元格地址的值重新计算。例如公式“=A1”就属于单元格的相对引用。</p><p>绝对引用:公式中的单元格或单元格区域地址不随着公式位置的改变而发生改变不论公式的单元格位置如何变化，公式中所引用的单元格位置都是其在工作表中的确切位置。绝对单元格引用的形式是:在每一个列标号及行号前面增加一个“$”符号，例如“=1.06*$C$4”</p><p>混合引用:指单元格或单元格区域地址部分是相对引用，部分是绝对引用。例如:$B2或者 B$2。</p><p><strong>注意:相对引用、绝对引用、混合引用相互转化可以用F4。</strong></p><p>三维地址引用:Excel中引用单元格时，不仅可以引用同一工作表中的单元格，还可以引用不同工作表中的单元格。格式为:[工作簿]+工作表名!+单元格引用。<br><strong>例如:[Book2]Sheet1!E3，表示工作簿 Book2的Sheetl 工作表的第三行第E列单元格。</strong></p><h5 id="设置单元格格式"><a href="#设置单元格格式" class="headerlink" title="设置单元格格式"></a>设置单元格格式</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524090504348.png" alt="image-20240524090504348"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524090508331.png" alt="image-20240524090508331"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524102657735.png" alt="image-20240524102657735"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524090512518.png" alt="image-20240524090512518"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524090516539.png" alt="image-20240524090516539"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524090522115.png" alt="image-20240524090522115"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524090524904.png" alt="image-20240524090524904"></p><h5 id="行高和列宽的调整"><a href="#行高和列宽的调整" class="headerlink" title="行高和列宽的调整"></a>行高和列宽的调整</h5><ul><li><p>通过拖动鼠标实现</p></li><li><p>双击分隔线实现<br>双击行号之间的分隔线或列标之间的分隔线，可实现自动调整行高或列宽。</p></li><li><p>通过对话框实现</p><p>如果需要设置更为精确的行高或列宽，在“开始”选项卡的“单元格”组中单击“格式”按钮，在弹出的下拉列表中单击“列宽”或“行高”选项，会弹出“列宽”或“行高”对话框。    </p></li><li><p>如果要将某一列的列宽复制到其他列中，则选定该列中的单元格，使用“复制”命令，然后选定目标列，在“选择性粘贴”对话框中，单击“列宽”选项，再单击“确定”按钮即可。</p></li></ul><p><strong>同一行的行高相同，同一列的列宽相同。</strong></p><h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><h6 id="自动套用格式"><a href="#自动套用格式" class="headerlink" title="自动套用格式"></a>自动套用格式</h6><p>开始-&gt;样式-&gt;套用表格格式</p><h6 id="条件格式"><a href="#条件格式" class="headerlink" title="条件格式"></a>条件格式</h6><p>开始-&gt;样式-&gt;条件格式</p><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524154007232.png" alt="image-20240524154007232"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524154035194.png" alt="image-20240524154035194"></p><h5 id="批注"><a href="#批注" class="headerlink" title="批注"></a>批注</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524154316767.png" alt="image-20240524154316767"></p><p>设置批注的单元格右上角有红色倒立三角</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524154400152.png" alt="image-20240524154400152"></p><h5 id="输入和编辑数据"><a href="#输入和编辑数据" class="headerlink" title="输入和编辑数据"></a>输入和编辑数据</h5><p>Excel 2016单元格中可以接受的数据类型有:文本类型(字符、文字)、数字(值)、日期和时间、公式与函数。</p><ul><li><p>单击输入数据的单元格直接输入  改写</p></li><li><p>单击单元格，在编辑栏输入   插入</p></li><li><p>双击单元格   插入</p></li><li><p>拖动复制：1.使用剪贴板  2.按住ctrl，鼠标指针变为十字空心箭头，拖动</p></li><li><p>移动剪切：1.使用剪贴板  2.鼠标指针变为十字空心箭头，拖动</p></li><li><p>选择性粘贴：</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523103657521.png" alt="image-20240523103657521"></p></li></ul><p>word中可以输入的两类数据：常量和公式</p><p><strong>执行表格中的数据行列交换，可以使用选择性粘贴的转置进行操作</strong></p><h5 id="数据填充"><a href="#数据填充" class="headerlink" title="数据填充"></a>数据填充</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523110205088.png" alt="image-20240523110205088"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523110137636.png" alt="image-20240523110137636"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526171441310.png" alt="image-20240526171441310"></p><p>开始-&gt;编辑-&gt;填充-&gt;序列</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523110314195.png" alt="image-20240523110314195"></p><p>生成等差数列时可以选中两行直接拖动填充柄</p><p>按住右键拖动单元格右下角</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524143100183.png" alt="image-20240524143100183"></p><p><strong>输入数据后按enter定位到下方单元格，按tab定位到右边单元格</strong></p><h5 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h5><p>数据-&gt;数据工具-&gt;数据验证-&gt;数据验证</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524152017032.png" alt="image-20240524152017032"></p><h5 id="数据清除和数据删除"><a href="#数据清除和数据删除" class="headerlink" title="数据清除和数据删除"></a>数据清除和数据删除</h5><p>数据清除指的是清除单元格格式、单元格中的内容及格式、批注、超链接等，单元格身并不受影响。<br>在“开始”选项卡的“编辑”组中,单击“清除”按钮。数据清除后单元格本身“清除批注”、保留在原位置不变。</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523113254718.png" alt="image-20240523113254718"></p><p>选定单元格或单元格区域后按Delete键，相当于选择“清除内容”命令,<br>数据删除的对象是单元格、行或列，即单元格、行或列的删除。删除后，选取的单元格行或列连同里面的数据都从工作表中消失。</p><h5 id="文本类型"><a href="#文本类型" class="headerlink" title="文本类型"></a>文本类型</h5><p>文本可以是字母、汉字、数字、空格或者其他字符，以及它们的组合，<strong>默认对齐方式左对齐。</strong></p><p>把数字作为文本输入:先输人一个半角的单引号‘，再输入相应的字符;</p><h5 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h5><p>0-9，+-,./$%eE     <strong>默认右对齐</strong></p><p>分数： 前面先输0和一个空格，分数2/3输入“0 2/3”</p><p>负数：前面直接输负号，或者数两边添加小括号</p><p>直接输入2/3，系统视为日期，2月3日</p><p>数字内部使用千分号，不认为是标点符号</p><p>在单元格中输人超过11位的数字时,Excel会自动使用科学计数法来显示该数字。比如,在单元格中输人数字“1357 924 681012”,则该数字将显示为“1.35792E+12”。无论显示的数字的位数如何,Excel 2016都只保留15 位的数字精度。如果数字长度超出了15位,则Excel 2016会将多余的数字位转换为0(零)。</p><p>在 Excel 2016 中，若一单元格值为 0.05245，使用百分数按钮来格式化，然后连续按两下增加位数按钮，则显示内容为5.25%。为什么?<br>答:连续按两下增加位数按钮，表示小数点保留两位，注意四舍五入。</p><h5 id="日期和时间型数据类型"><a href="#日期和时间型数据类型" class="headerlink" title="日期和时间型数据类型"></a>日期和时间型数据类型</h5><p>Excel 2016将日期和时间型数据作为数据处理，<strong>默认对齐方式:右对齐。</strong></p><p>日期分隔符:“/”、“_”; 2022-8-16、2022/8/16、16/Aug/2022、16-Aug-2022，都表示2022年8月16日。（顺序或者逆序）</p><p>时间分隔符:“:”(冒号)<br>如果仅输人月份和日，Excel2016则将计算机当前内部时钟的年份作为默认值</p><p>输入时间:<br>(1)24小时制可以只输入时和分，例如(23:00);也可以只输入小时数和冒号例如(23:);也可以输人一个大于 24的小时数，系统将自动进行转换;</p><p>(2)12小时制可以在时间后面输入一个空格，然后输人AM或者PM(也可以是A或者P)，表示上午或下午。例如“3:00AM”表示凌晨3:00，而“3:00PM”则表示下午 3:00,或者 15:00了。注意:“3:AM”的写法不能表示上午 3:00，应修改为“3:00AM”</p><p>输入当天日期:&lt;Ctl +;&gt;键。输入当前时间:&lt;Ctl + Shift +;&gt;键。</p><h5 id="逻辑型数据"><a href="#逻辑型数据" class="headerlink" title="逻辑型数据"></a>逻辑型数据</h5><p>居中对齐</p><h5 id="运算符的种类"><a href="#运算符的种类" class="headerlink" title="运算符的种类"></a>运算符的种类</h5><p>公式中的运算符类型:算术运算符、比较运算符、文本运算符、引用运算符。</p><p>算术运算符:十、一、*、/、%、^。用于完成基本的算数运算。</p><p>比较运算符:-&gt;=、&lt;=、&lt;&gt;。用于实现两个值的比较，结果是 TRUE或者FALSE，<strong>参加算数运算时</strong>TRUE为1，FALSE为0。</p><p>文本运算符:&amp;。用于连接一个或者多个文本数据以产生组合的文本。</p><p>单元格引用运算符:<br>冒号:称为区域表示运算符;<br>空格区域交集运算符;<br>逗号，区域并集运算符。</p><p>4.在Excel 2016中，如果 A4单元格的值为100，那么公式“=A4&gt;100”的结果是FLASE</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523175236370.png" alt="image-20240523175236370"></p><h5 id="公式和函数"><a href="#公式和函数" class="headerlink" title="公式和函数"></a>公式和函数</h5><p>公式:由参与运算的数据和运算符组成，在输入时必须以“=”开头。函数:Excel 2016 提供了大量内置函数，包括日期和时间函数、数学与三角函数、统计、查找与引用、数据库、文本、逻辑、信息等方面。函数由函数名、括号和参数组成。</p><p>参数:可以是数字、文本、形如TRUE或FALSE的逻辑值、数组、形如 #N/A 的错误值MIN或单元格引用。给定的参数必须能产生有效的值。参数也可以是常量、公式或其他函数。</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524085757795.png" alt="image-20240524085757795"></p><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>(1)求和函数 SUM:<br>求和函数 SUM 的语法格式为 SUM(numberl,number2,…),其中numberl、number2、……为需要求和的参数。<strong>如果参数为数组或引用,只有其中的数字被计算,数组或引用中的空白单元格逻辑值、文本或错误值将被忽略</strong>。如果参数为错误值或不能转换成数字的文本,将会导致错误。</p><p>(2)单条件求和函数SUMIF:<br>SUMIF 函数的语法格式为SUMIF(range,criteria,[sum_range),用于对区域中符合指定条件的值求和。</p><p>range参数必选,用于条件计算的单元格区域。每个区域中的单元格都必须是数字或名称、数组或包含数字的引用,空值和文本值将被忽略。</p><p>criteria 参数必选,用于确定对哪些单元格求和的条件,其形式可以为数字、表达式、单元格引用、文本或函数。例如,条件可以表示为 32、”&gt;32”、B5、”32”或 TODAY0等。<strong>任何文本条件或任何含有逻辑或数学符号的条件都必须用双引号括起来。</strong>如果条件为数字,则无须使用双引号。</p><p>sum range 参数可选,指要求和的实际单元格。如果sum_range参数被省略,Excel会对range 参数中指定的单元格(即应用条件的单元格)求和。</p><p>在条件中可以使用通配符,即问号(?)和星号(*)。问号匹配任意单个字符,星号匹配任意一系列字符。若要查找实际的问号或星号,需在该字符前键入波形(~)。条件不区分大小写。</p><p>(3)求平均值函数AVERAGE:<br>AVERAGE函数的语法格式为AVERAGE(numberl,number2,…),其中 numberlnumber2、……为要计算平均值的参数。参数可以是数字或涉及数字的名称、数组或引用。如果数组或单元格引用参数中有文字、逻辑值或空白单元格,则忽略其值;如果单元格包含零值,则计算在内。</p><p>(4)COUNT函数:<br>COUNT 函数计算包含数字的单元格以及参数列表中数字的个数。使用函数COUNT可以获取区域或数字数组中数字输入项的个数。</p><p>例如,若“=COUNT(A1:A20)”的返回值为5,说明该区域中有5个单元格包含数字。</p><p>如果参数为数字、日期、逻辑值或者代表数字的文本(例如,加引号的数字,如”1”),则将被计算在内。如果参数为错误值或不能转换为数字的文本,则不会被计算在内。如果参数为数组或引用,则只计算数组或引用中数字的个数,不会计算数组或引用中的空单元格、逻辑值、文本或错误值。</p><p>(5)COUNTIF 函数:<br>COUNTIF 为统计区域中满足给定条件单元格个数的函数,其语法格式为COUNTIF(range,criteria),其中range 表示要统计的单元格区域,criteria表示指定的条件表达式,其形式可以为数字、表达式、单元格引用或文本,使用方法可参考 SUMIF 函数。<br>例如,公式“=COUNTIF(G2:G11,”&gt;80”)”用于计算平均分在 80 分以上的人数。</p><p>(6)排位函数 RANK:</p><p>排位函数 RANK 的语法格式为RANK(number,ref,order),其中number 为需要找到排位的数字,ref为包含一组数字的数组或引用,order 为一数字,用来指明排位的方式。<strong>如果 order 为0或省略,则Excel 将ref当作按降序排列的数据清单进行排位;如果 order 不为零,则Excel将ref当作按升序排列的数据清单进行排位。RANK函数对重复数的排位相同,但重复数的存在将影响后续数值的排位。</strong></p><p>例如,公式“=RANK(G2,$G$2:$G$11)”用于计算 G2 单元格中的数据在 G2:G11区域内的排名</p><p>(7)MAX、MIN 函数:</p><p>MAX、MIN 函数分别用来求解数据集的极值(即最大值、最小值)。函数的语法格式为函数(numberl,number2,…),其中 number1、number2……为需要找出最大数值的参数区域。参数中的空白单元格、逻辑值或文本将被忽略,因此,<strong>如果逻辑值和文本不能忽略,应使用带A的函数MAXA 或者 MINA 来代替</strong></p><p>(8)AND、OR 函数:<br>AND、OR函数的语法格式为函数(1ogicall,logical2,…)。<br>对于 AND函数,所有参数的逻辑值为真时,返回 True;只要有一个参数的逻辑值为假,即返回False。对于OR函数,所有参数的逻辑值为假时,返回False;只要有一个参数的逻辑值为真即返回 True。<br>参数必须是逻辑值True或False,或者包含逻辑值的数组或引用。<strong>参数中的文本或空白单元格将被忽略。如果指定的单元格区域内包含非逻辑值,则 AND 将返回错误值 #VALUE!。</strong></p><p>(9)IF 函数:</p><p>如果指定条件的计算结果为True,则正函数将返回某个值;如果该条件的计算结果为False,则返回另一个值。<br>IF 函数的语法格式为 IF(logical_test,[value_if true],[value if false]),其中logical_test参数为必选,是计算结果可能为True或False的任意值或表达式;value_if true 参数是计算结果为True 时所要返回的值;value_if false 参数是计算结果为 False 时所要返回的值。</p><p>(10)取字符串子串函数 LEFT、RIGHT、MID:<br>LEFT、RIGHT、MID 都是字符串提取函数。前两个格式是一样的,只是提取的方向相反LEFT 是从左向右取,RIGHT是从右向左取。<br>LEFT 和 RIGHT 函数的语法格式分别为LEFT(text,num_chars)、RIGHT(text,num_chars).其中第一个参数 text是文本,即包含要提取字符串的文本字符串,可以是一个字符串,或是一个单元格引用。第二个参数numchars 是想要提取的个数。<br>比如,“=LEFT(A1,2)”是从 A1单元格的文本里,从左边第一位开始,向右提取两位。如果A1是“山东高校”,则得到的结果是“山东”。<br>MID 函数的语法格式为 MID(text,start_num,num_chars),也是从左向右提取,但不一定是从第一个起,可以从中间开始。第一个参数是text,它的属性与前面两个函数中的 text是一样的。第二个参数 start_num 是要提取的开始字符,第三个参数 num_chars 是要提取的个数。例如,如果 A1是“山东高校”,则“=MID(A1,3,2)”的结果是“高校”。</p><p>(11)VLOOKUP 函数:<br>使用 VLOOKUP函数搜索某个单元格区域的第一列,然后返回该区域相同行上任何单元格中的值。其语法格式为VLOOKUP(lookup_value,table_array,col index_num,[range_lookup])</p><p>其中lookup_value 参数必选,表示要在表格或区域的第一列中搜索的值,可以是值或引用。如果为 lookup_value 参数提供的值小于 table_array 参数第一列中的最小值,则 VLOOKUP 将返回错误值 #N/A。</p><p>table_array 参数必选,表示包含数据的单元格区域,可以使用对区域(如 A2:D8)或区域名称的引用。table_array 第一列中的值是由 lookup_value 搜索的值,这些值可以是文本、数字或逻辑值。文本不区分大小写。</p><p>col_index_num 参数必选,是 table array参数中要返回的匹配值对应的列号。col_index_num 参数为1时,返回 table_array 第一列中的值;col index_num为2时,返回 table_array 第二列中的值,依此类推。如果 col_index_num 参数小于1,则 VLOOKUP 返回错误值 #VALUE!;若大于 table array 的列数,则 VLOOKUP 返回错误值 #REF!。</p><p>range_lookup 参数可选,是一个逻辑值,指定希望 VLOOKUP 查找精确匹配值还是近似匹配值:如果 range_lookup 为 True 或被省略,则返回精确匹配值或近似匹配值;如果找不到精确匹配值,则返回小于 lookup_value 的最大值。</p><p>如果range_lookup为True 或被省略,则必须按 table_array第一列中的值升序排序;否则VLOOKUP 可能无法返回正确的值。如果range_lookup为False,则不需要对 table_array 第一列中的值进行排序。</p><h5 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h5><p><strong>=COUNTIF(A:A,A1)=1</strong></p><p><strong>公式含义：</strong>用COUNTIF函数统计当前单元格中的内容在A列中出现的次数，结果等于1，说明输入的内容只出现过一次，否则执行禁止输入。</p><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><h5 id="数据清单"><a href="#数据清单" class="headerlink" title="数据清单"></a>数据清单</h5><p>Excel2016的数据清单具有类似数据库的特点，<strong>可以实现数据的排序、筛选分类汇总、统计、查询等操作</strong>，具有数据库的组织、管理和处理数据的功能。具有二维表性质的电子表格在 Excel 2016 中称为“数据清单”，<strong>其中行表示记录、列表示字段</strong>。数据清单需要满足如下条件:</p><ul><li>(1)第一行必须为文本类型，为相应列的名称;</li><li>(2)在第一行的下面是连续的数据区域，每一列包含相同类型的数据;</li><li>(3)不允许出现空行和空列;</li></ul><p>1个数据清单最好占有一个工作表</p><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>开始-&gt;编辑-&gt;排序和筛选     <strong>excel中排序条件最多支持64个关键字</strong></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524092924214.png" alt="image-20240524092924214"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524093056384.png" alt="image-20240524093056384"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527150712618.png" alt="image-20240527150712618"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524093147551.png" alt="image-20240524093147551"></p><h5 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h5><p>筛选就是将不符合特定条件的行隐藏起来，这样可以更方便用户查看数据。分为自动筛选和高级筛选。<br>(1)自动筛选</p><p>筛选结果显示在原数据清单区域</p><p><strong>选择“数据”选项卡，在“排序和筛选”组中单击“筛选”按钮</strong>，此时，数据清单中的字段名右侧会出现一个下拉箭头，单击下拉箭头，可设置筛选条件、删除筛选条件或自定义自动筛选条件。<br>在设置自动筛选的自定义条件时，可以使用通配符，其中问号(?)代表任意单个字符星号(*)代表任意一组字符。<br><strong>注意:若多个字段都设置了筛选条件，则多个字段的筛选条件之间是“与”的关系。</strong></p><p>(2)高级筛选</p><p><strong>先设置一个条件区域，条件区域和数据清单之间要间隔一个以上的空行或空列。单击“排序和筛选”组中的“高级”命令。</strong><br><strong>高级筛选的条件区域至少有两行，第一行是字段名，下面的行放置筛选条件，这里的字段名一定要与数据清单中的字段名完全一致;在条件区域的设置中，</strong></p><p>  <em><strong>同一行上的条件认为是“与”条件，而不同行上的条件认为是“或”条件。</strong></em></p><ul><li>(1)当使用公式作为筛选条件时，条件区域的标行不能使用数据列表的字段名称。标题行可以是其他内容，或者空白。</li><li>(2)当条件区域的公式返回逻辑值TRUE时，满足筛选条件。</li><li>(3)条件区域设置的公式针对数据列表的第1行数据。注意公式的相对引用和绝对引用。</li></ul><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524164538302.png" alt="image-20240524164538302"></p><p>1.在Excel 2016中,使用自动筛选功能对某姓名列中自定义筛选条件,要求筛选姓氏为“张的人员数据时，可在筛选条件“等于…”中输入 张*</p><p><strong>数字筛选-&gt;自定义筛选</strong></p><h5 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h5><p>想冻结第一行和第一列，就点击 B2(第二行第二列单元格)，也就是想冻结第几行第几列就点击下一行下一列的第一个单元格。例如想冻结两行四列，那么点选 E3，再选择“视图’选项卡的“冻结窗格”按钮就可以了!</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524094753873.png" alt="image-20240524094753873"></p><h5 id="分类汇总"><a href="#分类汇总" class="headerlink" title="分类汇总"></a>分类汇总</h5><p>数据-&gt;分级显示-&gt;分类汇总</p><p>分类汇总是指把<strong>数据清单</strong>中的数据记录先根据一列分类，然后再分别对每一类进行汇总统计。汇总的方式有求和、计数、平均值、最值等。选择“数据”选项卡中的“分类汇总”命令即可进行分类汇总。<br><strong>进行分类汇总之前，必须先进行排序，否则无法实现预期效果。排的依据与分类的依据相同，即按哪个字段分类就按哪个字段对数据进行排序。</strong></p><p><strong>分类汇总嵌套时取消替换当前分类汇总</strong></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524095820187.png" alt="image-20240524095820187"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524095941053.png" alt="image-20240524095941053"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524100028900.png" alt="image-20240524100028900"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524100656851.png" alt="image-20240524100656851"></p><h5 id="合并计算"><a href="#合并计算" class="headerlink" title="合并计算"></a>合并计算</h5><p>对于放置在不同工作表中，却拥有部分相同行字段或列字段的数据，我们有时需要对他们进行合并统计。按传统的方式，首先我们得把它们复制到同一张工作表，再利用排序、求和、分类汇总等手段进行计算。</p><p>excel提供了“合并计算”的功能，可以直接调取多个工作表的数据进行计算。比如分类汇总的功能，要先排序后再进行，而“分并计算”功能可以直接搞定。</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240525140017397.png" alt="image-20240525140017397"></p><p>合并方式默认是求和</p><p>按类型合并时，数据源必须包含行和列标题，并在标签位置勾选</p><p>按位置合并，则不用在标签位置勾选</p><h5 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526155155394.png" alt="image-20240526155155394"></p><h5 id="获取外部数据"><a href="#获取外部数据" class="headerlink" title="获取外部数据"></a>获取外部数据</h5><h5 id="模拟分析"><a href="#模拟分析" class="headerlink" title="模拟分析"></a>模拟分析</h5><p>方案管理器，模拟运算表  （根据各组的输入值来确定可能的结果）</p><p>单变量求解（根据结果来确定可能的输入值）</p><h5 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h5><p>数据图表:是将单元格中的数据以各种统计图表的形式显示，以使得数据更直观。图表和建立图表的数据就建立了一种动态链接关系:当工作表中的数据发生改变时，图表中的对应项会自动变化。</p><p><strong>工作表中的数据发生变化时，图表中对应项的数据系列自动变化;改变图表中的数据系列时，与系列对应的工作表数据不会发生相应的变化。</strong></p><p><strong>图表分两种，一种是嵌入式图表，它和创建图表的数据源放置在同一张工作表中;另一种是独立图表，和数据分开打印。</strong></p><p>一个完整的图表通常由图表区、绘图区、图表标题和图例等几大部分组成。</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524170336508.png" alt="image-20240524170336508"></p><p><strong>在excel中，某图表和与其生成的数据相连接，当删除该图表中某一序列时  工作表中数据无变化</strong></p><ul><li>柱形图:柱形图用于显示一段时间内的数据变化或说明各项之间的比较情况，在柱形图中，通常沿横坐标轴组织类别，沿纵坐标轴组织值。</li><li>折线图:折线图可以显示随时间而变化的连续数据(根据常用比例设置)因此非常适用于显示在相等时间间隔下数据的趋势。</li><li>饼图:仅排列在工作表的一列或一行中的数据可以绘制到饼图中。饼图显示一个数据系列中各项的大小，与各项总和成比例。</li><li>条形图:条形图显示各项之间的比较情况。</li></ul><h6 id="创建图表"><a href="#创建图表" class="headerlink" title="创建图表"></a>创建图表</h6><p>alt+I+H或者单击插入-&gt;图表组的对话框启动器或者单击插入-&gt;图表组</p><h6 id="图表编辑"><a href="#图表编辑" class="headerlink" title="图表编辑"></a>图表编辑</h6><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524171329506.png" alt="image-20240524171329506"></p><p>改变图表存放位置：</p><p>图表工具-&gt;位置-&gt;移动图表    同时它也可以转换嵌入式图表和独立图表</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524171708013.png" alt="image-20240524171708013"></p><p>改变数据系列产生的方向：</p><p>图表工具-&gt;设计-&gt;数据-&gt;切换行/列    /   图表工具-&gt;设计-&gt;选择数据-&gt;切换行/列</p><p>右击图表-&gt;选择数据源-&gt;切换行/列</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524172022766.png" alt="image-20240524172022766"></p><p>(6)设置图表标题、坐标轴标题、图例、显示或隐藏数据标签及坐标轴:</p><p>单击“图表工具/设计”选项卡“图表布局”组中的“添加图表元素”,可设置图表标题、坐标轴标题、图例及显示或隐藏数据标签等。</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524171339907.png" alt="image-20240524171339907"></p><p>(7)改变图表大小:<br>要改变图表的大小,可先选定图表,然后使用下列方法之一:<br>① 将鼠标指针指向图表的四个角之一,当鼠标指针变成双向箭头时,按住左键进行拖动,即可改变图表的大小。<br>②)在“图表工具/格式”选项卡的“大小”组中设置图表的高度和宽度。</p><h5 id="迷你图"><a href="#迷你图" class="headerlink" title="迷你图"></a>迷你图</h5><p>折线图 柱形图 盈亏图</p><p>创建迷你图时不需要选择标题，只选择一行即可</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524172949436.png" alt="image-20240524172949436"></p><h4 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h4><h5 id="分页符"><a href="#分页符" class="headerlink" title="分页符"></a>分页符</h5><p>分页符：页面布局-&gt;页面设置-&gt;分隔符</p><p>分页符出现在选中的单元格上方，删除时选中分页符下方的单元格进行删除</p><p>只有在分页预览视图下才能调整分页符位置，把分页符调整到打印区域外后，分页符被删除</p><p>视图-&gt;工作簿视图-&gt;分页预览</p><h5 id="页面设置"><a href="#页面设置" class="headerlink" title="页面设置"></a>页面设置</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524173758131.png" alt="image-20240524173758131"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524173811707.png" alt="image-20240524173811707"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524173819829.png" alt="image-20240524173819829"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524173830236.png" alt="image-20240524173830236"></p><h5 id="打印-1"><a href="#打印-1" class="headerlink" title="打印"></a>打印</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524174022971.png" alt="image-20240524174022971"></p><h4 id="选项卡"><a href="#选项卡" class="headerlink" title="选项卡"></a>选项卡</h4><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524103635615.png" alt="image-20240524103635615"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524103700773.png" alt="image-20240524103700773"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524113123889.png" alt="image-20240524113123889"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526105741089.png" alt="image-20240526105741089"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526105833281.png" alt="image-20240526105833281"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526105854657.png" alt="image-20240526105854657"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527115206879.png" alt="image-20240527115206879"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527115218551.png" alt="image-20240527115218551"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527115229407.png" alt="image-20240527115229407"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527115237620.png" alt="image-20240527115237620"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526110005537.png" alt="image-20240526110005537"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526110037427.png" alt="image-20240526110037427"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526110106179.png" alt="image-20240526110106179"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526110121360.png" alt="image-20240526110121360"></p><h4 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h4><p><strong>1.公式中引用字符串，要加双引号</strong></p><p><strong>字符串包括文本、字母、符号以及文本型数值</strong></p><p>2.双引号里面什么也没有，在Excel中代表空值、空单元格。</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526111944636.png" alt="image-20240526111944636">excle数组</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524103540626.png" alt="image-20240524103540626">  </p><p>trunc函数的语法为：</p><p>trunc（number，number_digits）  没有四舍五入</p><p>trunc函数有两个参数：</p><p>第一个参数number：指的是需要截尾取整的数字。</p><p>第二个参数number_digits：指定取整精度的数字。默认情况下，number_digits的值为0，也就是取整数了。</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526163545323.png" alt="image-20240526163545323"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526163642388.png" alt="image-20240526163642388"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526163701173.png" alt="image-20240526163701173"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526163711506.png" alt="image-20240526163711506"></p><h5 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h5><p>引用【如:=SUM(F13:G14)】中的空白单元格、逻辑值、文本将被忽略，遇到错误值将会提示出错。<br>但 =SUM(1, TRUE,”2”),逻辑值 true 默认为 1,false 默认为 0;”2”自动转换为数值 2。</p><h5 id="average"><a href="#average" class="headerlink" title="average"></a>average</h5><p>如果引用区域中包含“0”值单元格，则计算在内;<br>如果引用区域中包含空白或字符、逻辑值的单元格，则不计算在内，遇到错误值将会提示出错。<br>但 =average(1,TRUE,”2”)，逻辑值 true 默认为 1,false 默认为 0:”2”自动转换为数值 2。</p><h5 id="count"><a href="#count" class="headerlink" title="count"></a>count</h5><p>实例:如果 A1=90、A2=人数、A3=””、A4=54、A5=36，则公式“=COUNT(A1:A5)”返回3。【文本、空格、逻辑型全部忽略】</p><p>但 =count(1,TRUE,”2”)，逻辑值 true 默认为 1，false 默认为 0;”2”自动转换为数值 2。</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527084006282.png" alt="image-20240527084006282"></p><h5 id="vlookup"><a href="#vlookup" class="headerlink" title="vlookup"></a>vlookup</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527084828081.png" alt="image-20240527084828081"></p><h5 id="mod-被除数，除数"><a href="#mod-被除数，除数" class="headerlink" title="mod(被除数，除数)"></a>mod(被除数，除数)</h5><p>求余数,如果除数为0，那么显示  #div/0</p><h5 id="round"><a href="#round" class="headerlink" title="round"></a>round</h5><p>round（6.6445，2）=6.64   按指定的位数对数值进行四舍五入</p><h5 id="int"><a href="#int" class="headerlink" title="int"></a>int</h5><p>向下取整为最近的整数</p><h5 id="sqrt"><a href="#sqrt" class="headerlink" title="sqrt"></a>sqrt</h5><p>求平方根</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527090213274.png" alt="image-20240527090213274"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527090229088.png" alt="image-20240527090229088"></p><h5 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h5><p>简单的说就是可以产生一个 [0,1)之间的随机数函数。</p><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ul><li><p>excel的三个主要功能：电子表格，图表，数据库</p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527110740900.png" alt="image-20240527110740900"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527111416804.png" alt="image-20240527111416804"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527111624582.png" alt="image-20240527111624582"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528200800616.png" alt="image-20240528200800616"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527112205409.png" alt="image-20240527112205409"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528201355683.png" alt="image-20240527112417438"></p></li><li></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527112726534.png" alt="image-20240527112726534"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527113300056.png" alt="image-20240527113300056"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527113636389.png" alt="image-20240527113636389"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527113912987.png" alt="image-20240527113912987"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527114320349.png" alt="image-20240527114320349"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527114414758.png" alt="image-20240527114414758"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527142805952.png" alt="image-20240527142805952"></p></li><li><p>公式中的运算符类型：算术运算符，比较运算符，文本运算符，引用运算符</p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527143257904.png" alt="image-20240527143257904"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527143448829.png" alt="image-20240527143448829"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527144118851.png" alt="image-20240527144118851"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527144220203.png" alt="image-20240527144220203"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527144749617.png" alt="image-20240527144749617"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527144807944.png" alt="image-20240527144807944"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527145531778.png" alt="image-20240527145531778"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527145749569.png" alt="image-20240527145749569"></p></li><li><p>excel排序可以按照：列 行 拼音 笔划数</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527150012782.png" alt="image-20240527150012782"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527150026668.png" alt="image-20240527150026668"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527150439485.png" alt="image-20240527150439485"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527150453319.png" alt="image-20240527150453319"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527151038389.png" alt="image-20240527151038389"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527160108858.png" alt="image-20240527160108858"></p><p>除了插入页眉页脚也可以通过页面设置</p></li><li><p>excel不可以将所有工作表隐藏</p></li><li><p>创建数据透视表默认在新工作表</p></li><li><p>excel单元格不可以插入图片</p></li><li><p>数组区域的单元格不可以单独编辑，数组常量不能含有不同长度的行和列</p></li><li><p>数据库函数都以字母D开头</p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527161733233.png" alt="image-20240527161733233"></p></li><li><p>自动分页符无法删除，但可以改变位置</p></li><li><p>工作表中输入的数据分为常量和公式</p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527172954325.png" alt="image-20240527172954325"></p></li><li><p>运算符顺序：引用 算术  文本  比较</p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527192246807.png" alt="image-20240527192246807"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527193006426.png" alt="image-20240527193006426"></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527194638038.png" alt="image-20240527194638038"></p><p><strong>如果插入一条垂直分页符，活动单元格放在第一行a1单元格除外</strong></p></li><li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527195125646.png" alt="image-20240527195125646"></p></li></ul><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527195311577.png" alt="image-20240527195311577"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527200544921.png" alt="image-20240527200544921"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527200550880.png" alt="image-20240527200550880"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527200523988.png"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527201324799.png" alt="image-20240527201324799"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527201625958.png" alt="image-20240527201625958"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527201809529.png" alt="image-20240527201809529"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527202417776.png" alt="image-20240527202417776"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527202431606.png" alt="image-20240527202431606"></p><p><strong>插入新行列会影响绝对引用（如果新插入行列在引用地址前）</strong></p><ul><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527205401012.png" alt="image-20240527205401012"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527210008337.png" alt="image-20240527210008337"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527211434445.png" alt="image-20240527211434445"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527211631076.png" alt="image-20240527211631076"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527211912914.png" alt="image-20240527211912914"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527212120886.png" alt="image-20240527212120886"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527212623816.png" alt="image-20240527212623816"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527213020739.png" alt="image-20240527213020739"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527213111254.png" alt="image-20240527213111254"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527213642484.png" alt="image-20240527213642484"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527213728112.png" alt="image-20240527213728112"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527213915425.png" alt="image-20240527213915425"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527213954570.png" alt="image-20240527213954570"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527214955613.png" alt="image-20240527214955613"></li></ul><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527215436218.png" alt="image-20240527215436218"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527220241478.png" alt="image-20240527220241478"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527220434443.png" alt="image-20240527220434443"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527220705842.png" alt="image-20240527220705842"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527220844108.png" alt="image-20240527220844108"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527220918564.png" alt="image-20240527220918564"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527221158303.png" alt="image-20240527221158303"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527221410328.png" alt="image-20240527221410328"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527222151654.png" alt="image-20240527222151654"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527222346394.png" alt="image-20240527222346394"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527222407715.png" alt="image-20240527222407715"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528100207554.png" alt="image-20240528100207554"></p><p>exCel（圈释无效数据）数据有效性的功能’可以方便查找出错误或不符合条件的数据。</p><ul><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528114900732.png" alt="image-20240528114900732"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528115912759.png" alt="image-20240528115912759"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528162857639.png" alt="image-20240528162857639"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528163709805.png" alt="image-20240528163709805"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528163726948.png" alt="image-20240528163726948"></li><li></li></ul><p>打印批注</p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528194255834.png" alt="image-20240528194255834"></p><ul><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528194618115.png" alt="image-20240528194618115"></li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528194947856.png" alt="image-20240528194947856"></li><li>利用工作表数据建立图表，引用的数据区域是单元格绝对地址</li><li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528202940400.png" alt="image-20240528202940400"></li><li>单元格内的数据：常量和公式</li></ul><h4 id="真题"><a href="#真题" class="headerlink" title="真题"></a>真题</h4><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240530192734894.png" alt="image-20240530192734894"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240530192815593.png" alt="image-20240530192815593"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240530192834167.png" alt="image-20240530192834167"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240530192855611.png" alt="image-20240530192855611"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240530192922102.png" alt="image-20240530192922102"></p><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240530192944396.png" alt="image-20240530192944396"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="计算机文化基础" scheme="https://codecodegogogo.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机文化基础</title>
    <link href="https://codecodegogogo.github.io/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/"/>
    <id>https://codecodegogogo.github.io/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/</id>
    <published>2024-05-14T01:41:05.000Z</published>
    <updated>2024-05-23T00:54:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240514093859.jpg" alt="微信图片_20240514093859"></p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240514093922.jpg" alt="微信图片_20240514093922"></p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240514093935.jpg" alt="微信图片_20240514093935"></p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240514093948.jpg" alt="微信图片_20240514093948"></p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240514094004.jpg" alt="微信图片_20240514094004"></p><ul><li><input disabled type="checkbox"> <img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/微信图片_20240514094021.jpg" alt="微信图片_20240514094021" style="zoom:25%;transform: rotate(-90deg);"></li></ul><h2 id="word"><a href="#word" class="headerlink" title="word"></a>word</h2><ul><li><p>模板文件扩展名：.dotx  ，文档文件扩展名：.docx</p></li><li><p>启动word时，系统自动创建一个名为文档1的新文档</p></li><li><p>word可以打开html文件</p></li><li><p>word打开时在normal.dotx模板下创建文档，这个模板使用等线（中文正文）5号字体</p></li><li><p>第一次保存时无论按保存还是另存为打开的都是另存为对话框</p></li><li><p>选定文本</p><ol><li>鼠标直接拖动</li><li>鼠标点击起始位置，按住shift点击终止位置</li><li>选择一行：鼠标移动到左边选定栏，鼠标指针变为向右的箭头，单击</li><li>选择一句：按住ctrl，单击句中的任意位置</li><li>选择一段：鼠标移动到左边选定栏，鼠标指针变为向右的箭头，双击   / 或者在段内三击</li><li>选择全文：鼠标移动到左边选定栏，鼠标指针变为向右的箭头，三击   /或者在左边选定栏按住ctrl单击鼠标  / ctrl+a  /开始-&gt;编辑-&gt;选择-&gt;全选</li><li>通过样式进行选择 ：开始-&gt;编辑-&gt;选择-&gt;选择格式相似的文本</li></ol></li><li><p>剪贴板最多可以保存24次剪切和复制的内容，win10的剪贴板可以存放25次</p></li><li><p>中文字号初号最大，八号最小，数字字号5磅最小，72最大，用户最大输入1638磅</p></li><li><p>word拼写和语法检查：审阅-&gt;校对-&gt;拼写和语法</p></li><li><p>自动更正：文件-&gt;选项-&gt;校对-&gt;自动更正选项   既可以更正字符，也可以更正图形</p></li><li><p>word2016可以制作web网页</p></li><li><p>WORD中四大核心技术是<strong>样式、域、宏和模板</strong>。</p></li><li><p>文章中的段落指的是两个回车符之间的内容，包括回车符</p></li><li><p>shift+enter 手动换行符，换行但不是新起一段，本质上还是一段</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518113510153.png" alt="image-20240518113510153"></p></li><li><p>文本打印距离纸边界的距离等于页边距+缩进距离</p></li><li><p>删除段落标记后两端合为一段后，两端的格式同前一段，字体格式不变</p></li><li><p>格式刷可以复制项目符号</p></li><li><p>样式就是多个排版格式组合而成的集合，是一系列预制的排版指令</p><p>模板就是由多个特定的样式组合而成，是一种排版编辑文档的基本工具</p></li><li><p>数学公式在插入-&gt;符号-&gt;公式</p><p>右击公式可以更改显示和内嵌两种方式</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518152848835.png" alt="image-20240518152848835"></p></li><li><p>制表位：左对齐式制表符、居中对齐式制表符、右对齐式制表符、小数点对齐式制表符、竖线对齐式制表符</p></li><li><p>自动保存可取值范围[1,120]</p></li><li><p>页眉不可以分栏分节</p></li><li><p>如果要为文档的不同节设置不同的页眉和页脚，单击功能区导航组的上一节，下一节，并保证链接到前一条页眉选项不选。</p></li><li><p>新建的样式只适用于当前文档</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519085234465.png"></p><p>主题：设计-&gt;文档格式-&gt;主题-&gt;保存当前主题</p></li><li><p>屏幕截图是嵌入式，此处的截图不借助剪贴板</p></li><li><p>组合图形 shift  ctrl，必须保证图形为非嵌入式</p></li><li><p>对图片进行叠放次序需要保证图片是非嵌入式</p></li><li><p>艺术字可以通过选中文字在开始菜单文字组文本效果和版式命令  变为艺术字</p></li><li><p>生成目录的前提是生成大纲级别</p></li><li><p>快速清除格式不能清楚以不同颜色突出文本</p></li><li><p>页眉可以插入图片</p></li><li><p>设置字符格式时要先选中字符，如不选中，那么会对插入点及后续输入有效</p></li><li><p>图片，剪贴画，屏幕截图都是嵌入型，自选图形，艺术字，文本框都是浮于文字上方</p></li><li><p>页眉默认居中，页脚默认左对齐</p></li><li><p>保存当前打开的所有文件：快速访问工具栏-&gt;其他命令-&gt;word选项-&gt;全部命令-&gt;全部保存</p></li><li><p>选择性粘贴：<strong>保留原格式</strong>，<strong>合并格式</strong>，<strong>只保留文本</strong></p></li><li><p>ole图片插入到文档的方式有插入，链接到文件和插入和链接</p></li><li><p>新建的样式只能用于当前文档，可以将其保存为模板。</p></li><li><p>底纹只能设计颜色不能设计图案</p></li><li><p>把已经打开的多个文档全部显示在屏幕上，单击视图中的全部重排</p></li></ul><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><ul><li>alt+f4 关闭word</li><li>ctrl+w  关闭文档窗口不退出应用，word2016中文件选项卡没有退出</li><li>ctrl+o/ctrl+f12 打开文件</li><li>crtl+s/shift+f12 保存文件</li><li>ctrl+n 新建文档</li><li>home 快速移到行首 </li><li>end 快速移到行末</li><li>ctrl+home 移到文档开头</li><li>ctrl+end 移到文档末尾</li><li>ctrl+k 插入超链接</li><li>1.5倍行距的快捷键是ctrl+5</li><li>ctrl+y 如果可能，请重做上一个操作。</li><li>拆分文档窗口。    Ctrl+Alt+S</li><li>撤消拆分文档窗口。    Alt+Shift+C 或 Ctrl+Alt+S</li><li>展开或收起功能区。    Ctrl+F1</li><li>通过按一个屏幕向上滚动文档视图来移动光标。    Page up</li><li>通过将文档视图向下滚动一个屏幕来移动光标。    Page down</li><li>将光标移到下一页的顶部。    Ctrl+Page down</li><li>将光标移到上一页的顶部。    Ctrl+Page up</li><li>要选定插人点所在单元格可按快捷键shift +end</li><li>shift+左右光标键 左右方向扩展一个字符</li><li>shift+上下光标键 由插入点向上下扩展一行</li><li>如果要删除Word文档中选定文本块的格式设置’应按ctrl+shift+z</li><li>ctrl+shift+home  从当前位置选定到文档开头</li><li>ctrl+shift+end  从当前位置选定到文档结尾</li><li>ctrl+a/ctrl+5（小键盘）选择整篇文章</li><li>shift+enter 手动换行符，换行但不是新起一段，本质上还是一段</li><li>f5  /ctrl+g  定位</li><li>ctrl+enter   插入人工分页符，人工分页符可以删除，自动分页符不可以</li><li>f9 更新域     ctrl+f9 添加域括号    shift+f9更新域代码为值  </li><li>alt+shift+t  插入当前时间     alt+shift+d  插入当前日期 </li><li>ctrl+shift+enter 拆分表格   （插入点为新表第一行）</li><li>选定插入点所在的单元格   shift+end</li><li>f12 另存为</li><li>ctrl+shift+h  隐藏文字</li><li>ctrl+alt+s  拆分合并视图</li><li>ctrl+shift+c  复制格式     ctrl+shift+v   粘贴格式</li><li>ctrl+shift+g  字数统计</li><li>f7  拼音和语法检查</li><li>f1 帮助</li><li>页面视图  ctrl+alt+p</li><li>shift+home 快选到行首     shift+end  快选到行末</li><li>ctrl+shift+z/n 清除文本的段落格式</li><li>ctrl+shift+f9  可以取消链接</li><li>alt+=   输入公式</li><li>切换已经打开的文档   ctrl+f6 / alt+f6</li></ul><h4 id="选项卡"><a href="#选项卡" class="headerlink" title="选项卡"></a>选项卡</h4><h5 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h5><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240517215621647.png" alt="image-20240517215621647" style="zoom:50%;"><ul><li>word2016中文件选项卡没有退出    </li><li>选项-&gt;保存-&gt;自动保存  副本扩展名为.wbk</li></ul><h6 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h6><p>ctrl+p   /快速访问工具栏-&gt;打印预览和打印（不是快速打印）</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518153331916.png" alt="image-20240518153331916"></p><p>页面范围：</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518153409149.png" alt="image-20240518153409149"></p><p>保存：<img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518202752290.png" alt="image-20240518202752290"></p><h5 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h5><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518110511946.png" alt="image-20240518110511946" style="zoom:50%;"><h6 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h6><p>单个的带圈字符和文字边框区分：带圈字符放大后会和边框黏连</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519093807542.png" alt="image-20240519093807542"></p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213138820.png" alt="image-20240519213138820" style="zoom: 50%;"><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521152543025.png" alt="image-20240521152543025"></p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518112358371.png" alt="image-20240518112358371" style="zoom: 50%;"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518112531299.png" alt="image-20240518112531299" style="zoom:50%;"></p><h6 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h6><p>对齐方式：左对齐，右对齐，居中对齐，两端对齐（默认），分散对齐。</p><p><strong>两端对齐和左对齐区别看每行最后的字符是否对齐</strong></p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213247521.png" alt="image-20240519213247521" style="zoom:200%;"><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518112654622.png" alt="image-20240518112654622" style="zoom:50%;"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518113107499.png" alt="image-20240518113107499"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518113215088.png" alt="image-20240518113215088"></p><h6 id="边框和底纹"><a href="#边框和底纹" class="headerlink" title="边框和底纹"></a>边框和底纹</h6><p>开始-&gt;段落-&gt;边框和底纹</p><p>页面边框可以添加艺术型边框</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518114051240.png" alt="image-20240518114051240"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518114133660.png" alt="image-20240518114133660"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518114143926.png" alt="image-20240518114143926"></p><h6 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h6><p>开始-&gt;编辑-&gt;查找-&gt;高级查找</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518105343354.png" alt="image-20240518105343354"></p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519162558592.png" alt="image-20240519162558592"></p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519162545682.png" alt="image-20240519162545682"></p><h6 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h6><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518171528805.png" alt="image-20240518171528805"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518171555368.png" alt="image-20240518171555368"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518171612394.png" alt="image-20240518171612394"></p><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518110531618.png" alt="image-20240518110531618"></p><ul><li>文本组-&gt;首字下沉</li><li>页眉和页脚和页码<ul><li>页眉和页脚可以进行文本格式设置和插入图片</li><li>页码最小值为0</li></ul></li></ul><h6 id="域"><a href="#域" class="headerlink" title="域"></a>域</h6><p>域是隐藏在文档中的由一组特殊代码组成的命令</p><p>更新域：</p><ol><li>右击域，快捷菜单，更新域</li><li>f9</li></ol><p>f9 更新域     ctrl+f9 添加域括号    shift+f9更新域代码为值  </p><h6 id="文本框和图文框"><a href="#文本框和图文框" class="headerlink" title="文本框和图文框"></a>文本框和图文框</h6><p><strong>word查找可以查找图文框</strong></p><p>文本框：插入-&gt;文本-&gt;文本框</p><p>​            文本框可以创建文本框之间的链接，可以做成三维效果（绘图工具-&gt;格式-&gt;形状样式-&gt;形状效果-&gt;三维旋转）</p><p>图文框:插入-&gt;插图-&gt;形状</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518152227665.png" alt="image-20240518152227665"></p><h6 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h6><p>插入-&gt;插图-&gt;图片</p><p>非嵌入式对象：可以放到任意位置，允许和其他对象组合</p><p>嵌入式对象：只能在有文档插入点的地方，不能和其他对象组合</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518151002485.png" alt="image-20240518151002485"></p><p><strong>插入图片的方式：</strong></p><p>插入：图片成为文档的一部分，和原图片没关系</p><p>链接到文件：当原始图片位置被移动或者图片被重命名时，不显示图片</p><p>插入和链接：当图片发生变化时，图片可以更新，图片找不到时会显示最后一版</p><h6 id="艺术字"><a href="#艺术字" class="headerlink" title="艺术字"></a>艺术字</h6><p>艺术字默认为非嵌入式</p><h6 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h6><p>组合图形：</p><ol><li>按住shift依次单击</li><li>选中图形后右键快捷菜单选择组合，/绘图工具-&gt;排列-&gt;组合</li></ol><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518151820643.png" alt="image-20240518151820643"></p><p>位置：</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518151937321.png" alt="image-20240518151937321"></p><h6 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h6><p>插入-&gt;插图-&gt;图表</p><p>可以自动更新数据</p><p>对象的链接：被链接的信息存在源文件中，链接信息会自动更新</p><p>对象的嵌入：嵌入的对象在目标文件中，不会更新</p><h5 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518165432384.png" alt="image-20240518165432384"></p><p>页面背景-&gt;页面颜色-&gt;填充效果</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519203707274.png" alt="image-20240519203707274"></p><h5 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518114708852.png" alt="image-20240518114708852"></p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521154120981.png" alt="image-20240521154120981"></p><p>word分栏最多可以分为11栏</p><h6 id="页面设置"><a href="#页面设置" class="headerlink" title="页面设置"></a>页面设置</h6><p>页边距：自定义页边距大小，设置装订线的位置，设置纸张的方向</p><p>纸张：设置纸张大小</p><p>版式：设置节的起始位置，页眉，页脚相关参数，页面的垂直对齐方式</p><p>文档网格：设置文字的排列方向，每页的行数，每行的字符数</p><p>装订线位置：左 上</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518153527963.png" alt="image-20240518153527963"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518153540372.png" alt="image-20240518153540372"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518153551021.png" alt="image-20240518153551021"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518153600847.png" alt="image-20240518153600847"></p><p>页边距的内侧和外侧，，左和右</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519110420906.png" alt="image-20240519110420906"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519110501236.png" alt="image-20240519110501236"></p><p>布局-&gt;页面设置-&gt;版式-&gt;垂直对齐方式</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519110820112.png" alt="image-20240519110820112"></p><h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518164725453.png" alt="image-20240518164725453"></p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519162339121.png" alt="image-20240519162339121"></p><h5 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519093057425.png" alt="image-20240519093057425"></p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519162835973.png" alt="image-20240519162835973"></p><p>邮件合并：创建主文挡，设置数据源，插入合并域，邮件合并</p><h5 id="审阅"><a href="#审阅" class="headerlink" title="审阅"></a>审阅</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518154314077.png" alt="image-20240518154314077"></p><p>批注：对某项内容进行注释，并且注释不会出现在文档中</p><p>修订：让文档作者跟踪多位审阅者对文档做的修改。</p><h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518110601071.png" alt="image-20240518110601071"></p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519210910657.png" alt="image-20240519210910657"></p><ul><li><p>页面视图：默认视图，所见即所得，页和页有明显的分割线，可以编辑页眉和页脚，调整页边距，处理分栏和编辑图形图像</p></li><li><p>阅读视图：分左右两栏（不是分栏操作），功能区元素被隐藏，可以看到分栏效果</p></li><li><p>web版式视图：以网页形式显示文档，适用于创建网页，没有分栏,可以适应窗口大小自动换行显示文本</p></li><li><p>大纲视图：没有分栏，查看大纲，不显示页边距，页眉，页脚，图片，背景</p></li><li><p>草稿：最节省计算机资源，只显示标题和正文，不显示页边距，页眉和页脚，背景，图片，分栏。</p><p>草稿视图是适合文本录入和编辑的视图，文档满一页时，出现一条虚线</p></li></ul><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ol><li>显示水平标尺：                                    草稿，页面，web版式</li><li>显示分栏，页眉，页脚：                     页面，阅读,打印预览</li><li>分页符：                                                草稿，页面</li><li>网格线：                                                页面视图</li></ol><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518214616651.png" alt="image-20240518214616651"></p><h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518143944462.png" alt="image-20240518143944462"></p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518143928185.png" alt="image-20240518143928185"></p><h6 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h6><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519204037521.png" alt="image-20240519204037521"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519204044941.png" alt="image-20240519204044941"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519204053965.png" alt="image-20240519204053965"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519204058991.png" alt="image-20240519204058991"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519204101801.png" alt="image-20240519204101801"></p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521154636315.png" alt="image-20240521154636315"></p><h6 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h6><p>插入-&gt;表格</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518142832104.png" alt="image-20240518142832104"></p><ol><li>使用虚拟表格创建10列8行</li><li>使用插入表格对话框：63列*32767行</li></ol><h6 id="选定表格"><a href="#选定表格" class="headerlink" title="选定表格"></a>选定表格</h6><ol><li>单元格：鼠标移入单元格内部左侧，指针变为向右的黑色箭头，单击。此时按住鼠标左键拖动可以选定多个单元格</li><li>表行：鼠标移到左选定栏，指针变为向右的箭头，单击选择一行，按住左键向上向下拖动可以选定多行</li><li>表列：鼠标移到表格顶端，指针变为向下的黑色箭头，单击可以选择某一列，按住鼠标左键向左向右拖动可以选择多列。</li><li>矩形块：从矩形块的左上角拖动到右下角</li><li>整个表格：鼠标移动到表格内，表格左上角的按钮就是全选，使用ctrl+a不行。</li><li>表格工具-&gt;布局-&gt;表-&gt;选择   （可以选单元格，列，行，表格）</li></ol><h6 id="表格居中"><a href="#表格居中" class="headerlink" title="表格居中"></a>表格居中</h6><ol><li><p>表格属性-&gt;对齐方式</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518155004043.png" alt="image-20240518155004043"></p></li><li><p>选中整个表格后，开始-&gt;段落-&gt;居中</p></li></ol><h6 id="行高和列宽"><a href="#行高和列宽" class="headerlink" title="行高和列宽"></a>行高和列宽</h6><p>表格工具-&gt;布局-&gt;表-&gt;属性    /  右键某个单元格选择表格属性</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518154757110.png" alt="image-20240518154757110"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518154814025.png" alt="image-20240518154814025"></p><h6 id="插入行和列"><a href="#插入行和列" class="headerlink" title="插入行和列"></a>插入行和列</h6><ol><li><p>选中一行或者多行，点击表格工具-&gt;布局-&gt;行和列</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518143959123.png" alt="image-20240518143959123"></p></li><li><p>选中行和列后右击，快捷菜单插入</p></li><li><p>在末尾插入新行：最后一个单元格内按tab，最后一个单元格外按tab，enter</p></li></ol><h6 id="删除行和列"><a href="#删除行和列" class="headerlink" title="删除行和列"></a>删除行和列</h6><ol><li><p>右击要删除的行和列，快捷菜单删除</p></li><li><p>点击表格工具-&gt;布局-&gt;行和列-&gt;删除  （单元格，行，列，表格）</p></li><li><p>选中后右键剪切  </p></li><li><p>删除单元格 </p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519085856470.png" alt="image-20240519085856470"></p></li></ol><h6 id="拆分和合并"><a href="#拆分和合并" class="headerlink" title="拆分和合并"></a>拆分和合并</h6><p>点击表格工具-&gt;布局-&gt;合并 </p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518144706371.png" alt="image-20240518144706371"></p><p>快捷键： ctrl+shift+enter  （选中的行为第二个表格的第一行）</p><p>表格拆分后当前行会变成新表格的首行</p><p>要把拆分的表格合并，保证两个合并表格没有文字环绕，然后把中间的段落标记删除，</p><p>或者选中下面的表格 shift+alt+上方向键 （这种方式只是让他们靠在一起，还是2个表格）</p><p>delete删除表格内容，backspace删除表格</p><h6 id="表格格式化"><a href="#表格格式化" class="headerlink" title="表格格式化"></a>表格格式化</h6><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518145708340.png" alt="image-20240518145708340"></p><p>水平：两端对齐，居中对齐，右对齐</p><p>垂直: 靠上，中部，靠下</p><p><strong>表格中的域不会自动更新</strong></p><p>表格工具-&gt;布局-&gt;单元格大小-&gt;自动调整</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519111633308.png" alt="image-20240519111633308"></p><p>根据窗口自动调整表格会根据页面的大小进行自动扩张和缩小表格</p><h6 id="文字和表格的转换"><a href="#文字和表格的转换" class="headerlink" title="文字和表格的转换"></a>文字和表格的转换</h6><p>插入-&gt;表格-&gt;将文字转换成表格</p><p>表格工具-&gt;布局-&gt;数据-&gt;转换为文本</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518150106909.png" alt="image-20240518150106909"></p><p>排序时只可以选择3个关键字</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518150332594.png" alt="image-20240518150332594"></p><h5 id="绘图工具-格式-（艺术字，文本框）"><a href="#绘图工具-格式-（艺术字，文本框）" class="headerlink" title="绘图工具/格式  （艺术字，文本框）"></a>绘图工具/格式  （艺术字，文本框）</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519113522259.png" alt="image-20240519113522259"></p><h5 id="图片工具-格式-（图片）"><a href="#图片工具-格式-（图片）" class="headerlink" title="图片工具/格式   （图片）"></a>图片工具/格式   （图片）</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519113554342.png" alt="image-20240519113554342"></p><h5 id="公式工具-设计"><a href="#公式工具-设计" class="headerlink" title="公式工具/设计"></a>公式工具/设计</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519113819697.png" alt="image-20240519113819697"></p><h4 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h4><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518173555836.png" alt="image-20240518173555836"></p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518173607174.png" alt="image-20240518173607174"></p><p>字数统计：字符（空格） 字符 字 行  段落  页   中文字符和朝鲜语   非中文单词     （还可以选择是否包括文本框 脚注，尾注）</p><h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><ol><li><p>在书籍杂志的排版中，为了将页边距根据页面的内测，外侧进行设置，可以将页面设置为  对称页边距</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518162954787.png" alt="image-20240518162954787"></p></li><li><p>word2016中，默认的汉字字号是   等线（中文正文）五号</p></li><li><p>自动更正</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518163252553.png" alt="image-20240518163252553"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518163327750.png" alt="image-20240518163327750"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518163350570.png" alt="image-20240518163350570"></p></li><li><p>艺术字对象实际上是文字对象也是图形对象</p></li><li><p>审阅选项卡可以对不同版本的文档进行比较和合并</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518163840318.png" alt="image-20240518163840318"></p></li><li><p>表格  自动调整操作  表格工具-&gt;布局-&gt;单元格大小 </p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518164038212.png" alt="image-20240518164038212"></p></li><li><p>索引和书目不是通过标记引用项所在位置生成目录</p></li><li><p>文档模板中可以包括：样式，快捷键，页面设置信息，宏方案项，工具栏</p></li><li><p>word2016中，将图片作为字符来移动的版式是嵌入式</p></li><li><p>忘记了word2016文件的打开权限密码，则无法打开</p></li><li><p><strong>word文档三种加密方法</strong></p><p>​        打开密码：只有输对密码才能查看内容  信息-&gt;保护文档-&gt;用密码进行加密</p><p>​        限制编辑: 只能查看         审阅-&gt;保护-&gt;限制编辑</p><p>​        只读模式：编辑输密码，也可以只读     文件-&gt;另存为-&gt;工具-&gt;常规选项</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518171000958.png" alt="image-20240518171000958"></p></li><li><p>水印命令在设计-&gt;页面背景</p></li><li><p>alt+shift+t  插入当前时间     alt+shift+d  插入当前日期 </p></li><li><p>主文挡</p></li><li><p>翻译在 审阅-&gt;语言</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518165906282.png" alt="image-20240518165906282"></p></li><li><p>草稿视图中，多栏文本将显示为较窄的一栏</p></li><li><p>导航窗格可以浏览文档中的关键文字和词，没有脚注，尾注，题注</p></li><li><p>拼音指南的作用是给汉字添加汉语拼音</p></li><li><p>师大93</p></li><li><p>紧密型环绕：真环绕    四周型环绕：方块空白，矩形环绕</p></li><li><p>页码可以插入在页眉，页脚，左右页边距，当前位置</p></li><li><p>表格的单元格中可以添加表格，表格也可以添加在页眉</p></li><li><p>word在添加参考文献的源主列表时，可以来自  网络中知名网站，计算机的其他文档，自己录入</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518171241185.png" alt="image-20240518171241185"></p></li><li><p>段前间距最小值是   -0.2</p></li><li><p>布局可以设置段落的缩进和间距</p></li><li><p>word最大的缩放比例是 500%</p></li><li><p>改变文本框的文字方向可实现横排竖排的转换</p></li><li><p>同义词库可以帮助用户查找不熟悉单词的近义替换词</p></li><li><p>word两个单元格合并会保存所有内容</p></li><li><p>分布列和分布行 在所选列或行之间平均分布</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518174629816.png" alt="image-20240518174629816"></p></li><li><p>文字转表格，转换时行数根据文字行来确定</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518174819696.png" alt="image-20240518174819696"></p></li><li><p>带圈字符可以给字符加上</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518200324139.png" alt="image-20240518200324139"></p></li><li><p>隐藏文字  选中 开始-&gt;文字-&gt;隐藏 / ctrl+shift+h</p><p>隐藏的文字打印的时候不显示</p></li><li><p>拆分窗口</p><p>ctrl+alt+s</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518201503232.png" alt="image-20240518201503232"></p></li><li><p>重复标题行只能修改第一页的标题行，其他页面随着变</p></li><li><p>打印预览时不可以全屏显示</p></li><li><p>审阅-&gt;翻译   翻译文档，所选文字，屏幕提示</p></li><li><p>组织结构图，bmp图形，图像文档，写字板文档都可以插入word文档</p></li><li><p>另一种设置分栏的办法</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518203004496.png" alt="image-20240518203004496"></p></li><li><p>页码最小起始值是0</p></li><li><p>word默认样式可以修改不能删除</p></li><li><p>页面设置可以设置每一页的行数</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518203313753.png" alt="image-20240518203313753"></p></li><li><p>可以为创建的样式指定快捷键</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518203438029.png" alt="image-20240518203438029"></p></li><li><p>word中如果删除了某个分节符，其前面的文字将合并到后边的节中，并且采用前者的格式</p></li><li><p>在文档中点击构建基块库中已有的文档部件，会出现构建基块框架</p><p>插入-&gt;文本-&gt;文档部件</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518204156152.png" alt="image-20240518204156152"></p></li><li><p>草稿视图只能看到标题和正文</p></li><li><p>批注可以设置打印，也可以设置不打印</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518205245527.png" alt="image-20240518205245527"></p></li><li><p>dotx 模板格式    dotm  启用宏的模板格式</p></li><li><p>文章的任何位置都可以通过运用tc域标记为目录项后建立目录</p></li><li><p>在一个段落中只有开始的一行才可以加上项目符号和编号</p></li><li><p>复制的文本，可以粘贴为图片</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518210121446.png" alt="image-20240518210121446"></p></li><li><p>word的工具栏也可以在功能区下方显示</p></li><li><p>书签名字可以以字母，数字，汉字开头，可以有空格，下划线</p></li><li><p>英文字母大小写相互转换</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518212004648.png" alt="image-20240518212004648"></p></li><li><p>标尺上的移动表格列可以改变表格的宽度，调整表格行可以改变表格的高度</p></li><li><p>选定文本后会出现悬浮工具栏可以对字体进行快速设置</p></li><li><p>艺术字居中</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518212844251.png" alt="image-20240518212844251"></p></li><li><p>脚注和尾注可以相互转换</p></li><li><p>图片工具</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518213122009.png" alt="image-20240518213122009"></p></li><li><p>页边距的设置必定影响当前页，<strong>错误</strong></p></li></ol><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519084247549.png" alt="image-20240519084247549"></p><ol><li><p>公式工具选项卡不能通过插入-&gt;文本-&gt;对象这种方式打开，这种方式只是插入了一个公式</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519090801663.png" alt="image-20240519090801663"></p></li><li><p>word的页眉页脚不能设置文字方向，可以设置对齐方式，字符的字形，字号，设置页码格式</p><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519170314629.png" alt="image-20240519170314629"></p></li><li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519171834190.png" alt="image-20240519171834190"></p></li><li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519173447431.png" alt="image-20240519173447431"></p></li><li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519173757852.png" alt="image-20240519173757852"></p></li><li><p>把剪贴板重大1内容粘贴到文档的插入点位置后，剪贴板的内容将继续存在</p></li><li><p>对象被链接后，如果更改源文件的数据，链接信息会自动更新</p></li><li></li><li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519211105053.png" alt="image-20240519211105053"></p></li><li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519211145166.png" alt="image-20240519211145166"></p></li><li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519211355670.png" alt="image-20240519211355670"></p></li><li><p>!(./计算机文化基础/image-20240519213016737.png)<img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521152018461.png"></p></li><li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521152712830.png" alt="image-20240521152712830"></p></li><li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213328518.png" alt="image-20240519213328518" style="zoom:200%;"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521153445529.png" alt="image-20240521153445529"></p></li><li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521153851150.png" alt="image-20240521153851150"></p></li><li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213458503.png" alt="image-20240519213458503"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521154257890.png" alt="image-20240519213528668"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213554342.png" alt="image-20240519213554342"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213611072.png" alt="image-20240519213611072"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213630012.png" alt="image-20240519213630012"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521155727399.png" alt="image-20240521155727399"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213707800.png" alt="image-20240519213707800"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521160256431.png" alt="image-20240521160256431"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213727642.png" alt="image-20240519213727642"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213745659.png" alt="image-20240519213745659"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213813060.png" alt="image-20240519213813060"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213827123.png" alt="image-20240519213827123"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213842864.png" alt="image-20240519213842864"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213407496.png" alt="image-20240519213407496" style="zoom:200%;"></p></li><li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213427021.png" alt="image-20240519213427021"></p></li><li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518213517783.png" alt="image-20240518213517783" style="zoom:200%;"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518213612322.png" alt="image-20240518213612322" style="zoom:200%;"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518213718804.png" alt="image-20240518213718804" style="zoom:200%;"></p></li></ol><h4 id="考试题"><a href="#考试题" class="headerlink" title="考试题"></a>考试题</h4><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240523085253724.png" alt="image-20240523085253724"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240523085341111.png" alt="image-20240523085341111"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240523085402021.png" alt="image-20240523085402021"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240523085420397.png" alt="image-20240523085420397"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240523085444395.png" alt="image-20240523085444395"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="https://codecodegogogo.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm</title>
    <link href="https://codecodegogogo.github.io/2024/03/01/Algorithm/"/>
    <id>https://codecodegogogo.github.io/2024/03/01/Algorithm/</id>
    <published>2024-03-01T07:52:28.000Z</published>
    <updated>2024-03-02T10:36:58.669Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><img src="/2024/03/01/Algorithm/image-20240301155400055.png" alt="image-20240301155400055"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sunny on 24.03.01.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">10</span>; ++a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">10</span>; ++b) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">10</span>; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a*<span class="number">100</span>+b*<span class="number">10</span>+c+b*<span class="number">100</span>+c*<span class="number">10</span>+c==<span class="number">532</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/01/Algorithm/image-20240302144945929.png" alt="image-20240302144945929"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sunny on 24.03.02.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">10</span>; ++a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt;<span class="number">10</span> ; ++b) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">10</span>; ++c) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; <span class="number">10</span>; ++d) &#123;</span><br><span class="line">                    <span class="keyword">if</span>((a*<span class="number">1000</span>+b*<span class="number">100</span>+c*<span class="number">10</span>+d)*<span class="number">9</span>==(d*<span class="number">1000</span>+c*<span class="number">100</span>+b*<span class="number">10</span>+a))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,a,b,c,d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/01/Algorithm/image-20240302145553655.png" alt="image-20240302145553655"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sunny on 24.03.02.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isreserves</span><span class="params">(<span class="type">int</span> sum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> sum=i*i;</span><br><span class="line">        <span class="type">int</span> reserves=isreserves(sum);</span><br><span class="line">        <span class="keyword">if</span>(i*i==reserves)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d的平方为%d,他的逆序数是%d\n&quot;</span>,i,i*i,reserves);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isreserves</span><span class="params">(<span class="type">int</span> sum)</span>&#123;</span><br><span class="line">    <span class="type">int</span> reserves=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> remain=sum%<span class="number">10</span>;</span><br><span class="line">        reserves=reserves*<span class="number">10</span>+remain;</span><br><span class="line">        sum=sum/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reserves;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/01/Algorithm/image-20240302154133137.png" alt="image-20240302154133137"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sunny on 24.03.02.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入梯形的高度:&quot;</span>);</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (num-i<span class="number">-1</span>)*<span class="number">2</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num+i*<span class="number">2</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="算法" scheme="https://codecodegogogo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>javaweb</title>
    <link href="https://codecodegogogo.github.io/2024/02/11/javaweb/"/>
    <id>https://codecodegogogo.github.io/2024/02/11/javaweb/</id>
    <published>2024-02-11T14:09:26.000Z</published>
    <updated>2024-02-20T13:20:39.647Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="serlet"><a href="#serlet" class="headerlink" title="serlet"></a>serlet</h1><h2 id="tomcat安装"><a href="#tomcat安装" class="headerlink" title="tomcat安装"></a>tomcat安装</h2><p>解压安装包后配置环境变量：<br>CATALINA_HOME：tomcat根地址<br>JAVA_HOME：java根地址<br>path：CATALINA_HOME/bin   JAVA_HOME/bin</p><p><strong>配置成功后地址</strong>:<em><strong><a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></strong></em><br>cmd命令开启关闭:<br>开启服务器:startup.bat<br>关闭服务器:shutdown.bat</p><h2 id="协议规范"><a href="#协议规范" class="headerlink" title="协议规范"></a>协议规范</h2><p><img src="/2024/02/11/javaweb/%E5%8D%8F%E8%AE%AE.png" alt="?"></p><h2 id="测识程序"><a href="#测识程序" class="headerlink" title="测识程序"></a>测识程序</h2><p>将程序放入tomcat根目录下webapps目录下某个程序名文件夹下:<br><em><strong>CATALINA_HOME/webapps/程序名/</strong></em></p><p>测识程序地址：<em><strong><a href="https://github.com/codecodegogogo/javaweb/tree/main/hello">https://github.com/codecodegogogo/javaweb/tree/main/hello</a></strong></em></p><h3 id="控制台乱码"><a href="#控制台乱码" class="headerlink" title="控制台乱码"></a>控制台乱码</h3><p>将tomcat\conf\logging.properties中java.util.logging.ConsoleHandler.encoding<br>更改为java.util.logging.ConsoleHandler.encoding = GBK</p><h2 id="开发一个带有Servlet的webapp"><a href="#开发一个带有Servlet的webapp" class="headerlink" title="开发一个带有Servlet的webapp"></a>开发一个带有Servlet的webapp</h2><ol><li><p>第一步:在webapps目录下新建一个目录，起名crm(这个crm就是webapp的名字)。当然，也可以是其它项目，比如银行项目，可以创建一个目录bank，办公系统可以创建一个oa。注意: crm就是这个webapp的根</p></li><li><p>第二步: 在webapp的根下新建一个目录: WEB-INF注意: 这个目录的名字是Servlet规范中规定的，必须全部大写，必须一模一样。</p></li><li><p>第三步: 在WEB-INF目录下新建一个目录: classes,注意:这个目录的名字必须是全部小写的classes，这也是Servlet规范中规定的。另外这个目录下一定存放的是/ava程序编译之后的class文件 (这里存放的是字节码文件)。</p></li></ol><p>4.<br> 第四步:在WEB-INF目录下新建一个目录：lib</p><p>注意：这个目录不是必须的。但如果一个webapp需要第三方的jar包的话，这个jar包要放到这个lib目录下，这个目录的名字也不能随意编写，必须是全部小写的lib。例如java语言连接数据库需要数据库的驱动jar包。那么这个jar包就一定要放到lib目录下。这Servlet规范中规定的。</p><p>5.<br> 第五步：在WEB-INF目录下新建一个文件：web.xml</p><p>注意：这个文件是必须的，这个文件名必须叫做web.xml。这个文件必须放在这里。一个合法的webapp，web.xml文件是必须的，这个web.xml文件就是一个配置文件，在这个配置文件中描述了请求路径和Servlet类之间的对照关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">metadata-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>第六步：编写一个Java程序，这个小Java程序也不能随意开发，这个小java程序必须实现Servlet接口。</li></ol><p>这个Servlet接口不在JDK当中。（因为Servlet不是JavaSE了。Servlet属于JavaEE，是另外的一套类库。）</p><p>Servlet接口（Servlet.class文件）是Oracle提供的。（最原始的是sun公司提供的。）</p><p>Servlet接口是JavaEE的规范中的一员。</p><p>Tomcat服务器实现了Servlet规范，所以Tomcat服务器也需要使用Servlet接口。Tomcat服务器中应该有这个接口，Tomcat服务器的CATALINA_HOME\lib目录下有一个servlet-api.jar，解压这个servlet-api.jar之后，你会看到里面有一个Servlet.class文件。</p><p>重点：从JakartaEE9开始，Servlet接口的全名变了：jakarta.servlet.Servlet<br><strong>注意：编写这个Java小程序的时候，java源代码你愿意在哪里就在哪里，位置无所谓，你只需要将java源代码编译之后的class文件放到classes目录下即可。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.Servlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request,ServletResponse response)</span></span><br><span class="line"><span class="keyword">throws</span> ServletException , IOException&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向控制台打印输出</span></span><br><span class="line">System.out.println(<span class="string">&quot;My First Servlet, Hello Servlet&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置响应的内容类型是普通文本或html代码</span></span><br><span class="line"><span class="comment">// 需要在获取流对象之前设置，有效。</span></span><br><span class="line"><span class="comment">//response.setContentType(&quot;text/html&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 怎么将一个信息直接输出到浏览器上？</span></span><br><span class="line"><span class="comment">// 需要使用ServletResponse接口：response</span></span><br><span class="line"><span class="comment">// response表示响应：从服务器向浏览器发送数据叫做响应。</span></span><br><span class="line"><span class="comment">//PrintWriter out = response.getWriter();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置响应的内容类型时不要在获取流之后设置。</span></span><br><span class="line"><span class="comment">//response.setContentType(&quot;text/html&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//out.print(&quot;Hello Servlet, You are my first servlet!&quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 浏览器是能够识别html代码的，那我们是不是应该输出一段HTML代码呢？</span></span><br><span class="line"><span class="comment">//out.print(&quot;&lt;h1&gt;hello servlet，你好Servlet&lt;/h1&gt;&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个输出流，负责输出字符串到浏览器</span></span><br><span class="line"><span class="comment">// 这个输出流不需要我们刷新，也不需要我们关闭，这些都由Tomcat来维护。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//out.flush();</span></span><br><span class="line"><span class="comment">//out.close();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>第七步：编译我们编写的HelloServlet</li></ol><p>重点：你怎么能让你的HelloServlet编译通过呢？配置环境变量CLASSPATH</p><p>CLASSPATH=apache-tomcat-10.0.12\lib\servlet-api.jar</p><p>思考问题：以上配置的CLASSPATH和Tomcat服务器运行有没有关系？</p><p>没有任何关系，以上配置这个环境变量只是为了让你的HelloServlet能够正常编译生成class文件。</p><p>8.<br>第八步：将以上编译之后的HelloServlet.class文件拷贝到WEB-INF\classes目录下。</p><p>9.<br>第九步：在web.xml文件中编写配置信息，让“请求路径”和“Servlet类名”关联在一起。</p><p>这一步用专业术语描述：在web.xml文件中注册Servlet类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">metadata-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--servlet描述信息--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--任何一个servlet都对应一个servlet-mapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>fdsafdsagfdsafdsa<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个位置必须是带有包名的全限定类名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--servlet映射信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个也是随便的，不过这里写的内容要和上面的一样。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>fdsafdsagfdsafdsa<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里需要一个路径--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个路径唯一的要求是必须以 / 开始--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--当前这个路径可以随便写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/fd/fd<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>11.<br>第十一步：打开浏览器，在浏览器地址栏上输入一个url，这个URL必须是：</p><p><a href="http://127.0.0.1:8080/crm/fd/fd">http://127.0.0.1:8080/crm/fd/fd</a><br><strong>注意class文件的包名路径</strong><br>非常重要的一件事：浏览器上的请求路径不能随便写，这个请求路径必须和web.xml文件中的url-pattern一致。<br>注意：浏览器上的请求路径和web.xml文件中的url-pattern的唯一区别就是：浏览器上的请求路径带项目名：/crm<br>浏览器上编写的路径太复杂，可以使用超链接。（非常重要：html页面只能放到WEB-INF目录外面。）</p><p>以后不需要我们编写main方法了。tomcat服务器负责调用main方法，Tomcat服务器启动的时候执行的就是main方法。我们javaweb程序员只需要编写Servlet接口的实现类，然后将其注册到web.xml文件中，即可。</p><h2 id="向浏览器输出信息"><a href="#向浏览器输出信息" class="headerlink" title="向浏览器输出信息"></a>向浏览器输出信息</h2><p>javac -d . *.java<br><strong>编译生成多级目录结构的class文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.Servlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request,ServletResponse response)</span></span><br><span class="line"><span class="keyword">throws</span> ServletException , IOException&#123;</span><br><span class="line"></span><br><span class="line">response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 怎么将一个信息直接输出到浏览器上？</span></span><br><span class="line"><span class="comment">// 需要使用ServletResponse接口：response</span></span><br><span class="line"><span class="comment">// response表示响应：从服务器向浏览器发送数据叫做响应。</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">out.print(<span class="string">&quot;&lt;h1&gt;hello servlet，你好Servlet&lt;/h1&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个输出流，负责输出字符串到浏览器</span></span><br><span class="line"><span class="comment">// 这个输出流不需要我们刷新，也不需要我们关闭，这些都由Tomcat来维护。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//out.flush();</span></span><br><span class="line"><span class="comment">//out.close();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="servelet连接数据库"><a href="#servelet连接数据库" class="headerlink" title="servelet连接数据库"></a>servelet连接数据库</h2><p><strong>不要忘记在web.xml中配置新的项</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.Servlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request,ServletResponse response)</span></span><br><span class="line"><span class="keyword">throws</span> ServletException , IOException&#123;</span><br><span class="line">response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">Connection con=<span class="literal">null</span>;</span><br><span class="line">Statement statement=<span class="literal">null</span>;</span><br><span class="line">ResultSet res=<span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> res2;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">String host=<span class="string">&quot;jdbc:mysql://localhost:3306/java_mysql&quot;</span>;</span><br><span class="line">String name=<span class="string">&quot;root&quot;</span>;</span><br><span class="line">String password=<span class="string">&quot;&quot;</span>;</span><br><span class="line">con=DriverManager.getConnection(host,name,password);</span><br><span class="line">statement=con.createStatement();</span><br><span class="line">String sql1=<span class="string">&quot;select * from emp&quot;</span>;</span><br><span class="line">res=statement.executeQuery(sql1);</span><br><span class="line"><span class="keyword">while</span> (res.next())&#123;</span><br><span class="line">String ENAME=res.getString(<span class="string">&quot;ENAME&quot;</span>);</span><br><span class="line">String JOB=res.getString(<span class="string">&quot;JOB&quot;</span>);</span><br><span class="line">String MGR=res.getString(<span class="string">&quot;MGR&quot;</span>);</span><br><span class="line">String HIREDATE=res.getString(<span class="string">&quot;HIREDATE&quot;</span>);</span><br><span class="line">String SAL=res.getString(<span class="string">&quot;SAL&quot;</span>);</span><br><span class="line">String COMM=res.getString(<span class="string">&quot;COMM&quot;</span>);</span><br><span class="line">String DEPTNO=res.getString(<span class="string">&quot;DEPTNO&quot;</span>);</span><br><span class="line">out.print(ENAME+<span class="string">&quot; &quot;</span>+JOB+<span class="string">&quot; &quot;</span>+MGR+<span class="string">&quot; &quot;</span>+HIREDATE+<span class="string">&quot; &quot;</span>+SAL+<span class="string">&quot; &quot;</span>+COMM+<span class="string">&quot; &quot;</span>+DEPTNO);</span><br><span class="line">out.print(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">System.out.println(ENAME+<span class="string">&quot; &quot;</span>+JOB+<span class="string">&quot; &quot;</span>+MGR+<span class="string">&quot; &quot;</span>+HIREDATE+<span class="string">&quot; &quot;</span>+SAL+<span class="string">&quot; &quot;</span>+COMM+<span class="string">&quot; &quot;</span>+DEPTNO);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;查询完毕&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(res!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">res.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(statement!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">statement.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(con!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">con.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IDEA中servelet连接数据库"><a href="#IDEA中servelet连接数据库" class="headerlink" title="IDEA中servelet连接数据库"></a>IDEA中servelet连接数据库</h2><p>1.<br>New Project后新建模块</p><p>2.<br>让Module变成JavaEE的模块。（让Module变成webapp的模块。符合webapp规范。符合Servlet规范的Module）</p><p>在Module上点击右键：Add Framework Support…（添加框架支持）</p><p>在弹出的窗口中，选择Web Application（选择的是webapp的支持）</p><p><strong>在IDEA工具中根据Web Application模板生成的目录中有一个web目录，这个目录就代表webapp的根</strong></p><p>3.<br>编写Servlet（StudentServlet）</p><p>发现Servlet.class文件没有？<br><strong>将CATALINA_HOME/lib/servlet-api.jar和jsp-api.jar添加到classpath当中（这里的classpath说的是IDEA的classpath）</strong><br>File –&gt; Project Structrue –&gt; Modules –&gt; + 加号 –&gt; Add JARS….</p><p>实现jakarta.servlet.Servlet接口中的5个方法。</p><p>4.<br>在Servlet当中的service方法中编写业务代码</p><p>5.<br>在WEB-INF目录下新建了一个子目录：lib（这个目录名可不能随意，必须是全部小写的lib），并且将连接数据库的驱动jar包放到lib目录下。</p><p>6.<br>在web.xml文件中完成StudentServlet类的注册。（请求路径和Servlet之间对应起来）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">创建servlet</span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>StudyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>StudentServlte<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">将servlet映射到该路径</span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>StudyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        这里的路径是项目根目录，/s就代表根目录下的s</span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>7.</p><p>给一个html页面，在HTML页面中编写一个超链接，用户点击这个超链接，发送请求，Tomcat执行后台的StudentServlet。</p><p>student.html</p><p>这个文件不能放到WEB-INF目录里面，只能放到WEB-INF目录外面。</p><p>student.html文件的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>student page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里的项目名是 /StudyServlet ，无法动态获取，先写死--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/StudyServlet/s&quot;</span>&gt;</span>student list<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>8.<br>让IDEA工具去关联Tomcat服务器。关联的过程当中将webapp部署到Tomcat服务器当中。</p><p>IDEA工具右上角，绿色小锤子右边有一个：Add Configuration<br>左上角加号，点击Tomcat Server –&gt; local<br>在弹出的界面中设置服务器Server的参数（基本上不用动）<br>在当前窗口中有一个Deployment（点击这个用来部署webapp），继续点击加号，部署即可。<br>修改 Application context为：/StudyServlet</p><p>9.<br>启动Tomcat服务器</p><p>在右上角有绿色的箭头，或者绿色的小虫子，点击这个绿色的小虫子，可以采用debug的模式启动Tomcat服务器。<br>我们开发中建议适用debug模式启动Tomcat<br>第十二步：打开浏览器，在浏览器地址栏上输入：<a href="http://localhost:8080/StudyServlet/s.html">http://localhost:8080/StudyServlet/s.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="java" scheme="https://codecodegogogo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>vue脚手架结构</title>
    <link href="https://codecodegogogo.github.io/2024/02/08/vue%E8%84%9A%E6%89%8B%E6%9E%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://codecodegogogo.github.io/2024/02/08/vue%E8%84%9A%E6%89%8B%E6%9E%B6%E7%BB%93%E6%9E%84/</id>
    <published>2024-02-08T07:20:10.000Z</published>
    <updated>2024-02-08T07:21:45.555Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/2024/02/08/vue%E8%84%9A%E6%89%8B%E6%9E%B6%E7%BB%93%E6%9E%84/1.png" alt="?"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="vue" scheme="https://codecodegogogo.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue生命周期</title>
    <link href="https://codecodegogogo.github.io/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://codecodegogogo.github.io/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2024-02-07T03:14:25.000Z</published>
    <updated>2024-02-07T05:02:22.931Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段"></a>初始阶段</h2><p><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E5%88%9D%E5%A7%8B%E9%98%B6%E6%AE%B5.png" alt="?"><br><em><strong>1.beforeCreate方法</strong></em><br>方法执行前，进行一些事件对象的初始化，此时还么有进行数据代理，使用方法会报错，方法完成后才可以进行方法调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="title function_">say</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="title function_">beforeCreate</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">say</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeCreate&quot;</span>)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue.js:5108 [Vue warn]: Error in beforeCreate hook: &quot;TypeError: this.say is not a function&quot;</span><br></pre></td></tr></table></figure><p><em><strong>2.created方法</strong></em><br>方法执行后，观察代码中是否有el配置项进行指定元素挂载，如果没有需要调用$mount(元素)进行挂载，如果没有报错。再查看template:&lt;标签&gt;&lt;/标签&gt;配置项是否存在，存在直接覆盖渲染，如果没有则使用元素本来的样式。</p><h2 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h2><p><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5.png" alt="?"><br><em><strong>3.beforeMount方法</strong></em><br>方法执行前，和上方法执行后没变化，但是如果此时修改html元素，短暂生效后立刻失效，以为此时要将虚拟dom映射为真实dom</p><p><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B52.png" alt="?"><br><strong>点击下一步后立刻失效</strong></p><p><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B53.png" alt="?"></p><p><em><strong>4.Mount方法</strong></em><br>方法执行前，此时修改html元素生效，此时已经将虚拟dom映射为真实dom</p><h2 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h2><p><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5.png" alt="?"></p><p><em><strong>beforeUpdata方法</strong></em><br>方法执行前数据发生变化，但页面没有变化。</p><p><em><strong>updated方法</strong></em><br>方法执行前将进行页面重新渲染，此时diff算法有可能执行（根据组件key选择是否需要重新渲染）</p><h2 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h2><p><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B5.png" alt="?"><br><em><strong>beforeDestroy()执行前</strong></em><br>虽然此时还没有进行销毁，但是一下监视器等也不能使用了</p><p><em><strong>destroy()执行时</strong></em><br>此时一些监视器等不能用了，但是一些方法还可以用，因为并不是将vm的内存释放了<br><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B52.png" alt="?"></p><p><strong>一图全览：</strong><br><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="?"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="vue" scheme="https://codecodegogogo.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>数组的一些方法</title>
    <link href="https://codecodegogogo.github.io/2024/02/05/filter/"/>
    <id>https://codecodegogogo.github.io/2024/02/05/filter/</id>
    <published>2024-02-05T09:29:53.000Z</published>
    <updated>2024-02-06T05:14:17.496Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>0.filter()</p><p><strong>filter用于筛选数组中符合特定条件的元素，然后返回一个新的数组，包含符合条件的元素，他不会破坏原有的数组。</strong></p><p>filter 方法会对数组中的每个元素调用一次 callback 函数，并将返回值为 true 的元素添加到新数组中，最终返回这个新数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出大于等于3的元素</span></span><br><span class="line"><span class="keyword">const</span> filteredNumbers = numbers.<span class="title function_">filter</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num &gt;= <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filteredNumbers); <span class="comment">// 输出: [3, 4, 5]</span></span><br></pre></td></tr></table></figure><ol><li><p><code>push()</code>: 这个方法用于在数组的末尾添加一个或多个元素，并返回修改后数组的新长度。</p></li><li><p><code>pop()</code>: <code>pop()</code> 方法用于删除并返回数组的最后一个元素。</p></li><li><p><code>reverse()</code>: <code>reverse()</code> 方法用于颠倒数组中元素的顺序，即将数组中的元素倒序排列。</p></li><li><p><code>splice()</code>: <code>splice()</code> 方法可以用来插入、删除或替换数组的元素。它接受多个参数，包括要操作的起始位置、要删除的元素个数以及要插入的新元素。</p></li><li><p><code>shift()</code>: <code>shift()</code> 方法用于删除并返回数组的第一个元素。</p></li><li><p><code>unshift()</code>: <code>unshift()</code> 方法用于在数组的开头添加一个或多个元素，并返回修改后数组的新长度。</p></li><li><p><code>sort()</code>: <code>sort()</code> 方法用于对数组的元素进行排序，默认按照字母顺序排序。可选参数可以指定排序规则。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="javascript" scheme="https://codecodegogogo.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>箭头函数</title>
    <link href="https://codecodegogogo.github.io/2024/02/05/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://codecodegogogo.github.io/2024/02/05/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</id>
    <published>2024-02-05T09:06:40.000Z</published>
    <updated>2024-02-11T08:17:52.877Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>箭头函数是ES6（ECMAScript 2015）引入的一种新的函数声明方式，它提供了一种更简洁的语法形式。</strong></p><p><strong>和传统函数比较：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="comment">//括号中为参数，箭头后为方法体</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x, y</span>) =&gt; x + y;</span><br></pre></td></tr></table></figure><p>如果箭头函数体内只包含一个表达式，它将自动将该表达式的值作为函数的返回值。<br>如果箭头函数体内包含了多个语句，就需要使用花括号 {} 包裹起来，并显式地使用 return 语句来返回值。</p><p><strong>没有自己的this： 箭头函数不会创建自己的this，而是会继承外部作用域的this。这意味着箭头函数内部的this和外部的this是一致的。</strong></p><p>箭头函数有几个使用注意点：</p><p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。<br>不可以使用yield命令，因此箭头函数不能用作Generator函数。</p><p><strong>普通函数的上下文是调用使用才能确定的，并且规则很多，但是箭头函数的上下文是定义时候确定的。<br>箭头函数的上下文依靠的是父作用域函数的上下文，获取箭头函数的上下文this就是，就需要获取定义时候所处的普通函数的作用域，该普通函数的上下文就是箭头函数的上下文，如果所处环境没有普通函数上下文就是window.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TraditionalFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//setTimeout是由js引擎进行管理，他的this为window对象</span></span><br><span class="line">  <span class="comment">// 传统函数中的this</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>); <span class="comment">// undefined，因为this指向了全局对象</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ArrowFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 箭头函数中的this，继承了外部作用域的this</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>); <span class="comment">// 2，this指向了ArrowFunction的实例</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果需要多个语句，可以使用花括号{}包裹起来。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单一表达式的箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">double</span> = (<span class="params">x</span>) =&gt; x * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多语句的箭头函数，需要使用花括号</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">multiply</span> = (<span class="params">x, y</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = x * y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="javascript" scheme="https://codecodegogogo.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="https://codecodegogogo.github.io/2024/02/02/%E9%97%AD%E5%8C%85/"/>
    <id>https://codecodegogogo.github.io/2024/02/02/%E9%97%AD%E5%8C%85/</id>
    <published>2024-02-02T10:28:15.000Z</published>
    <updated>2024-02-05T10:15:57.509Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>函数套函数，内函数发生闭包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function makeFunc() &#123;</span><br><span class="line">  var name = &quot;Mozilla&quot;;</span><br><span class="line">  function displayName() &#123;</span><br><span class="line">    alert(name);</span><br><span class="line">  &#125;</span><br><span class="line">  return displayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myFunc = makeFunc();</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure><p>在本例子中，myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用。displayName 的实例维持了一个对它的词法环境（变量 name 存在于其中）的引用。因此，当 myFunc 被调用时，变量 name 仍然可用，其值 Mozilla 就被传递到alert中。</p><h3 id="使用闭包返回不同值"><a href="#使用闭包返回不同值" class="headerlink" title="使用闭包返回不同值"></a>使用闭包返回不同值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function makeAdder(x) &#123;</span><br><span class="line">  return function (y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add5 = makeAdder(5);</span><br><span class="line">var add10 = makeAdder(10);</span><br><span class="line"></span><br><span class="line">console.log(add5(2)); // 7</span><br><span class="line">console.log(add10(2)); // 12</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="javascript" scheme="https://codecodegogogo.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://codecodegogogo.github.io/2024/01/31/JVM/"/>
    <id>https://codecodegogogo.github.io/2024/01/31/JVM/</id>
    <published>2024-01-31T02:14:52.000Z</published>
    <updated>2024-01-31T06:09:36.736Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>jvm实现一次编写，跨平台到处使用。它有各种指令集和运行时的内存区域。</p><h2 id="JVM产品"><a href="#JVM产品" class="headerlink" title="JVM产品"></a>JVM产品</h2><p>Classic VM (早期 Sun 的 Java 虚拟机)<br>Exact VM (早期 Solaris 平台上)<br><strong>HotSpot(OracleDK与OpenJDK 默认)</strong><br>JRockit (BEA 的，被 Oracle 收购，并且整合到 HotSpot 里面)<br>J9 (IBM 商用)<br>Google Android Dalvik VM (Android 上的)<br>KVM、CDC、CLDC(嵌入式领域)<br>Microsof JVM(微软的)<br>Graal VM（跨语言全栈虚拟机 Run Programs Faster Anywhere）</p><h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>jvm只和class文件相关，除了java外还有别的语言也可以产生class文件，如：kotlin,scala。他并不关心class文件是由什么语言产生的。</p><p>内存大小端<br>大端存储：数据低位存在高地址（人类阅读方式）<br>小端存储：数据低位存在低地址</p><p><strong>我们在存放的时候是以一个存储单元为单位来存放，存储单元内部不需要再转变顺序。</strong><br>例如：0001-0101存放在0号地址，不需要把它变成1010-1000！</p><p><strong>class字节码按照大端存储</strong></p><h2 id="class文件结构"><a href="#class文件结构" class="headerlink" title="class文件结构"></a>class文件结构</h2><p>Class文件数据结构采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”.</p><p><strong>无符号数</strong>：<br>定义了一组专用的数据类型来表示Class文件的内容，它们包括u1、u2、u4分别代表1、2和4个字节的无符号数。</p><p>无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p><p>每个无符号数严格按照顺序连续存放，它们之间没有用任何填充或对齐。</p><p><strong>表</strong>：<br>表用于描述有层次关系的复合结构的数据。</p><p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型。</p><p>表的命名都习惯性地以“_info”结尾。</p><p>整个Class文件本质上也可以视作是一张表。<br><img src="/2024/01/31/JVM/2.2.png" alt="?"></p><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>文件内容起始几个字节使用固定的内容来描述该文件类型，因此这几个字节的内容称为魔数。</p><p><strong>class文件魔数：cafe babe</strong></p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>主版本（major version）记录每个大版本号，起始值为45.<br>次版本（minor version）记录每个小版本号，起始值为3.<br>jdk1.1.8=45.3<br>jdk8=52.0<br>jdk11=55.0</p><p><strong>JVM高版本可以执行低版本class，反之异常java.lang.UnsupportedClassVersionError</strong></p><h2 id="class文件数据结构"><a href="#class文件数据结构" class="headerlink" title="class文件数据结构"></a>class文件数据结构</h2><h2 id="class文件基本信息"><a href="#class文件基本信息" class="headerlink" title="class文件基本信息"></a>class文件基本信息</h2><h2 id="class文件常量池信息"><a href="#class文件常量池信息" class="headerlink" title="class文件常量池信息"></a>class文件常量池信息</h2><h2 id="class文件访问标志信息"><a href="#class文件访问标志信息" class="headerlink" title="class文件访问标志信息"></a>class文件访问标志信息</h2><h2 id="class文件类、接口信息"><a href="#class文件类、接口信息" class="headerlink" title="class文件类、接口信息"></a>class文件类、接口信息</h2><h2 id="class文件字段、属性、方法信息"><a href="#class文件字段、属性、方法信息" class="headerlink" title="class文件字段、属性、方法信息"></a>class文件字段、属性、方法信息</h2><h2 id="class文件字节码指令"><a href="#class文件字节码指令" class="headerlink" title="class文件字节码指令"></a>class文件字节码指令</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="java" scheme="https://codecodegogogo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>js原型和构造方法</title>
    <link href="https://codecodegogogo.github.io/2024/01/29/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <id>https://codecodegogogo.github.io/2024/01/29/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</id>
    <published>2024-01-29T07:17:55.000Z</published>
    <updated>2024-01-31T03:07:03.508Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><em>1。定义在构造函数内部的方法和定义在原型上的方法有什么区别？</em></p><p><strong>定义在构造函数内部的方法,会在它的每一个实例上都克隆这个方法;定义在构造函数的prototype属性上的方法会让它的所有示例都共享这个方法,但是不会在每个实例的内部重新定义这个方法.</strong> 如果我们的应用需要创建很多新的对象,并且这些对象还有许多的方法,为了节省内存,我们建议把这些方法都定义在构造函数的prototype属性上.</p><p>2.<em>如何互相访问</em></p><p>对象.<em>proto</em> 访问原型<br>构造方法.prototype 访问原型<br>原型.constructor 访问构造方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="javascript" scheme="https://codecodegogogo.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>SnakeGame</title>
    <link href="https://codecodegogogo.github.io/2024/01/27/SnakeGame/"/>
    <id>https://codecodegogogo.github.io/2024/01/27/SnakeGame/</id>
    <published>2024-01-27T12:57:53.000Z</published>
    <updated>2024-01-27T12:59:00.011Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>java实现贪吃蛇</p><p>闲来无事写了一个小游戏，具体代码参见：</p><p><strong><a href="https://github.com/codecodegogogo/Snake_Game">https://github.com/codecodegogogo/Snake_Game</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="java" scheme="https://codecodegogogo.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>程序是怎么跑起来的</title>
    <link href="https://codecodegogogo.github.io/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"/>
    <id>https://codecodegogogo.github.io/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</id>
    <published>2023-07-30T12:50:38.000Z</published>
    <updated>2023-08-09T13:43:19.912Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="cpu是什么"><a href="#cpu是什么" class="headerlink" title="cpu是什么"></a>cpu是什么</h1><p>CPU 是英文 Central Processing Unit( 中央处理器)的缩写，相当于计算机的大脑，它的内部由数百万至数亿个晶体管构成这些都是大家所熟知的。</p><h2 id="CPU-的内部结构解析"><a href="#CPU-的内部结构解析" class="headerlink" title="CPU 的内部结构解析"></a>CPU 的内部结构解析</h2><p>CPU和内存是由许多晶体管组成的电子部件，通常称为IC( Integrated Circuit，集成电路)。从功能方面来看，CPU的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。</p><p>寄存器可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有20~100个寄存器。</p><p>控制器负责把内存上的指令、数据等读人寄存器并根据指令的执行结果来控制整个计算机。</p><p>运算器负责运算从内存读入寄存器的数据。</p><p>时钟负责发出 CPU 开始计时的时钟信号“。不过，也有些计算机的时钟位于CPU的外部。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q2.png" alt="?"><br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q1.png" alt="?"></p><p>通常所说的内存指的是计算机的主存储器( main memory,简称主存。主存通过控制芯片等与CPU相连主要负责存储指令和数据。主存由可读写的元素构成，每个字节(1字节 =8位)都带有一个地址编号。CPU 可以通过该地址读取主存中的指令和数据，当然也可以写入数据。主存中存储的指令和数据会随着计算机的关机而自动清除。</p><p><strong>程序启动后，根据时钟信号，控制器会从内存中读取指令和数据。通过对这些指令加以解释和运行，运算器就会对数据进行运算，控制器根据该运算结果来控制计算机。所谓的控制就是指数据运算以外的处理(主要是数据输入输出的时机控制 )。比如内存和磁盘等媒介的输入输出、键盘和鼠标的输人、显示器和打印机的输出等，这些都是控制的内容。</strong></p><h2 id="CPU-是寄存器的集合体"><a href="#CPU-是寄存器的集合体" class="headerlink" title="CPU 是寄存器的集合体"></a>CPU 是寄存器的集合体</h2><p><strong>程序是把寄存器作为对象来描述的。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov  eax, dword ptr [ebp<span class="number">-8</span>]    …把数值从内存复制到eax</span><br><span class="line">add  eax, dword ptr [ebp<span class="number">-0</span>Ch]  …eax的数值和内存的数值相加</span><br><span class="line">mov  dword ptr [ebp<span class="number">-4</span>], eax    …把eax的数值（上一步的相加结果）存储在内存中</span><br></pre></td></tr></table></figure><p>汇编语言是80386以上的CPU所使用的语言。eax和ebp是CPU内部的寄存器的名称。内存的存储场所通过地址编号来区分，而寄存器的种类则通过名字来区分。使用高级语言编写的程序会在编译后转化成机器语言，然后再通过CPU内部的寄存器来处理。</p><p>寄存器中存储的内容既可以是指令也可以是数据。其中，数据分为“用于运算的数值”和“表示内存地址的数值”两种。数据种类不同，存储该数值的寄存器也不同。CPU中每个寄存器的功能都是不同的。用于运算的数值放在累加寄存器中存储，表示内存地址的数值则放在基址寄存器和变址寄存器中存储。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q3.png" alt="?"><br>CPU是具有各种功能的寄存器的集合体。其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器一般有多个。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q4.png" alt="?"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q5.png" alt="?"><br>地址0100是程序运行的开始位置。Windows等操作系统把程序从硬盘复制到内存后，会将程序计数器（CPU寄存器的一种）设定为0100，然后程序便开始运行。CPU每执行一个指令，程序计数器的值就会自动加1。例如，CPU执行0100地址的指令后，程序计数器的值就变成了0101（当执行的指令占据多个内存地址时，增加与指令长度相应的数值）。然后，CPU的控制器就会参照程序计数器的数值，从内存中读取命令并执行。也就是说，程序计数器决定着程序的流程。</p><h2 id="条件分支和循环机制"><a href="#条件分支和循环机制" class="headerlink" title="条件分支和循环机制"></a>条件分支和循环机制</h2><p>CPU在进行运算时，标志寄存器的数值会根据运算结果自动设定。条件分支在跳转指令前会进行比较运算。至于是否执行跳转指令，则由CPU在参考标志寄存器的数值后进行判断。运算结果的正、零、负三种状态由标志寄存器的三个位表示。图1-6是32位CPU（寄存器的长度是32位）的标志寄存器的示例。标志寄存器的第一个字节位、第二个字节位和第三个字节位的值为1时，表示运算结果分别为正数、零和负数。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q6.png" alt="?"><br>假设要比较累加寄存器中存储的XXX值和通用寄存器中存储的YYY值，执行比较的指令后，CPU的运算装置就会在内部（暗中）进行XXX-YYY的减法运算。而无论减法运算的结果是正数、零还是负数，都会保存到标志寄存器中。结果为正表示XXX比YYY大，零表示XXX和YYY相等，负表示XXX比YYY小。程序中的比较指令，就是在CPU内部做减法运算。</p><h2 id="函数的调用机制"><a href="#函数的调用机制" class="headerlink" title="函数的调用机制"></a>函数的调用机制</h2><p>哪怕是高级语言编写的程序，函数调用处理也是通过把程序计数器的值设定成函数的存储地址来实现的。</p><p>函数的调用需要在完成函数内部的处理后，处理流程再返回到函数调用点（函数调用指令的下一个地址）。因此，如果只是跳转到函数的入口地址，处理流程就不知道应该返回至哪里了。</p><p>给变量a和b分别代入123和456后，将其赋值给参数（parameter）来调用MyFunc函数的C语言程序。图中的地址是将C语言编译成机器语言后运行时的地址。由于1行C语言程序在编译后通常会变成多行的机器语言，所以图中的地址是离散的。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q7.png" alt="?"><br>此外，通过跳转指令把程序计数器的值设定成0260也可实现调用MyFunc函数。函数的调用原点（0132地址）和被调用函数（0260地址）之间的数据传递，可以通过内存或寄存器来实现。不过，当函数处理进行到最后的0354地址时，我们知道应该将程序计数器的值设定成函数调用后要执行的0154地址，但实际上这一操作根本无法实现。</p><p>机器语言的call指令和return指令能够解决这个问题。建议大家把二者结合起来来记忆。函数调用使用的是call指令，而不是跳转指令。在将函数的入口地址设定到程序计数器之前，call指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行return命令。return命令的功能是把保存在栈中的地址设定到程序计数器中。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w1.png" alt="?"></p><h2 id="通过地址和索引实现数组"><a href="#通过地址和索引实现数组" class="headerlink" title="通过地址和索引实现数组"></a>通过地址和索引实现数组</h2><p>基址寄存器和变址寄存器。通过这两个寄存器，我们可以对主内存上特定的内存区域进行划分，从而实现类似于数组的操作。</p><p>首先，我们用十六进制数将计算机内存上00000000～FFFFFFFF的地址划分出来。那么，凡是该范围的内存区域，只要有一个32位的寄存器，即可查看全部的内存地址。但如果想要像数组那样分割特定的内存区域以达到连续查看的目的，使用两个寄存器会更方便些。例如，查看10000000地址～1000FFFF地址时，可以将10000000存入基址寄存器，并使变址寄存器的值在00000000～0000FFFF变化。CPU则会把基址寄存器+变址寄存器的值解释为实际查看的内存地址。变址寄存器的值就相当于高级编程语言程序中数组的索引功能。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w2.png" alt="?"></p><h2 id="CPU的处理"><a href="#CPU的处理" class="headerlink" title="CPU的处理"></a>CPU的处理</h2><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w3.png" alt="?"></p><hr><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>计算机内部是由IC这种电子部件构成的。</p><p>CPU（微处理器）和内存也是IC的一种。IC有几种不同的形状，有的像一条黑色蜈蚣，在其两侧有数个乃至数百个引脚；有的则像插花用的针盘，引脚在IC内部并排排列着。IC的所有引脚，只有直流电压0V或5V两个状态。也就是说，IC的一个引脚，只能表示两个状态。</p><p>IC的这个特性，决定了计算机的信息数据只能用二进制数来处理。由于1位（一个引脚）只能表示两个状态，所以二进制的计数方式就变成了0、1、10、11、100…这种形式。</p><p>内存和磁盘都使用字节单位来存储和读写数据，使用位单位则无法读写数据。因此，字节是信息的基本单位。奔腾等32位微处理器，具有32个引脚以用于信息的输入和输出。也就是说，奔腾一次可以处理32位（32位=4字节）的二进制数信息。</p><h2 id="二进制数"><a href="#二进制数" class="headerlink" title="二进制数"></a>二进制数</h2><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w5.png" alt="?"><br>十进制数39用8位的二进制表示是00100111，左移两位后是10011100，再转换成十进制数就是156。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w6.png" alt="?"></p><h2 id="补数"><a href="#补数" class="headerlink" title="补数"></a>补数</h2><p>二进制数中表示负数值时，一般会把最高位作为符号来使用，因此我们把这个最高位称为符号位。符号位是0时表示正数，符号位是1时表示负数。那么-1用8位二进制数来表示的话是什么样的呢？</p><p>正确答案是11111111。</p><p>计算机在做减法运算时，实际上内部是在做加法运算。补数就是用正数来表示负数。</p><p>为了获得补数，我们需要将二进制数的各数位的数值全部取反，然后再将结果加1。例如，用8位二进制数表示- 1时，只需求得1，也就是00000001的补数即可。具体来说，就是将各数位的0取反成1, 1取反成0，然后再将取反的结果加1，最后就转化成了11111111。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w7.png" alt="?"></p><p>00000001+11111111确实为0（=00000000）。这个运算中出现了最高位溢出的情况，不过，正如之前所介绍的那样，对于溢出的位，计算机会直接忽略掉。在8位的范围内进行计算时，100000000这个9位二进制数就会被认为是00000000这一8位二进制数。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e1.png" alt="?"></p><p>当运算结果为负数时，计算结果的值也是以补数的形式来表示的。</p><p>比如3- 5这个运算，用8位二进制数表示3时为00000011，而5=00000101的补数为“取反+1”，也就是11111011。因此3- 5其实就是00000011+ 11111011的运算。00000011 + 11111011的运算结果为11111110，最高位变成了1。</p><p>C语言的数据类型中，既有不能处理负数的unsigned short类型，也有能处理负数的short类型。这两种类型，都是2字节（=16位）的变量，都能表示2的16次幂=65536种值，这一点是相同的。不过，值的范围有所不同，short类型是- 32768～32767,unsigned short类型是0～65535。</p><h2 id="逻辑右移和算术右移"><a href="#逻辑右移和算术右移" class="headerlink" title="逻辑右移和算术右移"></a>逻辑右移和算术右移</h2><p><strong>右移有移位后在最高位补0和补1两种情况。</strong></p><p>当二进制数的值表示图形模式而非数值时，移位后需要在最高位补0。</p><p>将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值（0或1）。这就称为算术右移。如果数值是用补数表示的负数值，那么右移后在空出来的最高位补1，就可以正确地实现1/2、1/4、1/8等的数值运算。如果是正数，只需在最高位补0即可。</p><p>现在我们来看一个右移的例子。将- 4（=11111100）右移两位。这时，逻辑右移的情况下结果就会变成00111111，也就是十进制数63，显然不是- 4的1/4。而算术右移的情况下，结果就会变成11111111，用补数表示就是- 1，即- 4的1/4。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e2.png" alt="?"></p><h2 id="符号扩充"><a href="#符号扩充" class="headerlink" title="符号扩充"></a>符号扩充</h2><p><strong>符号扩充就是指在保持值不变的前提下将其转换成16位和32位的二进制数。</strong></p><p>将01111111这个正的8位二进制数转换成16位二进制数时，很容易就能得出0000000001111111这个正确结果。</p><p>11111111这样用补数来表示的数值，该如何处理比较好呢？<br>实际上处理方法非常简单，将其表示成1111111111111111就可以了。也就是说，不管是正数还是用补数表示的负数，都只需用符号位的值（0或者1）填充高位即可。</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>计算机能处理的运算，大体可分为算术运算和逻辑运算。算术运算是指加减乘除四则运算。逻辑运算是指对二进制数各数字位的0和1分别进行处理的运算，包括逻辑非（NOT运算）、逻辑与（AND运算）、逻辑或（OR运算）和逻辑异或（XOR运算）四种。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e3.png" alt="?"></p><hr><h1 id="计算机进行小数运算时出错的原因"><a href="#计算机进行小数运算时出错的原因" class="headerlink" title="计算机进行小数运算时出错的原因"></a>计算机进行小数运算时出错的原因</h1><h2 id="将0-1累加100次也得不到10"><a href="#将0-1累加100次也得不到10" class="headerlink" title="将0.1累加100次也得不到10"></a>将0.1累加100次也得不到10</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> sum;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//将保存总和的变量清0</span></span><br><span class="line">    sum =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//0.1相加100次</span></span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">1</span>;  i &lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum +=<span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>10.000002</p></blockquote></blockquote><h2 id="用二进制数表示小数"><a href="#用二进制数表示小数" class="headerlink" title="用二进制数表示小数"></a>用二进制数表示小数</h2><p>由于计算机内部所有的信息都是以二进制数的形式来处理的，因此在这一点上，整数和小数并无差别。不过，使用二进制数来表示整数和小数的方法却有很大的不同。</p><p>把1011.0011这个有小数点的二进制数转换成十进制数。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w8.png" alt="?"></p><h2 id="计算机运算出错的原因"><a href="#计算机运算出错的原因" class="headerlink" title="计算机运算出错的原因"></a>计算机运算出错的原因</h2><p>计算机之所以会出现运算错误，是因为“有一些十进制数的小数无法转换成二进制数”。</p><p>小数点后4位用二进制数表示时的数值范围为0.0000～0.1111。因此，这里只能表示0.5、0.25、0.125、0.0625这四个二进制数小数点后面的位权组合而成（相加总和）的小数。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e4.png" alt="?"><br>因为无法正确表示的数值，最后都变成了近似值。计算机这个功能有限的机器设备，是无法处理无限循环的小数的。因此，在遇到循环小数时，计算机就会根据变量数据类型所对应的长度将数值从中间截断或者四舍五入。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>双精度浮点数类型用64位、单精度浮点数类型用32位来表示全体小数。</p><hr><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="内存的物理机制"><a href="#内存的物理机制" class="headerlink" title="内存的物理机制"></a>内存的物理机制</h2><p>内存实际上是一种名为内存IC的电子元件。虽然内存IC包括DRAM、SRAM、ROM等多种形式，但从外部来看，其基本机制都是一样的。内存IC中有电源、地址信号、数据信号、控制信号等用于输入输出的大量引脚（IC的引脚），通过为其指定地址（address），来进行数据的读写。</p><p>VCC和GND是电源，A0～A9是地址信号的引脚，D0～D7是数据信号的引脚，RD和WR是控制信号的引脚。将电源连接到VCC和GND后，就可以给其他引脚传递比如0或者1这样的信号。大多数情况下，+ 5V的直流电压表示1,0V表示0。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e5.png" alt="?"></p><p>首先，我们假设要往该内存IC中写入1字节的数据。为了实现该目的，可以给VCC接入+5V，给GND接入0V的电源，并使用A0～A9的地址信号来指定数据的存储场所，然后再把数据的值输入给D0～D7的数据信号，并把WR（write=写入的简写）信号设定成1。执行完这些操作，就可以在内存IC内部写入数据（图4-2 (a)）了。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e6.png" alt="?"><br>读出数据时，只需通过A0～A9的地址信号指定数据的存储场所，然后再将RD（read=读出的简写）信号设成1即可。</p><p><strong>当WR和RD同时为0时，写入和读出的操作都无法进行。</strong></p><h2 id="内存的逻辑模型"><a href="#内存的逻辑模型" class="headerlink" title="内存的逻辑模型"></a>内存的逻辑模型</h2><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/r1.png" alt="?"><br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/r2.png" alt="?"></p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针也是一种变量，它所表示的不是数据的值，而是存储着数据的内存的地址。通过使用指针，就可以对任意指定地址的数据进行读写。</p><p>Windows计算机上使用的程序通常都是32位（4字节）的内存地址。这种情况下，指针变量的长度也是32位。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是指多个同样数据类型的数据在内存中连续排列的形式。作为数组元素的各个数据会通过连续的编号被区分开来，这个编号称为索引（index）。指定索引后，就可以对该索引所对应地址的内存进行读写操作。而索引和内存地址的变换工作则是由编译器自动实现的。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/R3.png" alt="?"></p><h2 id="栈、队列以及环形缓冲区"><a href="#栈、队列以及环形缓冲区" class="headerlink" title="栈、队列以及环形缓冲区"></a>栈、队列以及环形缓冲区</h2><p>栈和队列，都可以不通过指定地址和索引来对数组的元素进行读写。需要临时保存计算过程中的数据、连接在计算机上的设备或者输入输出的数据时，都可以通过这些方法来使用内存。如果每次保存临时数据都需指定地址和索引，程序就会变得比较麻烦，因此要加以改进。</p><p>队列一般是以环状缓冲区（ring buffer）的方式来实现的.<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/R4.png" alt="?"></p><hr><h1 id="内存和磁盘"><a href="#内存和磁盘" class="headerlink" title="内存和磁盘"></a>内存和磁盘</h1><h2 id="不读入内存就无法运行"><a href="#不读入内存就无法运行" class="headerlink" title="不读入内存就无法运行"></a>不读入内存就无法运行</h2><p>计算机中主要的存储部件是内存和磁盘。磁盘中存储的程序，必须要加载到内存后才能运行。在磁盘中保存的原始程序是无法直接运行的。</p><p>这是因为，负责解析和运行程序内容的CPU，需要通过内部程序计数器来指定内存地址，然后才能读出程序。即使CPU可以直接读出并运行磁盘中保存的程序，由于磁盘读取速度慢，程序的运行速度还是会降低。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/R5.png" alt="?"></p><h2 id="磁盘缓存加快了磁盘访问速度"><a href="#磁盘缓存加快了磁盘访问速度" class="headerlink" title="磁盘缓存加快了磁盘访问速度"></a>磁盘缓存加快了磁盘访问速度</h2><p>磁盘缓存指的是把从磁盘中读出的数据存储到内存空间中的方式。使用磁盘缓存可以大大改善磁盘数据的访问速度。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/R6.png" alt="?"></p><p><strong>把低速设备的数据保存在高速设备中，需要时可以直接将其从高速设备中读出，这种缓存的方式在其他情况下也会用到。</strong></p><p>其中的一个实例就是在Web浏览器中的使用。由于Web浏览器是通过网络来获取远程Web服务器的数据并将其显示出来的。因此，在显示较大的图片等文件时，会花费不少时间。于是，Web浏览器就可以把获取的数据暂时保存在磁盘中，然后在需要时再显示磁盘中的数据。也就是说，把低速的网络数据保存到相对高速的磁盘中。</p><h2 id="虚拟内存把磁盘作为部分内存来使用"><a href="#虚拟内存把磁盘作为部分内存来使用" class="headerlink" title="虚拟内存把磁盘作为部分内存来使用"></a>虚拟内存把磁盘作为部分内存来使用</h2><p>虚拟内存是指把磁盘的一部分作为假想的内存来使用。这与磁盘缓存是假想的磁盘（实际上是内存）相对，虚拟内存是假想的内存（实际上是磁盘）。</p><p>通过借助虚拟内存，在内存不足时也可以运行程序。</p><p>为了实现虚拟内存，就必须把实际内存（也可称为物理内存）的内容，和磁盘上的虚拟内存的内容进行部分置换（swap），并同时运行程序。</p><h2 id="节约内存的编程方法"><a href="#节约内存的编程方法" class="headerlink" title="节约内存的编程方法"></a>节约内存的编程方法</h2><p>由于使用虚拟内存时发生的Page In和Page Out往往伴随着低速的磁盘访问，因此在这个过程中应用的运行会变得迟钝起来。<br>也就是说，虚拟内存无法彻底解决内存不足的问题。</p><p>为了从根本上解决内存不足的问题，需要增加内存的容量，或者尽量把运行的应用文件变小。</p><h3 id="（1）通过DLL文件实现函数共有"><a href="#（1）通过DLL文件实现函数共有" class="headerlink" title="（1）通过DLL文件实现函数共有"></a>（1）通过DLL文件实现函数共有</h3><p>DLL（Dynamic Link Library）文件，顾名思义，是在程序运行时可以动态加载Library（函数和数据的集合）的文件。多个应用可以共有同一个DLL文件。而通过共有同一个DLL文件则可以达到节约内存的效果。</p><p>例如，假设我们编写了一个具有某些处理功能的函数MyFunc()。应用A和应用B都会使用这个函数。在各个应用的运行文件中内置函数MyFunc()（这个称为Static Link，静态链接）后同时运行这两个应用，内存中就存在了具有同一函数的两个程序。但这会导致内存的利用效率降低。所以，有两个同样的函数，还是有点浪费。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/r7.png" alt="?"></p><p>此内存中存在的函数MyFunc()的程序就只有1个。这样一来，内存的利用效率也就提高了。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/r8.png" alt="?"></p><p>Windows的操作系统本身也是多个DLL文件的集合体。有时在安装新应用时，DLL文件也会被追加。应用则会通过利用这些DLL文件的功能来运行。像这样，之所以要利用多个DLL文件，其中一个原因就是可以节约内存。而且DLL文件还有一个优点就是，在不变更EXE文件的情况下，只通过升级DLL文件就可以更新。</p><h3 id="（2）通过调用-stdcall来减小程序文件的大小"><a href="#（2）通过调用-stdcall来减小程序文件的大小" class="headerlink" title="（2）通过调用_stdcall来减小程序文件的大小"></a>（2）通过调用_stdcall来减小程序文件的大小</h3><p>C语言中，在调用函数后，需要执行栈清理处理指令。栈清理处理是指，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。该命令不是程序记述的，而是在程序编译时由编译器自动附加到程序中的。编译器默认将该处理附加在函数调用方。</p><h2 id="磁盘的物理结构"><a href="#磁盘的物理结构" class="headerlink" title="磁盘的物理结构"></a>磁盘的物理结构</h2><p>磁盘是通过把其物理表面划分成多个空间来使用的。划分的方式有扇区方式和可变长方式两种，前者是指将磁盘划分为固定长度的空间，后者则是指把磁盘划分为长度可变的空间。一般的Windows计算机所使用的硬盘和软盘，采用的都是扇区方式。扇区方式中，把磁盘表面分成若干个同心圆的空间就是磁道，把磁道按照固定大小（能存储的数据长度相同）划分而成的空间就是扇区。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/r9.png" alt="?"></p><p>扇区是对磁盘进行物理读写的最小单位。Windows中使用的磁盘，一般1个扇区是512字节。不过，Windows在逻辑方面（软件方面）对磁盘进行读写的单位是扇区整数倍簇。根据磁盘容量的不同，1簇可以是512字节（1簇=1扇区）、1KB（1簇=2扇区）、2KB、4KB、8KB、16KB、32KB（1簇=64扇区）。磁盘的容量越大，簇的容量也越大。不过，在软盘中，1簇=512字节=1扇区，簇和扇区的大小是相等的。</p><p><strong>不管是多么小的文件，都会占用1簇的空间。这样一来，所有的文件都会占用1簇的整数倍的磁盘空间。如果减少簇的容量，磁盘访问次数就会增加，就会导致读写文件的时间变长。</strong></p><hr><h1 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h1><h2 id="文件以字节为单位保存"><a href="#文件以字节为单位保存" class="headerlink" title="文件以字节为单位保存"></a>文件以字节为单位保存</h2><p>文件是将数据存储在磁盘等存储媒介中的一种形式。</p><h2 id="RLE算法的机制"><a href="#RLE算法的机制" class="headerlink" title="RLE算法的机制"></a>RLE算法的机制</h2><p>AAAAAABBCDDEEEEEF就可以用A6B2C1D2E5F1来表示。</p><p>把文件内容用“数据×重复次数”的形式来表示的压缩方法称为RLE（Run Length Encoding，行程长度编码）算法（图6-2）。RLE算法是一种很好的压缩方法，经常被用于压缩传真的图像等。因为图像文件本质上也是字节数据的集合体，所以可以用RLE算法来压缩。</p><h2 id="RLE算法的缺点"><a href="#RLE算法的缺点" class="headerlink" title="RLE算法的缺点"></a>RLE算法的缺点</h2><p>然而，在实际的文本文件中，同样字符多次重复出现的情况并不多见。虽然针对相同数据经常连续出现的图像、文件等，RLE算法可以发挥不错的效果，但它并不适合文本文件的压缩。不过，因为该压缩机制非常简单，因此使用RLE算法的程序也相对更容易编写。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t1.png" alt="?"></p><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>哈夫曼算法的关键就在于“多次出现的数据用小于8位的字节数来表示，不常用的数据则可以用超过8位的字节数来表示”。</p><p>不过有一点需要注意，不管是不满8位的数据，还是超过8位的数据，最终都要以8位为单位保存到文件中。这是因为磁盘是以字节（8位）为单位来保存数据的。为了实现这一处理，压缩程序的内容会复杂很多，不过作为回报，最终得到的压缩率也是相当高的。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t2.png" alt="?"></p><h2 id="可逆压缩和非可逆压缩"><a href="#可逆压缩和非可逆压缩" class="headerlink" title="可逆压缩和非可逆压缩"></a>可逆压缩和非可逆压缩</h2><p>图像文件的使用目的通常是把图像数据输出到显示器、打印机等设备上。Windows的标准图像数据形式为BMP，是完全未压缩的。</p><p>我们把能还原到压缩前状态的压缩称为可逆压缩，无法还原到压缩前状态的压缩称为非可逆压缩。</p><hr><h1 id="程序是在何种环境中运行的"><a href="#程序是在何种环境中运行的" class="headerlink" title="程序是在何种环境中运行的"></a>程序是在何种环境中运行的</h1><h2 id="运行环境-操作系统-硬件"><a href="#运行环境-操作系统-硬件" class="headerlink" title="运行环境=操作系统 + 硬件"></a>运行环境=操作系统 + 硬件</h2><p>CPU只能解释其自身固有的机器语言。不同的CPU能解释的机器语言的种类也是不同的。例如，CPU有x86、MIPS、SPARC、PowerPC等几种类型，它们各自的机器语言是完全不同的。</p><p>机器语言的程序称为本地代码（native code）。程序员用C语言等编写的程序，在编写阶段仅仅是文本文件。文本文件（排除文字编码的问题）在任何环境下都能显示和编辑。我们称之为源代码。通过对源代码进行编译，就可以得到本地代码。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t3.png" alt="?"></p><h2 id="Windows克服了CPU以外的硬件差异"><a href="#Windows克服了CPU以外的硬件差异" class="headerlink" title="Windows克服了CPU以外的硬件差异"></a>Windows克服了CPU以外的硬件差异</h2><p>计算机的硬件并不仅仅是由CPU构成的，还包括用于存储程序指令和数据的内存，以及通过I/O连接的键盘、显示器、硬盘、打印机等外围设备。</p><p>在Windows的应用软件中，键盘输入、显示器输出等并不是直接向硬件发送指令，而是通过向Windows发送指令来间接实现的。因此，程序员就不用注意内存和I/O地址的不同构成了。因为Windows操作的是硬件而非应用软件，而且针对不同的机型，这些硬件的构成也是有差异的。</p><p>MS-DOS应用大多都是不经过操作系统而直接控制硬件的，而Windows应用则基本上都由Windows来完成对硬件的控制</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t4.png" alt="?"></p><h2 id="不同操作系统的API不同"><a href="#不同操作系统的API不同" class="headerlink" title="不同操作系统的API不同"></a>不同操作系统的API不同</h2><p>同样机型的计算机，可安装的操作系统类型也会有多种选择。<br>当然，应用软件则必须根据不同的操作系统类型来专门开发。CPU的类型不同，所对应的机器语言也不同，同样的道理，操作系统的类型不同，应用程序向操作系统传递指令的途径也是不同的。</p><p>应用程序向操作系统传递指令的途径称为API（Application Programming Interface）。Windows及Unix系列操作系统的API，提供了任何应用程序都可以利用的函数组合。因为不同操作系统的API是有差异的，因此，将同样的应用程序移植到其他操作系统时，就必须要重写应用中利用到API的部分。像键盘输入、鼠标输入、显示器输出、文件输入输出等同外围设备进行输入输出操作的功能，都是通过API提供的。</p><p>在同类型操作系统下，不管硬件如何，API基本上没有差别。因而，针对某特定操作系统的API所编写的程序，在任何硬件上都可以运行。当然，由于CPU种类不同，机器语言也不相同，因此本地代码当然也是不同的。这种情况下，就需要利用能够生成各CPU专用的本地代码的编译器，来对源代码进行重新编译了。</p><h2 id="FreeBSD-Port"><a href="#FreeBSD-Port" class="headerlink" title="FreeBSD Port"></a>FreeBSD Port</h2><p>既然CPU类型不同会导致同样的本地代码无法重复利用，那么为何不直接把源代码分发给程序呢？</p><p>Unix系列操作系统FreeBSD中，存在一种名为Ports的机制。该机制能够结合当前运行的硬件环境来编译应用的源代码，进而得到可以运行的本地代码系统。如果目标应用的源代码没有在硬件上的话，Ports就会自动使用FTP连接到相关站点来下载代码。</p><p>FreeBSD上应用的源代码，大部分都是用C语言来记述的。FreeBSD等Unix系列操作系统中，都带有标准的C编译器。C编译器可以结合FreeBSD的运行环境生成合适的本地代码。</p><h2 id="提供相同运行环境的Java虚拟机"><a href="#提供相同运行环境的Java虚拟机" class="headerlink" title="提供相同运行环境的Java虚拟机"></a>提供相同运行环境的Java虚拟机</h2><p>有一种方法能够提供不依赖于特定硬件及操作系统的程序运行环境，那就是Java。</p><p>同其他编程语言相同，Java也是将Java语法记述的源代码编译后运行。不过，编译后生成的并不是特定CPU使用的本地代码，而是名为字节代码的程序。字节代码的运行环境就称为Java虚拟机（JavaVM, Java Virtual Machine）。Java虚拟机是一边把Java字节代码逐一转换成本地代码一边运行的。而Java虚拟机（java.exe）则会把字节代码变换成x86系列CPU适用的本地代码，然后由x86系列CPU负责实际的处理。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t5.png" alt="?"></p><p>Java虚拟机每次运行时都要把字节代码变换成本机代码，这一机制是造成运行速度慢的原因。</p><h2 id="BIOS和引导"><a href="#BIOS和引导" class="headerlink" title="BIOS和引导"></a>BIOS和引导</h2><p>BIOS存储在ROM中，是预先内置在计算机主机内部的程序。BIOS除了键盘、磁盘、显卡等基本控制程序外，还有启动“引导程序”的功能。引导程序是存储在启动驱动器起始区域的小程序。操作系统的启动驱动器一般是硬盘，不过有时也可以是CD-ROM或软盘。</p><p>开机后，BIOS会确认硬件是否正常运行，没有问题的话就会启动引导程序。引导程序的功能是把在硬盘等记录的OS加载到内存中运行。虽然启动应用是OS的功能，但OS并不能自己启动自己，而是通过引导程序来启动。</p><hr><h1 id="从源文件到可执行文件"><a href="#从源文件到可执行文件" class="headerlink" title="从源文件到可执行文件"></a>从源文件到可执行文件</h1><h2 id="计算机只能运行本地代码"><a href="#计算机只能运行本地代码" class="headerlink" title="计算机只能运行本地代码"></a>计算机只能运行本地代码</h2><p>CPU能直接解析并运行的不是源代码而是本地代码的程序。作为计算机大脑的Pentium等CPU，也只能解释已经转换成本地代码的程序内容。</p><h2 id="编译器负责转换源代码"><a href="#编译器负责转换源代码" class="headerlink" title="编译器负责转换源代码"></a>编译器负责转换源代码</h2><p>能够把C语言等高级编程语言编写的源代码转换成本地代码的程序称为编译器。每个编写源代码的编程语言都需要其专用的编译器。</p><p>编译器首先读入代码的内容，然后再把源代码转换成本地代码。编译器中就好像有一个源代码同本地代码的对应表。但实际上，仅仅靠对应表是无法生成本地代码的。读入的源代码还要经过语法解析、句法解析、语义解析等，才能生成本地代码。</p><p>根据CPU类型的不同，本地代码的类型也不同。因而，编译器不仅和编程语言的种类有关，和CPU的类型也是相关的。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t6.png" alt="?"></p><p>还有一种交叉编译器，它生成的是和运行环境中的CPU不同的CPU所使用的本地代码。</p><h2 id="仅靠编译是无法得到可执行文件的"><a href="#仅靠编译是无法得到可执行文件的" class="headerlink" title="仅靠编译是无法得到可执行文件的"></a>仅靠编译是无法得到可执行文件的</h2><p>编译器转换源代码后，就会生成本地文件。不过，本地文件是无法直接运行的。为了得到可以运行的EXE文件，编译之后还需要进行“链接”处理。</p><p>编译后生成的不是EXE文件，而是扩展名为“.obj”的目标文件。</p><p>把多个目标文件结合，生成1个EXE文件的处理就是链接，运行连接的程序就称为链接器（linkage editor或连结器）。</p><h2 id="DLL文件及导入库"><a href="#DLL文件及导入库" class="headerlink" title="DLL文件及导入库"></a>DLL文件及导入库</h2><p>Windows以函数的形式为应用提供了各种功能。这些形式的函数称为API（Application Programming Interface，应用程序接口）。</p><p>Windows中，API的目标文件，并不是存储在通常的库文件中，而是存储在名为DLL（Dynamic Link Library）文件的特殊库文件中。就如Dynamic这一名称所表示的那样，DLL文件是程序运行时动态结合的文件。</p><p>与此相反，存储着目标文件的实体，并直接和EXE文件结合的库文件形式称为静态链接库。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t7.png" alt="?"></p><hr><h1 id="系统调用和高级编程语言的移植性"><a href="#系统调用和高级编程语言的移植性" class="headerlink" title="系统调用和高级编程语言的移植性"></a>系统调用和高级编程语言的移植性</h1><p>操作系统的硬件控制功能，通常是通过一些小的函数集合体的形式来提供的。这些函数及调用函数的行为统称为系统调用（system call），也就是应用对操作系统（system）的功能进行调用（call）的意思。</p><p>高级编程语言的机制就是，使用独自的函数名，然后再在编译时将其转换成相应操作系统的系统调用（也有可能是多个系统调用的组合）。也就是说，用高级编程语言编写的应用在编译后，就转换成了利用系统调用的本地代码（图9-6）。</p><h2 id="操作系统和高级编程语言使硬件抽象化"><a href="#操作系统和高级编程语言使硬件抽象化" class="headerlink" title="操作系统和高级编程语言使硬件抽象化"></a>操作系统和高级编程语言使硬件抽象化</h2><p>通过使用高级编程语言，有时甚至也无需考虑系统调用的存在。这是因为操作系统和高级编程语言能够使硬件抽象化。</p><p>当前主流的32位版Windows API也称为 Win32 API。之所以这样命名，是为了便于和以前的16位版的Win16 API，以及更先进的64位版的Win64 API区分开来。Win32 API中，各函数的参数及返回值的数据大小，基本上都是32位。</p><hr><h1 id="通过汇编语言了解程序的实际构成"><a href="#通过汇编语言了解程序的实际构成" class="headerlink" title="通过汇编语言了解程序的实际构成"></a>通过汇编语言了解程序的实际构成</h1><h2 id="汇编语言和本地代码是一一对应的"><a href="#汇编语言和本地代码是一一对应的" class="headerlink" title="汇编语言和本地代码是一一对应的"></a>汇编语言和本地代码是一一对应的</h2><p>通过调查本地代码的内容，可以了解程序最终是以何种形式来运行的。但是，如果直接打开本地代码来看的话，只能看到数值的罗列。如果直接使用这些数值来编写程序的话，还真是不太容易理解。因而就产生了这样一种想法，那就是在各本地代码中，附带上表示其功能的英语单词缩写。例如，在加法运算的本地代码中加上add（addition的缩写）、在比较运算的本地代码中加上cmp（compare的缩写）等。</p><p><strong>这些缩写称为助记符，使用助记符的编程语言称为汇编语言。</strong></p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t8.png" alt="?"></p><p>哪怕是用C语言编写的源代码，编译后也会转换成特定CPU用的本地代码。而将其反汇编的话，就可以得到汇编语言的源代码，并对其内容进行调查。不过，<strong>本地代码变换成C语言源代码的反编译，则要比反汇编困难。这是因为，C语言的源代码同本地代码不是一一对应的，因此完全还原到原始的源代码是不太可能的</strong></p><h2 id="通过编译器输出汇编语言的源代码"><a href="#通过编译器输出汇编语言的源代码" class="headerlink" title="通过编译器输出汇编语言的源代码"></a>通过编译器输出汇编语言的源代码</h2><p><strong>汇编语言源文件的扩展名，通常用“.asm”来表示。</strong></p><h2 id="不会转换成本地代码的伪指令"><a href="#不会转换成本地代码的伪指令" class="headerlink" title="不会转换成本地代码的伪指令"></a>不会转换成本地代码的伪指令</h2><p>汇编语言的源代码，是由转换成本地代码的指令（后面讲述的操作码）和针对汇编器的伪指令构成的。伪指令负责把程序的构造及汇编的方法指示给汇编器（转换程序）。不过伪指令本身是无法汇编转换成本地代码的。</p><p>伪指令proc和endp围起来的部分，表示的是过程（procedure）的范围。在汇编语言中，这种相当于C语言的函数的形式称为过程。</p><h2 id="汇编语言的语法是“操作码-操作数”"><a href="#汇编语言的语法是“操作码-操作数”" class="headerlink" title="汇编语言的语法是“操作码+操作数”"></a>汇编语言的语法是“操作码+操作数”</h2><p>在汇编语言中，1行表示对CPU的一个指令。汇编语言指令的语法结构是操作码+操作数（也存在只有操作码没有操作数的指令）。</p><p>能够使用何种形式的操作码，是由CPU的种类决定的。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t9.png" alt="?"></p><p>本地代码加载到内存后才能运行。内存中存储着构成本地代码的指令和数据。程序运行时，CPU会从内存中把指令和数据读出，然后再将其存储在CPU内部的寄存器中进行处理。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/y1.png" alt="?"><br>寄存器是CPU中的存储区域。不过，寄存器并不仅仅具有存储指令和数据的功能，也有运算功能。寄存器的名称会通过汇编语言的源代码指定给操作数。内存中的存储区域是用地址编号来区分的。CPU内的寄存器是用eax及ebx这些名称来区分的。此外，CPU内部也有程序员无法直接操作的寄存器。例如，表示运算结果正负及溢出状态的标志寄存器及操作系统专用的寄存器等，都无法通过程序员编写的程序直接进行操作。</p><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/y2.png" alt="?"></p><p> x86系列32位CPU的寄存器名称中，开头都带了一个字母e，例如eax、ebx、ecx、edx等。这是因为16位CPU的寄存器名称是ax、bx、cx、dx等。32位CPU寄存器的名称中的e，有扩展（extended）的意思。我们也可以仅利用32位寄存器的低16位，此时只需把要指定的寄存器名开头的字母e去掉即可。</p><h2 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h2><p> mov指令的两个操作数，分别用来指定数据的存储地和读出源。操作数中可以指定寄存器、常数、标签（附加在地址前），以及用方括号（[]）围起来的这些内容。如果指定了没有用方括号围起来的内容，就表示对该值进行处理；如果指定了用方括号围起来的内容，方括号中的值则会被解释为内存地址，然后就会对该内存地址对应的值进行读写操作。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> mov ebp, esp</span><br><span class="line">mov eax, dword ptr [ebp+<span class="number">8</span>]</span><br></pre></td></tr></table></figure><p> mov ebp, esp中，esp寄存器中的值被直接存储在了ebp寄存器中。esp寄存器的值是100时ebp寄存器的值也是100。而在mov eax, dword ptr [ebp+8]的情况下，ebp寄存器的值加8后得到的值会被解释为内存地址。如果ebp寄存器的值是100的话，那么eax寄存器中存储的就是100+ 8=108地址的数据。dword ptr（double word pointer）表示的是从指定内存地址读出4字节的数据。</p><blockquote><blockquote><p>16位cpu一个字是两个字节，这里是32位所以是双字，4字节</p></blockquote></blockquote><h2 id="push和pop"><a href="#push和pop" class="headerlink" title="push和pop"></a>push和pop</h2><p> <img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/y3.png" alt="?"><br> 栈是存储临时数据的区域，它的特点是通过push指令和pop指令进行数据的存储和读出。往栈中存储数据称为“入栈”，从栈中读出数据称为“出栈”。32位x86系列的CPU中，进行1次push或pop，即可处理32位（4字节）的数据。</p><p> push指令和pop指令中只有一个操作数。该操作数表示的是“push的是什么及pop的是什么”，而不需要指定“对哪一个地址编号的内存进行push或pop”。这是因为，对栈进行读写的内存地址是由esp寄存器（栈指针）进行管理的。push指令和pop指令运行后，esp寄存器的值会自动进行更新（push指令是-4, pop命令是+4），因而程序员就没有必要指定内存地址了。</p><h2 id="函数调用机制"><a href="#函数调用机制" class="headerlink" title="函数调用机制"></a>函数调用机制</h2><p> 函数的参数是通过栈来传递，返回值是通过寄存器来返回的</p><hr><h1 id="硬件控制方法"><a href="#硬件控制方法" class="headerlink" title="硬件控制方法"></a>硬件控制方法</h1><h2 id="应用和硬件无关？"><a href="#应用和硬件无关？" class="headerlink" title="应用和硬件无关？"></a>应用和硬件无关？</h2><p> Windows提供了通过应用来间接控制硬件的方法。利用操作系统提供的系统调用功能就可以实现对硬件的控制。在Windows中，系统调用称为API（图11-1）。各API就是应用调用的函数。这些函数的实体被存储在DLL文件中。</p><p> <img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/y4.png" alt="?"></p><p> 例如，假设要在窗口中显示字符串，就可以使用Windows API中的TextOut函数。</p><h2 id="支撑硬件输入输出的IN指令和OUT指令"><a href="#支撑硬件输入输出的IN指令和OUT指令" class="headerlink" title="支撑硬件输入输出的IN指令和OUT指令"></a>支撑硬件输入输出的IN指令和OUT指令</h2><p> 这是Pentium等x86系列CPU用的IN指令和OUT指令的语法。IN指令通过指定端口号的端口输入数据，并将其存储在CPU内部的寄存器中。OUT指令则是把CPU寄存器中存储的数据，输出到指定端口号的端口。</p><p> 计算机主机中，附带了用来连接显示器及键盘等外围设备的连接器。而各连接器的内部，都连接有用来交换计算机主机同外围设备之间电流特性的IC。这些IC，统称为I/O 控制器。由于电压不同，数字信号及模拟信号的电流特性也不同，计算机主机和外围设备是无法直接连接的。为了解决这个问题，I/O控制器就很有必要了。</p><p> I/O是Input/Output的缩写。显示器、键盘等外围设备都有各自专用的I/O控制器。I/O控制器中有用于临时保存输入输出数据的内存。这个内存就是端口。端口（port）的字面意思是“港口”。由于端口就像是在计算机主机和外围设备之间进行货物（数据）装卸的港口，所以因此得名。I/O控制器内部的内存，也称为寄存器。虽然都是寄存器，但它和CPU内部的寄存器在功能上是不同的。CPU内部的寄存器是用来进行数据运算处理的，而I/O寄存器则主要是用来临时存储数据的。</p><p> <img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/y5.png" alt="?"></p><h2 id="DMA可以实现短时间内传送大量数据"><a href="#DMA可以实现短时间内传送大量数据" class="headerlink" title="DMA可以实现短时间内传送大量数据"></a>DMA可以实现短时间内传送大量数据</h2><p> DMA是指在不通过CPU的情况下，外围设备直接和主内存进行数据传送。磁盘等都用到了这个DMA机制。通过利用DMA，大量数据就可以在短时间内转送到主内存。之所以这么快速，是因为CPU作为中介的时间被节省了。</p><h2 id="文字及图片的显示机制"><a href="#文字及图片的显示机制" class="headerlink" title="文字及图片的显示机制"></a>文字及图片的显示机制</h2><p> 用一句话来简单地概括该机制，那就是显示器中显示的信息一直存储在某内存中。该内存称为VRAM（Video RAM）。在程序中，只要往VRAM中写入数据，该数据就会在显示器中显示出来。实现该功能的程序，是由操作系统或BIOS提供，并借助中断来进行处理的。</p><p> <img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/y6.png" alt="?"><br> 在现在的计算机中，显卡等专用硬件中一般都配置有与主内存相独立的VRAM和GPU（Graphics Processing Unit，图形处理器，也称为图形芯片）。这是因为，对经常需要描绘图形的Windows来说，数百兆的VRAM是必需的。而为了提升图形的描绘速度，有时还需要专用的图形处理器。但不管怎样，内存VRAM中存储的数据就是显示器上显示的信息，这一机制是不变的。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="os" scheme="https://codecodegogogo.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>计算机是怎样跑起来的</title>
    <link href="https://codecodegogogo.github.io/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"/>
    <id>https://codecodegogogo.github.io/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</id>
    <published>2023-07-23T14:22:08.000Z</published>
    <updated>2023-07-30T12:50:11.616Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机的三大原则"><a href="#计算机的三大原则" class="headerlink" title="计算机的三大原则"></a>计算机的三大原则</h1><p>硬件和软件的区别是什么？</p><blockquote><p>硬件是看得见摸得着的设备，比如计算机主机、显示器、键盘等。而软件是计算机所执行的程序，即指令和数据。软件本身是看不见的。</p></blockquote><p>存储字符串“中国”需要几个字节？</p><blockquote><p>在GBK字符编码下，一个汉字占用2个字节。而在UTF-8字符编码下，一个汉字占用3个字节。</p></blockquote><p>什么是编码（Code）？</p><blockquote><p>通常将为了便于计算机处理而经过数字化处理的信息称作编码。</p></blockquote><h2 id="输入、运算、输出是硬件的基础"><a href="#输入、运算、输出是硬件的基础" class="headerlink" title="输入、运算、输出是硬件的基础"></a>输入、运算、输出是硬件的基础</h2><p>计算机的硬件由大量的IC（Integrated Circuit，集成电路）组成（如 图1.1所示）。每块IC上都带有许多引脚。这些引脚有的用于输入，有的用于输出。IC会在其内部对外部输入的信息进行运算，并把运算结果输出到外部。<br><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q1.png" alt="?"></p><p><strong>计算机只会输入、运算、输出</strong></p><h2 id="软件是指令和数据的集合"><a href="#软件是指令和数据的集合" class="headerlink" title="软件是指令和数据的集合"></a>软件是指令和数据的集合</h2><p>所谓指令，就是控制计算机进行输入、运算、输出的命令。把向计算机发出的指令一条条列出来，就得到了程序。</p><hr><h1 id="试着制造一台计算机"><a href="#试着制造一台计算机" class="headerlink" title="试着制造一台计算机"></a>试着制造一台计算机</h1><p>CPU 是 Central Processing Unit（中央处理器）的缩写。<br>Hz（赫兹）是频率的单位<br>Z80 CPU 是 8 比特的 CPU</p><h2 id="制作微型计算机所必需的元件"><a href="#制作微型计算机所必需的元件" class="headerlink" title="制作微型计算机所必需的元件"></a>制作微型计算机所必需的元件</h2><p>首先让我们来收集元件吧。制作微型计算机所需的基础元件只有3个，CPU、内存和I/O。CPU是计算机的大脑，负责解释、执行程序。内存负责存储程序和数据。I/O是Input/Output（输入／输出）的缩写，负责将计算机和外部设备（周边设备）连接在一起。</p><p>为了驱动CPU运转，称为“时 钟信号”的电信号必不可少。这种电信号就好像带有一个时钟，滴答滴答地每隔一定时间就变换一次电压的高低（如 图2.2所示）。输出时钟信号的元件叫作“时 钟发生器”。时钟发生器中带有晶振，根据其自身的频率（振 动的次数）产生时钟信号。时钟信号的频率可以衡量CPU的运转速度。这里使用的是2.5MHz（兆赫兹）的时钟发生器。</p><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q2.png" alt="?"></p><p>用于输入程序的装置也是必不可少的。在这里我们通过拨动指拨开关来输入程序，指拨开关是一种由8个开关并排连在一起构成的元件（如 照片2.1(a)所示）。输出程序执行结果的装置是8个LED（发   光二极管）</p><h2 id="电路图的读法"><a href="#电路图的读法" class="headerlink" title="电路图的读法"></a>电路图的读法</h2><p>在电路图中，用连接着各种元件符号的直线表示如何布线。电路中有些地方有交叉，但若只是交叉在一起的话，并不表示电路在交叉处构成通路。只有在交叉处再画上一个小黑点才表示构成通路。</p><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q3.png" alt="?"></p><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q4.png" alt="?"><br>IC的引脚（所 谓引脚就是IC边缘露出的像蜈蚣腿一样的部分）按照逆时针方向依次带有一个从1开始递增的序号。数引脚序号时，要先把表示正方向的标志，比如半圆形的缺口，朝向左侧。举例来说，带有14个引脚的7404，其引脚序号就如图2.5所示。<br><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q5.png" alt="?"></p><h2 id="连接电源、数据和地址总线"><a href="#连接电源、数据和地址总线" class="headerlink" title="连接电源、数据和地址总线"></a>连接电源、数据和地址总线</h2><p>首先连接电源。IC与普通的电器一样，只有接通了电源才能工作。Z80    CPU、TC5517和Z80    PIO上都分别带有Vcc引脚和GND引脚。Vcc和GND这一对儿引脚用于为IC供电。</p><p>将+5V电源连接到各个IC的Vcc引脚上，然后将0V电源连接到各个IC的GND引脚上。接下来还需要将+5V和0V连接到时钟发生器上。接通电源后这些IC和时钟发生器就可以工作了。</p><p>微型计算机所使用的IC属于数字IC。在数字IC中，每个引脚上的电压要么是0V、要么是+5V，通过这两个电压与其他的IC进行电信号的收发。用于给IC供电的Vcc引脚和GND引脚上的电压是恒定不变的+5V和0V，但是其他引脚上的电压，会随着计算机的操作在+5V和0V之间不断地变化。</p><p><strong>只要想成0V表示数字0、+5V表示数字1，那么数字IC就是在用二进制数的形式收发信息。</strong></p><h3 id="地址总线引脚"><a href="#地址总线引脚" class="headerlink" title="地址总线引脚"></a>地址总线引脚</h3><p>CPU可以与内存或I/O进行数据的输入输出。为了指定输入输出数据时的源头或目的地，CPU上备有“地址总线引脚”。Z80 CPU的地址总线引脚共有16个，用代号A0～A15表示，其中的A表示Address（地址）。后面的数字0～15表示一个16位的二进制数中各个数字的位置，0对应最后一位、15对应第一位。16个地址总线引脚所能指定的地址共有65536个，用二进制数表示的话就是0000000000000000～1111111111111111。因此Z80    CPU可以指定65536个数据存取单元（内 存存储单元或I/O地址），进行信息的输入输出。</p><h3 id="数据总线引脚"><a href="#数据总线引脚" class="headerlink" title="数据总线引脚"></a>数据总线引脚</h3><p>一旦指定了存取数据的地址，就可以使用数据总线引脚进行数据的输入输出了。Z80 CPU的数据总线引脚共有8个，用代号D0～D7表示。其中的D表示Data（数据），后面的数字0～7与地址总线引脚代号的规则相同，也表示二进制数中各个数字的位置。Z80 CPU可以一次性地输入输出8比特的数据，这就意味着如果想要输入输出位数（比特数）大于8比特的数据，就要以8比特为单位切分这个数据。</p><p>作为内存的TC5517上也有地址总线引脚（A0～A10）和数据总线引脚（D0～D7） 。这些引脚需要同Z80    CPU上带有相同代号的引脚相连。<br><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q6.png" alt="?"></p><h2 id="连接-I-O"><a href="#连接-I-O" class="headerlink" title="连接 I/O"></a>连接 I/O</h2><p>寄存器是位于CPU和I/O中的数据存储器。Z80 PIO上共有4个寄存器。2个用于设定PIO本身的功能，2个用于存储与外部设备进行输入输出的数据。</p><p>这4个寄存器分别叫作端口A控制、端口A数据、端口B控制和端口B数据。所谓端口就是I/O与外部设备之间输入输出数据的场所，可以把端口（Port）想象成是轮船装卸货物的港口。Z80 PIO有2个端口，端口A和端口B，最多可以连接2个用于输入输出8比特数据的外部设备（如图2.7所示）</p><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q7.png" alt="?"></p><p>下面就开始布线吧。因为Z80    PIO上也有D0～D7的数据总线引脚，所以先把它们和Z80 CPU中带有同样代号的引脚连接起来。这样CPU和PIO就能使用这8个引脚交换数据了。</p><h2 id="连接时钟信号"><a href="#连接时钟信号" class="headerlink" title="连接时钟信号"></a>连接时钟信号</h2><p>Z80 CPU和Z80    PIO的运转离不开时钟信号。为了传输时钟信号，就需要把时钟发生器的8号引脚和Z80    CPU的CLK（CLK即Clock，时钟）引脚、Z80 PIO的CLK引脚分别连接起来。时钟发生器的8号引脚与+5V之间的电阻用于清理时钟信号。</p><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/1.png" alt="?"></p><h2 id="连接用于区分读写对象是内存还是-I-O-的引脚"><a href="#连接用于区分读写对象是内存还是-I-O-的引脚" class="headerlink" title="连接用于区分读写对象是内存还是 I/O 的引脚"></a>连接用于区分读写对象是内存还是 I/O 的引脚</h2><p>至此，我们已经先后把Z80 CPU连接到了TC5517和Z80 PIO上，这两次连接都使用了地址总线引脚A0和A1。如果仅仅这样连接，就会导致一个问题，当地址的最后两位是00、01、10和11时，CPU就无法区分访问的是TC5517中的存储单元，还是Z80 PIO中的寄存器了。</p><p>Z80    CPU上的MREQ（即Memory Request，内存请求）引脚和IORQ（即I/O Request，I/O请求）引脚解决了这个问题。当Z80 CPU和内存之间有数据输入输出时，MREQ引脚上的值是0，反之则是1。当Z80 CPU和I/O之间有数据输入输出时，IORQ引脚上的值是0，反之则是1。</p><p>对内存和I/O而言，还必须要分清CPU是要输入数据还是输出数据。为此就要用到Z80    CPU的RD引脚（即Read，表示输入，为0时执行输入操作）和WR引脚（即Write，表示输出，为0时执行输出操作）了。请把这两个引脚与TC5517上同名的引脚连接起来。Z80 PIO虽然只有RD引脚，但由于数字IC引脚上的值要么是0要么是1，所以只用1个RD引脚也能区分是输入还是输出，0的话是输入，1的话就是输出<br><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q8.png" alt="?"></p><h2 id="连接剩余的控制引脚"><a href="#连接剩余的控制引脚" class="headerlink" title="连接剩余的控制引脚"></a>连接剩余的控制引脚</h2><p>CPU、内存、I/O中不但有地址总线引脚、数据总线引脚，还有其他引脚，通常把这些引脚统称为“控 制引脚”。之所以这样命名是因为这些引脚上输入输出的电信号具有控制IC的功能。</p><p>首先把Z80    CPU的M1引脚（即Machine Cycle 1，机器周期1）和INT引脚（即Interrupt，中断）与Z80    PIO上标有相同代号的引脚连接起来。M1是用于同步的引脚，INT引脚是用于从Z80    PIO向Z80    CPU发出中断请求的引脚。所谓中断就是让CPU根据外部输入的数据执行特定的程序。</p><p>一旦把Z80    CPU的RESET引脚（即Reset，重置）上的值先设成0再还原成1，CPU就会被重置，重新从内存0号地址上的指令开始顺序往下执行。重置CPU可以通过按键开关完成。</p><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w1.png" alt="?"></p><p>总线是连接到CPU中数据引脚、地址引脚、控制引脚上的电路的统称。使用快动开关可以使Z80    CPU的BUSRQ引脚（即Bus    Request，总线请求）上的值在0和1之间切换。若将BUSRQ引脚的值设为0，则Z80    CPU从电路中隔离。当处于这种隔离状态时，就可以不通过CPU，手动地向内存写入程序了。像这样不经过CPU而直接从外部设备读写内存的行为叫作DMA（Direct Memory Access，直接存储器访问）。在个人计算机里，硬盘等设备要读写内存时使用的就是DMA。</p><p>当Z80    CPU从电路中隔离后，BUSAK引脚（即Bus    Acknowledge，响应总线请求）上的值就会变成0。也就是说，把BUSRQ引脚上的值设成0以后，还要确认BUSAK引脚上的值已经变成了0，然后才能进行DMA。</p><h2 id="连接外部设备，通过-DMA-输入程序"><a href="#连接外部设备，通过-DMA-输入程序" class="headerlink" title="连接外部设备，通过 DMA 输入程序"></a>连接外部设备，通过 DMA 输入程序</h2><p>这次将计算机主机系统和外部设备连接起来。我们要使用2个指拨开关和1个按键开关，向地址总线引脚和数据总线引脚发送电信号，然后通过DMA将数据总线上的数据存储到内存。</p><hr><h1 id="手工汇编"><a href="#手工汇编" class="headerlink" title="手工汇编"></a>手工汇编</h1><p>什么是机器语言？</p><blockquote><p>由二进制数字构成的程序，CPU 可以直接对其解释、执行。</p></blockquote><p>通常把标识内存或 I/O 中存储单元的数字称作什么？</p><blockquote><p>标识内存或 I/O 中存储单元的数字叫作“地址”。</p></blockquote><p>CPU 中的标志寄存器（Flags Register）有什么作用？</p><blockquote><p>用于在运算指令执行后，存储运算结果的某些状态。</p></blockquote><h2 id="从程序员的角度看硬件"><a href="#从程序员的角度看硬件" class="headerlink" title="从程序员的角度看硬件"></a>从程序员的角度看硬件</h2><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w2.png" alt="?"><br>即便是相同的机器语言，例如01010011，只要CPU的种类不同，对它的解释也就不同。有的CPU会把它解释成是执行加法运算，有的CPU会把它解释成是向I/O输出。</p><p>所谓时钟信号的频率，就是由时钟发生器发送给CPU的电信号的频率。表示时钟信号频率的单位是MHz（兆赫兹= 100万回／秒）。微型计算机使用的是2.5MHz的时钟信号。时钟信号是在0和1两个数之间反复变换的电信号，就像滴答滴答左右摆动的钟摆一样。通常把发出一次滴答的时间称作一个时钟周期。</p><p>所谓I/O的地址空间，是指用于指定I/O寄存器的地址范围。在Z80 PIO上，地址空间为0～3，每一个地址对应一个寄存器。</p><p>在内存中，每个地址的功能都一样，既可用于存储指令又可用于存储数据。而I/O则不同，地址编号不同（即 寄存器的类型不同），功能也就不同。在微型计算机中，是这样分配Z80 PIO上的寄存器的：端口A数据寄存器对应0号地址，端口B数据寄存器对应1号地址，端口A控制寄存器对应2号地址，端口B控制寄存器对应3号地址。端口A数据寄存器和端口B数据寄存器存储的是与周边设备进行输入输出时所需的数据。其中，端口A连接用于输入数据的指拨开关，端口B连接用于输出数据的LED。而端口A控制寄存器和端口B控制寄存器则存储的是用于设定Z80 PIO功能的参数。</p><h2 id="机器语言和汇编语言"><a href="#机器语言和汇编语言" class="headerlink" title="机器语言和汇编语言"></a>机器语言和汇编语言</h2><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w3.png" alt="?"><br>标签的作用是为该行代码对应的内存地址起一个名字。<br>操作码就是表示“做什么”的指令,比如LD是Load（加载）的缩写。<br>操作数表示的是指令执行的对象。CPU的寄存器、内存地址、I/O地址或者直接给出的数字都可以作为操作数。</p><p>Z80    CPU的MREQ引脚和IORQ引脚实现了一种能区分输入输出对象的机制，可以区分出使用着相同内存地址的内存和I/O。在汇编语言中，读写内存的指令不同于读写I/O的指令。一旦执行了读写内存的指令，比如LD指令，MREQ引脚上的值就会变为0，于是内存被选为输入输出的对象；而一旦执行了读写I/O的指令，比如IN或OUT指令，IORQ引脚上的值就会变为0，于是I/O（这  里用的是Z80    PIO）被选为输入输出的对象。</p><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w5.png" alt="?"><br>num：表示1个数值，(num)：表示值为num的地址reg、reg1、reg2：名为reg、reg1、reg2的寄存器，(reg)：存储在名为reg的寄存器中的地址</p><h2 id="Z80-CPU-的寄存器结构"><a href="#Z80-CPU-的寄存器结构" class="headerlink" title="Z80 CPU 的寄存器结构"></a>Z80 CPU 的寄存器结构</h2><p>既然数据的运算是在CPU中进行的，那么在CPU内部就应该有存储数据的地方。这种存储数据的地方叫作“寄 存器”。虽然也叫寄存器，但是与I/O的寄存器不同，CPU的寄存器不仅能存储数据，还具备对数据进行运算的能力。CPU带有什么样的寄存器取决于CPU的种类。Z80 CPU所带有的寄存器如图3.2所示A。A、B、C、D等字母是寄存器的名字。在汇编语言当中，可以将寄存器的名字指定为操作数。</p><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w6.png" alt="?"></p><p>A、B、C、D、E、F、H、L每个寄存器都带有一个辅助寄存器<br>IX、IY、SP、PC这4个寄存器的大小是16比特，其余寄存器的大小都是8比特。寄存器的用途取决于它的类型。有的指令只能将特定的寄存器指定为操作数。</p><p>A寄存器也叫作“累 加器”，是运算的核心。所以连接到它上面的导线也一定会比其他寄存器的多。F寄存器也叫作“标 志寄存器”，用于存储运算结果的状态，比如是否发生了进位，数字大小的比较结果等。PC寄存器也叫作“程 序指针”，存储着指向CPU接下来要执行的指令的地址。PC寄存器的值会随着滴答滴答的时钟信号自动更新，可以说程序就是依靠不断变化的PC寄存器的值运行起来的。SP寄存器也叫作“栈 顶指针”，用于在内存中创建出一块称为“栈”的临时数据存储区域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LD  A, <span class="number">207</span></span><br><span class="line">OUT (<span class="number">2</span>),A</span><br><span class="line">LD  A,<span class="number">255</span> </span><br><span class="line"> OUT (<span class="number">2</span>), A</span><br></pre></td></tr></table></figure><p>这里的207和255是连续向Z80    PIO的端口A控制寄存器（对 应该I/O的地址编号为2）写入的两个数据。虽然使用OUT指令可以向I/O写入数据，但是不能直接把207、255这样的数字作为OUT指令的操作数。<strong>操作数必须是已存储在CPU寄存器中的数字，这是汇编语言的规定.</strong></p><p>完成了Z80 PIO的设定后，就进入了一段死循环处理，用于把由指拨开关输入的数据输出到LED。为了实现这个功能，需要如下的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOOP: </span><br><span class="line">IN  A, (<span class="number">0</span>)</span><br><span class="line"> OUT (<span class="number">1</span>), A</span><br><span class="line">  JP  LOOP</span><br></pre></td></tr></table></figure><p>“IN   A,   (0)”的作用是把数据由端口A数据寄存器（连 接在指拨开关上，对应的I/O地址为0号）输入到CPU的寄存器A。“OUT    (1),    A的作用是把寄存器A的值输出到端口B数据寄存器上（连 接在LED上，对应的I/O地址为1号）</p><p>“JP  LOOP”的作用是使程序的流程跳转到LOOP（笔者随意起的一个标签名）标签所标识的指令上。JP是Jump的缩写。   “IN   A,   (0)”所在行的开头有一个标签“LOOP:”  ，代表着这一行的内存地址。</p><h2 id="追踪程序的运行过程"><a href="#追踪程序的运行过程" class="headerlink" title="追踪程序的运行过程"></a>追踪程序的运行过程</h2><p>用汇编语言编写的程序是不能直接运行的，必须先转换成机器语言。机器语言是唯一一种CPU能直接理解的编程语言。</p><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w7.png" alt="?"><br>一旦重置了CPU，00000000就会被自动存储到PC寄存器中，这意味着接下来CPU将要从00000000号地址读出程序。首先CPU会从00000000号地址读出指令001  11110，判断出这是一条由2个字节构成的指令，于是接下来会从下一个地址（即00000001，1号地址，代码清单3.3中并没有标记出该地址本身）读出数据11001   111，把这两个数据汇集到一起解释、执行。执行的指令是把数值207写入到寄存器A，用汇编语言表示的话就是“LD   A,   207” 。这时，由于刚刚从内存读出了一条2字节的指令（占 用2个内存地址），所以PC寄存器的值要增加2，并接着从00000010号地址读出指令，解释并执行。</p><p>接下来的流程与此类似，通过反复进行“读 取指令”“解 释、执行指令”“更 新PC寄存器的值”这3个操作，程序就能运行起来了。一旦执行完最后一行的JP  LOOP所对应的机器语言，PC寄存器的值就会被设为标签LOOP对应的地址00010000，这样就可以循环执行同样的操作。请诸位重点观察PC寄存器是如何控制程序流程的。</p><h2 id="尝试手工汇编"><a href="#尝试手工汇编" class="headerlink" title="尝试手工汇编"></a>尝试手工汇编</h2><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w8.png" alt="?"><br>下面就从汇编语言的第1行开始转换。第一行的“LD   A,   207”匹配“LD   A,   num”这个模式，所以可以先转换成“00111110   num” 。然后将十进制数的207转换成8比特的二进制数，用这个二进制数替换num。<br><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e1.png" alt="?"></p><p>第2条指令“OUT    (2),    A”匹配“OUT    (num), A”这个模式，所以可以先转换成“1  1010011  num” 。然后把num的部分替换成00000010，即用8比特的二进制数表示的十进制数2，最终就得到了机器语言“1  1010011  00000010”。因为内存中已经存储了2字节的机器语言，所以这条机器语言要从00000010号地址（用 十进制表示的话就是2号地址）开始记录。</p><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e2.png" alt="?"></p><p><strong>机器语言中每条语句的字节数是多少，内存地址就相应地增加多少。</strong></p><p>接下来是“IN A, (0)”匹配“IN A, (num)”这个模式，所以可以先转换成“11011011 num”。然后把num替换成00000000，即用8比特的二进制数表示的十进制数0，最终就得到了机器语言“11011011 00000000”。对于接下来的“OUT (1), A”，也可以按照同样的方法转换</p><p>最后一句的JP  LOOP匹配模式“JP  num” ，所以可以先转换成“1  1000011  num” 。请注意这里要用16比特的二进制数替代作为内存地址的num。在微型计算机中是以8比特为单位指定内存地址的，但在Z80    CPU中用于设定内存地址的引脚却有16个，所以在机器语言中也要用16比特的二进制数设定内存地址。JP指令跳转的目的地为00010000，即“LOOP:”标签所标示的语句“LD   A,   0”对应的内存地址。把这个地址扩充为16比特就是“00000000 00010000”。要扩充到16位，只需要把高8位全部设为0就可以了。</p><p>在将一个2字节的数据存储到内存时，存储顺序是低8位在前、高8位在后（也 就是逆序存储）。这样的存储顺序叫作“小 端序”（Little Endian）  ，与此相反，将数据由高位到低位顺序地存储到内存的存储顺序则叫作“大 端序”（Big    Endian）  。根据CPU种类的不同，有的CPU使用大端序，有的CPU使用小端序。Z80 CPU使用的是小端序，因此JP  LOOP对应的机器语言为“1  1000011 00010000 00000000”。</p><hr><h1 id="程序像河水一样流动着"><a href="#程序像河水一样流动着" class="headerlink" title="程序像河水一样流动着"></a>程序像河水一样流动着</h1><h2 id="程序的流程分为三种"><a href="#程序的流程分为三种" class="headerlink" title="程序的流程分为三种"></a>程序的流程分为三种</h2><p>计算机的硬件系统由CPU、I/O和内存三部分构成。内存中存储着程序，也就是指令和数据。CPU配合着由时钟发生器发出的滴答滴答的时钟信号，从内存中读出指令，然后再依次对其进行解释和执行。</p><p>CPU中有各种各样的各司其职的寄存器。其中有一个被称为PC（Program Counter，程序计数器）的寄存器，负责存储内存地址，该地址指向下一条即将执行的指令。每解释执行完一条指令，PC寄存器的值就会自动被更新为下一条指令的地址。</p><p>在计算机硬件上的操作中，循环是通过当满足条件时就返回到之前处理过的步骤来实现的。一旦使用了机器语言或汇编语言所提供的跳转指令，就可以将PC寄存器的值设置为任意的内存地址。如果将它的值设为之前执行过的步骤所对应的内存地址，那么就构成了循环。</p><h2 id="特殊的程序流程——中断处理"><a href="#特殊的程序流程——中断处理" class="headerlink" title="特殊的程序流程——中断处理"></a>特殊的程序流程——中断处理</h2><p>中断处理是指计算机使程序的流程突然跳转到程序中的特定地方，这样的地方被称为中断处理例程（Routine）或是中断处理程序（Handler）   ，而这种跳转是通过CPU所具备的硬件功能实现的。</p><p>在Z80    CPU中有INT和NMI两个引脚，它们可以接收从I/O设备发出的中断请求信号A。以硬件形式连接到CPU上的I/O模块会发出中断请求信号，CPU根据该信号执行相应的中断处理程序。</p><p>每当用户按下键盘上的按键，键盘上的I/O模块就会把中断请求信号发送给CPU。CPU通过这种方式就可以知道有按键被按下，于是就会从I/O设备读入数据（如 图4.14所示）。CPU并不会时刻监控键盘是否有按键被按下。<br><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t1.png" alt="?"></p><h2 id="特殊的程序流程——事件驱动"><a href="#特殊的程序流程——事件驱动" class="headerlink" title="特殊的程序流程——事件驱动"></a>特殊的程序流程——事件驱动</h2><p>通常把用户在应用程序中点击鼠标或者敲击键盘这样的操作称作“事 件”（Event）  。负责检测事件的是Windows。Windows通过调用应用程序的WndProc()函数通知应用程序事件的发生。而应用程序则根据事件的类型做出相应的处理。这种机制就是事件驱动。</p><p>程序的流程还是只有顺序执行、条件分支和循环这三种，这一点是没有改变的。其中的顺序执行是最基本的程序流程，这是因为CPU中的PC寄存器的值会自动更新。条件分支和循环，在高级语言中用程序块表示，在机器语言和汇编语言中用跳转指令表示，在硬件上是通过把PC寄存器的值设为要跳转到的目的地的内存地址来实现。</p><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t2.png" alt="?"></p><hr><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>哨兵”指的是一种含有特殊值的数据，可用于标识数据的结尾等。字符串的末尾用0表示，链表的末尾用－1表示，像这种特殊的数据就是哨兵。</p><h2 id="算法是程序设计的“熟语"><a href="#算法是程序设计的“熟语" class="headerlink" title="算法是程序设计的“熟语"></a>算法是程序设计的“熟语</h2><h2 id="算法中解决问题的步骤是明确且有限的"><a href="#算法中解决问题的步骤是明确且有限的" class="headerlink" title="算法中解决问题的步骤是明确且有限的"></a>算法中解决问题的步骤是明确且有限的</h2><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t4.png" alt="?"></p><h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>假设有100个箱子，里面分别装有一个写有任意数字的纸条，箱子上面标有1～100的序号。现在要从这100个箱子当中查找是否有箱子装有写着要查找数字的纸条。</p><p>首先看看不使用哨兵的方法。从第一个箱子开始依次检查每个箱子中的纸条。每检查完一个纸条，还要再检查箱子的编号（用 变量N表示），并进一步确认编号是否已超过最后一个编号了。</p><p>为了消除这种不必要的处理，于是添加了一个101号箱子，其中预先放入的纸条上写有正要查找的数字。这种数据就被称为“哨 兵”。通过放入哨兵，就一定能找到要找的数据了。找到要找的数据后，如果该箱子的编号还没有到101就意味着找到了实际的数据；如果该箱子的编号是101，则意味着找到的是哨兵，而没有找到实际的数据。</p><hr><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="了解内存和变量的关系"><a href="#了解内存和变量的关系" class="headerlink" title="了解内存和变量的关系"></a>了解内存和变量的关系</h2><p>计算机所处理的数据都存储在了被称为内存的IC（Integrated Circuit，集成电路）中。在一般的个人计算机中，内存内部被分割成了若干个数据存储单元，每个单元可以存储8比特的数据（8比特= 1字节）。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是数据结构的基础，之所以这么说是因为数组反映了内存的物理结构本身。在内存中存储数据的空间是连续分布的。而在程序中，往往要从内存整体中分配出一块连续的空间以供使用。如果用程序中的语句表示这种分配使用方式的话，就要用到数组（如图6.2所示）</p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈和队列的相似点在于，它们都可以把不能立刻处理的数据暂时存储起来；不同点在于，栈对所存储数据的存取方式是LIFO的，而队列对所存储数据的存取方式是FIFO的。</p><hr><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>面向对象编程（OOP，Object Oriented Programming）是一种编写程序的方法，旨在提升开发大型程序的效率，使程序易于维护。</p><h2 id="对-OOP-的多种理解方法"><a href="#对-OOP-的多种理解方法" class="headerlink" title="对 OOP 的多种理解方法"></a>对 OOP 的多种理解方法</h2><p>面向对象编程是一种基于以下思路的程序设计方法：将关注点置于对象（Object）本身，对象的构成要素包含对象的行为及操作B，以此为基础进行编程。这种方法使程序易于复用，软件的生产效率因而得以提升。其中所使用的主要编程技巧有继承、封装、多态三种。</p><h2 id="观点-1：面向对象编程通过把组件拼装到一起构建程序"><a href="#观点-1：面向对象编程通过把组件拼装到一起构建程序" class="headerlink" title="观点 1：面向对象编程通过把组件拼装到一起构建程序"></a>观点 1：面向对象编程通过把组件拼装到一起构建程序</h2><p>在面向对象编程中，使用了一种称为“类”的要素，通过把若干个类组装到一起构建一个完整的程序。从这一点来看，可以说类就是程序的组件（Component）。面向对象编程的关键在于能否灵活地运用类。</p><p>在大型程序中需要用到大量的函数和变量。假设要用非面向对象的编程方法编写一个由10000个函数和20000个变量构成的程序，那么结果就很容易是代码凌乱不堪，开发效率低到令人吃惊，维护起来也十分困难。</p><p>于是一种新的编程方法就被发明出来了，即把程序中有关联的函数和变量汇集到一起编成组。这里的组就是类。</p><h2 id="观点-2：面向对象编程能够提升程序的开发效率和可维护性"><a href="#观点-2：面向对象编程能够提升程序的开发效率和可维护性" class="headerlink" title="观点 2：面向对象编程能够提升程序的开发效率和可维护性"></a>观点 2：面向对象编程能够提升程序的开发效率和可维护性</h2><h2 id="观点-3：面向对象编程是适用于大型程序的开发方法"><a href="#观点-3：面向对象编程是适用于大型程序的开发方法" class="headerlink" title="观点 3：面向对象编程是适用于大型程序的开发方法"></a>观点 3：面向对象编程是适用于大型程序的开发方法</h2><h2 id="观点-5：面向对象编程可以借助-UML-设计程序"><a href="#观点-5：面向对象编程可以借助-UML-设计程序" class="headerlink" title="观点 5：面向对象编程可以借助 UML 设计程序"></a>观点 5：面向对象编程可以借助 UML 设计程序</h2><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/a1.png" alt="?"></p><h2 id="观点-6：面向对象编程通过在对象间传递消息驱动程序"><a href="#观点-6：面向对象编程通过在对象间传递消息驱动程序" class="headerlink" title="观点 6：面向对象编程通过在对象间传递消息驱动程序"></a>观点 6：面向对象编程通过在对象间传递消息驱动程序</h2><h2 id="观点-7：在面向对象编程中使用继承、封装和多态"><a href="#观点-7：在面向对象编程中使用继承、封装和多态" class="headerlink" title="观点 7：在面向对象编程中使用继承、封装和多态"></a>观点 7：在面向对象编程中使用继承、封装和多态</h2><h2 id="在-Java-和-NET-中有关-OOP-的知识不能少"><a href="#在-Java-和-NET-中有关-OOP-的知识不能少" class="headerlink" title="在 Java 和 .NET 中有关 OOP 的知识不能少"></a>在 Java 和 .NET 中有关 OOP 的知识不能少</h2><p>Java和.NET其实是位于操作系统（Windows或Linux等）之上，旨在通过隐藏操作系统的复杂性从而提升开发效率的程序集，这样的程序集也被称作“框 架”（Framework）。框架由两部分构成，一部分是负责安全执行程序的“执 行引擎”，另一部分是作为程序组件集合的“类库”   （如图7.8所示）</p><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/a2.png" alt="?"></p><hr><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库是数据的基地"><a href="#数据库是数据的基地" class="headerlink" title="数据库是数据的基地"></a>数据库是数据的基地</h2><p>适合存储大规模数据的是关系型数据库（Relational Database）。在关系型数据库中，数据被拆分整理到多张表中，同时表与表之间的关系也可以被记录下来。</p><h2 id="数据文件、DBMS-和数据库应用程序"><a href="#数据文件、DBMS-和数据库应用程序" class="headerlink" title="数据文件、DBMS 和数据库应用程序"></a>数据文件、DBMS 和数据库应用程序</h2><p>数据库的实质虽然是某种数据文件，但是诸位编写的应用程序并不是直接去读写这些数据文件，而是以DBMS作为中介间接地读写（如 图8.3所示）。DBMS不但可以使应用程序轻松地读写数据文件，而且还具有一致并且安全地存储数据的功能。</p><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/a3.png" alt="?"><br>数据库系统的构成要素包括“数据文件”“DBMS”  “应用程序”三部分。</p><p>在小型系统中，把三个要素全部部署在一台计算机上，称作“独立型系统”。在中型系统中，把数据文件部署在一台计算机上，并且使数据文件被部署了DBMS和应用程序的多台计算机共享，这样的系统被称为“文件共享型系统”。在大型系统中，把数据文件和DBMS部署在一台（或者多台）计算机上，然后用户从另外一些部署着应用程序的计算机上访问，这样的系统被称作“客户端／服务器型系统”。</p><p>其中部署着数据文件和DBMS的计算机是服务器（Server），即服务的提供者；部署着应用程序的计算机是客户端（Client），即服务的使用者。如果把服务器和客户端之间用互联网联结起来，就形成了Web系统。在Web系统中，一般情况下应用程序也是部署在服务器中的，在客户端只部署Web浏览器.</p><h2 id="设计数据库"><a href="#设计数据库" class="headerlink" title="设计数据库"></a>设计数据库</h2><p>在关系型数据库中，把录入到表中的每一行数据都称为记录，把构成一条记录中的各个数据项（在本例中是商品名称、单价等）所在的列都称作字段。记录有时也被称为行或元组（Tuple） ，字段有时也被称为列或属性（Attribute）。上面提到的属性（数 据的类型）就是设置在字段上的。为了代表字段所存储数据的内容还要为每个字段起一个名字。</p><h2 id="索引能够提升数据的检索速度"><a href="#索引能够提升数据的检索速度" class="headerlink" title="索引能够提升数据的检索速度"></a>索引能够提升数据的检索速度</h2><p>可以在表的各个字段上设置索引（Index）  ，这也是DBMS所具备的功能之一。虽然索引和键这两个概念容易让人混淆，但其实两者是完全不同的。索引仅仅是提升数据检索和排序速度的内部机制。一旦在字段上设置了索引，DBMS就会自动为这个字段创建索引表。</p><p>索引表是一种数据结构，存储着字段的值以及字段所对应记录的位置。例如，如果在顾客表的顾客姓名字段上设置了索引，DBMS就会创建一张索引表（如 图8.13所示），表中有两个字段，分别存储着顾客姓名和位置（所 对应的记录在数据文件中的位置）。与原来的顾客表相比，索引表中的字段数更少，所以可以更快地进行数据的检索和排序。当查询数据时，DBMS先在索引表中进行数据的检索和排序，然后再根据位置信息从原来的数据表中把完整的记录取出来。索引所起的就是“目 录”的作用。与图书的目录一样，数据库的索引也是一种能够高效地查找目标数据的机制。</p><h2 id="事务控制也可以交给-DBMS-处理"><a href="#事务控制也可以交给-DBMS-处理" class="headerlink" title="事务控制也可以交给 DBMS 处理"></a>事务控制也可以交给 DBMS 处理</h2><p><strong>事务由若干条SQL语句构成，表示对数据库一系列相关操作的集合。</strong></p><blockquote><p>为了从顾客A的账户中给顾客B的账户汇入1万元，就需要将以下两条SQL语句依次发送给DBMS：1.把A的账户余额更新（UPDATE语句）为现有余额减去1万元；2.把B的账户余额更新（UPDATE语句）为现有余额加上1万元。此时这两条SQL语句就构成了一个事务。</p></blockquote><p>假设在第一条SQL语句执行后，网络或计算机发生了故障，第二条SQL语句无法执行，那么会发生什么呢？A的账户余额虽然减少了1万日元，但是B的账户余额却没有相应地增加1万日元，这就导致了数据不一致。</p><p>为了防止出现这种问题，在SQL语言中设计了以下三条语句：1.  BEGIN TRANSACTION（开启事务）语句，用于通知DBMS开启事务；2.  COMMIT（提交事务）语句，用于通知DBMS提交事务；3.  ROLL BACK（事务回滚）语句，用于在事务进行中发生问题时，把数据库中的数据恢复到事务开始前的状态。</p><hr><h1 id="TCP-IP-网络"><a href="#TCP-IP-网络" class="headerlink" title="TCP/IP 网络"></a>TCP/IP 网络</h1><h2 id="实验-1：查看网卡的-MAC-地址"><a href="#实验-1：查看网卡的-MAC-地址" class="headerlink" title="实验 1：查看网卡的 MAC 地址"></a>实验 1：查看网卡的 MAC 地址</h2><p>以太网使用了一种略显粗糙的方法连接LAN内的计算机（如图9.2所示）。以太网中的每台计算机都需要先确认一件事：在网线上有没有其他的计算机正在传输电信号，也就是说要先确保没有人在占用网络，然后才能发送自己想传输的电信号。谁先抢到了网线的使用权，谁就先发送。万一遇到了多台计算机同时都想发送电信号的情况，只需要让这些计算机等待一段长度随机的时间后再重新发送相同的电信号即可。这套机制叫作CSMA/CD（Career Sense Multiple Access with Collision Detection，带冲突检测的载波监听多路访问）。所谓载波监听（Career Sense）  ，指的是这套机制会去监听（Sense）表示网络是否正在使用的电信号（Career）  。而多路复用（Multiple Access）指的是多个（Multiple）设备可以同时访问（Access）传输介质。带冲突检测（with Collision Detection）则表示这套机制会去检测（Detection）因同一时刻的传输而导致的电信号冲突（Collision）。在小规模的LAN中，像这样略显粗躁的CSMA/CD机制是可以正常运转的。因为CSMA/CD归根结底也只是一种适用于LAN的机制。</p><p>在以太网中，发送给一台计算机的电信号也可以被其他所有的计算机收到。一台计算机收到了电信号以后会先做判断，如果是发送给自己的则选择接收，反之则选择忽略。可以用被称作MAC（Media Access Control）地址的编号来指定电信号的接收者。在每一块网卡所带有的ROM（Read Only Memory，只读存储器）中，都预先烧录了一个唯一的MAC地址。</p><p><strong>因为MAC地址是由制造厂商的编号和产品编号两部分组成的，所以世界上的每一个MAC地址都是独一无二的。</strong></p><p><strong>使用 ipconfig /all 命令查看 MAC 地址</strong></p><h2 id="实验-2：查看计算机的-IP-地址"><a href="#实验-2：查看计算机的-IP-地址" class="headerlink" title="实验 2：查看计算机的 IP 地址"></a>实验 2：查看计算机的 IP 地址</h2><p>在TCP/IP网络中，除了硬件上的MAC地址，还需要为每台计算机设定一个软件上的编号。这个编号就是众所周知的IP地址。通常把设定了IP地址的计算机称为“主 机”（Host） 。因为路由器也算是计算机的一种，所以它们也有IP地址。在TCP/IP网络中，传输的数据都会携带MAC地址和IP地址两个地址。</p><p><strong>使用 ipconfig /all 命令查看 IP 地址</strong></p><h2 id="实验-3：了解-DHCP-服务器的作用"><a href="#实验-3：了解-DHCP-服务器的作用" class="headerlink" title="实验 3：了解 DHCP 服务器的作用"></a>实验 3：了解 DHCP 服务器的作用</h2><p>DHCP的全称是Dynamic Host    Configuration Protocol（动态主机设置协议）。</p><p>DHCP服务器上记录着可以被分配到LAN内计算机的IP地址范围和子网掩码的值。作为DHCP客户端的计算机在启动时，就可以从中知道哪些IP地址还没有分配给其他计算机。</p><p>有一个叫作“默 认网关”的配置项。通常会把路由器的IP地址设置在这里。也就是说路由器就是从LAN通往互联网世界的入口（Gateway）。路由器的IP地址也可以从DHCP服务器获取。</p><h2 id="实验-4：路由器是数据传输过程中的指路人"><a href="#实验-4：路由器是数据传输过程中的指路人" class="headerlink" title="实验 4：路由器是数据传输过程中的指路人"></a>实验 4：路由器是数据传输过程中的指路人</h2><p>与LAN内的其他计算机一样，路由器也是连接在集线器上的。因为LAN内采用了CSMA/CD机制，所以所有发送出去的数据也都会发到路由器上。当从公司内的计算机向另一家公司的计算机发送数据时会发生什么呢？首先，一个不属于LAN内计算机的IP地址会被附加到数据的发送目的地字段上。这样的数据虽然会被LAN内的计算机所忽略，但是不会被路由器忽略。因为路由器的工作原理就是查看附加到数据上的IP地址中的网络地址部分，只要发现这个数据不是发送给LAN内计算机的，就把它发送到LAN外，即互联网的世界中。</p><p>分布在世界各地的LAN中的路由器相互交换着信息，互联网正是由于这种信息的交换才得以联通。这种信息被称作“路 由表”，用来记录应该把数据转发到哪里。在像互联网这样的网络中，传输路径错综复杂，而路由器就是站在各个岔路口的指路人（如 图9.6所示）。在一台路由器的路由表中，只会记录通往与之相邻的路由器的路径，而并不会记录世界范围内的所有传输路径。</p><p>路由表由5列构成。Network Destination、Netmask、Gateway、Interface这四列记录着数据发送的目的地和路由器的IP地址等信息。Metric这一列记录着路径的权重，这个值由某种算法决定，比如数据传输过程中经过的路由器的数量。如果遇到有多条候选路径都可以通往目的地的情况，路由器就会选择Metric值较小的那条路径。在路由表中还有如下的规则：如果数据的发送目的地就在本LAN中，则可以直接发送数据而无需经过路由器转发；反之如果在LAN外（或 发送目的地的IP地址不在路由表中），则需要经过路由器转发。</p><h2 id="实验-5：查看路由器的路由过程"><a href="#实验-5：查看路由器的路由过程" class="headerlink" title="实验 5：查看路由器的路由过程"></a>实验 5：查看路由器的路由过程</h2><p>在命令提示符窗口中执行tracert命令后，就可以查看路由的过程了。</p><blockquote><p>tracert <a href="http://www.google.com/">www.google.com</a></p></blockquote><h2 id="9-7-实验-6：DNS-服务器可以把主机名解析成-IP-地址"><a href="#9-7-实验-6：DNS-服务器可以把主机名解析成-IP-地址" class="headerlink" title="9.7 实验 6：DNS 服务器可以把主机名解析成 IP 地址"></a>9.7 实验 6：DNS 服务器可以把主机名解析成 IP 地址</h2><p>在互联网中，难以记忆的IP地址使用起来很麻烦。于是人们就发明出了DNS服务器，这样只需要使用FQDN，DNS服务器就可以自动地把它解析为IP地址了（这 个过程叫作“域 名解析”）。DNS服务器通常被部署在各个LAN中，里面记录着FQDN和IP地址的对应关系表。世界范围内的DNS服务器是通过相互合作运转起来的。如果一台DNS服务器无法解析域名，它就会去询问其他的DNS服务器。这套流程是自动进行的，诸位并不会意识到。</p><p>计算机都有一个主机名，每个LAN也都有一个域名。举例来说，笔者所使用的计算机的主机名是ma50j（源于这台计算机的型号），所在的LAN的域名是yzw  .co.jp。把主机名和域名组合起来所形成的ma50j.yze.co.jp，就是能够标识笔者这台计算机的一个世界范围内独一无二的名字，这个名字与IP地址的作用是等价的。通常把这种由主机名和域名组合起来形成的名字称作FQDN（Fully Qualified Domain Name，完整限定域名）。</p><p>在互联网中，难以记忆的IP地址使用起来很麻烦。于是人们就发明出了DNS服务器，这样只需要使用FQDN，DNS服务器就可以自动地把它解析为IP地址了（这 个过程叫作“域 名解析”）。DNS服务器通常被部署在各个LAN中，里面记录着FQDN和IP地址的对应关系表。世界范围内的DNS服务器是通过相互合作运转起来的。如果一台DNS服务器无法解析域名，它就会去询问其他的DNS服务器。这套流程是自动进行的。</p><h2 id="实验-7：查看-IP-地址和-MAC-地址的对应关系"><a href="#实验-7：查看-IP-地址和-MAC-地址的对应关系" class="headerlink" title="实验 7：查看 IP 地址和 MAC 地址的对应关系"></a>实验 7：查看 IP 地址和 MAC 地址的对应关系</h2><hr><h1 id="加密数据"><a href="#加密数据" class="headerlink" title="加密数据"></a>加密数据</h1><h2 id="什么是加密"><a href="#什么是加密" class="headerlink" title="什么是加密"></a>什么是加密</h2><p>文本数据可以由各种各样的字符构成。其中每个字符都被分配了一个数字，我们称之为“字 符编码”。定义了应该把哪个编码分配给哪个字符的字符编码体系叫作字符集。字符集分为ASCII字符集、JIS字符集、Shift-JIS字符集，EUC字符集、Unicode字符集等若干种。</p><h2 id="错开字符编码的加密方式"><a href="#错开字符编码的加密方式" class="headerlink" title="错开字符编码的加密方式"></a>错开字符编码的加密方式</h2><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/a5.png" alt="?"></p><h2 id="密钥越长，解密越困难"><a href="#密钥越长，解密越困难" class="headerlink" title="密钥越长，解密越困难"></a>密钥越长，解密越困难</h2><h2 id="适用于互联网的公开密钥加密技术"><a href="#适用于互联网的公开密钥加密技术" class="headerlink" title="适用于互联网的公开密钥加密技术"></a>适用于互联网的公开密钥加密技术</h2><p><strong>对称密钥加密技</strong><br>这种加密技术的特征是在加密和解密的过程中使用数值相同的密钥。因此，要使用这种技术，就必须事先把密钥的值作为只有发送者和接收者才知道的秘密保护好。</p><p>在公开密钥加密技术中，用于加密的密钥可以公开给全世界，因此称为“公 钥”，而用于解密的密钥是只有自己才知道的秘密，因此称为“私 钥”。</p><p>1、消息接收方准备好公钥和私钥</p><p>2、私钥接收方自己留存、公钥发布给消息发送方</p><p>3、消息发送方使用接收方公钥对消息进行加密</p><p>4、消息接收方用自己的私钥对消息解密</p><h2 id="数字签名可以证明数据的发送者是谁"><a href="#数字签名可以证明数据的发送者是谁" class="headerlink" title="数字签名可以证明数据的发送者是谁"></a>数字签名可以证明数据的发送者是谁</h2><p>【文本数据的发送者】<br>（1）选取一段明文例：NIKKEI<br>（2）计算出明文内容的信息摘要例：(78＋73＋75＋75＋69＋73)÷100的余数= 43<br>（3）用私钥对计算出的信息摘要进行加密例：43→66（字母B的编码）<br>（4）把步骤（3）得出的值附加到明文后面再发送给接收者例：NIKKEI B</p><p>【文本数据的接收者】<br>（1）用发送者的公钥对信息摘要进行解密例：B = 66→43<br>（2）计算出明文部分的信息摘要例：(78＋73＋75＋75＋69＋73)÷100的余数= 43<br>（3）比较在步骤（1）和（2）中求得的值，二者相同则证明接收的信息有效</p><hr><h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="XML-是标记语言"><a href="#XML-是标记语言" class="headerlink" title="XML 是标记语言"></a>XML 是标记语言</h2><p>XML是eXtensible Markup Language的缩写，译为可扩展标记语言。</p><p>&lt;html&gt;是用于表示这是HTML文件的标签。同样，其他标签也分别被赋予了意义.</p><p>通常把通过添加标签为数据赋予意义的行为称为“标 记”。为这种给数据赋予意义的行为定义规则的语言就是“标 记语言”。HTML是用于编写网页的标记语言，更简单地说法就是HTML决定了可用于编写网页的标签。</p><h2 id="XML-是可扩展的语言"><a href="#XML-是可扩展的语言" class="headerlink" title="XML 是可扩展的语言"></a>XML 是可扩展的语言</h2><p>在iuhist.xml中就有&lt;publisherName&gt;和&lt;processorArchitecture&gt;等标签，而且很有可能这两个标签表示的就是“发行者的名字”和“处理器的架构”</p><p>那么是XML规定了这些标签吗？答案是否定的。XML本身并不会限定标签的种类，反倒是允许XML的使用者随心所欲地创建标签。也就是说，在“&lt;”和“&gt;”中的单词可以是任意的。这就是所谓的“可扩展”。在HTML中，我们只能使用由HTML定义出的那若干种标签，因此HTML是固定的标记语言。</p><h2 id="XML-是元语言"><a href="#XML-是元语言" class="headerlink" title="XML 是元语言"></a>XML 是元语言</h2><p>通过定义要使用的标签种类，就可以创造出一门新的标记语言。通常把这种用于创造语言的语言称作“元 语言”。例如，我们可以使用&lt;dog&gt;和&lt;cat&gt;等标签，创造一种属于自己的标记语言——宠物语言。</p><p>XML的数据是纯文本格式的，也就是说只包含字符。通常把遵循了XML的约束编写出的文档称为“XML文档”；把保存着XML文档的文件称为“XML文件”。可以使用记事本等文本编辑器编写XML文件。</p><h2 id="XML-可以为信息赋予意义"><a href="#XML-可以为信息赋予意义" class="headerlink" title="XML 可以为信息赋予意义"></a>XML 可以为信息赋予意义</h2><p>如果网站只提供了HTML，那么这个程序几乎不可能完成。因为HTML中规定的各种标签只能用来指定信息的呈现样式，而不能表示信息的含义。</p><h2 id="xML-是通用的数据交换格式"><a href="#xML-是通用的数据交换格式" class="headerlink" title="xML 是通用的数据交换格式"></a>xML 是通用的数据交换格式</h2><p>如果某家厂商的某个应用程序把数据保存到了XML文件中，那么其他厂商的另一个应用程序就应该可以通过加载这个XML文件来使用数据。</p><h2 id="可以为-XML-标签设定命名空间"><a href="#可以为-XML-标签设定命名空间" class="headerlink" title="可以为 XML 标签设定命名空间"></a>可以为 XML 标签设定命名空间</h2><p>在XML文档中，通过把“xmlns=”命名空间的名字””作为标签的一个属性记述，就可以为标签设定命名空间。xmlns即XML    NameSpace（命名空间）的缩写。通常用全世界唯一的标识符作为命名空间的名称。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="https://codecodegogogo.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论-虚拟机</title>
    <link href="https://codecodegogogo.github.io/2023/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://codecodegogogo.github.io/2023/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2023-07-23T14:10:24.000Z</published>
    <updated>2023-07-23T14:20:57.278Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="虚拟机监视器"><a href="#虚拟机监视器" class="headerlink" title="虚拟机监视器"></a>虚拟机监视器</h1><p><strong>希望同时在机器上运行不同的操作系统，该怎么办？</strong></p><p>IBM以虚拟机监视器（Virtual Machine Monitor，VMM）（也称为管理程序，hypervisor）[G74]的形式，引入了另一个间接层。</p><p>监视器位于一个或多个操作系统和硬件之间，并为每个运行的操作系统提供控制机器的假象。然而，在幕后，实际上是监视器在控制硬件，并必须在机器的物理资源上为运行的OS提供多路复用。实际上，VMM作为操作系统的操作系统，但在低得多层次上。操作系统仍然认为它与物理硬件交互。因此，透明度（transparency）是VMM的主要目标。</p><h2 id="虚拟化-CPU"><a href="#虚拟化-CPU" class="headerlink" title="虚拟化 CPU"></a>虚拟化 CPU</h2><p>如果想在VMM之上“启动”新操作系统，只需跳转到第一条指令的地址，并让操作系统开始运行，就这么简单。</p><p>假设我们在单个处理器上运行，并且希望在两个虚拟机之间进行多路复用，即在两个操作系统和它们各自的应用程序之间进行多路复用。非常类似于操作系统在运行进程之间切换的方式（上下文切换，context  switch），虚拟机监视器必须在运行的虚拟机之间执行机器切换（machine  switch）。因此，当执行这样的切换时，VMM必须保存一个OS的整个机器状态（包括寄存器，PC，并且与上下文切换不同，包括所有特权硬件状态），恢复待运行虚拟机的机器状态，然后跳转到待运行虚拟机的PC，完成切换。注意，待运行VM的PC可能在OS本身内（系统正在执行系统调用），或可能就在该OS上运行的进程内（用户模式应用程序）。</p><p><img src="/2023/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%99%9A%E6%8B%9F%E6%9C%BA/q1.png" alt="?"></p><h2 id="虚拟化内存"><a href="#虚拟化内存" class="headerlink" title="虚拟化内存"></a>虚拟化内存</h2><p>每个操作系统通常将物理内存视为一个线性的页面数组，并将每个页面分配给自己或用户进程。当然，操作系统本身已经为其运行的进程虚拟化了内存，因此每个进程都有自己的私有地址空间的假象。现在我们必须添加另一层虚拟化，以便多个操作系统可以共享机器的实际物理内存，我们必须透明地这样做。</p><p>这个额外的虚拟化层使“物理”内存成为一个虚拟化层，在VMM所谓的机器内存（machine  memory）之上，机器内存是系统的真实物理内存。因此，我们现在有一个额外的间接层：每个操作系统通过其每个进程的页表映射虚拟到物理地址，VMM通过它的每个OS页面表，将生成的物理地址映射到底层机器地址。图B.1描述了这种额外的间接层。</p><p><img src="/2023/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%99%9A%E6%8B%9F%E6%9C%BA/q2.png" alt="?"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="os" scheme="https://codecodegogogo.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论-分布式</title>
    <link href="https://codecodegogogo.github.io/2023/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>https://codecodegogogo.github.io/2023/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%88%86%E5%B8%83%E5%BC%8F/</id>
    <published>2023-07-23T13:48:26.000Z</published>
    <updated>2023-07-23T14:09:47.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><p>Web浏览器连接到地球上其他地方的We b服务器时，它就会参与似乎是简单形式的客户端/服务器（client/server）分布式系统。当你连上Google和Facebook等现代网络服务时，不只是与一台机器进行交互。在幕后，这些复杂的服务是利用大量机器（成千上万台）来提供的，每台机器相互合作，以提供站点的特定服务。</p><h2 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h2><p>通信基本是不可靠的。无论是在广域Internet，还是Infiniband等局域高速网络中，数据包都会经常丢失、损坏，或无法到达目的地</p><h2 id="不可靠的通信层"><a href="#不可靠的通信层" class="headerlink" title="不可靠的通信层"></a>不可靠的通信层</h2><p>UDP是不可靠通信层的一个很好的例子。如果你使用它，就会遇到数据包丢失（丢弃），从而无法到达目的地的情况。发送方永远不会被告知丢失。但是，这并不意味着UDP根本不能防止任何故障。例如，UDP包含校验和（checksum），以检测某些形式的数据包损坏。</p><h2 id="可靠的通信层"><a href="#可靠的通信层" class="headerlink" title="可靠的通信层"></a>可靠的通信层</h2><p><img src="/2023/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%88%86%E5%B8%83%E5%BC%8F/q1.png" alt="?"><br><img src="/2023/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%88%86%E5%B8%83%E5%BC%8F/q2.png" alt="?"></p><p>常用的可靠通信层称为TCP/IP，或简称为TCP。TCP比上面描述的要复杂得多，包括处理网络拥塞的机制[VJ88]，多个未完成的请求，以及数百个其他的小调整和优化。</p><h2 id="通信抽象"><a href="#通信抽象" class="headerlink" title="通信抽象"></a>通信抽象</h2><p>分布式共享内存（Distributed Shared Memory，DSM）系统使不同机器上的进程能够共享一个大的虚拟地址空间[LH89]。这种抽象将分布式计算变成貌似多线程应用程序。唯一的区别是这些线程在不同的机器上运行，而不是在同一台机器上的不同处理器上。</p><p>在DSM系统中，一些访问是便宜的，但是其他访问导致页面错误和远程机器的昂贵提取。</p><h2 id="远程过程调用（RPC）"><a href="#远程过程调用（RPC）" class="headerlink" title="远程过程调用（RPC）"></a>远程过程调用（RPC）</h2><p>操作系统抽象对于构建分布式系统来说是一个糟糕的选择，但编程语言（PL）抽象要有意义得多。最主要的抽象是基于远程过程调用（Remote  Procedure  Call），或简称RPC [BN84]①。</p><p>远程过程调用包都有一个简单的目标：使在远程机器上执行代码的过程像调用本地函数一样简单直接。因此，对于客户端来说，进行一个过程调用，并在一段时间后返回结果。服务器只是定义了一些它希望导出的例程。其余的由RPC系统处理，RPC系统通常有两部分：存根生成器（stub generator，有时称为协议编译器，protocol compiler）和运行时库（run-time library）。</p><h3 id="存根生成器"><a href="#存根生成器" class="headerlink" title="存根生成器"></a>存根生成器</h3><p>存根生成器的工作很简单：通过自动化，消除将函数参数和结果打包成消息的一些痛苦。这有许多好处：通过设计避免了手工编写此类代码时出现的简单错误。此外，存根生成器也许可以优化此类代码，从而提高性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="os" scheme="https://codecodegogogo.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论-持久性</title>
    <link href="https://codecodegogogo.github.io/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/"/>
    <id>https://codecodegogogo.github.io/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/</id>
    <published>2023-07-06T09:28:10.000Z</published>
    <updated>2023-07-23T13:47:37.328Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h1><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>CPU通过某种内存总线（memory bus）或互连电缆连接到系统内存。图像或者其他高性能I/O设备通过常规的I/O总线（I/O bus）连接到系统，在许多现代系统中会是PCI或它的衍生形式。最后，更下面是外围总线（peripheral bus），比如SCSI、SATA或者USB。它们将最慢的设备连接到系统，包括磁盘、鼠标及其他类似设备。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q1.png" alt="?"></p><p><strong>为什么要用这样的分层架构？</strong></p><p>因为物理布局及造价成本。<br>越快的总线越短，因此高性能的内存总线没有足够的空间连接太多设备。另外，在工程上高性能总线的造价非常高。所以，系统的设计采用了这种分层的方式，这样可以让要求高性能的设备（比如显卡）离CPU更近一些，低性能的设备离CPU远一些。将磁盘和其他低速设备连到外围总线的好处很多，其中较为突出的好处就是你可以在外围总线上连接大量的设备。</p><h2 id="标准设备"><a href="#标准设备" class="headerlink" title="标准设备"></a>标准设备</h2><p>一个标准设备（不是真实存在的）<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q2.png" alt="?"><br>第一部分是向系统其他部分展现的硬件接口（interface）。同软件一样，硬件也需要一些接口，让系统软件来控制它的操作。因此，所有设备都有自己的特定接口以及典型交互的协议。</p><p>第2部分是它的内部结构（internal  structure）。这部分包含设备相关的特定实现，负责具体实现设备展示给系统的抽象接口。非常简单的设备通常用一个或几个芯片来实现它们的功能。更复杂的设备会包含简单的CPU、一些通用内存、设备相关的特定芯片，来完成它们的工作。例如，现代RAID控制器通常包含成百上千行固件（firmware，即硬件设备中的软件），以实现其功能。</p><h2 id="标准协议"><a href="#标准协议" class="headerlink" title="标准协议"></a>标准协议</h2><p>一个（简化的）设备接口包含3个寄存器：一个状态（status）寄存器，可以读取并查看设备的当前状态；一个命令（command）寄存器，用于通知设备执行某个具体任务；一个数据（data）寄存器，将数据传给设备或从设备接收数据。通过读写这些寄存器，操作系统可以控制设备的行为。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">While (STATUS == BUSY)</span><br><span class="line">; <span class="comment">// wait until device is not busy</span></span><br><span class="line">Write data to DATA <span class="keyword">register</span></span><br><span class="line">Write command to COMMAND <span class="title function_">register</span></span><br><span class="line"><span class="params">(Doing so starts the device and executes the command)</span></span><br><span class="line"><span class="title function_">While</span> <span class="params">(STATUS == BUSY)</span></span><br><span class="line">; <span class="comment">// wait until device is done with your request</span></span><br></pre></td></tr></table></figure><p>该协议包含4步。第1步，操作系统通过反复读取状态寄存器，等待设备进入可以接收命令的就绪状态。我们称之为轮询（polling）设备（基本上，就是问它正在做什么）。第2步，操作系统下发数据到数据寄存器。例如，你可以想象如果这是一个磁盘，需要多次写入操作，将一个磁盘块（比如4KB）传递给设备。如果主CPU参与数据移动（就像这个示例协议一样），我们就称之为编程的I/O（programmed I/O，PIO）。第3步，操作系统将命令写入命令寄存器；这样设备就知道数据已经准备好了，它应该开始执行命令。最后一步，操作系统再次通过不断轮询设备，等待并判断设备是否执行完成命令（有可能得到一个指示成功或失败的错误码）。</p><p><strong>简单有效但效率低（在等待设备执行完成命令时浪费大量CPU时间）</strong></p><h2 id="利用中断减少-CPU-开销"><a href="#利用中断减少-CPU-开销" class="headerlink" title="利用中断减少 CPU 开销"></a>利用中断减少 CPU 开销</h2><p>常见的中断（interrupt）来减少CPU开销。有了中断后，CPU 不再需要不断轮询设备，而是向设备发出一个请求，然后就可以让对应进程睡眠，切换执行其他任务。当设备完成了自身操作，会抛出一个硬件中断，引发CPU跳转执行操作系统预先定义好的中断服务例程（Interrupt  Service  Routine，ISR），或更为简单的中断处理程序（interrupt  handler）。中断处理程序是一小段操作系统代码，它会结束之前的请求（比如从设备读取到了数据或者错误码）并且唤醒等待I/O的进程继续执行。</p><p><strong>中断允许计算与I/O重叠（overlap），这是提高CPU利用率的关键。</strong></p><p>其中，进程1在CPU上运行一段时间（对应CPU那一行上重复的1），然后发出一个读取数据的I/O请求给磁盘。如果没有中断，那么操作系统就会简单自旋，不断轮询设备状态，直到设备完成I/O操作（对应其中的p）。当设备完成请求的操作后，进程1又可以继续运行。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q3.png" alt="?"></p><p>如果我们利用中断并允许重叠，操作系统就可以在等待磁盘操作时做其他事情：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q4.png" alt="?"><br>在这个例子中，在磁盘处理进程1的请求时，操作系统在CPU上运行进程2。磁盘处理完成后，触发一个中断，然后操作系统唤醒进程1继续运行。这样，在这段时间，无论CPU还是磁盘都可以有效地利用。</p><p><strong>如果设备非常快，那么最好的办法反而是轮询。如果设备比较慢，那么采用允许发生重叠的中断更好。</strong></p><h2 id="利用-DMA-进行更高效的数据传送"><a href="#利用-DMA-进行更高效的数据传送" class="headerlink" title="利用 DMA 进行更高效的数据传送"></a>利用 DMA 进行更高效的数据传送</h2><p>如果使用编程的I/O将一大块数据传给设备，CPU又会因为琐碎的任务而变得负载很重，浪费了时间和算力，本来更好是用于运行其他进程。下面的时间线展示了这个问题：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q5.png" alt="?"><br>进程1在运行过程中需要向磁盘写一些数据，所以它开始进行I/O操作，将数据从内存拷贝到磁盘（其中标示c的过程）(<strong>从内存拷贝到磁盘缓冲区</strong>)。拷贝结束后，磁盘上的I/O操作开始执行，此时CPU才可以处理其他请求。</p><p><strong>使用PIO的方式，CPU的时间会浪费在向设备传输数据或从设备传出数据的过程中。如何才能分离这项工作，从而提高CPU的利用率？</strong></p><p>解决方案就是使用DMA（Direct Memory Access）。DMA引擎是系统中的一个特殊设备，它可以协调完成内存和设备间的数据传递，不需要CPU介入。</p><p>DMA工作过程如下。为了能够将数据传送给设备，操作系统会通过编程告诉DMA引擎数据在内存的位置，要拷贝的大小以及要拷贝到哪个设备。在此之后，操作系统就可以处理其他请求了。当DMA的任务完成后，DMA控制器会抛出一个中断来告诉操作系统自己已经完成数据传输。修改后的时间线如下：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q6.png" alt="?"></p><p>从时间线中可以看到，数据的拷贝工作都是由DMA控制器来完成的。因为CPU在此时是空闲的，所以操作系统可以让它做一些其他事情，比如此处调度进程2到CPU来运行。因此进程2在进程1再次运行之前可以使用更多的CPU。</p><blockquote><p>PIO通过在计算机系统的总线上进行并行数据传输来完成输入和输出操作。在PIO模式下，数据是逐位地在系统总线上传输的，需要使用多个时钟周期完成一个数据传输操作。此外，PIO通常涉及主处理器的直接参与，主处理器负责控制和协调数据传输操作。</p></blockquote><blockquote><p>相比之下，DMA（Direct Memory Access，直接内存访问）是另一种数据传输模式。在DMA模式下，数据传输由DMA控制器负责，而不再需要主处理器直接参与。这种方式可以降低主处理器的负载，并提高数据传输效率。</p></blockquote><h2 id="设备交互的方法"><a href="#设备交互的方法" class="headerlink" title="设备交互的方法"></a>设备交互的方法</h2><p>硬件如何如与设备通信？是否需要一些明确的指令？或者其他的方式？</p><p>主要有两种方式来实现与设备的交互。第一种办法相对老一些（在IBM主机中使用了多年），就是<strong>用明确的I/O指令</strong>。这些指令规定了操作系统将数据发送到特定设备寄存器的方法，从而允许构造上文提到的协议。</p><p>例如在x86上，in和out指令可以用来与设备进行交互。当需要发送数据给设备时，调用者指定一个存入数据的特定寄存器及一个代表设备的特定端口。执行这个指令就可以实现期望的行为。</p><p>这些指令通常是特权指令（privileged）。操作系统是唯一可以直接与设备交互的实体。</p><p><strong>第二种方法是内存映射I/O（memory- mapped I/O）</strong>。通过这种方式，硬件将设备寄存器作为内存地址提供。当需要访问设备寄存器时，操作系统装载（读取）或者存入（写入）到该内存地址；然后硬件会将装载/存入转移到设备上，而不是物理内存。</p><h2 id="纳入操作系统：设备驱动程序"><a href="#纳入操作系统：设备驱动程序" class="headerlink" title="纳入操作系统：设备驱动程序"></a>纳入操作系统：设备驱动程序</h2><p>如何保持操作系统的大部分与设备无关，从而对操作系统的主要子系统隐藏设备交互的细节？</p><p>在最底层，操作系统的一部分软件清楚地知道设备如何工作，我们将这部分软件称为<strong>设备驱动程序（device driver）</strong>，所有设备交互的细节都封装在其中。</p><p>文件系统（当然也包括在其之上的应用程序）完全不清楚它使用的是什么类型的磁盘。它只需要简单地向通用块设备层发送读写请求即可，块设备层会将这些请求路由给对应的设备驱动，然后设备驱动来完成真正的底层操作。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q7.png" alt="?"></p><hr><h1 id="磁盘驱动器"><a href="#磁盘驱动器" class="headerlink" title="磁盘驱动器"></a>磁盘驱动器</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>驱动器由大量扇区（512字节块）组成，每个扇区都可以读取或写入。在具有n个扇区的磁盘上，扇区从0到n−1编号。因此，我们可以将磁盘视为一组扇区，0到n−1是驱动器的地址空间（address space）。</p><p>多扇区操作是可能的。实际上，许多文件系统一次读取或写入4KB（或更多）。但是，在更新磁盘时，驱动器制造商唯一保证的是单个512字节的写入是原子的（atomic，即它将完整地完成或者根本不会完成）。</p><h2 id="基本几何形状"><a href="#基本几何形状" class="headerlink" title="基本几何形状"></a>基本几何形状</h2><p>让我们开始了解现代磁盘的一些组件。我们从一个盘片（platter）开始，它是一个圆形坚硬的表面，通过引入磁性变化来永久存储数据。磁盘可能有一个或多个盘片。每个盘片有两面，每面都称为表面。这些盘片通常由一些硬质材料（如铝）制成，然后涂上薄薄的磁性层，即使驱动器断电，驱动器也能持久存储数据位。</p><p>所有盘片都围绕主轴（spindle）连接在一起，主轴连接到一个电机，以一个恒定（固定）的速度旋转盘片（当驱动器接通电源时）。旋转速率通常以每分钟转数（Rotations Per Minute，RPM）来测量，典型的现代数值在7200～15000 RPM范围内。请注意，我们经常会对单次旋转的时间感兴趣，例如，以10000 RPM旋转的驱动器意味着一次旋转需要大约6ms。</p><p>数据在扇区的同心圆中的每个表面上被编码。我们称这样的同心圆为一个磁道（track）。一个表面包含数以千计的磁道，紧密地排在一起，数百个磁道只有头发的宽度。</p><p>要从表面进行读写操作，我们需要一种机制，使我们能够感应（即读取）磁盘上的磁性图案，或者让它们发生变化（即写入）。读写过程由磁头（disk  head）完成；驱动器的每个表面有一个这样的磁头。磁头连接到单个磁盘臂（disk arm）上，磁盘臂在表面上移动，将磁头定位在期望的磁道上。</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q9.png" alt="?"><br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q8.png" alt="?"><br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w1.png" alt="?"></p><h2 id="简单的磁盘驱动器"><a href="#简单的磁盘驱动器" class="headerlink" title="简单的磁盘驱动器"></a>简单的磁盘驱动器</h2><p>该磁道只有12个扇区，每个扇区的大小为512字节（典型的扇区大小，回忆一下），因此用0到11的数字表示。这里的单个盘片围绕主轴旋转，电机连接到主轴。当然，磁道本身并不太有趣，我们希望能够读取或写入这些扇区，因此需要一个连接到磁盘臂上的磁头:<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w2.png" alt="?"></p><h3 id="单磁道延迟：旋转延迟"><a href="#单磁道延迟：旋转延迟" class="headerlink" title="单磁道延迟：旋转延迟"></a>单磁道延迟：旋转延迟</h3><p>现在收到读取块0的请求。磁盘应如何处理该请求？</p><p>简单磁盘中，磁盘不必做太多工作。具体来说，它必须等待期望的扇区旋转到磁头下。这种等待在现代驱动器中经常发生，并且是I/O服务时间的重要组成部分，它有一个特殊的名称：旋转延迟（rotational delay，有时称为rotation delay，尽管听起来很奇怪）</p><h3 id="多磁道：寻道时间"><a href="#多磁道：寻道时间" class="headerlink" title="多磁道：寻道时间"></a>多磁道：寻道时间</h3><p>到目前为止，我们的磁盘只有一条磁道，这是不太现实的。现代磁盘当然有数以百万计的磁道。因此，我们来看看更具现实感的磁盘表面，这个表面有3条磁道（见图37.3左图）。在该图中，磁头当前位于最内圈的磁道上（它包含扇区24～35）。下一个磁道包含下一组扇区（12～23），最外面的磁道包含最前面的扇区（0～11）。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w4.png" alt="?"></p><p>读取扇区11。为了服务这个读取请求，驱动器必须首先将磁盘臂移动到正确的磁道（在这种情况下，是最外面的磁道），通过一个所谓的寻道（seek）过程。寻道，以及旋转，是最昂贵的磁盘操作之一。</p><p>寻道有许多阶段：首先是磁盘臂移动时的加速阶段。然后随着磁盘臂全速移动而惯性滑动。然后随着磁盘臂减速而减速。最后，在磁头小心地放置在正确的磁道上时停下来。停放时间（settling  time）通常不小，例如0.5～2ms，因为驱动器必须确定找到正确的磁道（想象一下，如果它只是移到附近！）。</p><p>寻道之后，磁盘臂将磁头定位在正确的磁道上。</p><p>在这个例子中，大约旋转了3个扇区。因此，扇区9即将通过磁头下方，我们只能承受短暂的转动延迟，以便完成传输。</p><p>当扇区11经过磁盘磁头时，I/O的最后阶段将发生，称为传输（transfer），数据从表面读取或写入表面。因此，我们得到了完整的I/O时间图：首先寻道，然后等待转动延迟，最后传输。</p><h3 id="一些其他细节"><a href="#一些其他细节" class="headerlink" title="一些其他细节"></a>一些其他细节</h3><p>许多驱动器采用某种形式的磁道偏斜（track skew）(轻微错位)，以确保即使在跨越磁道边界时，顺序读取也可以方便地服务。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w5.png" alt="?"><br>扇区往往会偏斜，因为从一个磁道切换到另一个磁道时，磁盘需要时间来重新定位磁头（即便移到相邻磁道）。如果没有这种偏斜，磁头将移动到下一个磁道，但所需的下一个块已经旋转到磁头下，因此驱动器将不得不等待整个旋转延迟，才能访问下一个块。</p><p>任何现代磁盘驱动器都有一个重要组成部分，即它的缓存（cache），由于历史原因有时称为磁道缓冲区（track buffer）。该缓存只是少量的内存（通常大约8MB或16MB），驱动器可以使用这些内存来保存从磁盘读取或写入磁盘的数据。例如，当从磁盘读取扇区时，驱动器可能决定读取该磁道上的所有扇区并将其缓存在其存储器中。这样做可以让驱动器快速响应所有后续对同一磁道的请求。</p><p>在写入时，驱动器面临一个选择：是先写入缓存再写入磁盘？还是边写缓存边写入磁盘？前者被称为后写（write back）缓存（有时称为立即报告，immediate reporting），后者则称为直写（write through）。后写缓存有时会使驱动器看起来“更快”，但可能有危险。</p><h2 id="I-O-时间：用数学"><a href="#I-O-时间：用数学" class="headerlink" title="I/O 时间：用数学"></a>I/O 时间：用数学</h2><p>现在可以将I/O时间表示为3个主要部分之和：</p><p>TI/O  =  T寻道+ T旋转+ T传输</p><p>为了更好地感受I/O时间，我们执行以下计算。假设有两个我们感兴趣的工作负载。第一个工作负载称为随机（random）工作负载，它向磁盘上的随机位置发出小的（例如4KB）读取请求。随机工作负载在许多重要的应用程序中很常见，包括数据库管理系统。第二种称为顺序（sequential）工作负载，只是从磁盘连续读取大量的扇区，不会跳过。顺序访问模式很常见，因此也很重要。</p><blockquote><p>提示：顺序地使用磁盘<br>尽可能以顺序方式将数据传输到磁盘，并从磁盘传输数据。如果顺序不可行，至少应考虑以大块传输数据：越大越好。如果I/O是以小而随机方式完成的，则I/O性能将受到显著影响。而且，用户也会痛苦。而且，你也会痛苦，因为你知道正是你不小心的随机I/O让你痛苦。</p></blockquote><h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p>与任务调度不同，每个任务的长度通常是不知道的，对于磁盘调度，我们可以很好地猜测“任务”（即磁盘请求）需要多长时间。通过估计请求的查找和可能的旋转延迟，磁盘调度程序可以知道每个请求将花费多长时间，因此（贪婪地）选择先服务花费最少时间的请求。因此，磁盘调度程序将尝试在其操作中遵循SJF（最短任务优先）的原则（principle of SJF，shortest job first）。</p><h3 id="SSTF：最短寻道时间优先"><a href="#SSTF：最短寻道时间优先" class="headerlink" title="SSTF：最短寻道时间优先"></a>SSTF：最短寻道时间优先</h3><p>SSTF按磁道对I/O请求队列排序，选择在最近磁道上的请求先完成。例如，假设磁头当前位置在内圈磁道上，并且我们请求扇区21（中间磁道）和2（外圈磁道），那么我们会首先发出对21的请求，等待它完成，然后发出对2的请求。</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w6.png" alt="?"></p><p>第一个问题，主机操作系统无法利用驱动器的几何结构，而是只会看到一系列的块。幸运的是，这个问题很容易解决。操作系统可以简单地实现最近块优先（Nearest-Block-First，NBF），而不是SSTF，然后用最近的块地址来调度请求。</p><p>第二个问题更为根本：饥饿（starvation）。想象一下，在我们上面的例子中，是否有对磁头当前所在位置的内圈磁道有稳定的请求。然后，纯粹的SSTF方法将完全忽略对其他磁道的请求。</p><h3 id="电梯（又称-SCAN-或-C-SCAN）"><a href="#电梯（又称-SCAN-或-C-SCAN）" class="headerlink" title="电梯（又称 SCAN 或 C-SCAN）"></a>电梯（又称 SCAN 或 C-SCAN）</h3><p>简单地以跨越磁道的顺序来服务磁盘请求。我们将一次跨越磁盘称为扫一遍。因此，如果请求的块所属的磁道在这次扫一遍中已经服务过了，它就不会立即处理，而是排队等待下次扫一遍。</p><p>SCAN有许多变种，所有这些变种都是一样的。例如，Coffman等人引入了F-SCAN，它在扫一遍时冻结队列以进行维护[CKR72]。这个操作会将扫一遍期间进入的请求放入队列中，以便稍后处理。这样做可以避免远距离请求饥饿，延迟了迟到（但更近）请求的服务。</p><p>C-SCAN是另一种常见的变体，即循环SCAN（Circular  SCAN）的缩写。不是在一个方向扫过磁盘，该算法从外圈扫到内圈，然后从内圈扫到外圈，如此下去。</p><p><strong>它们忽视了旋转。</strong></p><h3 id="SPTF：最短定位时间优先"><a href="#SPTF：最短定位时间优先" class="headerlink" title="SPTF：最短定位时间优先"></a>SPTF：最短定位时间优先</h3><p><strong>8还是16?</strong></p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w7.png" alt="?"><br>这里的情况是旋转与寻道相比的相对时间。如果在我们的例子中，寻道时间远远高于旋转延迟，那么SSTF（和变体）就好了。但是，想象一下，如果寻道比旋转快得多。然后，在我们的例子中，寻道远一点的、在外圈磁道的服务请求8，比寻道近一点的、在中间磁道的服务请求16更好，后者必须旋转很长的距离才能移到磁头下。</p><p>因此SPTF是有用的，它提高了性能。然而，它在操作系统中实现起来更加困难，操作系统通常不太清楚磁道边界在哪，也不知道磁头当前的位置（旋转到了哪里）。因此，SPTF通常在驱动器内部执行.</p><h3 id="其他调度问题"><a href="#其他调度问题" class="headerlink" title="其他调度问题"></a>其他调度问题</h3><p>磁盘可以接受多个分离的请求，它们本身具有复杂的内部调度程序（它们可以准确地实现SPTF。在磁盘控制器内部，所有相关细节都可以得到，包括精确的磁头位置）。因此，操作系统调度程序通常会选择它认为最好的几个请求（如16），并将它们全部发送到磁盘。磁盘然后利用其磁头位置和详细的磁道布局信息等内部知识，以最佳可能（SPTF）顺序服务于这些请求。</p><p>磁盘调度程序执行的另一个重要相关任务是I/O合并（I/O merging）。例如，设想一系列请求读取块33，然后是8，然后是34，如图37.8所示。在这种情况下，调度程序应该将块33和34的请求合并（merge）为单个两块请求。调度程序执行的所有请求都基于合并后的请求。合并在操作系统级别尤其重要，因为它减少了发送到磁盘的请求数量，从而降低了开销。</p><hr><h1 id="廉价冗余磁盘阵列-RAID"><a href="#廉价冗余磁盘阵列-RAID" class="headerlink" title="廉价冗余磁盘阵列(RAID)"></a>廉价冗余磁盘阵列(RAID)</h1><p>如何得到大型、快速、可靠的磁盘?</p><p><strong>廉价冗余磁盘阵列(RAID)这种技术使用多个磁盘一起构建更快、更大、更可靠的磁盘系统。</strong></p><p>在内部，RAID是一个复杂的庞然大物，由多个磁盘、内存（包括易失性和非易失性）以及一个或多个处理器来管理系统。硬件RAID非常像一个计算机系统，专门用于管理一组磁盘。</p><h2 id="接口和-RAID-内部"><a href="#接口和-RAID-内部" class="headerlink" title="接口和 RAID 内部"></a>接口和 RAID 内部</h2><p>当文件系统向RAID发出逻辑I/O请求时，RAID内部必须计算要访问的磁盘（或多个磁盘）以完成请求，然后发出一个或多个物理I/O来执行此操作。这些物理I/O的确切性质取决于RAID级别。</p><p>考虑一个RAID，它保留每个块的两个副本（每个都在一个单独的磁盘上）。当写入这种镜像（mirrored）RAID系统时，RAID必须为它发出的每一个逻辑I/O执行两个物理I/O。</p><p>RAID系统通常构建为单独的硬件盒，并通过标准连接（例如，SCSI或SATA）接入主机。然而，在内部，RAID相当复杂。它包括一个微控制器，运行固件以指导RAID的操作。它还包括DRAM这样的易失性存储器，在读取和写入时缓冲数据块。在某些情况下，还包括非易失性存储器，安全地缓冲写入。它甚至可能包含专用的逻辑电路，来执行奇偶校验计算（在某些RAID级别中非常有用，下面会提到）。在很高的层面上，RAID是一个非常专业的计算机系统：它有一个处理器，内存和磁盘。然而，它不是运行应用程序，而是运行专门用于操作RAID的软件。</p><h2 id="故障模型"><a href="#故障模型" class="headerlink" title="故障模型"></a>故障模型</h2><p>故障—停止（fail-stop）故障模型</p><p>磁盘可以处于两种状态之一：工作状态或故障状态。使用工作状态的磁盘时，所有块都可以读取或写入。相反，当磁盘出现故障时，我们认为它永久丢失。</p><h2 id="如何评估-RAID"><a href="#如何评估-RAID" class="headerlink" title="如何评估 RAID"></a>如何评估 RAID</h2><p>第一个方面是容量（capacity）。在给定一组N个磁盘的情况下，RAID的客户端可用的容量有多少？没有冗余，答案显然是N。不同的是，如果有一个系统保存每个块的两个副本，我们将获得N/2的有用容量。不同的方案（例如，基于校验的方案）通常介于两者之间。</p><p>第二个方面是可靠性（reliability）。给定设计允许有多少磁盘故障？根据我们的故障模型，我们只假设整个磁盘可能会故障。在后面的章节（例如，关于数据完整性的第44章）中，我们将考虑如何处理更复杂的故障模式。</p><p>最后，第三个方面是性能（performance）。性能有点难以评估，因为它在很大程度上取决于磁盘阵列提供的工作负载。因此，在评估性能之前，我们将首先提出一组应该考虑的典型工作负载。</p><h2 id="RAID-0-级：条带化"><a href="#RAID-0-级：条带化" class="headerlink" title="RAID 0 级：条带化"></a>RAID 0 级：条带化</h2><p>第一个RAID级别实际上不是RAID级别，因为没有冗余。</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w8.png" alt="?"></p><p>以轮转方式将磁盘阵列的块分布在磁盘上。这种方法的目的是在对数组的连续块进行请求时，从阵列中获取最大的并行性（例如，在一个大的顺序读取中）。我们将同一行中的块称为条带，因此，上面的块0、1、2和3在相同的条带中。</p><blockquote><p>补充：RAID映射问题<br><strong>简单地说，给定一个逻辑块来读或写，RAID如何确切地知道要访问哪个物理磁盘和偏移量？</strong></p></blockquote><blockquote><p>以上面的第一个条带为例（大块大小=  1块=  4KB）。在这种情况下，给定逻辑块地址A，RAID可以使用两个简单的公式轻松计算要访问的磁盘和偏移量：<br><strong>磁盘= A % 磁盘数<br>偏移量  =  A  /  磁盘数</strong></p></blockquote><blockquote><p>假设在上面的第一个RAID中，对块15的请求到达。鉴于有4个磁盘，这意味着我们感兴趣的磁盘是（14 % 4 = 2）：磁盘2。确切的块计算为（14 / 4 = 3）：块3。因此，应在第三个磁盘（磁盘2，从0开始）的第四个块（块3，从0开始）处找到块14，该块恰好位于该位置</p></blockquote><h3 id="大块大小"><a href="#大块大小" class="headerlink" title="大块大小"></a>大块大小</h3><p>一方面，大块大小主要影响阵列的性能。例如，大小较小的大块意味着许多文件将跨多个磁盘进行条带化，从而增加了对单个文件的读取和写入的并行性。但是，跨多个磁盘访问块的定位时间会增加，因为整个请求的定位时间由所有驱动器上请求的最大定位时间决定。</p><p>另一方面，较大的大块大小减少了这种文件内的并行性，因此依靠多个并发请求来实现高吞吐量。但是，较大的大块大小减少了定位时间。例如，如果一个文件放在一个块中并放置在单个磁盘上，则访问它时发生的定位时间将只是单个磁盘的定位时间。</p><h3 id="RAID-0-分析"><a href="#RAID-0-分析" class="headerlink" title="RAID-0 分析"></a>RAID-0 分析</h3><p>从容量的角度来看，它是顶级的：给定N个磁盘，条件化提供N个磁盘的有用容量。从可靠性的角度来看，条带化也是顶级的，但是最糟糕：任何磁盘故障都会导致数据丢失。最后，性能非常好：通常并行使用所有磁盘来为用户I/O请求提供服务。</p><h2 id="RAID-1-级：镜像"><a href="#RAID-1-级：镜像" class="headerlink" title="RAID 1 级：镜像"></a>RAID 1 级：镜像</h2><p>第一个超越条带化的RAID级别称为RAID 1级，即镜像。对于镜像系统，我们只需生成系统中每个块的多个副本。当然，每个副本应该放在一个单独的磁盘上。通过这样做，我们可以容许磁盘故障。</p><p>在一个典型的镜像系统中，我们将假设对于每个逻辑块，RAID保留两个物理副本。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/e1.png" alt="?"></p><p>从镜像阵列读取块时，RAID有一个选择：它可以读取任一副本。例如，如果对RAID发出对逻辑块5的读取，则可以自由地从磁盘2或磁盘3读取它。但是，在写入块时，不存在这样的选择：RAID必须更新两个副本的数据，以保持可靠性。但请注意，这些写入可以并行进行。例如，对逻辑块5的写入可以同时在磁盘2和3上进行。</p><h3 id="RAID-1-分析"><a href="#RAID-1-分析" class="headerlink" title="RAID-1 分析"></a>RAID-1 分析</h3><p>从容量的角度来看，RAID-1价格昂贵。在镜像级别=2的情况下，我们只能获得峰值有用容量的一半。因此，对于N个磁盘，镜像的有用容量为N/2。</p><p>从可靠性的角度来看，RAID-1表现良好。它可以容许任何一个磁盘的故障。</p><p>最后，我们分析性能。从单个读取请求的延迟角度来看，我们可以看到它与单个磁盘上的延迟相同。所有RAID-1都会将读取导向一个副本。写入有点不同：在完成写入之前，需要完成两次物理写入。这两个写入并行发生，因此时间大致等于单次写入的时间。然而，因为逻辑写入必须等待两个物理写入完成，所以它遭遇到两个请求中最差的寻道和旋转延迟，因此（平均而言）比写入单个磁盘略高。</p><blockquote><p>补充：RAID一致更新问题</p></blockquote><blockquote><p>我们假设对磁盘0的请求已完成（但对磁盘1的请求显然没有完成，因为它从未发出）。</p></blockquote><blockquote><p>这种不合时宜的掉电，导致现在数据块的两个副本不一致（inconsistent）。磁盘0上的副本是新版本，而磁盘1上的副本是旧的。我们希望的是两个磁盘的状态都原子地（atomically）改变，也就是说，两者都应该最终成为新版本或者两者都不是。</p></blockquote><blockquote><p>解决此问题的一般方法，是使用某种预写日志（write-ahead log），在做之前首先记录RAID将要执行的操作（即用某个数据更新两个磁盘）。通过采取这种方法，我们可以确保在发生崩溃时，会发生正确的事情。通过运行一个恢复（recovery）过程，将所有未完成的事务重新在RAID上执行，我们可以确保两个镜像副本（在RAID-1情况下）同步。</p></blockquote><blockquote><p>最后一个注意事项：每次写入都在磁盘上记录日志，这个代价昂贵得不行，因此大多数RAID硬件都包含少量非易失性RAM（例如电池有备份的），用于执行此类记录。因此，既提供了一致的更新，又不需要花费高昂的代价，将日志记录到磁盘。</p></blockquote><h2 id="RAID-4-级：通过奇偶校验节省空间"><a href="#RAID-4-级：通过奇偶校验节省空间" class="headerlink" title="RAID 4 级：通过奇偶校验节省空间"></a>RAID 4 级：通过奇偶校验节省空间</h2><p>我们现在展示一种向磁盘阵列添加冗余的不同方法，称为奇偶校验（parity）。基于奇偶校验的方法试图使用较少的容量，从而克服由镜像系统付出的巨大空间损失。不过，这样做的代价是——性能。</p><p>这是5个磁盘的RAID-4系统的例子（见表38.4）。对于每一条数据，我们都添加了一个奇偶校验（parity）块，用于存储该条块的冗余信息。例如，奇偶校验块P1具有从块4、5、6和7计算出的冗余信息。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/e2.png" alt="?"><br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w9.png" alt="?"></p><p><strong>任何一行中的1的数量必须是偶数（而不是奇数）。这是RAID必须保持的不变性（invariant），以便奇偶校验正确。</strong></p><p><strong>如何利用奇偶校验信息从故障中恢复?</strong></p><p>标为C2的列丢失了。要找出该列中肯定存在的值，我们只需读取该行中的所有其他值（包括XOR的奇偶校验位）并重构（reconstruct）正确的答案。</p><p>假设C2列中第一行的值丢失（它是1）。通过读取该行中的其他值（C0中的0，C1中的0，C3中的1以及奇偶校验列P中的0），我们得到值0、0、1和0。因为我们知道XOR保持每行有偶数个1，所以就知道丢失的数据肯定是什么——1。这就是重构在基于异或的方案中的工作方式！还要注意如何计算重构值：只要将数据位和奇偶校验位异或，就像开始计算奇偶校验一样。</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/e3.png" alt="?"></p><p><strong>可以看出，每个块的每个比特计算奇偶校验，结果放在奇偶校验块中。</strong></p><h3 id="RAID-4-分析"><a href="#RAID-4-分析" class="headerlink" title="RAID-4 分析"></a>RAID-4 分析</h3><p>RAID-4使用1个磁盘作为它所保护的每组磁盘的奇偶校验信息。因此，RAID组的有用容量是（N−1）。</p><p>可靠性也很容易理解：RAID-4容许1个磁盘故障，不容许更多。如果丢失多个磁盘，则无法重建丢失的数据。</p><p>改写数据？</p><p>存在两种方法。第一种称为加法奇偶校验（additive  parity），要求我们做以下工作。为了计算新奇偶校验块的值，并行读取条带中所有其他数据块（在本例中为块0、2和3），并与新块（1）进行异或。结果是新的校验块。为了完成写操作，你可以将新数据和新奇偶校验写入其各自的磁盘，也是并行写入。</p><p>这种技术的问题在于它随磁盘数量而变化，因此在较大的RAID中，需要大量的读取来计算奇偶校验。因此，导致了减法奇偶校验（subtractive parity）方法。</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/e4.png" alt="?"></p><p>想象一下，我们希望用一个新值来覆盖C2位，称之为C2new。减法方法分三步工作。首先，我们读入C2（C2old = 1）和旧数据（Pold = 0）的旧数据。然后，比较旧数据和新数据。如果它们相同（例如，C2new  =  C2old），那么我们知道奇偶校验位也将保持相同（即Pnew  =  Pold）。但是，如果它们不同，那么我们必须将旧的奇偶校验位翻转到其当前状态的相反位置，也就是说，如果（Pold == 0），Pnew将被设置为0。如果（Pold == 0），Pnew将被设置为1。我们可以用XOR（⊕是XOR运算符）漂亮地表达完整的复杂情况：</p><p><strong>Pnew = (Cold⊕ Cnew) ⊕ Pold</strong></p><p>对于每次写入，RAID必须执行4次物理I/O（两次读取和两次写入）</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/e6.png" alt="?"><br>现在想象几乎同时向RAID-4提交2个小的请求，写入块4和块13（在表38.8中标出）。这些磁盘的数据位于磁盘0和1上，因此对数据的读写操作可以并行进行，这很好。出现的问题是奇偶校验磁盘。这两个请求都必须读取4和13的奇偶校验块，即奇偶校验块1和3（用+标记）。估计你已明白了这个问题：在这种类型的工作负载下，奇偶校验磁盘是瓶颈。因此我们有时将它称为基于奇偶校验的RAID的小写入问题（small-write problem）。</p><h2 id="RAID-5-级：旋转奇偶校验"><a href="#RAID-5-级：旋转奇偶校验" class="headerlink" title="RAID 5 级：旋转奇偶校验"></a>RAID 5 级：旋转奇偶校验</h2><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/e5.png" alt="?"></p><p>每个条带的奇偶校验块现在都在磁盘上旋转，以消除RAID-4的奇偶校验磁盘瓶颈。</p><h2 id="RAID-比较：总结"><a href="#RAID-比较：总结" class="headerlink" title="RAID 比较：总结"></a>RAID 比较：总结</h2><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/e8.png" alt="?"><br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/r1.png" alt="?"></p><hr><h1 id="插叙：文件和目录"><a href="#插叙：文件和目录" class="headerlink" title="插叙：文件和目录"></a>插叙：文件和目录</h1><p>到目前为止，我们看到了两项关键操作系统技术的发展：<br><strong>进程，它是虚拟化的CPU；地址空间，它是虚拟化的内存。</strong></p><p>在这两种抽象共同作用下，程序运行时就好像它在自己的私有独立世界中一样，好像它有自己的处理器（或多处理器），好像它有自己的内存。</p><p>持久存储（persistent storage）。永久存储设备永久地（或至少长时间地）存储信息，如传统硬盘驱动器（hard  disk  drive）或更现代的固态存储设备（solid-state storage device）。持久存储设备与内存不同。内存在断电时，其内容会丢失，而持久存储设备会保持这些数据不变。因此，操作系统必须特别注意这样的设备：用户用它们保存真正关心的数据。</p><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>随着时间的推移，存储虚拟化形成了两个关键的抽象。第一个是文件（file）。文件就是一个线性字节数组，每个字节都可以读取或写入。每个文件都有某种低级名称（low-level name），通常是某种数字。用户通常不知道这个名字（我们稍后会看到）。由于历史原因，文件的低级名称通常称为inode号（inode  number）。</p><p>第二个抽象是目录（directory）。一个目录，像一个文件一样，也有一个低级名字（即inode号），但是它的内容非常具体：它包含一个（用户可读名字，低级名字）对的列表。例如，假设存在一个低级别名称为“10”的文件，它的用户可读的名称为“foo”。“foo”所在的目录因此会有条目（“foo”，“10”），将用户可读名称映射到低级名称。目录中的每个条目都指向文件或其他目录。通过将目录放入其他目录中，用户可以构建任意的目录树（directory tree，或目录层次结构，directory hierarchy），在该目录树下存储所有文件和目录。</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/r2.png" alt="?"></p><h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>通过调用open()并传入O_CREAT标志，程序可以创建一个新文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;foo&quot;</span>, O_CREAT | O_WRONLY | O_TRUNC);</span><br></pre></td></tr></table></figure><p>open()的一个重要方面是它的返回值：文件描述符（file descriptor）。文件描述符只是一个整数，是每个进程私有的，在UNIX系统中用于访问文件。因此，一旦文件被打开，你就可以使用文件描述符来读取或写入文件，假定你有权这样做。这样，一个文件描述符就是一种权限（capability）[L84]，即一个不透明的句柄，它可以让你执行某些操作。另一种看待文件描述符的方法，是将它作为指向文件类型对象的指针。一旦你有这样的对象，就可以调用其他“方法”来访问文件，如read()和write()。</p><blockquote><p>句柄（Handle）是计算机科学中的一个术语，用于表示对资源或对象的引用。在操作系统中，句柄通常是一个整数或指针，用于标识和跟踪分配给进程的资源，例如文件、内存、设备或其他系统对象。</p></blockquote><blockquote><p>句柄可以看作是对实际对象的间接引用，类似于人们使用门牌号码来访问房屋。通过使用句柄，程序可以在需要的时候引用和操作特定的资源，而不需要了解其具体的内部表示或实现细节。</p></blockquote><blockquote><p>句柄在编程中非常常见，特别是在底层操作系统编程、图形用户界面(GUI)开发和资源管理方面。通过使用句柄，程序可以更有效地管理和控制系统资源，并提高代码的可读性和维护性。</p></blockquote><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><blockquote><p>使用strace（和类似工具）strace工具提供了一种非常棒的方式，来查看程序在做什么。通过运行它，你可以跟踪程序生成的系统调用，查看参数和返回代码，通常可以很好地了解正在发生的事情。</p></blockquote><p>下面是一个例子，使用strace来找出cat在做什么（为了可读性删除了一些调用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; strace cat foo</span><br><span class="line">...</span><br><span class="line">open(<span class="string">&quot;foo&quot;</span>, O_RDONLY|O_LARGEFILE)</span><br><span class="line">= <span class="number">3</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;hello\n&quot;</span>, <span class="number">4096</span>)</span><br><span class="line">= <span class="number">6</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello\n&quot;</span>, <span class="number">6</span>)</span><br><span class="line">= <span class="number">6</span></span><br><span class="line">hello</span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;&quot;</span>, <span class="number">4096</span>) = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>) = <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure><p>cat做的第一件事是打开文件准备读取。我们应该注意几件事情。首先，该文件仅为读取而打开（不写入），如O_RDONLY标志所示。其次，使用64位偏移量（O_LARGEFILE）。最后，open()调用成功并返回一个文件描述符，其值为3。</p><p><strong>为什么第一次调用open()会返回3，而不是0或1？</strong></p><p>每个正在运行的进程已经打开了3个文件：标准输入（进程可以读取以接收输入），标准输出（进程可以写入以便将信息显示到屏幕），以及标准错误（进程可以写入错误消息）。这些分别由文件描述符0、1和2表示。因此，当你第一次打开另一个文件时（如上例所示），它几乎肯定是文件描述符3。</p><p>打开成功后，cat使用read()系统调用重复读取文件中的一些字节。read()的第一个参数是文件描述符，从而告诉文件系统读取哪个文件。一个进程当然可以同时打开多个文件，因此描述符使操作系统能够知道某个特定的读取引用了哪个文件。第二个参数指向一个用于放置read()结果的缓冲区。在上面的系统调用跟踪中，strace显示了这时的读取结果（“hello”）。第三个参数是缓冲区的大小，在这个例子中是4KB。对read()的调用也成功返回，这里返回它读取的字节数（6，其中包括“hello”中的5个字母和一个行尾标记）。</p><p>write()系统调用的一次调用，针对文件描述符1。如上所述，此描述符被称为标准输出，因此用于将单词“Hello”写到屏幕上，这正是cat程序要做的事。但是它直接调用write()吗？也许（如果它是高度优化的）。但是，如果不是，那么可能会调用库例程printf()。在内部，printf()会计算出传递给它的所有格式化细节，并最终对标准输出调用write，将结果显示到屏幕上。</p><p>然后，cat程序试图从文件中读取更多内容，但由于文件中没有剩余字节，read()返回0，程序知道这意味着它已经读取了整个文件。因此，程序调用close()，传入相应的文件描述符，表明它已用完文件“foo”。该文件因此被关闭，对它的读取完成了。</p><h2 id="读取和写入，但不按顺序"><a href="#读取和写入，但不按顺序" class="headerlink" title="读取和写入，但不按顺序"></a>读取和写入，但不按顺序</h2><p>有时能够读取或写入文件中的特定偏移量是有用的。例如，如果你在文本文件上构建了索引并利用它来查找特定单词，最终可能会从文件中的某些随机（random）偏移量中读取数据。为此，我们将使用lseek()系统调用。下面是函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fildes, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>第一个参数是熟悉的（一个文件描述符）。第二个参数是偏移量，它将文件偏移量定位到文件中的特定位置。第三个参数，由于历史原因而被称为whence，明确地指定了搜索的执行方式。</p><p>从这段描述中可见，对于每个进程打开的文件，操作系统都会跟踪一个“当前”偏移量，这将决定在文件中读取或写入时，下一次读取或写入开始的位置。因此，打开文件的抽象包括它具有当前偏移量，偏移量的更新有两种方式。第一种是当发生N个字节的读或写时，N被添加到当前偏移。因此，每次读取或写入都会隐式更新偏移量。第二种是明确的lseek，它改变了上面指定的偏移量。</p><blockquote><p>调用lseek()不会执行磁盘寻道<br>lseek()调用只是在OS内存中更改一个变量，该变量跟踪特定进程的下一个读取或写入开始的偏移量。如果发送到磁盘的读取或写入与最后一次读取或写入不在同一磁道上，就会发生磁盘寻道，因此需要磁头移动。</p></blockquote><h2 id="用-fsync-立即写入"><a href="#用-fsync-立即写入" class="headerlink" title="用 fsync()立即写入"></a>用 fsync()立即写入</h2><p>大多数情况下，当程序调用write()时，它只是告诉文件系统：请在将来的某个时刻，将此数据写入持久存储。出于性能的原因，文件系统会将这些写入在内存中缓冲（buffer）一段时间（例如5s或30s）。在稍后的时间点，写入将实际发送到存储设备。从调用应用程序的角度来看，写入似乎很快完成，并且只有在极少数情况下（例如，在write()调用之后但写入磁盘之前，机器崩溃）数据会丢失。</p><p><strong>在数据库管理系统（DBMS）中，开发正确的恢复协议要求能够经常强制写入磁盘。</strong></p><p>当进程针对特定文件描述符调用fsync()时，文件系统通过强制将所有脏（dirty）数据（即尚未写入的）写入磁盘来响应，针对指定文件描述符引用的文件。一旦所有这些写入完成，fsync()例程就会返回。</p><p>以下是如何使用fsync()的简单示例。代码打开文件foo，向它写入一个数据块，然后调用fsync()以确保立即强制写入磁盘。一旦fsync()返回，应用程序就可以安全地继续前进，知道数据已被保存（如果fsync()实现正确，那就是了）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;foo&quot;</span>, O_CREAT | O_WRONLY | O_TRUNC);</span><br><span class="line">assert(fd &gt; <span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> rc = write(fd, buffer, size);</span><br><span class="line">assert(rc == size);</span><br><span class="line">rc = fsync(fd);</span><br><span class="line">assert(rc == <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在某些情况下，还需要fsync()包含foo文件的目录。添加此步骤不仅可以确保文件本身位于磁盘上，而且可以确保文件（如果新创建）也是目录的一部分。</p><h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2><p>有时需要给一个文件一个不同的名字。在命令行键入时，这是通过mv命令完成的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; mv foo bar</span><br></pre></td></tr></table></figure><p>利用strace，我们可以看到mv使用了系统调用rename(char  *  old,  char  *  new)，它只需要两个参数：文件的原来名称（old）和新名称（new）。</p><p>rename()调用提供了一个有趣的保证：它（通常）是一个原子（atomic）调用，不论系统是否崩溃。如果系统在重命名期间崩溃，文件将被命名为旧名称或新名称，不会出现奇怪的中间状态。因此，对于支持某些需要对文件状态进行原子更新的应用程序，rename()非常重要。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;foo.txt.tmp&quot;</span>, O_WRONLY|O_CREAT|O_TRUNC);</span><br><span class="line">write(fd, buffer, size); <span class="comment">// write out new version of file</span></span><br><span class="line">fsync(fd);</span><br><span class="line">close(fd);</span><br><span class="line">rename(<span class="string">&quot;foo.txt.tmp&quot;</span>, <span class="string">&quot;foo.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>编辑器做的事很简单：将文件的新版本写入临时名称（foot.txt.tmp），使用fsync()将其强制写入磁盘。然后，当应用程序确定新文件的元数据和内容在磁盘上，就将临时文件重命名为原有文件的名称。最后一步自动将新文件交换到位，同时删除旧版本的文件，从而实现原子文件更新。</strong></p><h2 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h2><p>除了文件访问之外，我们还希望文件系统能够保存关于它正在存储的每个文件的大量信息。我们通常将这些数据称为文件元数据（metadata）。要查看特定文件的元数据，我们可以使用stat()或fstat()系统调用。这些调用将一个路径名（或文件描述符）添加到一个文件中，并填充一个stat结构，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line"><span class="type">dev_t</span> st_dev; <span class="comment">/* ID of device containing file */</span></span><br><span class="line"><span class="type">ino_t</span> st_ino; <span class="comment">/* inode number */</span></span><br><span class="line"><span class="type">mode_t</span> st_mode; <span class="comment">/* protection */</span></span><br><span class="line"><span class="type">nlink_t</span> st_nlink; <span class="comment">/* number of hard links */</span></span><br><span class="line"><span class="type">uid_t</span> st_uid; <span class="comment">/* user ID of owner */</span></span><br><span class="line"><span class="type">gid_t</span> st_gid; <span class="comment">/* group ID of owner */</span></span><br><span class="line"><span class="type">dev_t</span> st_rdev; <span class="comment">/* device ID (if special file) */</span></span><br><span class="line"><span class="type">off_t</span> st_size; <span class="comment">/* total size, in bytes */</span></span><br><span class="line"><span class="type">blksize_t</span> st_blksize; <span class="comment">/* blocksize for filesystem I/O */</span></span><br><span class="line"><span class="type">blkcnt_t</span> st_blocks; <span class="comment">/* number of blocks allocated */</span></span><br><span class="line"><span class="type">time_t</span> st_atime; <span class="comment">/* time of last access */</span></span><br><span class="line"><span class="type">time_t</span> st_mtime; <span class="comment">/* time of last modification */</span></span><br><span class="line"><span class="type">time_t</span> st_ctime; <span class="comment">/* time of last status change */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要查看此信息，可以使用命令行工具stat：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; echo hello &gt; file</span><br><span class="line">prompt&gt; stat file</span><br><span class="line">File: <span class="string">&#x27;file&#x27;</span></span><br><span class="line">Size: <span class="number">6</span> Blocks: <span class="number">8</span> IO Block: <span class="number">4096</span> regular file</span><br><span class="line">Device: <span class="number">811</span>h/<span class="number">2065</span>d Inode: <span class="number">67158084</span> Links: <span class="number">1</span></span><br><span class="line">Access: (<span class="number">0640</span>/-rw-r-----) Uid: (<span class="number">30686</span>/ remzi) Gid: (<span class="number">30686</span>/ remzi)</span><br><span class="line">Access: <span class="number">2011</span><span class="number">-05</span><span class="number">-03</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">20.157594748</span> <span class="number">-0500</span></span><br><span class="line">Modify: <span class="number">2011</span><span class="number">-05</span><span class="number">-03</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">20.157594748</span> <span class="number">-0500</span></span><br><span class="line">Change: <span class="number">2011</span><span class="number">-05</span><span class="number">-03</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">20.157594748</span> <span class="number">-0500</span></span><br></pre></td></tr></table></figure><p>事实表明，每个文件系统通常将这种类型的信息保存在一个名为 inode<br>①的结构中。应该将 inode看作是由文件系统保存的持久数据结构，包含上述信息。</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; strace rm foo</span><br><span class="line">...</span><br><span class="line">unlink(<span class="string">&quot;foo&quot;</span>) = <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>unlink()只需要待删除文件的名称，并在成功时返回零。</p><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>除了文件外，还可以使用一组与目录相关的系统调用来创建、读取和删除目录。永远不能直接写入目录。因为目录的格式被视为文件系统元数据，所以你只能间接更新目录，例如，通过在其中创建文件、目录或其他对象类型。通过这种方式，文件系统可以确保目录的内容始终符合预期。</p><p>要创建目录，可以用系统调用mkdir()。同名的mkdir程序可以用来创建这样一个目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; strace mkdir foo</span><br><span class="line">...</span><br><span class="line">mkdir(<span class="string">&quot;foo&quot;</span>, <span class="number">0777</span>) = <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure><p>这样的目录创建时，它被认为是“空的”，尽管它实际上包含最少的内容。具体来说，空目录有两个条目：一个引用自身的条目，一个引用其父目录的条目。前者称为“.”（点）目录，后者称为“..”（点-点）目录。你可以通过向程序ls传递一个标志（-a）来查看这些目录：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ls -a</span><br><span class="line">./ ../</span><br><span class="line">prompt&gt; ls -al</span><br><span class="line">total <span class="number">8</span></span><br><span class="line">drwxr-x--- <span class="number">2</span> remzi remzi <span class="number">6</span> Apr <span class="number">30</span> <span class="number">16</span>:<span class="number">17</span> ./</span><br><span class="line">drwxr-x--- <span class="number">26</span> remzi remzi <span class="number">4096</span> Apr <span class="number">30</span> <span class="number">16</span>:<span class="number">17</span> ../</span><br></pre></td></tr></table></figure><h2 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h2><p>创建了目录，也可能希望读取目录。实际上，这正是ls程序做的事。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">DIR *dp = opendir(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">assert(dp != <span class="literal">NULL</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">d</span>;</span></span><br><span class="line"><span class="keyword">while</span> ((d = readdir(dp)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, (<span class="type">int</span>) d-&gt;d_ino, d-&gt;d_name);</span><br><span class="line">&#125;</span><br><span class="line">closedir(dp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h2><p>可以通过调用rmdir()来删除目录（它由相同名称的程序rmdir使用）。然而，与删除文件不同，删除目录更加危险，因为你可以使用单个命令删除大量数据。因此，rmdir()要求该目录在被删除之前是空的（只有“.”和“..”条目）。如果你试图删除一个非空目录，那么对rmdir()的调用就会失败。</p><h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p><strong>理解在文件系统树中创建条目的新方法，即通过所谓的link()系统调用。</strong></p><p>link()系统调用有两个参数：一个旧路径名和一个新路径名。当你将一个新的文件名“链接”到一个旧的文件名时，你实际上创建了另一种引用同一个文件的方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; echo hello &gt; file</span><br><span class="line">prompt&gt; cat file</span><br><span class="line">hello</span><br><span class="line">prompt&gt; ln file file2</span><br><span class="line">prompt&gt; cat file2</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>link只是在要创建链接的目录中创建了另一个名称，并将其指向原有文件的相同inode号（即低级别名称）。该文件不以任何方式复制。相反，你现在就有了两个人类可读的名称（file和file2），都指向同一个文件。通过打印每个文件的inode号，我们甚至可以在目录中看到这一点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ls -i file file2</span><br><span class="line"><span class="number">67158084</span> file</span><br><span class="line"><span class="number">67158084</span> file2</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure><p>创建一个文件时，实际上做了两件事。首先，要构建一个结构（inode），它将跟踪几乎所有关于文件的信息，包括其大小、文件块在磁盘上的位置等等。其次，将人类可读的名称链接到该文件，并将该链接放入目录中。</p><p>在创建文件的硬链接之后，在文件系统中，原有文件名（file）和新创建的文件名（file2）之间没有区别。实际上，它们都只是指向文件底层元数据的链接，可以在inode编号67158084中找到。</p><p>这样的结果是因为当文件系统取消链接文件时，它检查inode号中的引用计数（reference count）。该引用计数（有时称为链接计数，link count）允许文件系统跟踪有多少不同的文件名已链接到这个inode。调用unlink()时，会删除人类可读的名称（正在删除的文件）与给定inode号之间的“链接”，并减少引用计数。只有当引用计数达到零时，文件系统才会释放inode和相关数据块，从而真正“删除”该文件。</p><p>可以使用stat()来查看文件的引用计数。让我们看看创建和删除文件的硬链接时，引用计数是什么。在这个例子中，我们将为同一个文件创建 3 个链接，然后删除它们。仔细看链接计数！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; echo hello &gt; file</span><br><span class="line">prompt&gt; stat file</span><br><span class="line">... Inode: <span class="number">67158084</span> Links: <span class="number">1</span> ...</span><br><span class="line">prompt&gt; ln file file2</span><br><span class="line">prompt&gt; stat file</span><br><span class="line">... Inode: <span class="number">67158084</span> Links: <span class="number">2</span> ...</span><br><span class="line">prompt&gt; stat file2</span><br><span class="line">... Inode: <span class="number">67158084</span> Links: <span class="number">2</span> ...</span><br><span class="line">prompt&gt; ln file2 file3</span><br><span class="line">prompt&gt; stat file</span><br><span class="line">... Inode: <span class="number">67158084</span> Links: <span class="number">3</span> ...</span><br><span class="line">prompt&gt; rm file</span><br><span class="line">prompt&gt; stat file2</span><br><span class="line">... Inode: <span class="number">67158084</span> Links: <span class="number">2</span> ...</span><br><span class="line">prompt&gt; rm file2</span><br><span class="line">prompt&gt; stat file3</span><br><span class="line">... Inode: <span class="number">67158084</span> Links: <span class="number">1</span> ...</span><br><span class="line">prompt&gt; rm file3</span><br></pre></td></tr></table></figure><h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><p>还有一种非常有用的链接类型，称为符号链接（symbolic link），有时称为软链接（soft link）。事实表明，硬链接有点局限：你不能创建目录的硬链接（因为担心会在目录树中创建一个环）。你不能硬链接到其他磁盘分区中的文件（因为inode号在特定文件系统中是唯一的，而不是跨文件系统），等等。因此，人们创建了一种称为符号链接的新型链接。</p><p>要创建这样的链接，可以使用相同的程序ln，但使用-s标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; echo hello &gt; file</span><br><span class="line">prompt&gt; ln -s file file2</span><br><span class="line">prompt&gt; cat file2</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>如你所见，创建软链接看起来几乎相同，现在可以通过文件名称file以及符号链接名称file2来访问原始文件。但是，除了表面相似之外，符号链接实际上与硬链接完全不同。第一个区别是符号链接本身实际上是一个不同类型的文件。我们已经讨论过常规文件和目录。符号链接是文件系统知道的第三种类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; stat file</span><br><span class="line">... regular file ...</span><br><span class="line">prompt&gt; stat file2</span><br><span class="line">... symbolic link ...</span><br></pre></td></tr></table></figure><p>如果仔细观察 ls 输出的长格式的第一个字符，可以看到常规文件最左列中的第一个字符是“-”，目录是“d”，软链接是“l”。你还可以看到符号链接的大小（本例中为 4 个字节），以及链接指向的内容（名为 file 的文件）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ls -al</span><br><span class="line">drwxr-x--- <span class="number">2</span> remzi remzi <span class="number">29</span> May <span class="number">3</span> <span class="number">19</span>:<span class="number">10</span> ./</span><br><span class="line">drwxr-x--- <span class="number">27</span> remzi remzi <span class="number">4096</span> May <span class="number">3</span> <span class="number">15</span>:<span class="number">14</span> ../</span><br><span class="line">-rw-r----- <span class="number">1</span> remzi remzi <span class="number">6</span> May <span class="number">3</span> <span class="number">19</span>:<span class="number">10</span> file</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> remzi remzi <span class="number">4</span> May <span class="number">3</span> <span class="number">19</span>:<span class="number">10</span> file2 -&gt; file</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; echo hello &gt; file</span><br><span class="line">prompt&gt; ln -s file file2</span><br><span class="line">prompt&gt; cat file2</span><br><span class="line">hello</span><br><span class="line">prompt&gt; rm file</span><br><span class="line">prompt&gt; cat file2</span><br><span class="line">cat: file2: No such file or directory</span><br></pre></td></tr></table></figure><p>符号链接与硬链接完全不同，删除名为file的原始文件会导致符号链接指向不再存在的路径名。</p><h2 id="创建并挂载文件系统"><a href="#创建并挂载文件系统" class="headerlink" title="创建并挂载文件系统"></a>创建并挂载文件系统</h2><p>如何从许多底层文件系统组建完整的目录树。这项任务的实现是先制作文件系统，然后挂载它们，使其内容可以访问。</p><p>为了创建一个文件系统，大多数文件系统提供了一个工具，通常名为mkfs（发音为“make fs”），它就是完成这个任务的。思路如下：作为输入，为该工具提供一个设备（例如磁盘分区，例如/dev/sda1），一种文件系统类型（例如ext3），它就在该磁盘分区上写入一个空文件系统，从根目录开始。mkfs说，要有文件系统！</p><p>但是，一旦创建了这样的文件系统，就需要在统一的文件系统树中进行访问。这个任务是通过mount程序实现的（它使底层系统调用mount()完成实际工作）。mount的作用很简单：以现有目录作为目标挂载点（mount  point），本质上是将新的文件系统粘贴到目录树的这个点上。</p><p>因此mount的美妙之处在于：它将所有文件系统统一到一棵树中，而不是拥有多个独立的文件系统，这让命名统一而且方便。</p><p>要查看系统上挂载的内容，以及在哪些位置挂载，只要运行mount程序。你会看到类似下面的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/dev/sda1 on / type <span class="title function_">ext3</span> <span class="params">(rw)</span></span><br><span class="line">proc on /proc type <span class="title function_">proc</span> <span class="params">(rw)</span></span><br><span class="line">sysfs on /sys type <span class="title function_">sysfs</span> <span class="params">(rw)</span></span><br><span class="line">/dev/sda5 on /tmp type <span class="title function_">ext3</span> <span class="params">(rw)</span></span><br><span class="line">/dev/sda7 on /var/vice/cache type <span class="title function_">ext3</span> <span class="params">(rw)</span></span><br><span class="line">tmpfs on /dev/shm type <span class="title function_">tmpfs</span> <span class="params">(rw)</span></span><br><span class="line">AFS on /afs type <span class="title function_">afs</span> <span class="params">(rw)</span></span><br></pre></td></tr></table></figure><hr><h1 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h1><p>VSFS（Very Simple File System，简单文件系统）。它是典型UNIX文件系统的简化版本，用于介绍一些基本磁盘结构、访问方法和各种策略。</p><p>文件系统是纯软件。与CPU和内存虚拟化的开发不同，我们不会添加硬件功能来使文件系统的某些方面更好地工作。</p><h2 id="思考方式"><a href="#思考方式" class="headerlink" title="思考方式"></a>思考方式</h2><p>考虑文件系统时，考虑它们的两个不同方面。</p><p>第一个方面是文件系统的数据结构（data structure）。文件系统在磁盘上使用哪些类型的结构来组织其数据和元数据？我们即将看到的第一个文件系统（包括下面的VSFS）使用简单的结构，如块或其他对象的数组，而更复杂的文件系统（如SGI的XFS）使用更复杂的基于树的结构。</p><p>文件系统的第二个方面是访问方法（access method）。如何将进程发出的调用，如open()、read()、write()等，映射到它的结构上？在执行特定系统调用期间读取哪些结构？改写哪些结构？所有这些步骤的执行效率如何？</p><h2 id="整体组织"><a href="#整体组织" class="headerlink" title="整体组织"></a>整体组织</h2><p>VSFS文件系统在磁盘上的数据结构的整体组织。我们需要做的第一件事是将磁盘分成块（block）。简单的文件系统只使用一种块大小，这里正是这样做的。我们选择常用的4KB。</p><p>我们对构建文件系统的磁盘分区的看法很简单：一系列块，每块大小为4KB。在大小为N个4KB块的分区中，这些块的地址为从0到N−1。假设我们有一个非常小的磁盘，只有64块。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/r3.png" alt="?"></p><p>实际上，任何文件系统中的大多数空间都是（并且应该是）用户数据。我们将用于存放用户数据的磁盘区域称为数据区域（data region），简单起见，将磁盘的固定部分留给这些块，例如磁盘上64个块的最后56个：</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/r5.png" alt="?"></p><p>文件系统必须记录每个文件的信息。该信息是元数据（metadata）的关键部分，并且记录诸如文件包含哪些数据块（在数据区域中）、文件的大小，其所有者和访问权限、访问和修改时间以及其他类似信息的事情。</p><p>为了存储这些信息，文件系统通常有一个名为inode的结构。为了存放inode，我们还需要在磁盘上留出一些空间。我们将这部分磁盘称为inode表（inode table），它只是保存了一个磁盘上inode的数组。因此，假设我们将64个块中的5块用于inode，磁盘映像现在看起来如下：</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/r6.png" alt="?"></p><p>还需要某种方法来记录inode或数据块是空闲还是已分配。因此，这种分配结构（allocation structure）是所有文件系统中必需的部分。</p><p>我们可以用一个空闲列表（free list），指向第一个空闲块，然后它又指向下一个空闲块，依此类推。我们选择一种简单而流行的结构，称为位图（bitmap），一种用于数据区域（数据位图，data bitmap），另一种用于inode表（inode位图，inode bitmap）。位图是一种简单的结构：每个位用于指示相应的对象/块是空闲（0）还是正在使用（1）。因此新的磁盘布局如下，包含inode位图（i）和数据位图（d）：</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/r7.png" alt="?"></p><p>在极简文件系统的磁盘结构设计中，还有一块。我们将它保留给超级块（superblock），在下图中用S表示。超级块包含关于该特定文件系统的信息，包括例如文件系统中有多少个inode和数据块（在这个例子中分别为80和56）、inode表的开始位置（块3）等等。它可能还包括一些幻数，来标识文件系统类型（在本例中为VSFS）<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/r8.png" alt="?"><br>因此，在挂载文件系统时，操作系统将首先读取超级块，初始化各种参数，然后将该卷添加到文件系统树中。当卷中的文件被访问时，系统就会知道在哪里查找所需的磁盘上的结构。</p><h2 id="文件组织：inode"><a href="#文件组织：inode" class="headerlink" title="文件组织：inode"></a>文件组织：inode</h2><p>文件系统最重要的磁盘结构之一是inode，几乎所有的文件系统都有类似的结构。名称inode是index node（索引节点）的缩写，它是由UNIX开发人员Ken Thompson [RT74]给出的历史性名称，因为这些节点最初放在一个数组中，在访问特定inode时会用到该数组的索引。</p><blockquote><p>补充：数据结构—— inode<br> inode是许多文件系统中使用的通用名称，用于描述保存给定文件的元数据的结构，例如其长度、权限以及其组成块的位置。这个名称至少可以追溯到UNIX（如果不是早期的系统，可能还会追溯到Multics）。它是index  node（索引节点）的缩写，因为inode号用于索引磁盘上的inode数组，以便查找该inode号对应的inode。我们将看到，inode的设计是文件系统设计的一个关键部分。大多数现代系统对于它们记录的每个文件都有这样的结构，但也许用了不同的名字（如dnodes、fnodes等）。</p></blockquote><p> 每个inode都由一个数字（称为inumber）隐式引用，我们之前称之为文件的低级名称（low-level name）。在VSFS（和其他简单的文件系统）中，给定一个inumber，你应该能够直接计算磁盘上相应节点的位置。例如，如上所述，获取VSFS的inode表：大小为20KB（5个4KB块），因此由80个inode（假设每个inode为256字节）组成。进一步假设inode区域从12KB开始（即超级块从0KB开始，inode位图在4KB地址，数据位图在8KB，因此inode表紧随其后）。因此，在VSFS中，我们为文件系统分区的开头提供了以下布局（特写视图）：<br> <img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/t1.png" alt="?"></p><p> 要读取inode号32，文件系统首先会计算inode区域的偏移量（32×inode的大小，即8192），将它加上磁盘inode表的起始地址（inodeStartAddr  =  12KB），从而得到希望的inode块的正确字节地址：20KB。</p><p>在每个inode中，实际上是所有关于文件的信息：文件类型（例如，常规文件、目录等）、大小、分配给它的块数、保护信息（如谁拥有该文件以及谁可以访问它）、一些时间信息（包括文件创建、修改或上次访问的时间文件下），以及有关其数据块驻留在磁盘上的位置的信息（如某种类型的指针）。我们将所有关于文件的信息称为元数据（metadata）。实际上，文件系统中除了纯粹的用户数据外，其他任何信息通常都称为元数据。</p><h3 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h3><p>为了支持更大的文件，文件系统设计者必须在inode中引入不同的结构。一个常见的思路是有一个称为间接指针（indirect  pointer）的特殊指针。它不是指向包含用户数据的块，而是指向包含更多指针的块，每个指针指向用户数据。因此，inode可以有一些固定数量（例如 12个）的直接指针和一个间接指针。如果文件变得足够大，则会分配一个间接块（来自磁盘的数据块区域），并将inode的间接指针设置为指向它。假设一个块是4KB，磁盘地址是4字节，那就增加了1024个指针。文件可以增长到（12 + 1024）×4KB，即4144KB。</p><p>这种不平衡树被称为指向文件块的多级索引（multi-level  index）方法。我们来看一个例子，它有12个直接指针，以及一个间接块和一个双重间接块。假设块大小为4KB，并且指针为4字节，则该结构可以容纳一个刚好超过4GB的文件，即（12  +  1024  +  10242）×4KB。</p><h2 id="目录组织"><a href="#目录组织" class="headerlink" title="目录组织"></a>目录组织</h2><p>在VSFS中（像许多文件系统一样），目录的组织很简单。一个目录基本上只包含一个二元组（条目名称，inode号）的列表。对于给定目录中的每个文件或目录，目录的数据块中都有一个字符串和一个数字。</p><p>删除一个文件（例如调用unlink()）会在目录中间留下一段空白空间，因此应该有一些方法来标记它（例如，用一个保留的inode号，比如0）。这种删除是使用记录长度的一个原因：新条目可能会重复使用旧的、更大的条目，从而在其中留有额外的空间。</p><p>通常，文件系统将目录视为特殊类型的文件。因此，目录有一个inode，位于inode表中的某处（inode表中的inode标记为“目录”的类型字段，而不是“常规文件”）。该目录具有由inode指向的数据块（也可能是间接块）。这些数据块存在于我们的简单文件系统的数据块区域中。我们的磁盘结构因此保持不变。</p><h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><p>文件系统必须记录哪些inode和数据块是空闲的，哪些不是，这样在分配新文件或目录时，就可以为它找到空间。因此，空闲空间管理（free space management）对于所有文件系统都很重要。在VSFS中，我们用两个简单的位图来完成这个任务。</p><p>例如，当我们创建一个文件时，我们必须为该文件分配一个inode。文件系统将通过位图搜索一个空闲的内容，并将其分配给该文件。文件系统必须将inode标记为已使用（用1），并最终用正确的信息更新磁盘上的位图。分配数据块时会发生类似的一组活动。</p><h2 id="访问路径：读取和写入"><a href="#访问路径：读取和写入" class="headerlink" title="访问路径：读取和写入"></a>访问路径：读取和写入</h2><p>我们假设文件系统已经挂载，因此超级块已经在内存中。其他所有内容（如inode、目录）仍在磁盘上。</p><h3 id="从磁盘读取文件"><a href="#从磁盘读取文件" class="headerlink" title="从磁盘读取文件"></a>从磁盘读取文件</h3><p>想打开一个文件（例如/foo/bar，读取它，然后关闭它）。对于这个简单的例子，假设文件的大小只有4KB（即1块）。</p><p>当你发出一个open(“/foo/bar”, O_RDONLY)调用时，文件系统首先需要找到文件bar的inode，从而获取关于该文件的一些基本信息（权限信息、文件大小等等）,必须能够找到inode，但它现在只有完整的路径名。文件系统必须遍历（traverse）路径名，从而找到所需的inode。</p><p>所有遍历都从文件系统的根开始，即根目录（root  directory），它就记为/。因此，文件系统的第一次磁盘读取是根目录的inode。但是这个inode在哪里？要找到inode，我们必须知道它的i-number。通常，我们在其父目录中找到文件或目录的i-number。根没有父目录（根据定义）。因此，根的inode号必须是“众所周知的”。在挂载文件系统时，文件系统必须知道它是什么。在大多数UNIX文件系统中，根的inode号为2。因此，要开始该过程，文件系统会读入inode号2的块（第一个inode块）。</p><p>一旦inode被读入，文件系统可以在其中查找指向数据块的指针，数据块包含根目录的内容。因此，文件系统将使用这些磁盘上的指针来读取目录，在这个例子中，寻找foo的条目。通过读入一个或多个目录数据块，它将找到foo的条目。一旦找到，文件系统也会找到下一个需要的foo的inode号（假定是44）。</p><p>下一步是递归遍历路径名，直到找到所需的inode。在这个例子中，文件系统读取包含foo的inode及其目录数据的块，最后找到bar的inode号。open()的最后一步是将bar的inode读入内存。然后文件系统进行最后的权限检查，在每个进程的打开文件表中，为此进程分配一个文件描述符，并将它返回给用户。</p><p>打开后，程序可以发出read()系统调用，从文件中读取。第一次读取（除非lseek()已被调用，则在偏移量0处）将在文件的第一个块中读取，查阅inode以查找这个块的位置。它也会用新的最后访问时间更新inode。读取将进一步更新此文件描述符在内存中的打开文件表，更新文件偏移量，以便下一次读取会读取第二个文件块，等等。</p><h3 id="写入磁盘"><a href="#写入磁盘" class="headerlink" title="写入磁盘"></a>写入磁盘</h3><p>写入文件是一个类似的过程。首先，文件必须打开（如上所述）。其次，应用程序可以发出write()调用以用新内容更新文件。最后，关闭该文件。</p><p>要创建一个文件，文件系统不仅要分配一个inode，还要在包含新文件的目录中分配空间。这样做的I/O工作总量非常大：一个读取inode位图（查找空闲inode），一个写入inode位图（将其标记为已分配），一个写入新的inode本身（初始化它），一个写入目录的数据（将文件的高级名称链接到它的inode号），以及一个读写目录inode以便更新它。如果目录需要增长以容纳新条目，则还需要额外的I/O（即数据位图和新目录块）。所有这些只是为了创建一个文件！</p><h2 id="缓存和缓冲"><a href="#缓存和缓冲" class="headerlink" title="缓存和缓冲"></a>缓存和缓冲</h2><p>读取和写入文件可能是昂贵的，会导致（慢速）磁盘的许多I/O。这显然是一个巨大的性能问题，为了弥补，大多数文件系统积极使用系统内存（DRAM）来缓存重要的块。</p><p>早期的文件系统因此引入了一个固定大小的缓存（fixed-size cache）来保存常用的块。正如我们在讨论虚拟内存时一样，LRU及不同变体策略会决定哪些块保留在缓存中。</p><p>现代系统采用动态划分（dynamic  partitioning）方法。具体来说，许多现代操作系统将虚拟内存页面和文件系统页面集成到统一页面缓存中（unified page cache）[S00]。通过这种方式，可以在虚拟内存和文件系统之间更灵活地分配内存，具体取决于在给定时间哪种内存需要更多的内存。</p><hr><h1 id="局部性和快速文件系统"><a href="#局部性和快速文件系统" class="headerlink" title="局部性和快速文件系统"></a>局部性和快速文件系统</h1><p>当UNIX操作系统首次引入时，Ken Thompson编写了第一个文件系统。我们称之为“老UNIX文件系统”，它非常简单，基本上，它的数据结构在磁盘上看起来像这样：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/u1.png" alt="?"></p><p>超级块（S）包含有关整个文件系统的信息：卷的大小、有多少inode、指向空闲列表块的头部的指针等等。磁盘的inode区域包含文件系统的所有inode。最后，大部分磁盘都被数据块占用。</p><p>老文件系统的好处在于它很简单，支持文件系统试图提供的基本抽象：文件和目录层次结构。</p><h2 id="问题：性能不佳"><a href="#问题：性能不佳" class="headerlink" title="问题：性能不佳"></a>问题：性能不佳</h2><p><strong>老UNIX文件系统将磁盘当成随机存取内存。</strong> 数据遍布各处，而不考虑保存数据的介质是磁盘的事实.</p><p>例如，文件的数据块通常离其inode非常远，因此每当第一次读取inode然后读取文件的数据块（非常常见的操作）时，就会导致昂贵的寻道。</p><p>更糟糕的是，文件系统最终会变得非常碎片化（fragmented），因为空闲空间没有得到精心管理。空闲列表最终会指向遍布磁盘的一堆块，并且随着文件的分配，它们只会占用下一个空闲块。结果是在磁盘上来回访问逻辑上连续的文件，从而大大降低了性能。</p><h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><p>假设以下数据块区域包含4个文件（A、B、C和D），每个文件大小为两个块：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/u2.png" alt="?"><br>如果删除B和D，则生成的布局为：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/u3.png" alt="?"><br>如你所见，可用空间被分成两块构成的两大块，而不是很好的连续4块。假设我们现在希望分配一个大小为4块的文件E：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/u4.png" alt="?"></p><p>E分散在磁盘上，因此，在访问E时，无法从磁盘获得峰值（顺序）性能。你首先读取E1和E2，然后寻道，再读取E3和E4。这个碎片问题一直发生在老UNIX文件系统中，并且会影响性能。</p><blockquote><p>这个问题正是磁盘碎片整理工具要解决的。它们将重新组织磁盘数据以连续放置文件，并为让空闲空间成为一个或几个连续的区域，移动数据，然后重写inode等以反映变化。</p></blockquote><p>另一个问题：原始块大小太小（512字节）。因此，从磁盘传输数据本质上是低效的。较小的块是好的，因为它们最大限度地减少了内部碎片（internal fragmentation，块内的浪费），但是由于每个块可能需要一个定位开销来访问它，因此传输不佳。</p><h2 id="快速文件系统（Fast-File-System，FFS）：磁盘意识是解决方案"><a href="#快速文件系统（Fast-File-System，FFS）：磁盘意识是解决方案" class="headerlink" title="快速文件系统（Fast File System，FFS）：磁盘意识是解决方案"></a>快速文件系统（Fast File System，FFS）：磁盘意识是解决方案</h2><h2 id="组织结构：柱面组"><a href="#组织结构：柱面组" class="headerlink" title="组织结构：柱面组"></a>组织结构：柱面组</h2><p>第一步是更改磁盘上的结构。FFS将磁盘划分为一些分组，称为柱面组（cylinder group，而一些现代文件系统，如Linux ext2和ext3，就称它们为块组，即block group）。因此，我们可以想象一个具有10个柱面组的磁盘：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/u5.png" alt="?"><br>这些分组是FFS用于改善性能的核心机制。通过在同一组中放置两个文件，FFS可以确保先后访问两个文件不会导致穿越磁盘的长时间寻道。</p><p>因此，FFS需要能够在每个组中分配文件和目录。每个组看起来像这样：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/u6.png" alt="?"></p><p>出于可靠性原因，每个组中都有超级块（super block）的一个副本（例如，如果一个被损坏或划伤，你仍然可以通过使用其中一个副本来挂载和访问文件系统）。</p><p>在每个组中，我们需要记录该组的inode和数据块是否已分配。每组的inode位图（inode bitmap，ib）和数据位图（data bitmap，db）起到了这个作用，分别针对每组中的inode和数据块。位图是管理文件系统中可用空间的绝佳方法，因为很容易找到大块可用空间并将其分配给文件，这可能会避免旧文件系统中空闲列表的某些碎片问题。</p><p>最后，inode和数据块区域就像之前的极简文件系统一样。像往常一样，每个柱面组的大部分都包含数据块。</p><h2 id="策略：如何分配文件和目录"><a href="#策略：如何分配文件和目录" class="headerlink" title="策略：如何分配文件和目录"></a>策略：如何分配文件和目录</h2><p><strong>相关的东西放一起</strong></p><p>首先是目录的放置。FFS采用了一种简单的方法：找到分配数量少的柱面组（因为我们希望跨组平衡目录）和大量的自由inode（因为我们希望随后能够分配一堆文件），并将目录数据和inode放在该分组中。</p><p>对于文件，FFS做两件事。首先，它确保（在一般情况下）将文件的数据块分配到与其inode相同的组中，从而防止inode和数据之间的长时间寻道（如在老文件系统中）。其次，它将位于同一目录中的所有文件，放在它们所在目录的柱面组中。因此，如果用户创建了4个文件，/dir1/1.txt、/dir1/2.txt、/dir1/3.txt和/dir99/4.txt，FFS会尝试将前3个放在一起（同一组），与第四个远离（它在另外某个组中）。</p><h2 id="测量文件的局部性"><a href="#测量文件的局部性" class="headerlink" title="测量文件的局部性"></a>测量文件的局部性</h2><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/u7.png" alt="?"></p><h2 id="大文件例外"><a href="#大文件例外" class="headerlink" title="大文件例外"></a>大文件例外</h2><p>在FFS中，文件放置的一般策略有一个重要的例外，它出现在大文件中。如果没有不同的规则，大文件将填满它首先放入的块组（也可能填满其他组）。以这种方式填充块组是不符合需要的，因为它妨碍了随后的“相关”文件放置在该块组内，因此可能破坏文件访问的局部性。</p><p>因此，对于大文件，FFS执行以下操作。在将一定数量的块分配到第一个块组（例如，12个块，或inode中可用的直接指针的数量）之后，FFS将文件的下一个“大”块（即第一个间接块指向的那些部分）放在另一个块组中（可能因为它的利用率低而选择）。然后，文件的下一个块放在另一个不同的块组中，依此类推。</p><p>让我们看一些图片，更好地理解这个策略。如果没有大文件例外，单个大文件会将其所有块放入磁盘的一部分。我们使用一个包含10个块的文件的小例子，来直观地说明该行为。</p><p>FFS没有大文件例外时的图景：</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/i1.png" alt="?"><br>有了大文件例外，我们可能会看到像这样的情形，文件以大块的形式分布在磁盘上：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/i2.png" alt="?"></p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/i3.png" alt="?"></p><h2 id="关于-FFS-的其他几件事"><a href="#关于-FFS-的其他几件事" class="headerlink" title="关于 FFS 的其他几件事"></a>关于 FFS 的其他几件事</h2><p>当时许多文件大小为2KB左右，使用4KB块虽然有利于传输数据，但空间效率却不太好。因此，在典型的文件系统上，这种内部碎片（internal fragmentation）可能导致大约一半的磁盘浪费。</p><p>FFS设计人员采用很简单的解决方案解决了这个问题。他们决定引入子块（sub-block），这些子块有512字节，文件系统可以将它们分配给文件。因此，如果你创建了一个小文件（比如大小为1KB），它将占用两个子块，因此不会浪费整个4KB块。随着文件的增长，文件系统将继续为其分配512字节的子块，直到它达到完整的4KB数据。此时，FFS将找到一个4KB块，将子块复制到其中，并释放子块以备将来使用。</p><hr><h1 id="崩溃一致性：FSCK和日志"><a href="#崩溃一致性：FSCK和日志" class="headerlink" title="崩溃一致性：FSCK和日志"></a>崩溃一致性：FSCK和日志</h1><p>文件系统管理一组数据结构以实现预期的抽象：文件、目录，以及所有其他元数据，它们支持我们期望从文件系统获得的基本抽象。</p><p><strong>文件系统面临的一个主要挑战在于，如何在出现断电（power loss）或系统崩溃（system crash）的情况下，更新持久数据结构。</strong></p><h2 id="一个详细的例子"><a href="#一个详细的例子" class="headerlink" title="一个详细的例子"></a>一个详细的例子</h2><p>先看一个例子。我们需要一种工作负载（workload），它以某种方式更新磁盘结构。这里假设工作负载很简单：将单个数据块附加到原有文件。通过打开文件，调用lseek()将文件偏移量移动到文件末尾，然后在关闭文件之前，向文件发出单个4KB写入来完成追加。</p><p>假定磁盘上使用标准的简单文件系统结构，类似于之前看到的文件系统。这个小例子包括一个inode位图（inode bitmap，只有8位，每个inode一个），一个数据位图（data bitmap，也是8位，每个数据块一个），inode（总共8个，编号为0到7，分布在4个块上），以及数据块（总共8个，编号为0～7）。以下是该文件系统的示意图：</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/a1.png" alt="?"></p><p>查看图中的结构，可以看到分配了一个inode（inode号为2），它在inode位图中标记，单个分配的数据块（数据块4）也在数据中标记位图。inode表示为I [v1]，因为它是此inode的第一个版本。它将很快更新（由于上述工作负载）。</p><p>再来看看这个简化的inode。</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/a2.png" alt="?"><br>在这个简化的inode中，文件的大小为1（它有一个块位于其中），第一个直接指针指向块4（文件的第一个数据块，Da），并且所有其他3个直接指针都被设置为null（表示它们未被使用）。当然，真正的inode有更多的字段。</p><p>向文件追加内容时，要向它添加一个新数据块，因此必须更新3个磁盘上的结构：inode（必须指向新块，并且由于追加而具有更大的大小），新数据块Db和新版本的数据位图（称之为B[v2]）表示新数据块已被分配。</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/a3.png" alt="?"></p><p>更新的数据位图（B[v2]）现在看起来像这样：00001100。最后，有数据块（Db），它只是用户放入文件的内容。我们希望文件系统的最终磁盘映像如下所示：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/a4.png" alt="?"></p><p>要实现这种转变，文件系统必须对磁盘执行3次单独写入，分别针对inode（I[v2]），位图（B[v2]）和数据块（Db）。请注意，当用户发出write()系统调用时，这些写操作通常不会立即发生。脏的inode、位图和新数据先在内存（页面缓存，page cache，或缓冲区缓存，buffer  cache）中存在一段时间。然后，当文件系统最终决定将它们写入磁盘时（比如说5s或30s），文件系统将向磁盘发出必要的写入请求。遗憾的是，可能会发生崩溃，从而干扰磁盘的这些更新。特别是，如果这些写入中的一个或两个完成后发生崩溃，而不是全部 3个，则文件系统可能处于有趣的状态。</p><h3 id="崩溃场景"><a href="#崩溃场景" class="headerlink" title="崩溃场景"></a>崩溃场景</h3><ol><li><p>只将数据块（Db）写入磁盘。在这种情况下，数据在磁盘上，但是没有指向它的inode，也没有表示块已分配的位图。因此，就好像写入从未发生过一样。从文件系统崩溃一致性的角度来看，这种情况根本不是问题①。</p></li><li><p>只有更新的inode（I[v2]）写入了磁盘。在这种情况下，inode指向磁盘地址（5），其中Db即将写入，但Db尚未写入。因此，如果我们信任该指针，我们将从磁盘读取垃圾数据（磁盘地址5的旧内容）。</p></li></ol><p>遇到了一个新问题，我们将它称为文件系统不一致（file-system inconsistency）。磁盘上的位图告诉我们数据块5尚未分配，但是inode说它已经分配了。文件系统数据结构中的这种不同意见，是文件系统的数据结构不一致。要使用文件系统，我们必须以某种方式解决这个问题。</p><ol start="3"><li>只有更新后的位图（B  [v2]）写入了磁盘。在这种情况下，位图指示已分配块5，但没有指向它的inode。因此文件系统再次不一致。如果不解决，这种写入将导致空间泄露（space leak），因为文件系统永远不会使用块5。</li></ol><p>在这个向磁盘写入3次的尝试中，还有3种崩溃场景。在这些情况下，两次写入成功，最后一次失败。</p><ol><li><p>inode（I[v2]）和位图（B[v2]）写入了磁盘，但没有写入数据（Db）。在这种情况下，文件系统元数据是完全一致的：inode有一个指向块5的指针，位图指示5正在使用，因此从文件系统的元数据的角度来看，一切看起来都很正常。但是有一个问题：5中又是垃圾。</p></li><li><p>写入了inode（I[v2]）和数据块（Db），但没有写入位图（B[v2]）。在这种情况下，inode指向了磁盘上的正确数据，但同样在inode和位图（B1）的旧版本之间存在不一致。因此，我们在使用文件系统之前，又需要解决问题。</p></li><li><p>写入了位图（B[v2]）和数据块（Db），但没有写入inode（I[v2]）。在这种情况下，inode和数据位图之间再次存在不一致。但是，即使写入块并且位图指示其使用，我们也不知道它属于哪个文件，因为没有inode指向该块。</p></li></ol><h2 id="解决方案-1：文件系统检查程序"><a href="#解决方案-1：文件系统检查程序" class="headerlink" title="解决方案 1：文件系统检查程序"></a>解决方案 1：文件系统检查程序</h2><p>早期的文件系统采用了一种简单的方法来处理崩溃一致性。基本上，它们决定让不一致的事情发生，然后再修复它们（重启时）。这种偷懒方法的典型例子可以在一个工具中找到：fsck①。fsck是一个UNIX工具，用于查找这些不一致并修复它们[M86]。</p><p><strong>它在文件系统挂载并可用之前运行（fsck假定在运行时没有其他文件系统活动正在进行）。一旦完成，磁盘上的文件系统应该是一致的，因此可以让用户访问。</strong></p><ol><li><p>超级块：fsck首先检查超级块是否合理，主要是进行健全性检查，例如确保文件系统大小大于分配的块数。通常，这些健全性检查的目的是找到一个可疑的（冲突的）超级块。在这种情况下，系统（或管理员）可以决定使用超级块的备用副本。</p></li><li><p>空闲块：接下来，fsck扫描inode、间接块、双重间接块等，以了解当前在文件系统中分配的块。它利用这些知识生成正确版本的分配位图。因此，如果位图和inode之间存在任何不一致，则通过信任inode内的信息来解决它。对所有inode执行相同类型的检查，确保所有看起来像在用的inode，都在inode位图中有标记。</p></li><li><p>inode状态：检查每个inode是否存在损坏或其他问题。例如，fsck确保每个分配的inode具有有效的类型字段（即常规文件、目录、符号链接等）。如果inode字段存在问题，不易修复，则inode被认为是可疑的，并被fsck清除，inode位图相应地更新。</p></li><li><p>fsck还会验证每个已分配的inode的链接数。你可能还记得，链接计数表示包含此特定文件的引用（即链接）的不同目录的数量。为了验证链接计数，fsck从根目录开始扫描整个目录树，并为文件系统中的每个文件和目录构建自己的链接计数。如果新计算的计数与inode中找到的计数不匹配，则必须采取纠正措施，通常是修复inode中的计数。如果发现已分配的inode但没有目录引用它，则会将其移动到lost + found目录。</p></li><li><p>重复：fsck还检查重复指针，即两个不同的inode引用同一个块的情况。如果一个inode明显不好，可能会被清除。或者，可以复制指向的块，从而根据需要为每个inode提供其自己的副本。</p></li><li><p>坏块：在扫描所有指针列表时，还会检查坏块指针。如果指针显然指向超出其有效范围的某个指针，则该指针被认为是“坏的”，例如，它的地址指向大于分区大小的块。在这种情况下，fsck不能做任何太聪明的事情。它只是从inode或间接块中删除（清除）该指针</p></li><li><p>目录检查：fsck不了解用户文件的内容。但是，目录包含由文件系统本身创建的特定格式的信息。因此，fsck对每个目录的内容执行额外的完整性检查，确保“.”和“..”是前面的条目，目录条目中引用的每个inode都已分配，并确保整个层次结构中没有目录的引用超过一次。</p></li></ol><p><strong>fsck（和类似的方法）有一个更大的、也许更根本的问题：它们太慢了。对于非常大的磁盘卷，扫描整个磁盘，以查找所有已分配的块并读取整个目录树，可能需要几分钟或几小时。</strong></p><h2 id="解决方案-2：日志（或预写日志）"><a href="#解决方案-2：日志（或预写日志）" class="headerlink" title="解决方案 2：日志（或预写日志）"></a>解决方案 2：日志（或预写日志）</h2><p><strong>基本思路如下。更新磁盘时，在覆写结构之前，首先写下一点小注记（在磁盘上的其他地方，在一个众所周知的位置），描述你将要做的事情。写下这个注记就是“预写”部分，我们把它写入一个结构，并组织成“日志”。因此，就有了预写日志。</strong></p><p>通过将注释写入磁盘，可以保证在更新（覆写）正在更新的结构期间发生崩溃时，能够返回并查看你所做的注记，然后重试。因此，你会在崩溃后准确知道要修复的内容（以及如何修复它），而不必扫描整个磁盘。</p><p>现在将描述Linux ext3（一种流行的日志文件系统）如何将日志记录到文件系统中。大多数磁盘上的结构与Linux  ext2相同，例如，磁盘被分成块组，每个块组都有一个inode和数据位图以及inode和数据块。新的关键结构是日志本身，它占用分区内或其他设备上的少量空间。因此，ext2文件系统（没有日志）看起来像这样：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/s1.png" alt="?"></p><p>假设日志放在同一个文件系统映像中（虽然有时将它放在单独的设备上，或作为文件系统中的文件），带有日志的ext3文件系统如下所示：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/s2.png" alt="?"></p><h3 id="数据日志"><a href="#数据日志" class="headerlink" title="数据日志"></a>数据日志</h3><p>假设再次进行标准的更新，我们再次希望将inode（I[v2]）、位图（B[v2]）和数据块（Db）写入磁盘。在将它们写入最终磁盘位置之前，现在先将它们写入日志。这就是日志中的样子：</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/s3.png" alt="?"><br>事务开始（TxB）告诉我们有关此更新的信息，包括对文件系统即将进行的更新的相关信息（例如，块I[v2]、B[v2]和Db的最终地址），以及某种事务标识符（transaction identifier，TID）。中间的3个块只包含块本身的确切内容，这被称为物理日志（physical logging），因为我们将更新的确切物理内容放在日志中（另一种想法，逻辑日志（logical  logging），在日志中放置更紧凑的更新逻辑表示，例如，“这次更新希望将数据块Db追加到文件X”，这有点复杂，但可以节省日志中的空间，并可能提高性能）。最后一个块（TxE）是该事务结束的标记，也会包含TID。</p><p>一旦这个事务安全地存在于磁盘上，我们就可以覆写文件系统中的旧结构了。这个过程称为加检查点（checkpointing）。因此，为了对文件系统加检查点（checkpoint，即让它与日志中即将进行的更新一致），我们将I[v2]、B[v2]和Db写入其磁盘位置，如上所示。如果这些写入成功完成，我们已成功地为文件系统加上了检查点，基本上完成了。因此，我们的初始操作顺序如下。</p><ol><li><p>日志写入：将事务（包括事务开始块，所有即将写入的数据和元数据更新以及事务结束块）写入日志，等待这些写入完成。</p></li><li><p>加检查点：将待处理的元数据和数据更新写入文件系统中的最终位置。</p></li></ol><p>在我们的例子中，先将TxB、I[v2]、B[v2]、Db和TxE写入日志。这些写入完成后，我们将加检查点，将I[v2]、B[v2]和Db写入磁盘上的最终位置，完成更新。</p><p><strong>在写入日志期间发生崩溃时，事情变得有点棘手。</strong></p><p>为避免该问题，文件系统分两步发出事务写入。首先，它将除TxE块之外的所有块写入日志，同时发出这些写入。当这些写入完成时，日志将看起来像这样（假设又是文件追加的工作负载）：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/s4.png" alt="?"><br>当这些写入完成时，文件系统会发出TxE块的写入，从而使日志处于最终的安全状态：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/s5.png" alt="?"></p><p>此过程的一个重要方面是磁盘提供的原子性保证。事实证明，磁盘保证任何512字节写入都会发生或不发生（永远不会半写）。因此，为了确保TxE的写入是原子的，应该使它成为一个512字节的块。因此，我们当前更新文件系统的协议如下，3个阶段中的每一个都标上了名称。</p><ol><li>日志写入：将事务的内容（包括TxB、元数据和数据）写入日志，等待这些写入完成。</li><li>日志提交：将事务提交块（包括TxE）写入日志，等待写完成，事务被认为已提交（committed）。</li><li>加检查点：将更新内容（元数据和数据）写入其最终的磁盘位置。</li></ol><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>如果崩溃发生在事务被安全地写入日志之前（在上面的步骤2完成之前），那么我们的工作很简单：简单地跳过待执行的更新。如果在事务已提交到日志之后但在加检查点完成之前发生崩溃，则文件系统可以按如下方式恢复（recover）更新。系统引导时，文件系统恢复过程将扫描日志，并查找已提交到磁盘的事务。然后，这些事务被重放（replayed，按顺序），文件系统再次尝试将事务中的块写入它们最终的磁盘位置。</p><h3 id="批处理日志更新"><a href="#批处理日志更新" class="headerlink" title="批处理日志更新"></a>批处理日志更新</h3><p>为了解决这个问题，一些文件系统不会一次一个地向磁盘提交每个更新（例如，Linux ext3）。与此不同，可以将所有更新缓冲到全局事务中。在上面的示例中，当创建两个文件时，文件系统只将内存中的inode位图、文件的inode、目录数据和目录inode标记为脏，并将它们添加到块列表中，形成当前的事务。当最后应该将这些块写入磁盘时（例如，在超时5s之后），会提交包含上述所有更新的单个全局事务。因此，通过缓冲更新，文件系统在许多情况下可以避免对磁盘的过多的写入流量。</p><h3 id="使日志有限"><a href="#使日志有限" class="headerlink" title="使日志有限"></a>使日志有限</h3><p>日志的大小有限。如果不断向它添加事务（如下所示），它将很快填满。</p><p>日志越大，恢复时间越长，因为恢复过程必须重放日志中的所有事务（按顺序）才能恢复。第二个问题更重要：当日志已满（或接近满）时，不能向磁盘提交进一步的事务，从而使文件系统“不太有用”（即无用）。</p><p><strong>日志文件系统将日志视为循环数据结构，一遍又一遍地重复使用。</strong><br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/s6.png" alt="?"></p><p>1．日志写入：将事务的内容（包括TxB和更新内容）写入日志，等待这些写入完成。2．日志提交：将事务提交块（包括TxE）写入日志，等待写完成，事务被认为已提交（committed）。3．加检查点：将更新内容写入其最终的磁盘位置。4．释放：一段时间后，通过更新日志超级块，在日志中标记该事务为空闲。</p><blockquote><p>补充：优化日志写入<br>写入日志的效率特别低。也就是说，文件系统首先必须写出事务开始块和事务的内容。只有在这些写入完成后，文件系统才能将事务结束块发送到磁盘。</p></blockquote><blockquote><p>将事务写入日志时，在开始和结束块中包含日志内容的校验和。这样做可以使文件系统立即写入整个事务，而不会产生等待。如果在恢复期间，文件系统发现计算的校验和与事务中存储的校验和不匹配，则可以断定在写入事务期间发生了崩溃，从而丢弃了文件系统更新。因此，通过写入协议和恢复系统中的小调整，文件系统可以实现更快的通用情况性能。最重要的是，系统更可靠了，因为来自日志的任何读取现在都受到校验和的保护。</p></blockquote><h3 id="元数据日志"><a href="#元数据日志" class="headerlink" title="元数据日志"></a>元数据日志</h3><p>我们上面描述的日志模式通常称为数据日志（data journaling，如在Linux ext3中），因为它记录了所有用户数据（除了文件系统的元数据之外）。一种更简单（也更常见）的日志形式有时称为有序日志（ordered  journaling，或称为元数据日志，metadata  journaling）<strong>它几乎相同，只是用户数据没有写入日志。</strong></p><p>1．数据写入：将数据写入最终位置，等待完成（等待是可选的，详见下文）。<br>2．日志元数据写入：将开始块和元数据写入日志，等待写入完成。<br>3．日志提交：将事务提交块（包括TxE）写入日志，等待写完成，现在认为事务（包括数据）已提交（committed）。<br>4．加检查点元数据：将元数据更新的内容写入文件系统中的最终位置。<br>5．释放：稍后，在日志超级块中将事务标记为空闲。</p><h3 id="棘手的情况：块复用"><a href="#棘手的情况：块复用" class="headerlink" title="棘手的情况：块复用"></a>棘手的情况：块复用</h3><p>假设你有一个名为foo的目录。用户向foo添加一个条目（例如通过创建文件），因此foo的内容（因为目录被认为是元数据）被写入日志。假设foo目录数据的位置是块1000。因此日志包含如下内容：</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/d1.png" alt="?"><br>此时，用户删除目录中的所有内容以及目录本身，从而释放块1000以供复用。最后，用户创建了一个新文件（比如foobar），结果复用了过去属于foo的相同块（1000）。foobar的inode提交给磁盘，其数据也是如此。但是，请注意，因为正在使用元数据日志，所以只有foobar的inode被提交给日志，文件foobar中块1000中新写入的数据没有写入日志。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/d2.png" alt="?"></p><p>现在假设发生了崩溃，所有这些信息仍然在日志中。在重放期间，恢复过程简单地重放日志中的所有内容，包括在块1000中写入目录数据。因此，重放会用旧目录内容覆盖当前文件foobar的用户数据！</p><h3 id="总结日志：时间线"><a href="#总结日志：时间线" class="headerlink" title="总结日志：时间线"></a>总结日志：时间线</h3><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/d3.png" alt="?"><br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/d4.png" alt="?"></p><h1 id="日志结构文件系统"><a href="#日志结构文件系统" class="headerlink" title="日志结构文件系统"></a>日志结构文件系统</h1><p>LFS永远不会覆写现有数据，而是始终将段写入空闲位置。由于段很大，因此可以有效地使用磁盘，并且文件系统的性能接近其峰值。</p><h2 id="按顺序写入磁盘"><a href="#按顺序写入磁盘" class="headerlink" title="按顺序写入磁盘"></a>按顺序写入磁盘</h2><p>我们正在将数据块D写入文件。将数据块写入磁盘可能会导致以下磁盘布局，其中D写在磁盘地址A0：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z1.png" alt="?"><br>但是，当用户写入数据块时，不仅是数据被写入磁盘；还有其他需要更新的元数据（metadata）。在这个例子中，让我们将文件的inode（I）也写入磁盘，并将其指向数据块D。写入磁盘时，数据块和inode看起来像这样（注意inode看起来和数据块一样大，但通常情况并非如此。在大多数系统中，数据块大小为4KB，而inode小得多，大约128B）<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z2.png" alt="?"></p><h2 id="顺序而高效地写入"><a href="#顺序而高效地写入" class="headerlink" title="顺序而高效地写入"></a>顺序而高效地写入</h2><p>例如，假设我们在时间T向地址A写入一个块。然后等待一会儿，再向磁盘写入地址A+1（下一个块地址按顺序），但是在时间T+δ。遗憾的是，在第一次和第二次写入之间，磁盘已经旋转。</p><p><strong>实际上，你必须向驱动器发出大量连续写入（或一次大写入）才能获得良好的写入性能。</strong></p><p>为了达到这个目的，LFS使用了一种称为写入缓冲①（write buffering）的古老技术。在写入磁盘之前，LFS会跟踪内存中的更新。收到足够数量的更新时，会立即将它们写入磁盘，从而确保有效使用磁盘。</p><p>LFS一次写入的大块更新被称为段（segment）。</p><p>下面是一个例子，其中LFS将两组更新缓冲到一个小段中。实际段更大（几MB）。第一次更新是对文件j的4次块写入，第二次是添加到文件k的一个块。然后，LFS立即将整个七个块的段提交到磁盘。这些块的磁盘布局如下：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z3.png" alt="?"></p><h2 id="要缓冲多少"><a href="#要缓冲多少" class="headerlink" title="要缓冲多少"></a>要缓冲多少</h2><p>取决于磁盘本身，特别是与传输速率相比定位开销有多高。</p><h2 id="问题：查找-inode"><a href="#问题：查找-inode" class="headerlink" title="问题：查找 inode"></a>问题：查找 inode</h2><p><strong>老UNIX文件系统将所有inode保存在磁盘的固定位置。因此，给定一个inode号和起始地址，要查很特定的inode，只需将inode号乘以inode的大小，然后将其加上磁盘数组的起始地址，即可计算其确切的磁盘地址。给定一个inode号，基于数组的索引是快速而直接的。因为它们以数组形式组织，并放在磁盘的固定位置上。</strong></p><p>在FFS中查很给定inode号的inode仅稍微复杂一些，因为FFS将inode表拆分为块并在每个柱面组中放置一组inode。因此，必须知道每个inode块的大小和每个inode的起始地址。</p><p>我们已经设法将inode分散在整个磁盘上！更糟糕的是，我们永远不会覆盖，<strong>因此最新版本的inode（即我们想要的那个）会不断移动。</strong></p><h2 id="通过间接解决方案：inode-映射"><a href="#通过间接解决方案：inode-映射" class="headerlink" title="通过间接解决方案：inode 映射"></a>通过间接解决方案：inode 映射</h2><p>为了解决这个问题，LFS的设计者通过名为inode映射（inode map，imap）的数据结构，在inode号和inode之间引入了一个间接层（level of indirection）。imap是一个结构，它将inode号作为输入，并生成最新版本的inode的磁盘地址。因此，你可以想象它通常被实现为一个简单的数组，每个条目有4个字节（一个磁盘指针）。每次将inode写入磁盘时，imap都会使用其新位置进行更新。</p><p>LFS将inode映射的块放在它写入所有其他新信息的位置旁边。因此，当将数据块追加到文件k时，LFS实际上将新数据块，其inode和一段inode映射一起写入磁盘<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z4.png" alt="?"></p><p>在该图中，imap数组存储在标记为imap的块中，它告诉LFS，inode  k位于磁盘地址A1。接下来，这个inode告诉LFS它的数据块D在地址A0。</p><h2 id="检查点区域"><a href="#检查点区域" class="headerlink" title="检查点区域"></a>检查点区域</h2><p>LFS在磁盘上只有这样一个固定的位置，称为检查点区域（checkpoint  region，CR）。检查点区域包含指向最新的inode映射片段的指针（即地址），因此可以通过首先读取CR来很到inode映射片段。请注意，检查点区域仅定期更新（例如每30s左右），因此性能不会受到影响。因此，磁盘布局的整体结构包含一个检查点区域（指向内部映射的最新部分），每个inode映射块包含inode的地址，inode指向文件（和目录），就像典型的UNIX文件系统一样。</p><p><strong>inode映射在LFS中的意义是将文件或目录与其对应的inode号码进行关联，通过inode号码可以快速访问文件或目录的元数据信息，从而实现文件系统的高效管理和访问。</strong></p><p>下面的例子是检查点区域（注意它始终位于磁盘的开头，地址为0），以及单个imap块，inode和数据块。一个真正的文件系统当然会有一个更大的CR（事实上，它将有两个，我们稍后会理解），许多imap块，当然还有更多的inode、数据块等。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z5.png" alt="?"></p><h2 id="从磁盘读取文件：回顾"><a href="#从磁盘读取文件：回顾" class="headerlink" title="从磁盘读取文件：回顾"></a>从磁盘读取文件：回顾</h2><p>假设从内存中没有任何东西开始。我们必须读取的第一个磁盘数据结构是检查点区域。检查点区域包含指向整个inode映射的指针（磁盘地址），因此LFS读入整个inode映射并将其缓存在内存中。在此之后，当给定文件的inode号时，LFS只是在imap中查很inode号到inode磁盘地址的映射，并读入最新版本的inode。要从文件中读取块，此时，LFS完全按照典型的UNIX文件系统进行操作，方法是使用直接指针或间接指针或双重间接指针。在通常情况下，从磁盘读取文件时，LFS应执行与典型文件系统相同数量的I/O，整个imap被缓存，因此LFS在读取过程中所做的额外工作是在imap中查很inode的地址。</p><h2 id="目录如何"><a href="#目录如何" class="headerlink" title="目录如何"></a>目录如何</h2><p>目录结构与传统的UNIX文件系统基本相同，因为目录只是（名称，inode号）映射的集合。例如，在磁盘上创建文件时，LFS必须同时写入新的inode，一些数据，以及引用此文件的目录数据及其inode。请记住，LFS将在磁盘上按顺序写入（在缓冲更新一段时间后）。因此，在目录中创建文件foo，将导致磁盘上的以下新结构：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z6.png" alt="?"><br>inode映射的片段包含目录文件dir以及新创建的文件f的位置信息。因此，访问文件foo（具有inode号f）时，你先要查看inode映射（通常缓存在内存中），很到目录dir（A3）的inode的位置。然后读取目录的inode，它给你目录数据的位置（A2）。读取此数据块为你提供名称到inode号的映射（foo，k）。然后再次查阅inode映射，很到inode号k（A1）的位置，最后在地址A0处读取所需的数据块。</p><h2 id="一个新问题：垃圾收集"><a href="#一个新问题：垃圾收集" class="headerlink" title="一个新问题：垃圾收集"></a>一个新问题：垃圾收集</h2><p>LFS会在整个磁盘中分散旧版本的文件结构。我们（毫不客气地）将这些旧版本称为垃圾（garbage）。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z7.png" alt="?"><br>在图中，可以看到inode和数据块在磁盘上有两个版本，一个是旧的（左边那个），一个是当前的，因此是活的（live，右边那个）。对于覆盖数据块的简单行为，LFS必须持久许多新结构，从而在磁盘上留下上述块的旧版本。</p><p>另外举个例子，假设我们将一块添加到该原始文件k中。在这种情况下，会生成新版本的inode，但旧数据块仍由旧inode指向。因此，它仍然存在，并且与当前文件系统分离：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z8.png" alt="?"></p><p><strong>可以保留那些旧版本并允许用户恢复旧文件版本（例如，当他们意外覆盖或删除文件时，这样做可能非常方便）。这样的文件系统称为版本控制文件系统（versioning file system），因为它跟踪文件的不同版本。</strong></p><p>但是，LFS只保留文件的最新活版本。</p><p>LFS清理程序定期读入许多旧的（部分使用的）段，确定哪些块在这些段中存在，然后写出一组新的段，只包含其中活着的块，从而释放旧块用于写入。具体来说，我们预期清理程序读取M个现有段，将其内容打包（compact）到N个新段（其中N  &lt;  M），然后将N段写入磁盘的新位置。然后释放旧的M段，文件系统可以使用它们进行后续写入。</p><h2 id="确定块的死活"><a href="#确定块的死活" class="headerlink" title="确定块的死活"></a>确定块的死活</h2><p>对于每个数据块D，LFS包括其inode号（它属于哪个文件）及其偏移量（这是该文件的哪一块）。该信息记录在一个数据结构中，位于段头部，称为段摘要块（segment summary block）。</p><p>对于位于地址A的磁盘上的块D，查看段摘要块并很到其inode号N和偏移量T。接下来，查看imap以很到N所在的位置，并从磁盘读取N（可能它已经在内存中，这更好）。最后，利用偏移量T，查看inode（或某个间接块），看看inode认为此文件的第T个块在磁盘上的位置。如果它刚好指向磁盘地址A，则LFS可以断定块D是活的。如果它指向其他地方，LFS可以断定D未被使用（即它已经死了），因此知道不再需要该版本。</p><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z9.png" alt="?"></p><h2 id="策略问题：要清理哪些块，何时清理"><a href="#策略问题：要清理哪些块，何时清理" class="headerlink" title="策略问题：要清理哪些块，何时清理"></a>策略问题：要清理哪些块，何时清理</h2><h2 id="崩溃恢复和日志"><a href="#崩溃恢复和日志" class="headerlink" title="崩溃恢复和日志"></a>崩溃恢复和日志</h2><p>为了确保CR更新以原子方式发生，LFS实际上保留了两个CR，每个位于磁盘的一端，并交替写入它们。当使用最新的指向inode映射和其他信息的指针更新CR时，LFS还实现了一个谨慎的协议。具体来说，它首先写出一个头（带有时间戳），然后写出CR的主体，然后最后写出最后一部分（也带有时间戳）。如果系统在CR更新期间崩溃，LFS可以通过查看一对不一致的时间戳来检测到这一点。LFS将始终选择使用具有一致时间戳的最新CR，从而实现CR的一致更新。</p><p>我们现在关注第一种情况。由于LFS每隔30s左右写入一次CR，因此文件系统的最后一致快照可能很旧。因此，在重新启动时，LFS可以通过简单地读取检查点区域、它指向的imap片段以及后续文件和目录，从而轻松地恢复。但是，最后许多秒的更新将会丢失。</p><hr><h1 id="数据完整性和保护"><a href="#数据完整性和保护" class="headerlink" title="数据完整性和保护"></a>数据完整性和保护</h1><h2 id="磁盘故障模式"><a href="#磁盘故障模式" class="headerlink" title="磁盘故障模式"></a>磁盘故障模式</h2><p>在早期的RAID系统中，故障模型非常简单：要么整个磁盘都在工作，要么完全失败，而且检测到这种故障很简单。</p><p>具体来说，两种类型的单块故障是常见的，值得考虑：潜在扇区错误（Latent-Sector Errors，LSE）和块讹误（block corruption）</p><p>当磁盘扇区（或扇区组）以某种方式讹误时，会出现LSE。例如，如果磁头由于某种原因接触到表面（磁头碰撞，head crash，在正常操作期间不应发生的情况），则可能会讹误表面，使得数据位不可读。宇宙射线也会导致数据位翻转，使内容不正确。幸运的是，驱动器使用磁盘内纠错码（Error Correcting Code，ECC）来确定块中的磁盘位是否良好，并且在某些情况下，修复它们。如果它们不好，并且驱动器没有足够的信息来修复错误，则在发出请求读取它们时，磁盘会返回错误。</p><h2 id="处理潜在的扇区错误"><a href="#处理潜在的扇区错误" class="headerlink" title="处理潜在的扇区错误"></a>处理潜在的扇区错误</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="os" scheme="https://codecodegogogo.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>多线程,多进程,并发,并行,cpu</title>
    <link href="https://codecodegogogo.github.io/2023/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C-cpu/"/>
    <id>https://codecodegogogo.github.io/2023/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C-cpu/</id>
    <published>2023-07-05T06:22:24.000Z</published>
    <updated>2023-07-05T06:29:06.759Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>首先，要先了解几个概念：</p><p>1、进程是程序的一次执行。</p><p>2、进程是资源分配的基本单位（调度单位）。</p><p>3、一个进程可以包括多个线程。</p><p>4、在单CPU计算机中，有一个资源是无法被多个程序并行使用的：CPU。</p><p>5、操作系统调度器：拆分CPU为一段段时间的运行片，轮流分配给不同的程序。</p><p>6、操作系统内存管理模块：管理物理内存、虚拟内存相关的事务。　　</p><p><strong>由于CPU同时刻只能执行一个进程，如果我们不加以控制的话，一个进程可能使用CPU直到运行结束，于是出现了操作系统调度器，而进程也成为了调度单位。</strong> 进程的运行不仅仅需要CPU，还需要很多其他资源，如内存啊，显卡啊，GPS啊，磁盘啊等等，统称为程序的执行环境，也就是程序上下文。</p><p>在这里就出现了并发的概念，调度器切换CPU给不同进程使用的速度非常快，于是在使用者看来程序是在同时运行，<strong>这就是并发，而实际上CPU在同一时刻只在运行一个进程。</strong></p><h2 id="CPU进程无法同时刻共享，但是出现一定要共享CPU的需求呢？"><a href="#CPU进程无法同时刻共享，但是出现一定要共享CPU的需求呢？" class="headerlink" title="CPU进程无法同时刻共享，但是出现一定要共享CPU的需求呢？"></a>CPU进程无法同时刻共享，但是出现一定要共享CPU的需求呢？</h2><p>此时线程的概念就出现了。线程被包含在进程当中，进程的不同线程间共享CPU和程序上下文。（共享进程分配到的资源）</p><p><strong>单CPU进行进程调度的时候，</strong> 需要读取上下文+执行程序+保存上下文，即进程切换。如果这个CPU是单核的话，那么在进程中的不同线程为了使用CPU核心，则会进行线程切换，但是由于共享了程序执行环境，这个线程切换比进程切换开销少了很多。<strong>在这里依然是并发，唯一核心同时刻只能执行一个线程。</strong></p><p><strong>如果这个CPU是多核的话，那么进程中的不同线程可以使用不同核心，真正的并行出现了。</strong></p><p><strong>线程是CPU调度和分配的基本单位，进程是操作系统进行资源分配（包括cpu、内存、磁盘IO等）的最小单位。</strong></p><p>CPU只能看到线程</p><p>另外在有的操作系统里，进程不是调度单位，线程是最基本的调度单位，调度器只调度线程，不调度进程，如VxWorks。</p><p>总结：</p><p>1、单CPU中进程只能是并发，多CPU计算机中进程可以并行。</p><p>2、单CPU单核中线程只能并发，单CPU多核中线程可以并行。</p><p>3、无论是并发还是并行，使用者来看，看到的是多进程，多线程。</p><h2 id="CPU的几核几线程是什么意思？"><a href="#CPU的几核几线程是什么意思？" class="headerlink" title="CPU的几核几线程是什么意思？"></a>CPU的几核几线程是什么意思？</h2><p>“8核16线程”是指一款处理器的核心数和线程数配置。在这种情况下，该处理器有8个物理核心和16个逻辑线程。</p><p>具体解释如下：</p><p>核心数：指处理器内部的物理核心数量。每个物理核心都可以独立地执行指令和运算操作。<br>线程数：指处理器能够同时处理的线程数量。</p><p>逻辑线程是通过超线程（Hyper-Threading）技术实现的。在超线程中，每个物理核心被模拟成两个逻辑核心，使得处理器可以同时执行两个线程。</p><p>因此，对于一个有8核16线程的处理器，它具有8个物理核心和每个核心能够模拟出2个逻辑核心，总共能够同时处理16个线程。这样的配置可以提高处理器的并发性和多任务处理能力，增加系统的整体性能表现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="os" scheme="https://codecodegogogo.github.io/tags/os/"/>
    
  </entry>
  
</feed>
