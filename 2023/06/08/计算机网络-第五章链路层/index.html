<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>计算机网络-第五章链路层 | yong&#39;s Blog</title>
  <meta name="description" content="总述在链路层的讨论中，我们将看到两种截然不同类型的链路层信道。 第一种类型是广播信道，这种信道用于连接有线局域网、卫星网和混合光纤同轴电缆（Hybrid Fiber Coaxialcable, HFC）接入网中的多台主机。因为许多主机与相同的广播信道连接,需要所谓的媒体访问协议来协调帧传输。在某些场合中，可以使用中心控制器来协调传输。 第二种类型的链路层信道是点对点通信链路，这在诸如长距离链路连接">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络-第五章链路层">
<meta property="og:url" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/index.html">
<meta property="og:site_name" content="Sunny">
<meta property="og:description" content="总述在链路层的讨论中，我们将看到两种截然不同类型的链路层信道。 第一种类型是广播信道，这种信道用于连接有线局域网、卫星网和混合光纤同轴电缆（Hybrid Fiber Coaxialcable, HFC）接入网中的多台主机。因为许多主机与相同的广播信道连接,需要所谓的媒体访问协议来协调帧传输。在某些场合中，可以使用中心控制器来协调传输。 第二种类型的链路层信道是点对点通信链路，这在诸如长距离链路连接">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q1.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q2.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q3.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q4.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q5.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q6.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q7.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q8.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q9.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w1.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w2.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w3.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w4.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w5.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w6.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w7.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w8.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w9.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e1.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e2.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e3.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e4.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e5.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e6.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e8.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/r1.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/r1.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/r2.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w9.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t1.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t2.png">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t5.jpg">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t4.jpg">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t3.jpg">
<meta property="og:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t6.png">
<meta property="article:published_time" content="2023-06-08T02:22:08.000Z">
<meta property="article:modified_time" content="2023-06-12T06:18:20.030Z">
<meta property="article:author" content="Sunny">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q1.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Sunny" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/favicon.png" type="image/x-icon">
  
  <!-- <link rel="icon" href="/images/favicon.png" type="image/x-icon"> -->

  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="main-center theme-purple" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/codecodegogogo" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">yong</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a target="_blank" rel="noopener" href="https://github.com/codecodegogogo">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/codecodegogogo" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>今天网站换了个新皮肤~</p> <p align="right">2023.4.14</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/" rel="tag">code</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/os/" rel="tag">os</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%B0%88/" rel="tag">杂谈</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/" rel="tag">计算机工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/" rel="tag">计算机文化基础</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a><span class="tag-list-count">9</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-ppt/" class="title">计算机文化基础-ppt</a>
              </p>
              <p class="item-date">
                <time datetime="2024-06-10T03:33:43.000Z" itemprop="datePublished">2024-06-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/" class="title">计算机文化基础-excel</a>
              </p>
              <p class="item-date">
                <time datetime="2024-06-10T03:31:52.000Z" itemprop="datePublished">2024-06-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-word/" class="title">计算机文化基础-word</a>
              </p>
              <p class="item-date">
                <time datetime="2024-06-10T03:30:44.000Z" itemprop="datePublished">2024-06-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/" class="title">计算机文化基础-数据库</a>
              </p>
              <p class="item-date">
                <time datetime="2024-06-10T03:29:24.000Z" itemprop="datePublished">2024-06-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-ppt/" class="title">(no title)</a>
              </p>
              <p class="item-date">
                <time datetime="2024-06-10T02:05:08.833Z" itemprop="datePublished">2024-06-10</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">总述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">链路层概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.</span> <span class="toc-text">链路层提供的服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9C%A8%E4%BD%95%E5%A4%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">链路层在何处实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E7%89%B9%E7%BA%A7%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BA%A0%E6%AD%A3"><span class="toc-number">3.</span> <span class="toc-text">比特级差错检测和纠正</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="toc-number">3.1.</span> <span class="toc-text">奇偶校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E9%AA%8C%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">检验和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E6%B5%8B"><span class="toc-number">3.3.</span> <span class="toc-text">循环冗余检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE%E9%93%BE%E8%B7%AF%E5%92%8C%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.</span> <span class="toc-text">多路访问链路和协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE-multiple-access-protocol"><span class="toc-number">4.0.1.</span> <span class="toc-text">多路访问协议 (multiple access protocol)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.1.</span> <span class="toc-text">信道划分协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%8E%A5%E5%85%A5%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.2.</span> <span class="toc-text">随机接入协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%9A%99ALOHA"><span class="toc-number">4.2.1.</span> <span class="toc-text">时隙ALOHA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AFALOHA"><span class="toc-number">4.2.2.</span> <span class="toc-text">纯ALOHA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BD%E6%B3%A2%E4%BE%A6%E5%90%AC%E5%A4%9A%E8%B7%AF%E8%AE%BF%E9%97%AE-CSMA"><span class="toc-number">4.2.3.</span> <span class="toc-text">载波侦听多路访问(CSMA)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7min%E5%92%8Cmax"><span class="toc-number">4.2.4.</span> <span class="toc-text">以太网帧min和max</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E6%B5%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.3.</span> <span class="toc-text">轮流协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOCSIS-%E7%94%A8%E4%BA%8E%E7%94%B5%E7%BC%86%E5%9B%A0%E7%89%B9%E7%BD%91%E6%8E%A5%E5%85%A5%E7%9A%84%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.4.</span> <span class="toc-text">DOCSIS:用于电缆因特网接入的链路层协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">5.</span> <span class="toc-text">交换局域网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E5%AF%BB%E5%9D%80%E5%92%8CARP"><span class="toc-number">5.1.</span> <span class="toc-text">链路层寻址和ARP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MAC%E5%9C%B0%E5%9D%80"><span class="toc-number">5.1.1.</span> <span class="toc-text">MAC地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.1.2.</span> <span class="toc-text">地址解析协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%B0%E5%AD%90%E7%BD%91%E4%BB%A5%E5%A4%96"><span class="toc-number">5.1.3.</span> <span class="toc-text">发送数据报到子网以外</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">5.2.</span> <span class="toc-text">以太网</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.1.</span> <span class="toc-text">以太网帧结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%8A%80%E6%9C%AF"><span class="toc-number">5.2.2.</span> <span class="toc-text">以太网技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">5.3.</span> <span class="toc-text">链路层交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%BD%AC%E5%8F%91%E5%92%8C%E8%BF%87%E6%BB%A4"><span class="toc-number">5.3.1.</span> <span class="toc-text">交换机转发和过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AD%A6%E4%B9%A0"><span class="toc-number">5.3.2.</span> <span class="toc-text">自学习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">5.3.3.</span> <span class="toc-text">链路层交换机的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E6%AF%94%E8%BE%83"><span class="toc-number">5.3.4.</span> <span class="toc-text">交换机和路由器比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">5.4.</span> <span class="toc-text">虚拟局域网</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E8%99%9A%E6%8B%9F%E5%8C%96-%E7%BD%91%E7%BB%9C%E4%BD%9C%E4%B8%BA%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">6.</span> <span class="toc-text">链路虚拟化:网络作为链路层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%8D%8F%E8%AE%AE%E6%A0%87%E7%AD%BE%E4%BA%A4%E6%8D%A2"><span class="toc-number">6.1.</span> <span class="toc-text">多协议标签交换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E7%BD%91%E7%BB%9C"><span class="toc-number">7.</span> <span class="toc-text">数据中心网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">7.1.</span> <span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E7%BA%A7%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.</span> <span class="toc-text">等级体系结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE-Web%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8E%86%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">回顾:Web页面请求的历程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87-DHCP%E3%80%81UDP%E3%80%81IP%E5%92%8C%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">8.1.</span> <span class="toc-text">准备:DHCP、UDP、IP和以太网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8D%E5%9C%A8%E5%87%86%E5%A4%87-DNS-%E5%92%8C-ARP"><span class="toc-number">8.2.</span> <span class="toc-text">仍在准备:DNS 和 ARP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8D%E5%9C%A8%E5%87%86%E5%A4%87-%E5%9F%9F%E5%86%85%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%88%B0-DNS-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">8.3.</span> <span class="toc-text">仍在准备:域内路由选择到 DNS 服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%A4%E4%BA%92-TCP%E5%92%8C-HTTP"><span class="toc-number">8.4.</span> <span class="toc-text">Web 客户-服务器交互:TCP和 HTTP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">习题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-1"><span class="toc-number">10.</span> <span class="toc-text">习题</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-计算机网络-第五章链路层" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      计算机网络-第五章链路层
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/" class="article-date">
	  <time datetime="2023-06-08T02:22:08.000Z" itemprop="datePublished">2023-06-08</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 23.7k(字)</span>
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>在链路层的讨论中，我们将看到两种截然不同类型的链路层信道。</p>
<p>第一种类型是广播信道，这种信道用于连接有线局域网、卫星网和混合光纤同轴电缆（Hybrid Fiber Coaxialcable, HFC）接入网中的多台主机。因为许多主机与相同的广播信道连接,需要所谓的媒体访问协议来协调帧传输。在某些场合中，可以使用中心控制器来协调传输。</p>
<p>第二种类型的链路层信道是点对点通信链路，这在诸如长距离链路连接的两台路由器之间，或用户办公室计算机与它们所连接的邻近以太网交换机之间等场合经常能够发现。协调对点对点链路的访问较为简单;</p>
<h2 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h2><p>在本章中为方便讨论，将运行链路层协议(即第2层)协议的任何设备均称为结点 (node)。结点包括主机、路由器、交换机和 Wii接入点。我们也把沿着通信路径连接相邻结点的通信信道称为链路(link)。为了将一个数据报从源主机传输到目的主机，数据报必须通过沿端到端路径上的各段链路传输。</p>
<p>考虑从无线主机之一向服务器之一发送一个数据报。该数据报将实际通过6段链路:发送主机与WiFi接人点之间的Wifi链路，接入点和链路层交换机之间的以太网链路，链路层交换机与路由器之间的链路，两台路由器之间的链路，最后是交换机和服务器之间的以太网链路。在通过特定的链路时，传输结点将数据报封装在链路层帧中，并将该帧传送到链路中。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q1.png" alt="?"></p>
<h3 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h3><p>**成帧(raming)**。在每个网络层数据报经链路传送之前，几乎所有的链路层协议都要将其用链路层帧封装起来。一个帧由一个数据字段和若干首部字段组成，其中网络层数据报就插在数据字段中。帧的结构由链路层协议规定。</p>
<p><strong>链路接入</strong>。媒体访问控制(MediumAccessControl，MAC)协议规定了帧在链路上传输的规则。对于在链路的一端仅有一个发送方、链路的另一端仅有一个接收方的点对点链路，MAC协议比较简单(或者不存在)，即无论何时链路空闲，发送方都能够发送帧。更有趣的情况是当多个结点共享单个广播链路时，即所谓多路访问问题。这里，MAC协议用于协调多个结点的帧传输。</p>
<p><strong>可靠交付</strong>。当链路层协议提供可靠交付服务时，它保证无差错地经链路层移动每个网络层数据报。链路层的可靠交付服务通常是通过确认和重传取得的。链路层可靠交付服务通常用于易于产生高差错率的链路，例如无线链路，其目的是本地(也就是在差错发生的链路上)纠正一个差错，而不是通过运输层或应用层协议迫使进行端到端的数据重传。然而，对于低比特差错的链路包括光纤、同轴电缆和许多双绞铜线链路，链路层可靠交付可能会被认为是一种不必要的开销。由于这个原因，许多有线的链路层协议不提供可靠交付服务。</p>
<p><strong>差错检测和纠正</strong>。当帧中的一个比特作为1传输时，接收方结点中的链路层硬件可能不正确地将其判断为0，反之亦然。这种比特差错是由信号衰减和电磁噪声导致的。因为没有必要转发一个有差错的数据报，所以许多链路层协议提供一种机制来检测这样的比特差错。通过让发送结点在帧中包括差错检测比特，让接收结点进行差错检查，以此来完成这项工作。因特网的运输层和网络层也提供了有限形式的差错检测，即因特网检验和。链路层的差错检测通常更复杂并且用硬件实现。差错纠正类似于差错检测，区别在于接收方不仅能检测帧中出现的比特差错，而且能够准确地确定帧中的差错出现的位置(并因此纠正这些差错)。</p>
<h3 id="链路层在何处实现"><a href="#链路层在何处实现" class="headerlink" title="链路层在何处实现"></a>链路层在何处实现</h3><p>链路层的主体部分是在网络适配器(networkadapter)中实现的，网络适配器有时也称为网络接口卡(NetworkInterface Card，NIC)位于网络适配器核心的是链路层控制器，该控制器通常是一个实现了许多链路层服务(成帧、链路接人、差错检测等) 的专用芯片。因此，链路层控制器的许多功能是用硬件实现<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q2.png" alt="?"><br>图5-2显示了与主机总线(例如一条PCI或PCI-X总线)连接的网络适配器，这里它看起来非常像与其他主机组件连接的任何其他Io设备。图5-2还显示了尽管<strong>大部分链路层是在硬件中实现的，但部分链路层是在运行于主机CPU上的软件中实现的</strong>。链路层的软件组件实现了高层链路层功能，如组装链路层寻址信息和激活控制器硬件。在接收端，链路层软件响应控制器中断(例如，由于一个或多个帧的到达)，处理差错条件和将数据报向上传递给网络层。所以，<strong>链路层是硬件和软件的结合体</strong>，即此处是协议栈中软件与硬件交接的地方。</p>
<h2 id="比特级差错检测和纠正"><a href="#比特级差错检测和纠正" class="headerlink" title="比特级差错检测和纠正"></a>比特级差错检测和纠正</h2><p>在发送结点，为了保护比特免受差错，使用差错检测和纠正比特(Error-Detetion and-Corretion，EDC)来增强数据D。通常，<strong>要保护的数据不仅包括从网络层传递下来需要通过链路传输的数据报，而且包括链路帧首部中的链路级的寻址信息、序号和其他字段</strong>。链路级帧中的D和EDC都被发送到接收结点。在接收结点，接收到比特序列D1和EDC1。注意到因传输中的比特翻转所致，D1和EDC1可能与初始的D和EDC不同。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q3.png" alt="?"></p>
<p>差错检测和纠正技术使接收方有时但并总是检测出已经出现的比特差错。即使采用差错检测比特，也还是可能有未检出比特差错(undeteeted bit error);</p>
<h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>假设在图中要发送的信息D有d个比特。在偶校验方案中，发送方只需包含一个附加的比特，选择它的值，使得这 d+1个比特(初始信息加上一个校验比特)中1的总数是偶数。对于奇校验方案，选择校验比特值使得有奇数个1。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q4.png" alt="?"><br>采用单个奇偶校验位方式，如果在采用偶校验方案中发现了奇数个值为1的比特，接收方知道至少出现了一个比特差错。更精确的说法是，出现了奇数个比特差错。</p>
<p>图5-5显示了单比特奇偶校验方案的二维一般化方案。这里D中的d个比特被划分为i行j列。<strong>对每行和每列计算奇偶值。产生的i+j+1奇偶比特构成了链路层的差错检测比特</strong>。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q5.png" alt="?"><br>利用存在奇偶校验差错的列和行的索引来实际识别发生差错的比特并纠正它!</p>
<p>图5-5显示了一个例子，其中位于(2，2)的值为1的比特损坏了，变成了0，该差错就是一个在接收方可检测并可纠正的差错。尽管我们的讨论是针对初始d比特信息的，但校验比特本身的单个比特差错也是可检测和可纠正的。二维奇偶校验也能够检测(但不能纠正!)一个分组中两个比特差错的任何组合.</p>
<p>接收方检测和纠正差错的能力被称为前向纠错(Forward Error Correction，FEC)。这些技术通常用于如音频CD这样的音频存储和回放设备中。</p>
<h3 id="检验和方法"><a href="#检验和方法" class="headerlink" title="检验和方法"></a>检验和方法</h3><p>在检验和技术中，图5-4中的d比特数据被作为一个比特整数的序列处理。一个简单检验和方法就是将这比特整数加起来，并且用得到的和作为差错检测比特。因特网检验和(Internetchecksum)就基于这种方法，即数据的字节作为16比特的整数对待并求和，这个和的反码形成了携带在报文段首部的因特网检验和，并且检测其结果是否为全1比特来检测检验和。</p>
<p>检验和方法需要相对小的分组开销，与后面要讨论的常用于链路层的CRC相比，它们提供相对弱的差错保护。</p>
<p>为什么运输层使用检验和而链路层使用CRC呢?<br>前面讲过运输层通常是在主机中作为用户操作系统的一部分用软件实现的。因为运输层差错检测用软件实现，采用简单而快速如检验和这样的差错检测方案是重要的。在另一方面，链路层的差错检测在适配器中用专用的硬件实现，它能够快速执行更复杂的CRC操作。</p>
<h3 id="循环冗余检测"><a href="#循环冗余检测" class="headerlink" title="循环冗余检测"></a>循环冗余检测</h3><p>现今的计算机网络中广泛应用的差错检测技术基于循环余检测(Cyclic RedundancyCheck，CRC)编码。CRC编码也称为多项式编码(polynomialcode)，因为该编码能够将要发送的比特串看作为系数是0和1一个多项式，对比特串的操作被解释为多项式算术。</p>
<p>CRC编码操作如下。考虑d比特的数据D，发送结点要将它发送给接收结点。发送方和接收方首先必须协商一个r+1比特模式，称为生成多项式(generator)，我们将其表示为G。我们将要求G的最高有效位的比特(最边)是1。CRC编码的关键思想如图5-6所示。对于一个给定的数据段D，发送方要选择 个附加比特R并将它们附加到D上使得得到的d+r比特模式(被解释为一个二进制数)用模2算术恰好能被G整除即没有余数)。用CRC 进行差错检测的过程因此很简单:接收方用G去除接收到的d+r比特。如果余数为非零，接收方知道出现了差错;否则认为数据正确而被接收。</p>
<p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q6.png" alt="?"><br>所有CRC计算采用模2算术来做，在加法中不进位，在减法中不借位。<strong>这意味着加法和减法是相同的，而且这两种操作等价于操作数的按位异或(XOR)。</strong> 因此，举例来说<br>1011 XOR 0101=1110<br>1001 XOR 1101=0100<br>类似的，我们还会有:<br>1011-0101=1110<br>1001-1101=0100</p>
<p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q7.png" alt="?"><br>国际标准已经定义了8、12、16和32比特生成多项式G。CRC-3232比特的标准被多种链路级IEEE协议采用，使用的一个生成多项式是:<br>GcRc-32=100000100110000010001110110110111</p>
<h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><p>两种类型的网络链路:点对点链路和广播链路。<br>点对点链路(point-to-pointlik)由链路一端的单个发送方和链路另一端的单个接收方组成。许多链路层协议都是为点对点链路设计的，如点对点协议 (point-to-point protocol，PPP)和高级数据链路控制(high-level data link controlHDLC)就是两种这样的协议。</p>
<p>第二种类型的链路是广播链路(broadcast link)，它能够让多个发送和接收结点都连接到相同的、单一的、共享的广播信道上。这里使用术语“广播”是因为当任何一个结点传输一个帧时，信道广播该帧，每个其他结点都收到一个副本。以太网和无线局域网是广播链路层技术的例子。</p>
<h4 id="多路访问协议-multiple-access-protocol"><a href="#多路访问协议-multiple-access-protocol" class="headerlink" title="多路访问协议 (multiple access protocol)"></a>多路访问协议 (multiple access protocol)</h4><p>即结点通过这些协议来规范它们在共享的广播信道上的传输行为。如图5-8所示，在各种各样的网络环境下需要多路访问协议，包括有线和无线接人网，以及卫星网络。尽管从技术上讲每个结点通过它的适配器访问广播信道，但在本节中我们将把结点作为发送和接收设备。在实践中，数以百计或者甚至数以千计个结点能够通过一个广播信道直接通信。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q8.png" alt="?"></p>
<p>多个结点可能会同时传输帧。当发生这种情况时，所有结点同时接到多个帧;这就是说，传输的帧在所有的接收方处碰撞 (collide)了。通常，当碰撞发生时，没有一个接收结点能够有效地获得任何传输的帧;</p>
<p>我们能够将任何多路访问协议划分为3种类型之一:信道划分协议 (channel partitioning protocol)随机接入协议(randomaccess protocol)和轮流协议 (taking-turns protocol)。</p>
<h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><p>时分多路复用(TDM)和频分多路复用(FDM)是两种能够用于在所有共享信道结点之间划分广播信道带宽的技术。<br>举例来说，假设一个支持N个结点的信道且信道的传输速率为Rbps。TDM将时间划分为时间(timeframe)，并进一步划分每个时间帧为N个时隙 (slot)。(不应当把TDM时间与在发送和接收适配器之间交换的链路层数据单元相混淆，后者也被称为帧。为了减少混乱，在本小节中我们将链路层交换的数据单元称为分组。然后把每个时隙分配给N个结点中的一个。无论何时某个结点在有分组要发送的时候，它在循环的TDM 中指派给它的时隙内传输分组比特通常，选择的时隙长度应使一个时隙内能够传输单个分组。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q9.png" alt="?"></p>
<p>TDM每个结点在每个帧时间内得到了专用的传输速率R/N bps。然而它有两个主要缺陷。首先，结点被限制于R/Nbps的平均速率，即使当它是唯一有分组要发送的结点时。其次，结点必须总是等待它在传输序列中的轮次即我们再次看到，即使它是唯一一个有帧要发送的结点。</p>
<p>TDM在时间上共享广播信道，而FDM将Rbps信道划分为不同的频段(每个频段具有R/N带宽)，并把每个频率分配给N个结点中的一个。因此FDM在单个较大的Rbps信道中创建了N个较小的R/Nbps信道。FDM也有TDM同样的优点和缺点。它避免了碰撞在N个结点之间公平地划分了带宽。然而，FDM也有TDM所具有的主要缺点，也就是限制一个结点只能使用R/N的带宽，即使当它是唯一一个有分组要发送的结点时。</p>
<p>第三种信道划分协议是码分多址(Code Division Multiple Access，CDMA)。TDM和FDM分别为结点分配时隙和频率，而CDMA 对每个结点分配一种不同的编码。然后每个结点用它唯一的编码来对它发送的数据进行编码。如果精心选择这些编码，CDMA网络具有一种奇妙的特性，即不同的结点能够同时传输，并且它们各自相应的接收方仍能正确接收发送方编码的数据比特(假设接收方知道发送方的编码)，而不在乎其他结点的干扰传输。</p>
<p>CDMA已经在军用系统中使用了一段时间(由于它的抗干扰特性)，目前已经广泛地用于民用，尤其是蜂窝电话中。因为CDMA 的使用与无线信道紧密相关，此时，我们知道CDMA编码类似于TDM中的时隙和FDM中的频率，能分配给多路访问信道的用户就可以了。</p>
<h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><p>第二大类多访问协议是随机接入协议。<strong>在随机接入协议中，一个传输结点总是以信道的全部速率(即Rbps)进行发送。</strong> 当有碰撞时，涉及碰撞的每个结点反复地重发它的帧(也就是分组)，到该无碰撞地通过为止。但是当一个结点经历一次碰撞时，它不必立刻重发该帧。相反，它在重发该帧之前等待一个随机时延。涉及碰撞的每个结点独立地选择随机时延。因为该随机时延是独立地选择的，所以下述现象是有可能的:这些结点之一所选择的时延充分小于其他碰撞结点的时延，并因此能够无碰撞地将它的帧在信道中发出。</p>
<h4 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h4><p>当结点有一个新帧要发送时，它等到下一个时隙开始并在该时隙传输整个帧。</p>
<p>如果没有碰撞，该结点成功地传输它的帧，从而不需要考虑重传该帧。(如果该结点有新帧，它能够为传输准备一个新帧。)</p>
<p>如果有碰撞，该结点在时隙结束之前检测到这次碰撞。该结点以概率p在后续的每个时隙中重传它的帧，直到该帧被无碰撞地传输出去。</p>
<p>时隙ALOHA看起来有很多优点。与信道划分不同，当某结点是唯一活跃的结点时(一个结点如果有顿要发送就认为它是活跃的)，时隙ALOHA允许该结点以全速R连续传输。时隙ALOHA也是高度分散的，因为每个结点检测碰撞并独立地决定什么时候重传。</p>
<p>当有多个活跃结点时，一部分时隙将有碰撞，因此将被“浪费”掉了。第二个考虑是，时隙的另一部分将是空闲的，因为所有活跃结点由于概率传输策略会节制传输。唯一“未浪费的”时隙是那些刚好有一个结点传输的时隙。刚好有一个结点传输的时院称为一个成功时隙(successful slot）<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w1.png" alt="?"></p>
<h4 id="纯ALOHA"><a href="#纯ALOHA" class="headerlink" title="纯ALOHA"></a>纯ALOHA</h4><p>时隙ALOHA协议要求所有的结点同步它们的传输，以在每个时隙开始时开始传输。第1个ALOHA协议实际上是一个非时隙、完全分散的协议。在纯ALOHA中，当一帧首次到达(即一个网络层数据报在发送结点从网络层传递下来)，结点立刻将该帧完整地传输进广播信道。如果一个传输的帧与一个或多个传输经历了碰撞，这个结点将立即(在完全传输完它的碰撞帧之后) 以概率p重传该。否则，该结点等待一个顿传输时间在此等待之后，它则以概率p传输该，或者以概率1-p在另一个时间等待(保持空闲)。</p>
<blockquote>
<p>纯ALOHA是一种简单的多点接入协议，它允许所有的节点在任何时间发送数据帧。当一个节点发送完一个数据帧后，它需要等待一段时间来检查是否有其他节点同时发送，如果有冲突，则需要等待一段时间后重新发送。</p>
<p>时隙ALOHA是一种改进的多点接入协议，它将时间分割成若干个时隙，每个时隙只允许一个节点发送数据帧。节点需要等待下一个时隙才能发送数据帧，这样就避免了冲突的发生。时隙ALOHA的效率比纯ALOHA高，但是需要更多的控制开销来分配时隙。</p>
</blockquote>
<h4 id="载波侦听多路访问-CSMA"><a href="#载波侦听多路访问-CSMA" class="headerlink" title="载波侦听多路访问(CSMA)"></a>载波侦听多路访问(CSMA)</h4><p>在时隙和纯ALOHA中，一个结点传输的决定独立于连接到这个广播信道上的其他结点的活动。特别是，一个结点不关心在它开始传输时是否有其他结点碰巧在传输，而且即使有另一个结点开始干扰它的传输也不会停止传输。</p>
<p>说话之前先听。如果其他人正在说话，等到他们说完话为止。在网络领域中，这被称为载波侦听(carrier sensing)，即一个结点在传输前先听信道。如果来自另一个结点的帧正向信道上发送，结点则等待直到检测到一小段时间没有传输，然后开始传输。</p>
<p>如果与他人同时开始说话，停止说话。在网络领域中，这被称为碰撞检测 (collisiondetection)，即当一个传输结点在传输时一直在侦听此信道。如果它检测到另个结点正在传输干扰帧，它就停止传输，在重复“侦听-当空闲时传输”循环之前等待一段随机时间。</p>
<p>这两个规则包含在载波侦听多路访问(Carrier Sense MultipleAccess，CSMA)和具有碰撞检测的CSMA(CSMA with Collision Detection，CSMA/CD)协议族中</p>
<p>关于CSMA你可能要问的第一个问题是，如果所有的结点都进行载波侦听了，为什么当初会发生碰撞?毕竟，某结点无论何时侦听到另一个结点在传输，它都会停止传输。</p>
<p>在时刻t0，结点 B侦听到信道是空闲的，因为当前没有其他结点在传输。因此结点B开始传输，沿着广播媒体在两个方向上传播它的比特。图5-12中B的比特随着时间的增加向下传播，这表明B的比特沿着广播媒体传播所实际需要的时间不是零(虽然以接近光的速度)。在时刻t1，结点D有一个要发送。尽管结点B在时刻正在传输但B传输的比特还没有到达D，因此D在侦听到信道空闲。根据CSMA协议，从而D开始传输它的顿。一个短暂的时间之后，B的传输开始在D干扰D的传输。从图5-12中可以看出，显然广播信道的端到端信道传播时延(channel propagation delay)(信号从一个结点传播到另一个结点所花费的时间)在决定其性能方面起着关键的作用。该传播时延越长，载波侦听结点不能侦听到网络中另一个结点已经开始传输的机会就越大。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w2.png" alt="?"></p>
<p>在图5-12中，结点没有进行碰撞检测;即使已经出现了碰撞，B和D都将继续完整地传输它们的帧。当某结点执行碰撞检测时，一旦它检测到碰撞将立即停止传输。图5-13表示了和图5-12相同的情况，只是这两个结点在检测到碰撞后很短的时间内都放弃了它们的传输。显然，在多路访问协议中加人碰撞检测，通过不传输一个无用的、(由来自另一个结点的顿干扰)损坏的帧，将有助于改善协议的性能。</p>
<p><strong>CSMA/CD运行</strong><br>1)适配器从网络层一条获得数据报，准备链路层帧，并将其放入顿适配器缓存中。<br>2)如果适配器侦听到信道空闲(即无信号能量从信道进入适配器)，它开始传输帧在另一方面，如果适配器侦听到信道正在忙，它将等待，直到侦听到没有信号能量时才开始传输帧。<br>3)在传输过程中，适配器监视来自其他使用该广播信道的适配器的信号能量的存在。<br>4)如果适配器传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了该帧。在另一方面，如果适配器在传输时检测到来自其他适配器的信号能量，它中止传输(即它停止了传输帧)。<br>5)中止传输后，适配器等待一个随机时间量，然后返回步骤2。</p>
<p>用于以太网以及DOCSIS电缆网络多路访问协议中的<strong>二进制指数后退(binaryexponentialbackoff)算法</strong>，简练地解决了这个等待时间量。</p>
<p>特别是，当传输一个给定，2”-1 中选择帧时，在该帧经历了一连串的n次碰撞后，结点随机地从0，1，2，··一个K值。因此，一个帧经历的碰撞越多，K选择的间隔越大。对于以太网，一个结点等待的实际时间量是k·512比特时间(即发送512比特进入以太网所需时间量的K倍)，n能够取的最大值在10以内。</p>
<blockquote>
<p>我们看一个例子。假设一个适配器首次尝试传输一个帧，并在传输中它检测到碰撞然后该结点以概率0.5选择K=0，以概率05选择K=1。如果该结点选择K=0，则它立即开始侦听信道。如果这个适配器选择K=1，它在开始“侦听-当空闲时传输”。周期前等待512比特时间(例如对于100Mbps 以太网来说为5.12微秒)。在第2次碰撞之后，从10,1，2,3 中等概率地选择K。在第3 次碰撞之后，从 0,1，2，3，4，5，6，7中等概率地选择K。在10次或更多次碰撞之后，从 0，1，2，··，1023中等概率地选择K。因此从中选择K的集合长度随着碰撞次数呈指数增长;正是由于这个原因，该算法被称为二进制指数后退。</p>
</blockquote>
<p>为了给出效率的一个闭式的近似表示，令dpp表示信号能量在任意两个适配器之间传播所需的最大时间。令dn表示传输一个最大长度的以太网的时间(对于10Mbps的以太网，该时间近似为12毫秒)。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w3.png" alt="?"></p>
<p>从这个公式我们看到，当d-接近0时，效率接近1。这和我们的直觉相符，如果传播时延是0，碰撞的结点将立即中止而不会浪费信道。同时，当dmn变得很大时，效率也接近于1。这也和直觉相符，因为当一个帧取得了信道时，它将占有信道很长时间;因此信道在大多数时间都会有效地工作。</p>
<h4 id="以太网帧min和max"><a href="#以太网帧min和max" class="headerlink" title="以太网帧min和max"></a>以太网帧min和max</h4><p><strong>以太网数据帧的长度在 64-1518 字节之间。. 数据部分在46~1500 B之间。<br>10Mbps以太网一帧的最小发送时间为51.2微秒。 这段时间所能传输的数据为512位，因此也称该时间为512位时。 这个时间定义为以太网时隙，或冲突时槽。 512位=64字节，这就是以太网帧最小64字节的原因。<br>最小帧的定义是在不包括任何额外头部或尾部的情况下的帧长度，因此在计算最小帧的长度时，不考虑VLAN标记。</strong></p>
<h3 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h3><p>多路访问协议的两个理想特性是:<br>当只有一个结点活跃时，该活跃结点具有Rbps的吞吐量;<br>当有M个结点活跃时，每个活跃结点的吞吐量接近R/Mbps。<br>ALOHA和CSMA 协议具备第一个特性，但不具备第二个特性。</p>
<p>第一种是轮询协议(pollingprotocol)。轮询协议要求这些结点之一要被指定为主结点。主结点以循环的方式轮询(poll)每个结点。特别是，主结点首先向结点1发送一个报文，告诉它(结点1)能够传输的帧的最多数量。在结点1传输了某些帧后，主结点告诉结点2它(结点2) 能够传输的帧的最多数量。(主结点能够通过观察在信道上是否缺乏信号，来决定一个结点何时完成了帧的发送。)上述过程以这种方式继续进行，主结点以循环的方式轮询了每个结点。轮询协议消除了困扰随机接入协议的碰撞和空时隙，这使得轮询取得高得多的效率但是它也有一些缺点。第一个缺点是该协议引人了轮询时延，即通知一个结点“它可以传输”所需的时间。例如，如果只有一个结点是活跃的，那么这个结点将以小于 Rbps 的速率传输，因为每次活跃结点发送了它最多数量的帧时，主结点必须依次轮询每一个非活跃的结点。第二个缺点可能更为严重，就是如果主结点有故障，整个信道都变得不可操作。</p>
<p>第二种轮流协议是令牌传递协议 (token-passing protocol)。在这种协议中没有主结点。一个称为令牌(token)的小的特殊在结点之间以某种固定的次序进行交换。例如，结点1可能总是把令牌发送给结点2，结点2可能总是把令牌发送给结点3，而结点N可能总是把令牌发送给结点1。当一个结点收到令牌时，仅当它有一些帧要发送时，它才持有这个令牌;否则，它立即向下一个结点转发该令牌。当一个结点收到令牌时，如果它确实有帧要传输，它发送最大数目的帧数，然后把令牌转发给下一个结点。令牌传递是分散的，并有很高的效率。但是它也有自己的一些问题。例如，一个结点的故障可能会使整个信道崩溃。或者如果一个结点偶然忘记了释放令牌，则必须调用某些恢复步骤使令牌返回到循环中来。</p>
<h3 id="DOCSIS-用于电缆因特网接入的链路层协议"><a href="#DOCSIS-用于电缆因特网接入的链路层协议" class="headerlink" title="DOCSIS:用于电缆因特网接入的链路层协议"></a>DOCSIS:用于电缆因特网接入的链路层协议</h3><p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w4.png" alt="?"></p>
<h2 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h2><p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w5.png" alt="?"></p>
<h3 id="链路层寻址和ARP"><a href="#链路层寻址和ARP" class="headerlink" title="链路层寻址和ARP"></a>链路层寻址和ARP</h3><p>主机和路由器具有链路层地址和网络层地址。<br>地址解析协议 (ARP)，该协议提供了将IP地址转换为链路层地址的机制。</p>
<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>链路层地址有各种不同的称呼:LAN地址(LANaddress)、物理地址(physicaladdress)或MAC地址(MACaddress)。我们此后就将链路层地址称为MAC地址。对于大多数局域网(包括以太网和802.11 无线局域网)而言，MAC地址长度为6字节，共有2^48个可能的MAC地址。如图5-16所示，这些6个字节地址通常用十六进制表示法，地址的每个字节被表示为一对十六进制数。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w6.png" alt="?"><br>链路层交换机的作用是在主机和路由器之间传输数据包，而不是像路由器一样需要对数据包进行转发决策。因此，交换机不需要与它们连接的主机或路由器相关联的链路层地址。交换机会透明地执行它的任务</p>
<p>尽管MAC地址被设计为永久的，但用软件改变一块适配器的 MAC 地址现在是可能的。然而对于本节的后面部分而言，我们将假设某适配器的MAC地址是固定的</p>
<p>IEEE在管理着该MAC地址空间。特别是，当一个公司要生产适配器时，它支付象征性的费用购买组成224个地址的一块地址空间。IEEE分配这块248个地址的方式是:固定一个MAC地址的前24比特，让公司自己为每个适配器生成后24比特的唯一组合。</p>
<p>IP 地址具有层次结构 (即一个网络部分和一个主机部分),而且当主机移动时，主机的IP地址需要改变，即改变它所连接到的网络。适配器的 MAC地址与人的社会保险号相似，后者也具有扁平寻址结构，而且无论人到哪里该号码都不会变化。</p>
<p>当某适配器要向某些目的适配器发送一个帧时，发送适配器将目的适配器的 MAC地址插入到该帧中，并将该帧发送到局域网上。如我们马上要看到的那样，一台交换机偶尔将一个人帧广播到它的所有接口。802.11 也广播。因此一块适配器可以接收一个并非向它寻址的帧。这样，当适配器接收到一个帧时，将检查该帧中的目的MAC地址是否与它自己的MAC地址匹配。如果匹配，该适配器提取出封装的数据报，并将该数据报沿协议栈向上传递。如果不匹配，该适配器丢弃该帧，而不会向上传递该网络层数据报。所以，仅当收到该帧时，才会中断目的地。<br>然而，有时某发送适配器的确要让局域网上所有其他适配器来接收并处理它打算发送的帧。在这种情况下，发送适配器在该帧的目的地址字段中插入一个特殊的MAC广播地址(broadcastaddress)。对于使用6字节地址的局域网(例如以太网和80211)来说，广播地址是48个连续的1组成的字符串(即以十六进制表示法表示的FF-FF-FF-FF-FF-FF).</p>
<h4 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h4><p>因为存在网络层地址(例如，因特网的IP地址)和链路层地址(即MAC地址)，所以需要在它们之间进行转换。对于因特网而言，这是地址解析协议(Address Resolution Protocol，ARP)的任务。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w7.png" alt="?"></p>
<p>现在假设IP地址为222222.222220的主机要向主机222222222222发送P数据报。在本例中，源和目的均位于相同的子网中。为了发送数据报，该源必须要向它的适配器不仅提供iP数据报，而且要提供目的主机222222.222222的MAC地址。然后发送适配器将构造一个包含目的地的 MAC地址的链路层，并把该帧发送进局域网</p>
<p>发送主机如何确定iP地址为222.222.222222的目的主机的MAC地址呢?</p>
<p>在发送主机中的ARP模块将取在相同局域网上的任何IP 地址作为输入，然后返回相应的 MAC地址。在眼下的这个例子中，发送主机222.222222220向它的ARP模块提供了地址222222222222并且其ARP模块返回了相应的MAC地址49-BD-D2-C7-56-2A。</p>
<p><strong>DNS为在因特网中任何地方的主机解析主机名，而ARP只为在同一个子网上的主机和路由器接口解析IP地址。</strong></p>
<p>每台主机或路由器在其内存中具有一个ARP表(ARP table)，该ARP表也包含一个寿命(TTL)值，它指示了从表中删除每个映射的时间。注意到这张表不必为该子网上的每台主机和路由器都包含一个表项:某些可能从来没有进人到该表中，某些可能已经过期。从一个表项放置到某ARP表中开始，个表项通常的过期时间是20分钟。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w8.png" alt="?"><br>现在假设主机222.222.222.220要发送一个数据报，该数据报要IP寻址到本子网上另一台主机或路由器。发送主机需要获得给定IP地址的目的主机的MAC地址。如果发送方的ARP表具有该目的结点的表项，很容易。</p>
<p>但如果ARP 表中当前没有该目的主机的表项，又该怎么办呢?</p>
<p>在这种情况下，发送方用ARP 协议来解析这个地址。首先，发送方构造一个称为ARP分组(ARPpacket)的特殊分组。一个ARP分组有几个字段，包括发送和接收IP地址及MAC地址。ARP查询分组和响应分组都具有相同的格式。ARP查询分组的目的是询问子网上所有其他主机和路由器，以确定对应于要解析的iP地址的那个MAC 地址。<br>222.222.222.220向它的适配器传递一个ARP查询分组，并且指示适配器应该用MAC广播地址(即FF-FF-FF-FF-FF-FF)来发送这个分组。适配器在链路层帧中封装这个 ARP分组，用广播地址作为的目的地址，并将该传输进子网中,包含该ARP查询的能被子网上的所有其他适配器接收到，并且(由于广播地址) 每个适配器都把在该中的ARP分组向上传递给ARP模块。这些ARP模块中的每个都检查它的iP地址是否与ARP分组中的目的iP地址相匹配。匹配的一个给查询主机发送回一个响应ARP分组。然后查询主机222.222222220能够更新它的ARP表，并发送它的IP数据报.</p>
<p>首先，查询ARP报文是在广播中发送的，而响应ARP报文在一个标准顿中发送。其次，ARP是即插即用的，这就是说，一个ARP 表是自动建立的，即它不需要系统管理员来配置。并且如果某主机与子网断开连接，它的表项最终会从留在子网中的结点的表中删除掉。</p>
<p>所以，可能最好把ARP看成是跨越链路层和网络层边界两边的协议</p>
<h4 id="发送数据报到子网以外"><a href="#发送数据报到子网以外" class="headerlink" title="发送数据报到子网以外"></a>发送数据报到子网以外</h4><p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w9.png" alt="?"></p>
<p>每台主机仅有一个iP地址和一个适配器。<br>一台路由器对它的每个接口都有一个IP 地址。对路由器的每个接口，(在路由器中)也有一个ARP模块和一个适配器。<br>网络中的每个适配器都有自已的MAC地址。</p>
<p>我们发现为了使一个数据报从111.111.111.111到子网2上的主机，该数据报必须首先发送给路由器接口111.111.111.110.它是通往最终目的地路径上的第一跳路由器的IP地址。因此，对于该来说，适当的MAC地址是路由器接口111.111.111.110的适配器地址E6-E9-00-17-BB-4B。</p>
<p>但发送主机怎样获得111.111.111.110的MAC地址呢?<br>当然是通过使用ARP!一旦发送适配器有了这个MAC地址，它创建一个帧(包含了寻址到222.222.222.222的数据报)，并把该发送到子网1中。在子网1上的路由器适配器看到该链路层帧是向它寻址的，因此把这个帧传递给路由器的网络层。该IP数据报终于被成功地从源主机移动到这台路由器了!</p>
<p>但是我们的任务还没有结束。我们仍然要将该数据报从路由器移动到目的地。路由器现在必须决定该数据报要被转发的正确接口。这是通过查询路由器中的转发表来完成的。转发表告诉这台路由器该数据报要通过路由器接口222.222.222220转发。然后该接口把这个数据报传递给它的适配器，适配器把该数据报封装到一个新的帧中，并且将帧发送进子网2中。这时，该帧的目的 MAC 地址确实是最终目的地 MAC 地址。路由器又是怎样获得这个目的地MAC地址的呢?当然是用ARP获得的!</p>
<h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>集线器(hub)是一种物理层设备，它作用于各个比特而不是作用于帧。当表示一个0或一个1的比特到达一个接口时，集线器只是重新生成这个比特，将其能量强度放大，并将该比特向其他所有接口传输出去。因此，采用基于集线器的星形拓扑的以太网也是一个广播局域网，即无论何时集线器从它的一个接口接收到一个比特，它向其所有其他接口发送该比特的副本。特别是，如果某集线器同时从两个不同的接口接收到帧，将出现一次碰撞，生成该帧的结点必须重新传输该帧。</p>
<p>在21世纪早期，以太网又经历了一次重要的革命性变化。以太网安装继续使用星形拓扑，但是位于中心的集线器被交换机(swith)所替代。眼下我们仅知道交换机不仅是“无碰撞的”，而且也是名副其实的存储转发分组交换机就可以了;但是与运行在高至第3 层的路由器不同，交换机仅运行在第2层。</p>
<h4 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h4><p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e1.png" alt="?"></p>
<p>考虑从一台主机向另一台主机发送一个iP数据报，且这两台主机在相同的以太局域网上,设发送适配器(即适配器A)的MAC 地址是AA-AA-AA-AA-AA-AA，接收适配器(即适配器B)的MAC地址是BB-BB-BB-BB-BB-BB。发送适配器在一个以太网中封装了一个iP数据报，并把该顿传递到物理层。接收适配器从物理层收到这个帧，提取出IP数据报，并将该IP数据报传递给网络层。</p>
<p>**数据字段(46~1500字节)**。这个字段承载了IP数据报。以太网的最大传输单元(MTU)是1500字节。这意味着如果IP数据报超过了1500字节，则主机必须将该数据报分片，如4.41节所讨论。数据字段的最小长度是46 字节。这意味着如果IP数据报小于46字节，数据报必须被填充到46字节。当采用填充时，传递到网络层的数据包括IP数据报和填充部分。网络层使用IP数据报首部中的长度字段来去除填充部分。<br>**目的地址(6字节)**。这个字段包含目的适配器的MAC地址，即BB-BB-BB-BB-BB-BB。当适配器B收到一个以太网顿，的目的地址无论是BB-BB-BB-BB-BBBB，还是MAC广播地址，它都将该的数据字段的内容传递给网络层:如果它收到了具有任何其他MAC地址的帧，则丢弃之。<br>**源地址(6字节)**。这个字段包含了传输该帧到局域网上的适配器的 MAC地址在本例中为AA-AAAA-AA-AA-AA。<br>**类型字段(2字节)**。类型字段允许以太网复用多种网络层协议。为了理解这点我们需要记住主机能够使用除了iP以外的其他网络层协议。此外，ARP协议有自己的类型编号，并且如果到达的帧包含 ARP分组(即类型字段的值为十六进制的0806)，则该ARP分组将被多路分解给ARP协议。注意到该类型字段和网络层数据报中的协议字段、运输层报文段的端口号字段相类似;所有这些字段都是为了把一层中的某协议与上一层的某协议结合起来。<br>**CRC(4字节)**。如5.23节中讨论的那样，CRC(循环余检测)字段的目的是使得接收适配器(适配器B)检测帧中是否引人了差错<br>**前同步码(8字节)**。以太网以一个8字节的前同步码(Preamble)字段开始。该前同步码的前7字节的值都是10101010:最后一个字节是10101011。前同步码字段的前7字节用于“唤醒”接收适配器，并且将它们的时钟和发送方的时钟同步。为什么这些时钟会不同步呢?记住适配器A的目的是根据以太局域网类型的不同，分别以10Mbps、100Mbps或者1Gbps的速率传输顿。然而，没有什么是完美无缺的，因此适配器A不会以精确的额定速率传输帧;相对于额定速率总有一些漂移，局域网上的其他适配器不会预先知道这种漂移的。接收适配器只需通过锁定前同步码的前7字节的比特，就能够锁定适配器A的时钟。前同步码的第8个字节的最后两个比特(第一个出现的两个连续的1)警告适配器B，“重要的内容就要到来了”</p>
<p>所有的以太网技术都向网络层提供无连接服务。这就是说，当适配器A要向适配器B发送一个数据报时，适配器 A在一个以太网中封装该数据报，并且把该帧发送到局域网上，没有先与适配器B握手。这种第二层的无连接服务类似于P的第三层数据报服务和UDP的第4层无连接服务。</p>
<p>以太网技术都向网络层提供不可靠服务(unreliable service)。特别是，当适配器B收到一个来自适配器A的顿，它对该执行 CRC校验，但是当该通过 CRC校验时它既不发送确认帧;而当该帧没有通过 CRC 校验时它也不发送否定确认顿。当某顿没有通过CRC校验，适配器B只是丢弃该。因此，适配器A根本不知道它传输的是否到达了B并通过了 CRC校验。(在链路层) 缺乏可靠的传输有助于使得以网简单和便宜。但是它也意味着传递到网络层的数据报流能够有间隙。</p>
<p>如果由于丢弃了以太网帧而存在间隙，主机B上的应用也会看见这个间隙吗?</p>
<p>这只取决于该应用是使用UDP 还是使用TCP。如果应用使用的是UDP，则主机B中的应用的确会看到数据中的间隙。另一方面，如果应用使用的是 TCP则主机B中的TCP将不会确认包含在丢弃中的数据，从而引起主机A的TCP重传。注意到当TCP重传数据时，数据最终将回到曾经丢弃它的以太网适配器。因此，从这种意义上来说，以太网的确重传了数据，尽管以太网并不知道它是正在传输一个具有全新数据的全新数据报，还是一个包含已经被传输过至少一次的数据的数据报。</p>
<h4 id="以太网技术"><a href="#以太网技术" class="headerlink" title="以太网技术"></a>以太网技术</h4><p>在总线拓扑和基于集线器的星形拓扑技术时代，以太网很显然是一种广播链路，其中多个结点同时传输时会出现帧碰撞。为了处理这些碰撞，以太网标准包括了CSMA/CD协议，该协议对于跨越一个小的地理半径的有线广播局域网特别有效。但是对于今天广为使用的以太网是基于交换机的星形拓扑，采用的是存储转发分组交换，是否还真正需要一种以太网MAC协议呢?如我们很快所见，交换机协调其传输，在任何时候决不会向相同的接口转发超过一个帧。此外，现代交换机是全双工的，这使得一台交换机和一个结点能够在同时向对方发送帧而没有干扰。换句话说，在基于交换机的以太局域网中，不会有碰撞，因此没有必要使用MAC协议了!</p>
<h3 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h3><p>交换机的任务是接收入链路层帧并将它们转发到出链路;我们将看到交换机自身对子网中的主机和路由器是透明的(transparent);这就是说，某主机/路由器向另一个主机/路由器寻址一个帧(而不是向交换机寻址该)，顺利地将该帧发送进局域网，并不知道某交换机将会接收该帧并将它转发到另一个结点。这些帧到达该交换机的任何输出接口之一的速率可能暂时会超过该接口的链路容量。为了解决这个问题，交换机输出接口设有缓存，这非常类似于路由器接口为数据报设有缓存。现在我们来仔细考察交换机运行的原理。</p>
<h4 id="交换机转发和过滤"><a href="#交换机转发和过滤" class="headerlink" title="交换机转发和过滤"></a>交换机转发和过滤</h4><p>过滤(fltering)是决定一个应该转发到某个接口还是应当将其丢弃的交换机功能转发(forwarding)是决定一个帧应该被导向哪个接口，并把该移动到那些接口的交换机功能。交换机的过滤和转发借助于交换机表(switeh table)完成。该交换机表包含某局域网上某些主机和路由器的但不必是全部的表项。交换机表中的一个表项包含:1一个MAC地址;2通向该MAC地址的交换机接口:3表项放置在表中的时间。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e2.png" alt="?"><br>为了理解交换机过滤和转发的工作过程，假定目的地址为DD-DD-DDDD-DD-DD的帧从交换机接口x到达。交换机用MAC地址DD-DD-DD-DD-DD-DD索引它的表。有3种可能的情况:</p>
<p>表中没有对于DD-DD-DD-DD-DD-DD的表项。在这种情况下，交换机向除接口x外的所有接口前面的输出缓存转发该帧的副本。换言之，如果没有对于目的地址的表项，交换机广播该帧。</p>
<p>表中有一个表项将DD-DD-DD-DD-DD-DD与接口x联系起来。在这种情况下，该帧从包括适配器DD-DD-DD-DD-DD-DD的局域网网段到来。无需将该转发到任何其他接口，交换机通过丢弃该帧执行过滤功能即可。</p>
<p>表中有一个表项将DD-DD-DD-DD-DD-DD与接口y联系起来。在这种情况下该帧需要被转发到与接口y相连的局域网网段。交换机通过将该顿放到接口y前面的输出缓存完成转发功能。</p>
<p>假设目的地址为62-FE-F7-11-89-A3的一个从接口1到达该交换机。交换机检查它的表并且发现其目的地是在与接口1相连的局域网网段上(即电子工程系的局域网)。这意味着该帧已经在包含目的地的局域网网段广播过了。因此该交换机过滤(即丢弃)了该帧。现在假设有同样目的地址的帧从接口2到达。交换机再次检查它的表并且发现其目的地址在接口1的方向上;因此它向接口1前面的输出缓存转发该。这个例子清楚地表明，只要交换机的表是完整和准确的，该交换机无需任何广播就向着目的地转发帧。</p>
<h4 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h4><p>1)交换机表初始为空。<br>2)对于在每个接口接收到的每个入帧，该交换机在其表中存储:D在该源地址字段中的MAC 地址;@该到达的接口，3当前时间。交换机以这种方式在它的表中记录了发送结点所在的局域网网段。如果在局域网上的每个结点最终都发送了一个帧，则每个结点最终将在这张表中留有记录。<br>3)如果在一段时间(称为老化期(aging time))后，交换机没有接收到以该地址作为源地址的帧，就在表中删除这个地址。以这种方式，如果一台PC 被另一台 PC(具有不同的适配器)代替，原来PC的MAC地址将最终从该交换机表中被清除掉。</p>
<h4 id="链路层交换机的性质"><a href="#链路层交换机的性质" class="headerlink" title="链路层交换机的性质"></a>链路层交换机的性质</h4><p>消除碰撞。在使用交换机(不使用集线器)构建的局域网中，没有因碰撞而浪费的带宽!交换机缓存顿并且决不会在网段上同时传输多于一个。就像使用路由器一样，交换机的最大聚合带宽是该交换机所有接口速率之和。因此，交换机提供了比使用广播链路的局域网高得多的性能改善。</p>
<p>异质的链路。交换机将链路彼此隔离，因此局域网中的不同链路能够以不同的速率运行并且能够在不同的媒体上运行。例如，图5-22 中最上面的交换机有3条1Gbps 1000BASE-T铜缆链路、2条100Mbps 10BASE-FX光缆链路和1条100BASE-T铜缆链路。因此，对于原有的设备与新设备混用，交换机是理想的。</p>
<p>管理。除了提供强化的安全性(参见插入材料“关注安全性”)，交换机也易于进行网络管理。例如，如果一个适配器工作异常并持续发送以太网帧(称为快而含糊的(jabbering)适配器)，交换机能够检测到该问题，并在内部断开异常适配器。有了这种特色，网络管理员不用起床并开车到工作场所去解决这个问题。类似地，一条割断的缆线仅使得使用该条缆线连接到交换机的主机断开连接。在使用同轴电缆的时代，许多网络管理员花费几个小时“沿线巡检”(或者更准确地说“在天花板上爬行”)，以找到使整个网络瘫痪的电缆断开之处。如在第9章(网络管理)中讨论的那样，交换机也收集带宽使用的统计数据、碰撞率和流量类型，并使这此信息为网络管理者使用。这些信息能够用于调试和解决问题，并规划该局域网在未来应当演化的方式。</p>
<h4 id="交换机和路由器比较"><a href="#交换机和路由器比较" class="headerlink" title="交换机和路由器比较"></a>交换机和路由器比较</h4><p>即使交换机和路由器从根本上是不同的，网络管理员在安装互联设备时也经常必须在它们之间进行选择。例如，对于图5-15 中的网络，网络管理员本来可以很容易地使用路由器而不是交换机来互联各个系的局域网、服务器和互联网网关路由器。路由器的确使得各系之间通信而不产生碰撞。</p>
<p>既然交换机和路由器都是候选的互联设备，那么这两种方式的优点和缺点各是什么呢?</p>
<p>首先考虑交换机的优点和缺点。如上面提到的那样，交换机是即插即用的、这是世界上所有超负荷工作的网络管理员都喜爱的特性。交换机还能够具有相对高的分组过滤和转发速率，就像图5-24中所示的那样，交换机必须处理高至第二层的顿，而路由器必须处理高至第三层的数据报。在另一方面，为了防止广播帧的循环，交换网络的活跃拓扑限制为一棵生成树。另外，一个大型交换网络将要求在主机和路由器中有大的ARP 表，这将生成可观的ARP流量和处理量。而且，交换机对于广播风暴并不提供任何保护措施，即如果某主机出了故障并传输出没完没了的以太网广播帧流，该交换机将转发所有这些帧.使得整个以太网的崩溃。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e3.png" alt="?"></p>
<p>现在考虑路由器的优点和缺点。因为网络寻址通常是分层次的(不像MAC寻址那样是扁平的)，即使当网络中存在冗余路径时，分组通常也不会通过路由器循环。(然而，当路由器表被误配置时，分组可能循环，但是如我们在第4 章所知，IP 用一个特殊的报文首部字段来限制循环。)所以，分组就不会被限制到一棵生成树上，并可以使用源和目的地之间的最佳路径。因为路由器没有生成树限制，所以它们允许以丰富的拓扑结构构建因特网，例如包括欧洲和北美之间的多条活跃链路。路由器的另一个特色是它们对第二层的广播风暴提供了防火墙保护。尽管也许路由器最重要的缺点就是它们不是即插即用的，即路由器和连接到它们的主机都需要人为地配置IP 地址。而且路由器对每个分组的处理时间通常比交换机更长，因为它们必须处理高达第三层的字段。</p>
<p>通常，由几百台主机组成的小网络通常有几个局域网网段。对于这些小网络，交换机就足够了，因为它们不要求P 地址的任何配置就能使流量局部化并增加总计吞吐量。但是在由几千台主机组成的更大网络中，通常在网络中(除了交换机之外)还包括路由器。路由器提供了更健壮的流量隔离方式和对广播风暴的控制，并在网络的主机之间使用更“智能的”路由。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e4.png" alt="?"></p>
<h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><p>虚拟局域网(Virtula Local NetworkVLAN)顾名思义，支持 VLAN的交换机允许经一个单一的物理局域网基础设施定义多个虚拟局域网。在一个VLAN内的主机彼此通信，仿佛它们(并且没有其他主机)与交换机连接。在一个基于端口的VLAN中，交换机的端口(接口)由网络管理员划分为组。每个组构成一个VLAN，在每个VLAN中的端口形成一个广播域(即来自一个端口的广播流量仅能到达该组中的其他端口)。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e5.png" alt="?"><br>交换机端口8的用户加人计算机科学系时，网络操作员只需重新配置VLAN软件，使得端口8与CSVLAN相关联即可。<br>网络管理员使用交换机管理软件声明一个端口属于某个给定的VLAN(其中未声明的端口属于一个默认的VLAN)，在交换机中维护一张端口到VLAN的映射表;交换机软件仅在属于相同VLAN的端口之间交付帧。<br>但完全隔离两个 VLAN带来了新的困难!来自电子工程系的流量怎样才能发送到计算机科学系呢?解决这个问题的一种方式是将VLAN交换机的一个端口(例如在图5-25中的端口1)与一台外部的路由器相连，并且将该端口配置为属于EE VLAN和CSVLAN。</p>
<p>跨越物理建立vlan<br>一种容易的解决方案是在每台交换机上定义一个属于CS VALN的端口(对EEVLAN也类似处理)，并且如图5-26a 所示将这两个端口彼此互联起来。然而，这种解决方案不具有扩展性，因为在每台交换机上N个VLAN将要求N个端口直接互联这两台交换机。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e6.png" alt="?"><br>-种更具扩展性互联VLAN交换机的方法称为VLAN干线连接(VLANtruking)。在图5-26b所示的VLAN千线方法中，每台交换机上的一个特殊端口(左侧交换机上的端口16，右侧交换机上的端口1)被配置为干线端口，以互联这两台 VLAN交换机。该干线端口属于所有VLAN，发送到任何 VLAN的经过干线链路转发到其他交换机。</p>
<p>但这会引起另外的问题:一个交换机怎样知道到达干线端口的顿属于某个特定的VLAN呢?</p>
<p>IEEE定义了一种扩展的以太网帧格式–802.10，用于跨越VLAN干线的。如图5-27中所示80210由标准以太网顿与加进首部的4字节VLAN标签(VLANtag)组成，而VLAN标签承载着该顿所属的VLAN标识符。VLAN标签由在VLAN千线发送侧的交换机加进顿中，解析后并由在VLAN干线接收侧的交换机删除。VLAN标签自身由一个2字节的标签协议标识符(Tag ProtocolIdentifier，TPID)字段(具有固定的十六进制值81-00)、一个2字节的标签控制信息字段(包含一个12比特的VLAN标识符字段)和一个3比特优先权字段(具有类似于P数据报TOS字段的目的)组成</p>
<h2 id="链路虚拟化-网络作为链路层"><a href="#链路虚拟化-网络作为链路层" class="headerlink" title="链路虚拟化:网络作为链路层"></a>链路虚拟化:网络作为链路层</h2><h3 id="多协议标签交换"><a href="#多协议标签交换" class="headerlink" title="多协议标签交换"></a>多协议标签交换</h3><p>通过采用虚电路网络领域的一个关键概念一,固定长度标签，多协议标签交换 (Mul.tiprotocolLabelSwitching，MPLS)以改善iP路由器的转发速度。其目标是:对于基于固定长度标签和虚电路的技术在不放弃基于目的地IP数据报转发的基础设施的前提下，当可能时通过选择性地标识数据报并允许路由器基于固定长度的标签(而不是目的地P地址)转发数据报来增强其功能重要的是，这些技术与iP协同工作，使用iP寻址和路由选择。</p>
<p>首先考虑由MPLS使能的路由器处理的链路层格式，以此开始学习MPLS。该帧具有一个小的MPLS首部该首部增加到第二层(如以太网)首部和第三层(即IP)首部之间。RFC 3032定义了用于这种链路的MPLS首部的格式;用于ATM和中继网络的首部也定义在其他的RFC文档中。包括在MPLS首部中的字段是:标签(它起着虚电路标识符的作用，我们已经在4.2.1节中讨论过该标识符);3比特的实验字段(保留用于实验);单比特S字段用于指示一系列“成栈”的MPLS首部的结束(我们这里不讨论这个高级主题):以及寿命字段。</p>
<p>一个MPLS加强的顿仅能在两个均为MPLS使能的路由器之间发送。(因为一个非MPLS使能的路由器，当它在期望发现iP首部的地方发现了一个MPLS首部时会相当混淆!)一个MPLS使能的路由器常被称为标签交换路由器(label-switchedrouter)，因为它通过在其转发表中查找MPLS标签，然后立即将数据报传递给适当的输出接口来转发MPLS。因此，MPLS使能的路由器不需要提取目的IP地址和在转发表中执行最长前缀匹配的查找。</p>
<p>但是路由器怎样才能知道它的邻居是否的确是MPLS使能的呢?路由器如何知道哪个标签与给定iP目的地相联系呢?</p>
<p>在图5-29所示的例子中，路由器R1到R4都是MPLS使能的，R5和R6是标准的P路由器。R1向R2和R3通告了它(R1)能够路由到目的地A，并且具有MPLS标签6的接收将要转发到目的地A。路由器 R3已经向路由器 B4通告了它能够路由到目的地A和D分别具有MPLS标签10和12的人将朝着这些目的地交换。路由器R2也向路由器B4通告了它(R2)能够到达目的地A，具有MPLS标签8的接收将朝着A交换。注意到路由器R4现在处于一个到达A且有两个MPLS路径的令人感兴趣的位置上，经接口0具有出MPLS标签10经接口1具有出MPLS标签8。在图5-29中画出的外围部分是IP设备R5R6A和D，它们经过一个MPLS基础设施(MPLS使能路由器R1R2R3和R4)连接在一起这与一个交换局域网或ATM 网络能够将P设备连接到一起的方式十分相似。并且与交换局域网或ATM网络相似，MPLS使能路由器R1到R4完成这些工作时从没有接触分组的IP首部。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e8.png" alt="?"></p>
<p>MPIS基于标签执行交换，而不必考虑分组的iP地址。然而MPLS 的真正优点和当前对MPIS感兴趣的原因并不在于交换速度的潜在增加，而在于MPLS使能的新的流量管理能力。</p>
<h2 id="数据中心网络"><a href="#数据中心网络" class="headerlink" title="数据中心网络"></a>数据中心网络</h2><p>主机就像是数据中心的工蜂:它们负责提供内容 (例如，网页和视频)，存储邮件和文档，并共同执行大规模分布式计算(例如，为搜索引擎提供分布式索引计算)。数据中心中的主机称为刀片(blade),一般是包括CPU、内存和磁盘存储的商用主机。主机被堆叠在机架上，每个机架一般堆放20~40台刀片。在每一个机架顶部有一台交换机，这台交换机被形象地称为机架顶部 (Top of Rack，TOR) 交换机，它们与机架上的主机互联，并与数据中心中的其他交换机互联。具体来说，机架上的每台主机都有一块与TOR交换机连接的网卡，每台TOR交换机有额外的端口能够与其他TOR交换机连接。尽管目前主机通常有1Gbps 的以太网与其TOR交换机连接，但10Cbps 的连接也许成为标准。每台主机也会分配一个自己的数据中心内部的P地址。</p>
<p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/r1.png" alt="?"></p>
<p>数据中心网络支持两种类型的流量:在外部客户与内部主机之间流动的流量，以及内部主机之间流动的流量。为了处理外部客户与内部主机之间流动的流量，数据中心网络包括了一台或者多台边界路由器(border router)，它们将数据中心网络与公共因特网相连。数据中心网络因此需要将所有机架彼此互联，并将机架与边界路由器连接。图5-30显示了一个数据(datacenternetworkdesign)是互联网络和协议设计的中心网络的例子。数据中心网络设计艺术，该艺术专注于机架彼此连接和与边界路由器相连。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>一个云数据中心，如一个谷歌或者微软的数据中心，能够同时提供诸如搜索、电子邮件和视频应用等许多应用。为了支持来自外部客户的请求，每一个应用都与一个公开可见的IP 地址关联，外部用户向该地址发送其请求并从该地址接收响应。在数据中心内部外部请求首先被定向到一个负载均器 (load balancer)。负载均衡器的任务是向主机分发请求，以主机当前的负载作为函数来在主机之间均衡负载。一个大型的数据中心通常会有几台负载均衡器，每台服务于一组特定的云应用。由于负载均衡器基于分组的目的端口号(第4层)以及目的P地址做决策，因此它们常被称为“第4层交换机”。一旦接收到一个对于特定应用程序的请求，负载均衡器将该请求分发到处理该应用的某一台主机上(该主机可能再调用其他主机的服务来协助处理该请求)。当主机处理完该请求后，向负载均衡器回送响应，再由负载均衡器将其中继发回给外部客户。负载均衡器不仅平衡主机间的工作负载，而且还提供类似NAT的功能，将外部P 地址转换为内部适当主机的IP 地址然后将反方向流向客户的分组按照相反的转换进行处理。这防止客户直接接触主机，从而具有隐藏网络内部结构和防止客户直接与主机交互等安全性益处。</p>
<h3 id="等级体系结构"><a href="#等级体系结构" class="headerlink" title="等级体系结构"></a>等级体系结构</h3><p>对于仅有数千台主机的小型数据中心，一个简单的网络也许就足够了。这种简单网络由一台边界路由器、一台负载均衡器和几十个机架组成，这些机架由单一以太网交换机进行互联。但是当主机规模扩展到几万至几十万的时候，数据中心通常应用路由器和交换机等级结构(hierarchyofrouterandswiteh)</p>
<p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/r1.png" alt="?"></p>
<h2 id="回顾-Web页面请求的历程"><a href="#回顾-Web页面请求的历程" class="headerlink" title="回顾:Web页面请求的历程"></a>回顾:Web页面请求的历程</h2><p>图5-32图示了我们的场景:一名学生 Bob 将他的便携机与学校的以太网交换机相连，下载一个Web页面(比如说<a target="_blank" rel="noopener" href="http://www.googlecom/">www.googlecom</a> 主页)。<br>我们假定Bob启动他的便携机，然后将其用一根以太网电缆连接到学校的以太网交换机，交换机又与学校的路由器相连，学校的这台路由器与一个ISP连接,本例中ISP为comcast. net。在本例中，comcast.net为学校提供了DNS服务;所以，DNS服务器驻留在Comcast网络中而不是学校网络中。我们将假设 DHCP服务器运行在路由器中,就像常见情况那样。</p>
<p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/r2.png" alt="?"></p>
<h3 id="准备-DHCP、UDP、IP和以太网"><a href="#准备-DHCP、UDP、IP和以太网" class="headerlink" title="准备:DHCP、UDP、IP和以太网"></a>准备:DHCP、UDP、IP和以太网</h3><p>当Bob首先将其便携机与网络连接时，没有IP地址他就不能做任何事情（例如下载一个Web网页)。所以，Bob的便携机所采取的一个网络相关的动作是运行DHCP协议,以从本地DHCP 服务器获得一个iP地址以及其他信息。</p>
<ol>
<li>Bob便携机上的操作系统生成一个 DHCP请求报文，并将这个报文放<br>人具有目的地端口67(DHCP服务器）和源端口68（DHCP客户）的UDP 报文段,该UDP报文段则被放置在一个具有广播IP目的地地址（255.255. 255.255）和源IP地址0.0.0.0的P数据报中，因为Bob的便携机还不具有一个IP地址。</li>
<li>包含DHCP请求报文的iP数据报则被放置在以太网帧中。该以太网帧具有目的MAC地址FF:FF:FF:FF:FF:FF，使该帧将广播到与交换机连接的所有设备(如果顺利的话也包括 DHCP服务器);该帧的源MAC地址是 Bob便携机的MAC地址00:16: D3: 23:68:8A。</li>
<li>包含 DHCP请求的广播以太网帧是第一个由Bob便携机发送到以太网交换机的帧。该交换机在所有的出端口广播入帧，包括连接到路由器的端口。</li>
<li>路由器在它的具有MAC地址00:22:6B:45:1F的接口接收到该广播以太网帧，该帧中包含 DHCP请求，并且从该以太网帧中抽取出iP数据报。该数据报的广播IP目的地址指示了这个IP数据报应当由在该结点的高层协议处理,因此该数据报的载荷被分解向上到达 UDP,DHCP请求报文从此UDP报文段中抽取出来。此时DHCP服务器有了DHCP请求报文。</li>
<li>我们假设运行在路由器中的 DHCP服务器能够以 CIDR块68.85.2.0/24分配iP地址。所以本例中，在学校内使用的所有iP地址都在Comcast 的地址块中。我们假设DHCP服务器分配地址68.85.2.101给 Bob的便携机。DHCP服务器生成包含这个IP地址以及 DNS服务器的IP地址（68.87.71. 226)、默认网关路由器的IP地址（68.85.2.1）和子网块（68.85.2.0/24)(等价为“网络掩码”）的一个 DHCP ACK 报文。该DHCP报文被放入一个UDP报文段中，UDP报文段被放入一个IP数据报中，iP数据报再被放入一个以太网帧中。这个以太网帧的源MAC 地址是路由器连到归属网络时接口的MAC地址（00:22:6B:45:1F: 1B).目的MAC地址是Bob便携机的MAC地址（00:16:D3:23:68:8A)。</li>
<li>包含 DHCP ACK 的以太网帧由路由器发送给交换机。因为交换机是自学习的,并且先前从 Bob便携机收到(包含 DHCP请求的)以太网帧，所以该交换机知道寻址到00:16:D3:23:68:8A的帧仅从通向Bob便携机的输出端口转发。</li>
<li>Bob便携机接收到包含 DHCP ACK的以太网帧,从该以太网帧中抽取iP数据报,从iP数据报中抽取UDP报文段，从UDP报文段抽取 DHCP ACK报文。Bob的 DHCP客户则记录下它的iP地址和它的 DNS服务器的iP地址。它还在其IP转发表中安装默认网关的地址。Bob便携机将向该默认网关发送目的地址为其子网68.85.2.0/24 以外的所有数据报。此时，Bob便携机已经初始化好它的网络组件,并准备开始处理Web网页获取。</li>
</ol>
<h3 id="仍在准备-DNS-和-ARP"><a href="#仍在准备-DNS-和-ARP" class="headerlink" title="仍在准备:DNS 和 ARP"></a>仍在准备:DNS 和 ARP</h3><p>当Bob将<a target="_blank" rel="noopener" href="http://www.google.com的url键入其web浏览器时,他开启了一长串事件,这将导致谷歌主页最终显示在其web浏览器上.bob/">www.google.com的URL键入其Web浏览器时，他开启了一长串事件，这将导致谷歌主页最终显示在其Web浏览器上。Bob</a> 的Web浏览器通过生成一个TCP套接字开始了该过程，套接字用于向<a target="_blank" rel="noopener" href="http://www.google.com发送/">www.google.com发送</a> HTTP请求。为了生成该套接字，Bob便携机将需要知道www. google.com的IP地址。使用DNS协议提供这种名字到IP地址的转换服务。</p>
<ol start="8">
<li>Bob便携机上的操作系统因此生成一个DNS 查询报文,将字符串www. google. com放人 DNS报文的问题段中。该DNS报文则放置在一个具有53号（DNS服务器)目的端口的UDP报文段中。该UDP报文段则被放人具有IP目的地址68.87.71. 226(在第5步中 DHCP ACK返回的 DNS服务器地址）和源P地址68.85.2.101的iP数据报中。</li>
<li>Bob便携机则将包含 DNS请求报文的数据报放入一个以太网帧中。该帧将发送(在链路层寻址）到Bob学校网络中的网关路由器。然而，即使Bob便携机经过上述第5步中的DHCP ACK报文知道了学校网关路由器的P地址（68.85.2.1)，但仍不知道该网关路由器的MAC地址。为了获得该网关路由器的MAC地址，Bob便携机将需要使用ARP协议。</li>
<li>Bob便携机生成一个具有目的iP地址68.85.2.1（默认网关)的 ARP 查询报文，将该ARP报文放置在一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧交付给所有连接的设备，包括网关路由器。</li>
<li>网关路由器在通往学校网络的接口上接收到包含该ARP查间报文的帧，发现在ARP报文中目标iP地址68.85.2.1匹配其接口的地址。网关路由器因此准备一个 ARP回答，指示它的MAC地址00:22:6B:45:1F:1B对应IP地址68.85.2.1。它将ARP回答放在一个以太网帧中，其目的地址为00:16:D3:23:68:8A (bob使携饥)，开同父泱饥尺达该桢,再由交换机将帧交付给Bob便携机。</li>
<li>Bob便携机接收包含ARP回答报文的帧，并从ARP回答报文中抽取网关路由器的 MAC地址（00: 22:6B:45:1F:1B）。</li>
<li>Bob便携机现在能够使包含DNS查询的以太网帧寻址到网关路由器的MAC地址。注意到在该帧中的iP数据报具有IP目的地址68.87.71. 226(DNS服务器)，而该帧具有目的地址00:22:6B:45:1F:1B(网关路由器)<br>Bob便携机向交换机发送该帧,交换机将该帧交付给网关路由器。</li>
</ol>
<h3 id="仍在准备-域内路由选择到-DNS-服务器"><a href="#仍在准备-域内路由选择到-DNS-服务器" class="headerlink" title="仍在准备:域内路由选择到 DNS 服务器"></a>仍在准备:域内路由选择到 DNS 服务器</h3><ol start="14">
<li>网关路由器接收该帧并抽取包含 DNS查询的IP数据报路由器查找该数据报的目的地址（68.87.71.226),并根据其转发表决定该数据报应当发送到图5-32的 Comcast网络中最左边的路由器。IP数据报放置在链路层帧中，该链路适合将学校路由器连接到最左边 Comcast路由器，并且该帧经这条链路发送。</li>
<li>在 Comcast 网络中最左边的路由器接收到该帧，抽取IP数据报,检查该数据报的目的地址（68.87.71.226)，并根据其转发表确定出接口，经过该接口朝着 DNS服务器转发数据报，而转发表已根据Comcast 的域内协议（如RIP、OSPF 或IS-IS)以及因特网的域间协议BGP 所填写。</li>
<li>最终包含 DNS查询的IP数据报到达了 DNS 服务器。DNS服务器抽取出 DNS查询报文，在它的 DNS数据库中查找名字www. google. com ，找到包含对应www. google. com的iP地址（64.233.169.105）的 DNS 源记录。（假设它当前缓存在 DNS服务器中。）前面讲过这种缓存数据源于google.com 的权威DNS服务器。该DNS服务器形成了一个包含这种主机名到iP地址映射的 DNS回答报文，将该 DNS回答报文放入UDP报文段中，该报文段放入寻址到Bob便携机（68.85.2.101）的P数据报中。该数据报将通过Comcast网络反向转发到学校的路由器，并从这里经过以太网交换机到Bob便携机。</li>
<li>Bob便携机从 DNS报文抽取出服务器www. google.com的IP地址。最终，在大量工作后，Bob便携机此时准备接触 www. google. com服务器!</li>
</ol>
<h3 id="Web-客户-服务器交互-TCP和-HTTP"><a href="#Web-客户-服务器交互-TCP和-HTTP" class="headerlink" title="Web 客户-服务器交互:TCP和 HTTP"></a>Web 客户-服务器交互:TCP和 HTTP</h3><ol start="18">
<li>既然Bob便携机有了<a target="_blank" rel="noopener" href="http://www.google.com的ip地址,它能够生成tcp套接字,该套接字将用于向/">www.google.com的iP地址，它能够生成TCP套接字,该套接字将用于向</a> <a target="_blank" rel="noopener" href="http://www.google.com发送http/">www.google.com发送HTTP</a> GET 报文。当 Bob生成<br>TCP套接字时，在Bob便携机中的TCP必须首先与<a target="_blank" rel="noopener" href="http://www.google.com中的tcp执行三次握手.bob便携机因此首先生成一个具有目的端口80(针对http的)的tcp/">www.google.com中的TCP执行三次握手。Bob便携机因此首先生成一个具有目的端口80（针对HTTP的)的TCP</a> SYN报文段，将该TCP报文段放置在具有目的iP地址64.233.169.105(www. google.com）的IP数据报中，将该数据报放置在MAC地址为00:22:6B:45:1F:1B(网关路由器）的帧中,并向交换机发送该帧。</li>
<li>在学校网络、Comcast网络和谷歌网络中的路由器朝着www. google. com 转发包含TCP SYN 的数据报，使用每台路由器中的转发表,如前面步骤14~16那样。前面讲过支配分组经Comcast 和谷歌网络之间域间链路转发的路由器转发表项，是由BGP协议决定的。</li>
<li>最终，包含TCP SYN 的数据报到达 www. googole.com。从数据报抽取出TCP SYN报文并分解到与端口80相联系的欢迎套接字。对于谷歌HTTP服务器和Bob便携机之间的TCP连接生成一个连接套接字。产生一个TCP SYNACK报文段,将其放入向Bob便携机寻址的一个数据报中，最后放入链路层帧中，该链路适合将<a target="_blank" rel="noopener" href="http://www.google/">www.google</a>. com 连接到其第一跳路由器。</li>
<li>包含 TCP SYNACK 报文段的数据报通过谷歌、Comcas<br>和学校网络,最终到达Bob便携机的以太网卡。数据报在操作系统中分解到步骤18生成的TCP套接字，从而进入连接状态。</li>
<li>借助于Bob便携机上的套接字，现在（最终!)准备向<a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a> 发送字节了，Bob 的浏览器生成包含要获取的URL 的HTTP CET报文。HTTP GET 报文则写入套接字，其中 GET报文成为一个TCP报文段的载荷。该TCP报文段放置进一个数据报中，并交付到www. google.com，如前面步骤18～20所述。</li>
<li>在<a target="_blank" rel="noopener" href="http://www.google.com的/">www.google.com的</a> HTTP服务器从TCP套接字读取 HTTP GET 报文，生成一个HTTP响应报文，将请求的Web页内容放入HTTP响应体中，并将报文发送进TCP套接字中。</li>
<li>包含 HTTP回答报文的数据报通过谷歌、Comcast和学校网络转发，到达Bob便携机。Bob 的 Web浏览器程序从套接字读取HTTP响应，从HT<br>响应体中抽取Web 网页的html，并终于（最终!)显示了 Web 网页。</li>
</ol>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol start="2">
<li><p>如果在因特网中的所有链路都提供可靠的交付服务，TCP可靠传输服务将是多余的吗?为什么?</p>
<blockquote>
<p>基本是多余的。<br>TCP可靠交付是多余的，拥塞控制是基于统计丢包的，也失去效果了。流量控制还有些用处。</p>
</blockquote>
</li>
<li><p>链路层协议能够向网络层提供哪些可能的服务?在这些链路层服务中，哪些在iP中有对应的服务哪些在TCP中有对应的服务?</p>
<blockquote>
<p>可能提供的服务有：成帧，链路接入，可靠交付，差错检测和纠正<br>IP对应的服务：IP数据报，数据报交付<br>TCP对应的服务：TCP报文段，可靠交付，差错检测</p>
</blockquote>
</li>
<li><p>假设<strong>两个结点同时</strong>经一个速率为R的广播信道开始传输一个长度为L的分组。用dp表示这两个结点之间的传播时延。如果dp&lt;L/R，会出现碰撞吗?为什么?</p>
<blockquote>
<p>会，节点还没有传输结束，就检测到别的结点的传输信号了。</p>
</blockquote>
</li>
<li><p>我们列出了广播信道的4种希望的特性。这些特性中的哪些是时隙 ALOHA 所具有的?令牌传递具有这些特性中的哪些?</p>
<blockquote>
<p>仅有一个结点发送时有R的吞吐量。<br>M个结点同时发送时，每个结点的吞吐量为R/M<br>协议是分散的，不会因为某个结点故障而崩溃。<br>协议简单，实现不昂贵。<br>时隙ALOHA有： 1，3，4<br>令牌传递有： 1，2，4</p>
</blockquote>
</li>
<li><p>在CSMA/CD中在第5次碰撞后，结点选择K=4的概率有多大?结果K=4在10Mbps以太网上对应于多少秒的时延?</p>
<blockquote>
<p>1/32的概率。<br>时延为4 * 5.12 * 10 = 204.8μs</p>
</blockquote>
</li>
</ol>
<p><strong>100Mbps以太网来说为5.12微秒</strong> 书上翻译错了</p>
<ol start="7">
<li><p>使用人类在鸡尾酒会交瓦的类比来描述轮询和令牌传递协议。</p>
<blockquote>
<p>轮询协议：有一个主持人，依次询问每个与会人员是否要发言，并且控制每个人的最长发言时间。<br>令牌传递协议：有一个话筒在每个与会人员之间传递，如果有人要发言则拿起话筒发言，不发言则传递给下一位与会人员。</p>
</blockquote>
</li>
<li><p>如果局域网有很大的周长时，为什么令牌环协议将是低效的?</p>
<blockquote>
<p>因为如果需要发送的结点很少时，也需要固定每次循环一圈。而循环的时间很长，造成低效。</p>
</blockquote>
</li>
<li><p>MAC地址空间有多大?IP4的地址空间呢?IP6的地址空间呢?</p>
<blockquote>
<p>MAC地址空间：2^48<br>IPV4地址空间：2^32<br>IPV6地址空间：2^128</p>
</blockquote>
</li>
<li><p>假设结点A、B和C(通过它们的适配器)都连接到同一个广播局域网上。如果A向B发送数千个IP数据报，每个封装帧都有B的MAC地址，C的适配器会处理这些吗?如果会，C的适配器将会把这些帧中的IP数据报传递给C的网络层吗?如果A用MAC广播地址来发送这些，你的回答将有怎样的变化呢?</p>
<blockquote>
<p>C 的适配器会处理A发送的帧但不会传递给C的网络层；若用广播地址则 C的适配器会接收A发送的帧且传递给C的网络层。</p>
</blockquote>
</li>
<li><p>ARP查询为什么要在广播中发送呢?ARP 响应为什么要在一个具有特定目的MAC地址的中发送呢?</p>
<blockquote>
<p>ARP查询因为不清楚的MAC地址，链路层不知道应该送往哪里。<br>ARP响应因为清楚目标主机的MAC地址，因此不需要广播。</p>
</blockquote>
</li>
<li><p>对于图5-19中的网络，路由器有两个ARP模块，每个都有自己的ARP表。同样的MAC地址可能在两张表中都出现吗?<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w9.png" alt="?"></p>
</li>
</ol>
<p><strong>路由器中有多个ARP表，每个接口都有一个ARP表。因此，如果路由器有多个接口，它就会有多个ARP表。</strong></p>
<blockquote>
<p>会把。。。</p>
</blockquote>
<ol start="13">
<li><p>比较10BASE-T、100BASE-T和吉比特以太网的帧结构。它们有什么不同吗?</p>
<blockquote>
<p>帧格式相同。</p>
</blockquote>
</li>
<li><p>考虑图5-15。在4.4节的寻址意义下，有多少个子网呢?</p>
<blockquote>
<p>1个子网(路由器划分子网，所有的主机交换机都在一根链路)</p>
</blockquote>
</li>
<li><p>在一个支持802.1Q协议交机上能够配置的VLAN的最大数量是多少?</p>
<blockquote>
<p>2^12个<br>IEEE 802.1Q是一个中继标准，802.1Q修改原始的以太网帧，插入4字节字段，通过这个字段标识带有VLAN 成员信息的以太帧。 由于标准规定用于标示VLAN ID的位置只有12bit，2的12次方=4096 也就是说最大4K个vlan</p>
</blockquote>
</li>
<li><p>假设支持K个VLAN组的N台交换机经过一个线协议连接起来。连接这些交换机需要多少端口?评价你的答案。</p>
<blockquote>
<p>互相连接，最少需要2N-2个端口。</p>
</blockquote>
</li>
</ol>
<h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><ol>
<li>假设某分组的信息内容是比特模式1110011010011101，并且使用了偶校验方案。在采用二维奇偶校验方案的情况下，包含该检验比特的字段的值是什么?你的回答应该使用最小长度检验和字段。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t1.png" alt="?"></li>
</ol>
<p><strong>第i+j+1位是一定可以被满足的</strong></p>
<ol start="2">
<li><p>说明(举一个不同于图5-5中那个的例子) 二维奇偶校验能够纠正和检测单比特差错。说明(举一个例子)某些双比特差错能够被检测但不能纠正。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t2.png" alt="?"></p>
</li>
<li><p>考虑5比特生成多项式，G=10011，并且假设D的值为1010101010。R的值是什么?</p>
<blockquote>
<p>r的位数等于G-1，D=D拼接R位0，进行模二不进位运算得r=0100</p>
</blockquote>
</li>
<li><p>考虑上一个习题，这时假设D具有值:<br>a. 1001010101<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t5.jpg" alt="?"><br>b. 0101101010<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t4.jpg" alt="?"><br>c. 1010100000<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t3.jpg" alt="?"></p>
</li>
<li><p>在这道习题中，我们探讨CRC的某些性质。对于在5.2.3 节中给出的生成多项式G(=1001)，回答下列问题:<br>a.为什么它能够检测数据D中的任何单比特差错?</p>
<blockquote>
<p>因为如果发生任意单比特差错，生成多项式变无法整除，因此可以检测到。<br>b.上述G能够检测任何奇数比特差错吗?为什么?<br>对此题而言，一个关键点是：G 能被 11（二进制）整除，但任意奇数比特差错都不能整除11，因此也不能整除 G，所以可以检测出奇数比特差错。</p>
</blockquote>
</li>
<li><p>如图5-33所示，考虑通过两台路由器互联的3个局域网。</p>
</li>
</ol>
<p>a. 对所有的接口分配IP地址。对子网1使用形式为192.168.1.xxx的地址对子网2使用形式为1921682xx的地址，对子网3使用形式为1921683x的地址。</p>
<blockquote>
<p>A 192.168.1.1<br>B 192.168.1.2<br>左路由左接口 192.168.1.3<br>C 192.168.2.1<br>D 192.168.2.2<br>左路由右接口 192.168.2.3<br>右路由左接口 192.168.2.4<br>E 192.168.3.1<br>F 192.168.3.2<br>右路由右接口 192.168.3.3</p>
</blockquote>
<p>b. 为所有的适配器分配MAC地址。</p>
<blockquote>
<p>A 01-01-01-01-01-01<br>B 02-02-02-02-02-02<br>左路由左接口 03-03-03-03-03-03<br>C 04-04-04-04-04-04<br>D 05-05-05-05-05-05<br>左路由右接口 06-06-06-06-06-06<br>右路由左接口 07-07-07-07-07-07<br>E 08-08-08-08-08-08<br>F 09-09-09-09-09-09<br>右路由右接口 0A-0A-0A-0A-0A-0A</p>
</blockquote>
<p>c. 考虑从主机E向主机B发送一个IP 数据报。假设所有的ARP 表都是最新的。就像在5.4.1节中对单路由器例子所做的那样，列举出所有步骤。</p>
<blockquote>
<p>主机E通过子网掩码发现是去别的网段的，首先查询转发表，且向ARP表查询右路由右接口IP地址对应的MAC地址（查网关），向右路由右接口发送数据报。<br>到达右路由右接口后，通过路由器的转发到右路由左接口。<br>右路由左接口向ARP表查询左路由右接口IP地址对应的MAC地址（发现是直链网络，找mac），向左路由右接口发送数据报。<br>到达左路由右接口后，通过路由器的转发到左路由左接口。<br>右路由左接口向ARP表查询主机BIP地址对应的MAC地址，向主机B发送数据报。<br>主机B收到数据报，提取处报文内容向上层传递。</p>
</blockquote>
<p>d. 重复(c)，现在假设在发送主机中的ARP表为空(并且其他表都是最新的)。</p>
<blockquote>
<p>主机E首先查询转发表，知道应该向右路由右接口IP地址发送数据包，但是没有该IP地址的MAC地址，于是发送ARP广播查询报文。<br>主机E收到查询报文后，可以构造一个数据报发送给右路由右接口。</p>
</blockquote>
<p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t6.png" alt="?"></p>
<ol start="15">
<li>考虑图5-33。现在我们用一台交换机代替子网1和子网2之间的路由器，并且将子网2和子网3之间的路由器标记为R1。<br>a. 考虑从主机E向主机F发送一个IP数据报。主机E将请求路由器RI帮助转发该数据报吗?为什么?在包含P数据报的以太网帧中，源和目的P和MAC地址分别是什么?<blockquote>
<p>主机E不请求路由器R1帮助转发该数据报。<br>源IP地址：192.168.3.1<br>目的IP地址：192.168.3.2<br>源MAC地址：08-08-08-08-08-08<br>目的MAC地址：09-09-09-09-09-09</p>
</blockquote>
</li>
</ol>
<p>b.假定E希望向B发送一个IP数据报，假设E的ARP缓存中不包含B的MAC地址。E将执行ARP查询来发现B的MAC地址吗?为什么?在交付给路由器R1的以太网帧(包含发向B的IP数据报)中，源和目的IP和MAC地址分别是什么?</p>
<blockquote>
<p>E不执行ARP协议来发现B的MAC地址。因为E和B并不在一个局域网中。<br>源IP地址：192.168.3.1<br>目的IP地址：192.168.1.2（目的ip）<br>源MAC地址：08-08-08-08-08-08<br>目的MAC地址：0A-0A-0A-0A-0A-0A(网关的mac)</p>
</blockquote>
<p>c.假定主机A希望向主机B发送一个IP数据报，A的ARP缓存不包含B的MAC地址，B的ARP缓存也不包含A的MAC地址。进一步假定交换机S1的转发表仅包含主机B和路由器RI的表项。因此，A将广播一个ARP请求报文。<br>一旦交换机S1收到ARP请求报文将执行什么动作?</p>
<blockquote>
<p>①交换机 S1 将通过其两个接口广播以太网帧，因为接收到的 ARP 帧的目标地址是广播地址。 它了解到 A 通过 S1 面向子网 1 的接口，连接到 S1 上，并且 S1 将更新其转发表，以包含主机 A 的条目。</p>
</blockquote>
<p>路由器RI也会收到这个ARP请求报文吗? 如果收到的话。R将向子网3转发该报文吗?</p>
<blockquote>
<p>②是的，路由器 R1 也接收这个 ARP 请求消息，但是 R1 不会将消息转发到子网 3。</p>
</blockquote>
<p>一但B收到这个ARP请求报文，它将向主机A回发一个ARP响应报文。但是它将发送一个ARP查询报文来请求A的MAC地址吗?为什么?</p>
<blockquote>
<p>③B 不会发送 ARP 查询消息来要求 A 的 MAC 地址，因为这个地址可以从 A的查询消息中获得。之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。</p>
</blockquote>
<p>一旦交换机SI收到来自主机B的一个ARP 响应报文，它将做什么?</p>
<blockquote>
<p>④一旦交换机 S1 接收到 B 的响应消息，它将在其转发表中为主机 B 添加一个条目，然后将接收到的帧删除，因为目标主机 A 与主机 B 在同一接口上(即 A 和 B 在同一局域网段上)。【注意 A 的帧中是广播 MAC 地址，S1 收到帧后是不会阻断广播帧的广播的，因此①中 S1 会通过两个接口转发，而在④中 S1 收到的帧目的地址明确是 A 的 MAC 地址，因此1 不会转发到右边</p>
</blockquote>
<ol start="17">
<li>前面讲过，使用CSMA/CD协议，适配器在碰撞之后等待K·512比特时间，其中K是随机选取的。对于K=100对于一个10Mbps的广播信道，适配器返回到第二步要等多长时间?对于100Mbps的广播信道来说呢?<blockquote>
<p>10Mbps的信道： 51.2μs * 100 = 5.12ms<br>100Mbps的信道： 5.12μs * 100 = 512μs</p>
</blockquote>
</li>
</ol>

      
    </div>
    <div class="article-footer">
      <br>
<br>
<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://codecodegogogo.github.io/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/" title="计算机网络-第五章链路层" target="_blank" rel="external">https://codecodegogogo.github.io/2023/06/08/计算机网络-第五章链路层/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong></strong>
      <!-- <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！ -->
    </li>
  </ul>
</blockquote>

    </div>
  </article>
  
    
  <section id="comments">
  	
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2023/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1/" title="计算机通信"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2023/06/03/%E4%BA%BA%E7%94%9F%E4%B8%8D%E6%AD%A2%E6%9C%89%E6%8A%80%E6%9C%AF/" title="人生不止有技术"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>






</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/codecodegogogo" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        联系邮箱：<br>codecodegogogo@163.com
        <!-- 2024 Sunny -->
        
        <!--  -->
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   






</body>

</html>