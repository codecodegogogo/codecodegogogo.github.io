<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>你好，世界</title>
    <url>/2023/02/28/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="海内存知己，天涯若比邻"><a href="#海内存知己，天涯若比邻" class="headerlink" title="海内存知己，天涯若比邻"></a><center>海内存知己，天涯若比邻</center></h3><p><img src="/2023/02/28/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C/1.png" alt="张宇老师"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-ppt/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h5 id="ppt"><a href="#ppt" class="headerlink" title="ppt"></a>ppt</h5><ul>
<li><p>设计-》自定义-》设置背景格式-》【隐藏背景图形】用于隐藏母版添加的背景图形，如图片、形状、文字等等</p>
</li>
<li><p>主题和背景默认应用于全部幻灯片，切换用于当前选中幻灯片</p>
</li>
<li><p>smart art图形设置动画</p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-ppt/image-20240604163225423.png" alt="image-20240604163225423"></p>
</li>
<li><p>执行动画时执行完第一行按顺序执行第二行，播放时按照时间轴进行</p>
</li>
<li><p>触发器控制动画的触发</p>
</li>
<li><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-ppt/image-20240604200221234.png" alt="image-20240604200221234"></p>
</li>
<li><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-ppt/image-20240604200705330.png" alt="image-20240604200705330"></p>
</li>
<li><p>模板是主题和用于特定用途的一些内容，提供了演示文稿的格式，配色方案，母版样式以及产生特效的字体样式。</p>
</li>
<li><p>主题是演示文稿的颜色搭配，字体格式化以及一些特效的命令</p>
</li>
<li><p>母板定义文稿中幻灯片的格式，包括文本和对象在幻灯片中的位置，文本和对象占位符的大小，文本样式，效果，主题颜色，背景</p>
</li>
<li><p>在幻灯片中按Shift＋Enter组合键就可插人—张新的幻灯片。</p>
</li>
</ul>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-ppt/image-20240605083949126.png" alt="image-20240605083949126"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-ppt/image-20240605084222029.png" alt="image-20240605084222029"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h3><ul>
<li><p>Access中’字段名称的长度最大为64个字符,文本字段大小255，数字、自动编号默认长整型</p>
</li>
<li><p>查询的数据来源可以是表’也可以是其他查询</p>
</li>
<li><p>设置为主键的字段系统自动设置索引</p>
</li>
<li><p>accdt 数据库模板</p>
</li>
<li><p>窗体对象中显示的字段为表对象或者查询对象中的字段</p>
</li>
<li><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604084208993.png" alt="image-20240604084208993"></p>
</li>
<li><p>查询：</p>
<p>选择查询：单表查询，多表连接查询</p>
<p>交叉表查询</p>
<p>操作查询：更新查询，生成表查询，追加查询，删除查询</p>
<p>参数查询</p>
<p>SQL查询</p>
</li>
</ul>
<h5 id="报表"><a href="#报表" class="headerlink" title="报表"></a>报表</h5><p>7个部分：报表页眉，页脚；页面页眉，页脚；组页眉，页脚；主体。</p>
<p>报表主体节中可以设置多个工具按钮</p>
<p>报表是只读的，只用于输出</p>
<h5 id="窗体"><a href="#窗体" class="headerlink" title="窗体"></a>窗体</h5><p>窗体页眉   主体   窗体页脚</p>
<h6 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h6><p>文本框、标签、按钮，选项卡，超链接，Web 浏览器控件和导航控件、组、分页符、组合框，图表、线条、切换按钮、列表框、矩形、复选框、未绑定对象框架、附件、选项按钮、子表单和子报表、绑定对象框架，甚至在表单上放置图像。</p>
<h5 id="表"><a href="#表" class="headerlink" title="表"></a>表</h5><h6 id="字段的命名规则"><a href="#字段的命名规则" class="headerlink" title="字段的命名规则:"></a>字段的命名规则:</h6><ul>
<li>长度为1~64个字符</li>
<li>可以含字母、汉字、数字、空格和其他字符</li>
<li>不能以空格开头， 不能仑含句号(. )、惊叹号(! )、方括号([]) 、单引号(’)</li>
<li>不能使用ASCII码为0~32的ASCII字符</li>
</ul>
<h6 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h6><p>文本:最多可以存储255个字符<br>备注:最多可以存储65 535个字符，不能对备注型字段进行排序和建立索引，所以在数据检索中速度要比文本型慢</p>
<h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603210953293.png" alt="image-20240603210953293"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603212804707.png" alt="image-20240603212804707"><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603212939347.png" alt="image-20240603212939347"><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603213252126.png" alt="image-20240603213252126"><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603213619904.png" alt="image-20240603213619904"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603213749377.png" alt="image-20240603213749377"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603213846750.png" alt="image-20240603213846750"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603213918569.png" alt="image-20240603213918569"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603213953871.png" alt="image-20240603213953871"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603214022843.png" alt="image-20240603214022843"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603214105869.png" alt="image-20240603214105869"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603214136466.png" alt="image-20240603214136466"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603214213053.png" alt="image-20240603214213053"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603214231136.png" alt="image-20240603214231136"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240603214459719.png" alt="image-20240603214300711"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604093731537.png" alt="image-20240604093731537"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604084645791.png" alt="image-20240604084645791"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604084750034.png" alt="image-20240604084750034"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604085116717.png" alt="image-20240604085116717"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604090325502.png" alt="image-20240604090325502"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604090622098.png" alt="image-20240604090622098"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604091914580.png" alt="image-20240604091914580"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604094520428.png" alt="image-20240604094520428"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604100431976.png" alt="image-20240604100431976"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604100501527.png" alt="image-20240604100501527"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604100526728.png" alt="image-20240604100526728"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240604100550034.png" alt="image-20240604100550034"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240606160418969.png" alt="image-20240606160418969"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240606160436614.png" alt="image-20240606160436614"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240606160447488.png" alt="image-20240606160447488"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240606160459936.png" alt="image-20240606160459936"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240606160509378.png" alt="image-20240606160509378"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240606160530029.png" alt="image-20240606160530029"></p>
<p><img src="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E5%BA%93/image-20240606160541786.png" alt="image-20240606160541786"></p>
]]></content>
  </entry>
  <entry>
    <title>计算机文化基础-excel</title>
    <url>/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="Excel2016"><a href="#Excel2016" class="headerlink" title="Excel2016"></a>Excel2016</h4><ul>
<li><p>主要功能有:</p>
<p>(1)表格制作;(2)图表功能;(3)数据处理和数据分析;(4)数据清单功能。</p>
</li>
<li><p>word2016新建工作簿只有1个工作表，工作簿缺省名叫工作簿1，只有1张工作表时不能删除工作表。</p>
</li>
<li><p>合并后的单元格和合并前的区域左上角的内容相同，其他省略。</p>
</li>
<li><p>模板名称.xltx  文件名 .xlsx</p>
</li>
<li><p>文本型数据左对齐，数字型数据和日期和时间型数据右对齐</p>
</li>
<li><p>直接左键拖动填充柄不能产生复制效果：时间，日期，数字字符串</p>
</li>
<li><p>直接左键拖动填充柄能产生复制效果：文本，数值</p>
</li>
<li><p>excel视图：普通视图，</p>
<p>分页预览，<img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527111947092.png" alt="image-20240527111947092">页面布局</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527112003814.png" alt="image-20240527112003814"></p>
</li>
<li><p>可以清除  批注 内容 格式 超链接</p>
</li>
<li><p>分页预览视图可以移动分页符</p>
</li>
<li><p>被打印的工作表最小缩放为10%，最大400%</p>
</li>
<li><p>一维数组的创建： 在上方的编辑栏内输入数组公式“={1,2,3,4,5}”，接着按Ctrl+shift+enter组合键来执行计算</p>
</li>
<li><p>输人“1   1／5”表示五分之六</p>
</li>
<li><p>Excel和WOrd之间共享信息的方式有两种’即对象的链接和对象的嵌人。</p>
</li>
<li><p>数据清单的第一列必须是文本类型</p>
</li>
<li><p>能够表现个体与整体之间关系的图表类型是饼图</p>
</li>
<li><p>汉字排序有笔划和字母</p>
</li>
<li><p>excel默认度量值11</p>
</li>
<li><p>Excel20l0提供了与假设前提相关的三种简单的数据分析方法:方案管理器｀单变量求解和模拟运算表</p>
</li>
<li><p>保护工作簿：审阅-》更改   可以组织添加删除隐藏表</p>
</li>
<li><p>保护工作表：审阅-》更改   可以阻止单元格，行，列一些操作</p>
</li>
<li><p>保护一些区域：选中允许操作的一些单元格，设置单元格格式-》保护，取消锁定，然后打开保护工作表</p>
</li>
<li><p>增加小数位数和百分比都会四舍五入</p>
</li>
</ul>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><ul>
<li>同时在多个单元格中输入相同的信息 ctrl+enter</li>
<li>按下&lt;Shift+F11&gt;组合键，可快速在当前工作表的前面插入一张新工作表。</li>
<li>双击输入有公式的单元格或者选择单元格再按f2，单元格显示公式</li>
<li>输入当天日期:&lt;Ctl +;&gt;键。输入当前时间:&lt;Ctl + Shift +;&gt;键。</li>
<li>alt+; 选择当前分类汇总屏幕内容</li>
<li>alt+I+H 插入图表</li>
<li>alt+f1 插入嵌入式图表   f11插入独立图表</li>
<li>f4可以切换引用方式</li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526165920913.png" alt="image-20240526165920913"></li>
<li>单元格内分段 alt+enter</li>
<li>打开单元格格式   ctrl+shift+f</li>
<li>移动到下一张工作表  ctrl+pagedown</li>
<li>shift+f2 插入批注</li>
<li>按住ctrl+任意方向键 跳转到该方向最近的有内容单元格</li>
</ul>
<h4 id="工作簿、工作表、单元格和单元格区域"><a href="#工作簿、工作表、单元格和单元格区域" class="headerlink" title="工作簿、工作表、单元格和单元格区域"></a>工作簿、工作表、单元格和单元格区域</h4><p>(1)工作簿(Book):是存储数据、进行数据运算以及数据格式化的文件。扩展名为.xlsx,工作簿可含有多个工作表(Sheet)(至少1个，无上限)。</p>
<p>(2)工作表:新建一个工作簿时，Excel2016自动创建1个工作表(系统默认，可修改)名为Sheet1。工作表的名字是可以改变的。工作表不是一个独立的文件,因此不能单独存盘的,直接删除，而不是删除到回收站中。</p>
<p><strong>1个工作表有16384列、1048576行。编号从A开始，最后一列为XFD:行编号从1开始最后一行为 1048576。</strong></p>
<p>同时选中多个工作表:使用 Ctrl或 shift 键结合鼠标操作。</p>
<p><strong>同时在多个工作表中输入信息（按ctrl选中多个工作簿后，输入），也可以同时在多个单元格中输入相同的信息 ctrl+enter（按ctrl选中多个单元格后，输入后ctrl+enter）</strong></p>
<p>移动:选中工作表，按住鼠标左键，拖动至目的地即可。<br>复制:选中工作表，按住Ctrl键，然后按住鼠标左键，拖动至目的地即可。</p>
<p>新建一个工作簿文件时，系统默认生成1个工作表。可以通过设置“文件”“选项”“常规”选项卡中的“包含的工作表数”修改新建工作簿文件含有的工作表数。最小数目是1,最大数目是 255。注:这个最大255 仅限于初始新建工作簿包含的工作表数。工作簿建立后,句含的工作表数最多没有限制，最少1个。</p>
<p>(3)单元格:工作表中行、列交叉的位置称为单元格，是工作表最基本的数据单元，是<strong>电子表格软件中处理数据的最小单位</strong>。单元格名称:也称为单元格地址，由单元格所处的列名(在前)和行名(在后)组成。在同一时刻只有一个单元格处于活动状态。每个单元格内容长度的最大限制是32767个字符。</p>
<p><strong>一个工作表最多有1048576*16384个单元格，一个单元格长度最大32767</strong></p>
<img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524110256693.png" alt="image-20240524110256693" style="zoom:200%;">



<h4 id="工作表的管理"><a href="#工作表的管理" class="headerlink" title="工作表的管理"></a>工作表的管理</h4><h5 id="单元格区域命名"><a href="#单元格区域命名" class="headerlink" title="单元格区域命名"></a>单元格区域命名</h5><p>用户可以为所选择的某个单元格区域定义一个名称。名称的定义和管理可通过<strong>“公式”选项卡中的“定义的名称”</strong>来实现。</p>
<ul>
<li>(1)新建名称:切换至“公式”选项卡在“定义的名称”组中单击“定义名称”按钮,打开“新建名称”对话框。</li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524111312375.png" alt="image-20240524111312375"></li>
<li>(2)根据所选内容创建:<br>根据所选内容创建是指在所选单元格区域中选择某一单元格中的数据作为名称,可以是首行、末行中的值,也可以是最左列、最右列中的值。</li>
<li>(3)除了运用上述方法外,用户还可利用名称框直接定义名称。具体方法是:选择需要定义的单元格区域,如E2:E11,在名称框中输人需要定义的名称,如“英语”,然后按 Enter 键即可。</li>
<li>重命名不能取消</li>
</ul>
<p>单击名称框右边的下拉箭头,即可看到以上述方法定义的两个单元格区域名称,选择“所有成绩”后,显示该名称对应的单元格区域。</p>
<h5 id="移动或复制工作表"><a href="#移动或复制工作表" class="headerlink" title="移动或复制工作表"></a>移动或复制工作表</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524112430215.png" alt="image-20240524112430215"></p>
<p>开始-&gt;单元格-&gt;格式-&gt;移动或复制工作表</p>
<p><strong>勾选建立副本则为复制</strong></p>
<p>通过拖动鼠标的方式移动或复制工作表:打开要进行操作的两个工作簿,在“视图”选项卡的“窗口”组中,选择“全部重排”命令,打开“重排窗口”对话框,这里选择“垂直并排”,然后单击“确定”按钮。</p>
<p>拖动工作表标签即可在不同的工作簿之间实现移动或复制操作。</p>
<h5 id="插入表"><a href="#插入表" class="headerlink" title="插入表"></a>插入表</h5><ul>
<li>(1)单击工作表标签右侧的“插入工作表”按钮，可快速插入新工作表。</li>
<li>(2)按下&lt;Shift+F11&gt;组合键，可快速在当前工作表的前面插入一张新工作表。</li>
<li>(3)在“开始”选项卡的“单元格”组中，单击“插人”按钮右侧的下拉按钮，在弹出的下拉列表中单击“插入工作表”选项。</li>
<li>(4)使用鼠标右键单击某个工作表标签,在弹出的快捷菜单中单击“插入”命令,打开“插入”对话框。在“常用”选项卡的列表框中选择“工作表”，然后单击“确定”按钮，即可在当前工作表的前面插入一张新工作表。<strong>如果要添加多个工作表，可以同时选定与待添加工作表数目相同的工作表标签。</strong></li>
</ul>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523095221791.png" alt="image-20240523095221791"></p>
<h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><ul>
<li>(1)右击需要删除的工作表标签，在弹出的快捷菜单中单击“删除”命令。</li>
<li>(2)选中需要删除的工作表，在“开始”选项卡的“单元格”组中，单击“删除”按钮右侧的下拉按钮，在弹出的下拉列表中单击“删除工作表”选项。删除工作表是永久删除无法撤消删除操作，其右侧的工作表将成为当前工作表。</li>
</ul>
<h5 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h5><ul>
<li>(1)右击要重命名的工作表标签，在弹出的快捷菜单中单击“重命名”命令。</li>
<li>(2)双击相应的工作表标签，输入新名称覆盖原有名称即可。</li>
<li>(3)在“开始”选项卡的“单元格”选项组中，从“格式”按钮中选择“重命名工作表命令。</li>
</ul>
<h5 id="保护工作表"><a href="#保护工作表" class="headerlink" title="保护工作表"></a>保护工作表</h5><ul>
<li>选中需要保护的工作表,单击“文件”选项卡,在左侧窗格中单击“信息”命令,在右侧单击“保护工作簿”按钮,在打开的下拉列表中单击“保护当前工作表”选项;</li>
<li>或者单击“开始”选项卡“单元格”组中的“格式”按钮,选择下拉列表中的“保护工作表”命令;</li>
<li>或者单击“审阅”选项卡“更改”组中的“保护工作表”</li>
</ul>
<h5 id="隐藏工作表和取消隐藏"><a href="#隐藏工作表和取消隐藏" class="headerlink" title="隐藏工作表和取消隐藏"></a>隐藏工作表和取消隐藏</h5><p>选中要隐藏的工作表，在“开始”选项卡的“单元格”组中单击“格式”按钮，在弹出的下拉列表的“可见性”栏中，依次单击“隐藏和取消隐藏”→“隐藏工作表”选项。</p>
<p><strong>工作簿，工作表，行，列，单元格都可以被隐藏</strong>？</p>
<p>工作簿隐藏在视图选项卡窗口组</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523100830378.png" alt="image-20240523100830378"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523100635580.png" alt="image-20240523100635580"></p>
<h4 id="行，列。单元格"><a href="#行，列。单元格" class="headerlink" title="行，列。单元格"></a>行，列。单元格</h4><h5 id="单元格，单元区域重命名"><a href="#单元格，单元区域重命名" class="headerlink" title="单元格，单元区域重命名"></a>单元格，单元区域重命名</h5><p>选中要命名的单元格或单元格区域后</p>
<ul>
<li>1)右击鼠标，从快捷菜单中选择“定义名称”命令，在弹出的“新建名称”对话框中输入新的名称。</li>
<li>2)在名称框中输入新的名称</li>
<li>3)“公式”→“定义名称”</li>
<li>4)“公式”→“根据所选内容创建’</li>
</ul>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526165738544.png" alt="image-20240526165738544"></p>
<p>注:单元格重命名时应遵循以下规则:<br>不能以数字开头，可以以下划线、字母或汉字开头<br>不能包含空格<br>不能与Excel系统的默认名称重名。</p>
<h5 id="插入行，列，单元格"><a href="#插入行，列，单元格" class="headerlink" title="插入行，列，单元格"></a>插入行，列，单元格</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524152727565.png" alt="image-20240524152727565"></p>
<p>插入单元格时,会打开“插入”对话框</p>
<ul>
<li>活动单元格右移:在当前单元格的左侧插入一个或多个单元格</li>
<li>活动单元格下移:在当前单元格的上方插人一个或多个单元格,</li>
<li>整行:在当前单元格的上方插入一行或多行。</li>
<li>整列:在当前单元格的左侧插人一列或多列。</li>
</ul>
<h5 id="删除行，列，单元格"><a href="#删除行，列，单元格" class="headerlink" title="删除行，列，单元格"></a>删除行，列，单元格</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524152810563.png" alt="image-20240524152810563"></p>
<h5 id="行列的隐藏和取消隐藏"><a href="#行列的隐藏和取消隐藏" class="headerlink" title="行列的隐藏和取消隐藏"></a>行列的隐藏和取消隐藏</h5><p>选中要隐藏的行或列,右击,在打开的快捷菜单中选择“隐藏”命令;或按Cul+9把选中的行隐藏,按 Ctrl+0 把选中的列隐藏。</p>
<p>取消隐藏时选中隐藏行列的上下行列，快捷菜单取消隐藏</p>
<h5 id="单元格的合并"><a href="#单元格的合并" class="headerlink" title="单元格的合并"></a>单元格的合并</h5><p>可以取消合并，但是不能拆分单元格</p>
<p>合并后居中:将多个单元格合并成一个,且内容在合并后单元格的对齐方式是居中对齐</p>
<p>跨越合并:行与行之间相互合并,而上下单元格之间不参与合并。<br>合并单元格:将选择的多个单元格合并成一个较大的单元格。</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524153523091.png" alt="image-20240524153523091"></p>
<h5 id="单元格的引用"><a href="#单元格的引用" class="headerlink" title="单元格的引用"></a>单元格的引用</h5><p>单元格的引用:分为相对引用和绝对引用，系统默认是相对引用。</p>
<p>相对引用:单元格引用是随着公式的位置的改变而改变。公式的值将会随更改后的单元格地址的值重新计算。例如公式“=A1”就属于单元格的相对引用。</p>
<p>绝对引用:公式中的单元格或单元格区域地址不随着公式位置的改变而发生改变不论公式的单元格位置如何变化，公式中所引用的单元格位置都是其在工作表中的确切位置。绝对单元格引用的形式是:在每一个列标号及行号前面增加一个“$”符号，例如“=1.06*$C$4”</p>
<p>混合引用:指单元格或单元格区域地址部分是相对引用，部分是绝对引用。例如:$B2或者 B$2。</p>
<p><strong>注意:相对引用、绝对引用、混合引用相互转化可以用F4。</strong></p>
<p>三维地址引用:Excel中引用单元格时，不仅可以引用同一工作表中的单元格，还可以引用不同工作表中的单元格。格式为:[工作簿]+工作表名!+单元格引用。<br><strong>例如:[Book2]Sheet1!E3，表示工作簿 Book2的Sheetl 工作表的第三行第E列单元格。</strong></p>
<h5 id="设置单元格格式"><a href="#设置单元格格式" class="headerlink" title="设置单元格格式"></a>设置单元格格式</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524090504348.png" alt="image-20240524090504348"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524090508331.png" alt="image-20240524090508331"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524102657735.png" alt="image-20240524102657735"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524090512518.png" alt="image-20240524090512518"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524090516539.png" alt="image-20240524090516539"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524090522115.png" alt="image-20240524090522115"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524090524904.png" alt="image-20240524090524904"></p>
<h5 id="行高和列宽的调整"><a href="#行高和列宽的调整" class="headerlink" title="行高和列宽的调整"></a>行高和列宽的调整</h5><ul>
<li><p>通过拖动鼠标实现</p>
</li>
<li><p>双击分隔线实现<br>双击行号之间的分隔线或列标之间的分隔线，可实现自动调整行高或列宽。</p>
</li>
<li><p>通过对话框实现</p>
<p>如果需要设置更为精确的行高或列宽，在“开始”选项卡的“单元格”组中单击“格式”按钮，在弹出的下拉列表中单击“列宽”或“行高”选项，会弹出“列宽”或“行高”对话框。    </p>
</li>
<li><p>如果要将某一列的列宽复制到其他列中，则选定该列中的单元格，使用“复制”命令，然后选定目标列，在“选择性粘贴”对话框中，单击“列宽”选项，再单击“确定”按钮即可。</p>
</li>
</ul>
<p><strong>同一行的行高相同，同一列的列宽相同。</strong></p>
<h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><h6 id="自动套用格式"><a href="#自动套用格式" class="headerlink" title="自动套用格式"></a>自动套用格式</h6><p>开始-&gt;样式-&gt;套用表格格式</p>
<h6 id="条件格式"><a href="#条件格式" class="headerlink" title="条件格式"></a>条件格式</h6><p>开始-&gt;样式-&gt;条件格式</p>
<h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524154007232.png" alt="image-20240524154007232"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524154035194.png" alt="image-20240524154035194"></p>
<h5 id="批注"><a href="#批注" class="headerlink" title="批注"></a>批注</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524154316767.png" alt="image-20240524154316767"></p>
<p>设置批注的单元格右上角有红色倒立三角</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524154400152.png" alt="image-20240524154400152"></p>
<h5 id="输入和编辑数据"><a href="#输入和编辑数据" class="headerlink" title="输入和编辑数据"></a>输入和编辑数据</h5><p>Excel 2016单元格中可以接受的数据类型有:文本类型(字符、文字)、数字(值)、日期和时间、公式与函数。</p>
<ul>
<li><p>单击输入数据的单元格直接输入  改写</p>
</li>
<li><p>单击单元格，在编辑栏输入   插入</p>
</li>
<li><p>双击单元格   插入</p>
</li>
<li><p>拖动复制：1.使用剪贴板  2.按住ctrl，鼠标指针变为十字空心箭头，拖动</p>
</li>
<li><p>移动剪切：1.使用剪贴板  2.鼠标指针变为十字空心箭头，拖动</p>
</li>
<li><p>选择性粘贴：</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523103657521.png" alt="image-20240523103657521"></p>
</li>
</ul>
<p>word中可以输入的两类数据：常量和公式</p>
<p><strong>执行表格中的数据行列交换，可以使用选择性粘贴的转置进行操作</strong></p>
<h5 id="数据填充"><a href="#数据填充" class="headerlink" title="数据填充"></a>数据填充</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523110205088.png" alt="image-20240523110205088"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523110137636.png" alt="image-20240523110137636"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526171441310.png" alt="image-20240526171441310"></p>
<p>开始-&gt;编辑-&gt;填充-&gt;序列</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523110314195.png" alt="image-20240523110314195"></p>
<p>生成等差数列时可以选中两行直接拖动填充柄</p>
<p>按住右键拖动单元格右下角</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524143100183.png" alt="image-20240524143100183"></p>
<p><strong>输入数据后按enter定位到下方单元格，按tab定位到右边单元格</strong></p>
<h5 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h5><p>数据-&gt;数据工具-&gt;数据验证-&gt;数据验证</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524152017032.png" alt="image-20240524152017032"></p>
<h5 id="数据清除和数据删除"><a href="#数据清除和数据删除" class="headerlink" title="数据清除和数据删除"></a>数据清除和数据删除</h5><p>数据清除指的是清除单元格格式、单元格中的内容及格式、批注、超链接等，单元格身并不受影响。<br>在“开始”选项卡的“编辑”组中,单击“清除”按钮。数据清除后单元格本身“清除批注”、保留在原位置不变。</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523113254718.png" alt="image-20240523113254718"></p>
<p>选定单元格或单元格区域后按Delete键，相当于选择“清除内容”命令,<br>数据删除的对象是单元格、行或列，即单元格、行或列的删除。删除后，选取的单元格行或列连同里面的数据都从工作表中消失。</p>
<h5 id="文本类型"><a href="#文本类型" class="headerlink" title="文本类型"></a>文本类型</h5><p>文本可以是字母、汉字、数字、空格或者其他字符，以及它们的组合，<strong>默认对齐方式左对齐。</strong></p>
<p>把数字作为文本输入:先输人一个半角的单引号‘，再输入相应的字符;</p>
<h5 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h5><p>0-9，+-,./$%eE     <strong>默认右对齐</strong></p>
<p>分数： 前面先输0和一个空格，分数2/3输入“0 2/3”</p>
<p>负数：前面直接输负号，或者数两边添加小括号</p>
<p>直接输入2/3，系统视为日期，2月3日</p>
<p>数字内部使用千分号，不认为是标点符号</p>
<p>在单元格中输人超过11位的数字时,Excel会自动使用科学计数法来显示该数字。比如,在单元格中输人数字“1357 924 681012”,则该数字将显示为“1.35792E+12”。无论显示的数字的位数如何,Excel 2016都只保留15 位的数字精度。如果数字长度超出了15位,则Excel 2016会将多余的数字位转换为0(零)。</p>
<p>在 Excel 2016 中，若一单元格值为 0.05245，使用百分数按钮来格式化，然后连续按两下增加位数按钮，则显示内容为5.25%。为什么?<br>答:连续按两下增加位数按钮，表示小数点保留两位，注意四舍五入。</p>
<h5 id="日期和时间型数据类型"><a href="#日期和时间型数据类型" class="headerlink" title="日期和时间型数据类型"></a>日期和时间型数据类型</h5><p>Excel 2016将日期和时间型数据作为数据处理，<strong>默认对齐方式:右对齐。</strong></p>
<p>日期分隔符:“/”、“_”; 2022-8-16、2022/8/16、16/Aug/2022、16-Aug-2022，都表示2022年8月16日。（顺序或者逆序）</p>
<p>时间分隔符:“:”(冒号)<br>如果仅输人月份和日，Excel2016则将计算机当前内部时钟的年份作为默认值</p>
<p>输入时间:<br>(1)24小时制可以只输入时和分，例如(23:00);也可以只输入小时数和冒号例如(23:);也可以输人一个大于 24的小时数，系统将自动进行转换;</p>
<p>(2)12小时制可以在时间后面输入一个空格，然后输人AM或者PM(也可以是A或者P)，表示上午或下午。例如“3:00AM”表示凌晨3:00，而“3:00PM”则表示下午 3:00,或者 15:00了。注意:“3:AM”的写法不能表示上午 3:00，应修改为“3:00AM”</p>
<p>输入当天日期:&lt;Ctl +;&gt;键。输入当前时间:&lt;Ctl + Shift +;&gt;键。</p>
<h5 id="逻辑型数据"><a href="#逻辑型数据" class="headerlink" title="逻辑型数据"></a>逻辑型数据</h5><p>居中对齐</p>
<h5 id="运算符的种类"><a href="#运算符的种类" class="headerlink" title="运算符的种类"></a>运算符的种类</h5><p>公式中的运算符类型:算术运算符、比较运算符、文本运算符、引用运算符。</p>
<p>算术运算符:十、一、*、/、%、^。用于完成基本的算数运算。</p>
<p>比较运算符:-&gt;=、&lt;=、&lt;&gt;。用于实现两个值的比较，结果是 TRUE或者FALSE，<strong>参加算数运算时</strong>TRUE为1，FALSE为0。</p>
<p>文本运算符:&amp;。用于连接一个或者多个文本数据以产生组合的文本。</p>
<p>单元格引用运算符:<br>冒号:称为区域表示运算符;<br>空格区域交集运算符;<br>逗号，区域并集运算符。</p>
<p>4.在Excel 2016中，如果 A4单元格的值为100，那么公式“=A4&gt;100”的结果是FLASE</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240523175236370.png" alt="image-20240523175236370"></p>
<h5 id="公式和函数"><a href="#公式和函数" class="headerlink" title="公式和函数"></a>公式和函数</h5><p>公式:由参与运算的数据和运算符组成，在输入时必须以“=”开头。函数:Excel 2016 提供了大量内置函数，包括日期和时间函数、数学与三角函数、统计、查找与引用、数据库、文本、逻辑、信息等方面。函数由函数名、括号和参数组成。</p>
<p>参数:可以是数字、文本、形如TRUE或FALSE的逻辑值、数组、形如 #N/A 的错误值MIN或单元格引用。给定的参数必须能产生有效的值。参数也可以是常量、公式或其他函数。</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524085757795.png" alt="image-20240524085757795"></p>
<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>(1)求和函数 SUM:<br>求和函数 SUM 的语法格式为 SUM(numberl,number2,…),其中numberl、number2、……为需要求和的参数。<strong>如果参数为数组或引用,只有其中的数字被计算,数组或引用中的空白单元格逻辑值、文本或错误值将被忽略</strong>。如果参数为错误值或不能转换成数字的文本,将会导致错误。</p>
<p>(2)单条件求和函数SUMIF:<br>SUMIF 函数的语法格式为SUMIF(range,criteria,[sum_range),用于对区域中符合指定条件的值求和。</p>
<p>range参数必选,用于条件计算的单元格区域。每个区域中的单元格都必须是数字或名称、数组或包含数字的引用,空值和文本值将被忽略。</p>
<p>criteria 参数必选,用于确定对哪些单元格求和的条件,其形式可以为数字、表达式、单元格引用、文本或函数。例如,条件可以表示为 32、”&gt;32”、B5、”32”或 TODAY0等。<strong>任何文本条件或任何含有逻辑或数学符号的条件都必须用双引号括起来。</strong>如果条件为数字,则无须使用双引号。</p>
<p>sum range 参数可选,指要求和的实际单元格。如果sum_range参数被省略,Excel会对range 参数中指定的单元格(即应用条件的单元格)求和。</p>
<p>在条件中可以使用通配符,即问号(?)和星号(*)。问号匹配任意单个字符,星号匹配任意一系列字符。若要查找实际的问号或星号,需在该字符前键入波形(~)。条件不区分大小写。</p>
<p>(3)求平均值函数AVERAGE:<br>AVERAGE函数的语法格式为AVERAGE(numberl,number2,…),其中 numberlnumber2、……为要计算平均值的参数。参数可以是数字或涉及数字的名称、数组或引用。如果数组或单元格引用参数中有文字、逻辑值或空白单元格,则忽略其值;如果单元格包含零值,则计算在内。</p>
<p>(4)COUNT函数:<br>COUNT 函数计算包含数字的单元格以及参数列表中数字的个数。使用函数COUNT可以获取区域或数字数组中数字输入项的个数。</p>
<p>例如,若“=COUNT(A1:A20)”的返回值为5,说明该区域中有5个单元格包含数字。</p>
<p>如果参数为数字、日期、逻辑值或者代表数字的文本(例如,加引号的数字,如”1”),则将被计算在内。如果参数为错误值或不能转换为数字的文本,则不会被计算在内。如果参数为数组或引用,则只计算数组或引用中数字的个数,不会计算数组或引用中的空单元格、逻辑值、文本或错误值。</p>
<p>(5)COUNTIF 函数:<br>COUNTIF 为统计区域中满足给定条件单元格个数的函数,其语法格式为COUNTIF(range,criteria),其中range 表示要统计的单元格区域,criteria表示指定的条件表达式,其形式可以为数字、表达式、单元格引用或文本,使用方法可参考 SUMIF 函数。<br>例如,公式“=COUNTIF(G2:G11,”&gt;80”)”用于计算平均分在 80 分以上的人数。</p>
<p>(6)排位函数 RANK:</p>
<p>排位函数 RANK 的语法格式为RANK(number,ref,order),其中number 为需要找到排位的数字,ref为包含一组数字的数组或引用,order 为一数字,用来指明排位的方式。<strong>如果 order 为0或省略,则Excel 将ref当作按降序排列的数据清单进行排位;如果 order 不为零,则Excel将ref当作按升序排列的数据清单进行排位。RANK函数对重复数的排位相同,但重复数的存在将影响后续数值的排位。</strong></p>
<p>例如,公式“=RANK(G2,$G$2:$G$11)”用于计算 G2 单元格中的数据在 G2:G11区域内的排名</p>
<p>(7)MAX、MIN 函数:</p>
<p>MAX、MIN 函数分别用来求解数据集的极值(即最大值、最小值)。函数的语法格式为函数(numberl,number2,…),其中 number1、number2……为需要找出最大数值的参数区域。参数中的空白单元格、逻辑值或文本将被忽略,因此,<strong>如果逻辑值和文本不能忽略,应使用带A的函数MAXA 或者 MINA 来代替</strong></p>
<p>(8)AND、OR 函数:<br>AND、OR函数的语法格式为函数(1ogicall,logical2,…)。<br>对于 AND函数,所有参数的逻辑值为真时,返回 True;只要有一个参数的逻辑值为假,即返回False。对于OR函数,所有参数的逻辑值为假时,返回False;只要有一个参数的逻辑值为真即返回 True。<br>参数必须是逻辑值True或False,或者包含逻辑值的数组或引用。<strong>参数中的文本或空白单元格将被忽略。如果指定的单元格区域内包含非逻辑值,则 AND 将返回错误值 #VALUE!。</strong></p>
<p>(9)IF 函数:</p>
<p>如果指定条件的计算结果为True,则正函数将返回某个值;如果该条件的计算结果为False,则返回另一个值。<br>IF 函数的语法格式为 IF(logical_test,[value_if true],[value if false]),其中logical_test参数为必选,是计算结果可能为True或False的任意值或表达式;value_if true 参数是计算结果为True 时所要返回的值;value_if false 参数是计算结果为 False 时所要返回的值。</p>
<p>(10)取字符串子串函数 LEFT、RIGHT、MID:<br>LEFT、RIGHT、MID 都是字符串提取函数。前两个格式是一样的,只是提取的方向相反LEFT 是从左向右取,RIGHT是从右向左取。<br>LEFT 和 RIGHT 函数的语法格式分别为LEFT(text,num_chars)、RIGHT(text,num_chars).其中第一个参数 text是文本,即包含要提取字符串的文本字符串,可以是一个字符串,或是一个单元格引用。第二个参数numchars 是想要提取的个数。<br>比如,“=LEFT(A1,2)”是从 A1单元格的文本里,从左边第一位开始,向右提取两位。如果A1是“山东高校”,则得到的结果是“山东”。<br>MID 函数的语法格式为 MID(text,start_num,num_chars),也是从左向右提取,但不一定是从第一个起,可以从中间开始。第一个参数是text,它的属性与前面两个函数中的 text是一样的。第二个参数 start_num 是要提取的开始字符,第三个参数 num_chars 是要提取的个数。例如,如果 A1是“山东高校”,则“=MID(A1,3,2)”的结果是“高校”。</p>
<p>(11)VLOOKUP 函数:<br>使用 VLOOKUP函数搜索某个单元格区域的第一列,然后返回该区域相同行上任何单元格中的值。其语法格式为VLOOKUP(lookup_value,table_array,col index_num,[range_lookup])</p>
<p>其中lookup_value 参数必选,表示要在表格或区域的第一列中搜索的值,可以是值或引用。如果为 lookup_value 参数提供的值小于 table_array 参数第一列中的最小值,则 VLOOKUP 将返回错误值 #N/A。</p>
<p>table_array 参数必选,表示包含数据的单元格区域,可以使用对区域(如 A2:D8)或区域名称的引用。table_array 第一列中的值是由 lookup_value 搜索的值,这些值可以是文本、数字或逻辑值。文本不区分大小写。</p>
<p>col_index_num 参数必选,是 table array参数中要返回的匹配值对应的列号。col_index_num 参数为1时,返回 table_array 第一列中的值;col index_num为2时,返回 table_array 第二列中的值,依此类推。如果 col_index_num 参数小于1,则 VLOOKUP 返回错误值 #VALUE!;若大于 table array 的列数,则 VLOOKUP 返回错误值 #REF!。</p>
<p>range_lookup 参数可选,是一个逻辑值,指定希望 VLOOKUP 查找精确匹配值还是近似匹配值:如果 range_lookup 为 True 或被省略,则返回精确匹配值或近似匹配值;如果找不到精确匹配值,则返回小于 lookup_value 的最大值。</p>
<p>如果range_lookup为True 或被省略,则必须按 table_array第一列中的值升序排序;否则VLOOKUP 可能无法返回正确的值。如果range_lookup为False,则不需要对 table_array 第一列中的值进行排序。</p>
<h5 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h5><p><strong>=COUNTIF(A:A,A1)=1</strong></p>
<p><strong>公式含义：</strong>用COUNTIF函数统计当前单元格中的内容在A列中出现的次数，结果等于1，说明输入的内容只出现过一次，否则执行禁止输入。</p>
<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><h5 id="数据清单"><a href="#数据清单" class="headerlink" title="数据清单"></a>数据清单</h5><p>Excel2016的数据清单具有类似数据库的特点，<strong>可以实现数据的排序、筛选分类汇总、统计、查询等操作</strong>，具有数据库的组织、管理和处理数据的功能。具有二维表性质的电子表格在 Excel 2016 中称为“数据清单”，<strong>其中行表示记录、列表示字段</strong>。数据清单需要满足如下条件:</p>
<ul>
<li>(1)第一行必须为文本类型，为相应列的名称;</li>
<li>(2)在第一行的下面是连续的数据区域，每一列包含相同类型的数据;</li>
<li>(3)不允许出现空行和空列;</li>
</ul>
<p>1个数据清单最好占有一个工作表</p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>开始-&gt;编辑-&gt;排序和筛选     <strong>excel中排序条件最多支持64个关键字</strong></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524092924214.png" alt="image-20240524092924214"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524093056384.png" alt="image-20240524093056384"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527150712618.png" alt="image-20240527150712618"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524093147551.png" alt="image-20240524093147551"></p>
<h5 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h5><p>筛选就是将不符合特定条件的行隐藏起来，这样可以更方便用户查看数据。分为自动筛选和高级筛选。<br>(1)自动筛选</p>
<p>筛选结果显示在原数据清单区域</p>
<p><strong>选择“数据”选项卡，在“排序和筛选”组中单击“筛选”按钮</strong>，此时，数据清单中的字段名右侧会出现一个下拉箭头，单击下拉箭头，可设置筛选条件、删除筛选条件或自定义自动筛选条件。<br>在设置自动筛选的自定义条件时，可以使用通配符，其中问号(?)代表任意单个字符星号(*)代表任意一组字符。<br><strong>注意:若多个字段都设置了筛选条件，则多个字段的筛选条件之间是“与”的关系。</strong></p>
<p>(2)高级筛选</p>
<p><strong>先设置一个条件区域，条件区域和数据清单之间要间隔一个以上的空行或空列。单击“排序和筛选”组中的“高级”命令。</strong><br><strong>高级筛选的条件区域至少有两行，第一行是字段名，下面的行放置筛选条件，这里的字段名一定要与数据清单中的字段名完全一致;在条件区域的设置中，</strong></p>
<p>  <em><strong>同一行上的条件认为是“与”条件，而不同行上的条件认为是“或”条件。</strong></em></p>
<ul>
<li>(1)当使用公式作为筛选条件时，条件区域的标行不能使用数据列表的字段名称。标题行可以是其他内容，或者空白。</li>
<li>(2)当条件区域的公式返回逻辑值TRUE时，满足筛选条件。</li>
<li>(3)条件区域设置的公式针对数据列表的第1行数据。注意公式的相对引用和绝对引用。</li>
</ul>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524164538302.png" alt="image-20240524164538302"></p>
<p>1.在Excel 2016中,使用自动筛选功能对某姓名列中自定义筛选条件,要求筛选姓氏为“张的人员数据时，可在筛选条件“等于…”中输入 张*</p>
<p><strong>数字筛选-&gt;自定义筛选</strong></p>
<h5 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h5><p>想冻结第一行和第一列，就点击 B2(第二行第二列单元格)，也就是想冻结第几行第几列就点击下一行下一列的第一个单元格。例如想冻结两行四列，那么点选 E3，再选择“视图’选项卡的“冻结窗格”按钮就可以了!</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524094753873.png" alt="image-20240524094753873"></p>
<h5 id="分类汇总"><a href="#分类汇总" class="headerlink" title="分类汇总"></a>分类汇总</h5><p>数据-&gt;分级显示-&gt;分类汇总</p>
<p>分类汇总是指把<strong>数据清单</strong>中的数据记录先根据一列分类，然后再分别对每一类进行汇总统计。汇总的方式有求和、计数、平均值、最值等。选择“数据”选项卡中的“分类汇总”命令即可进行分类汇总。<br><strong>进行分类汇总之前，必须先进行排序，否则无法实现预期效果。排的依据与分类的依据相同，即按哪个字段分类就按哪个字段对数据进行排序。</strong></p>
<p><strong>分类汇总嵌套时取消替换当前分类汇总</strong></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524095820187.png" alt="image-20240524095820187"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524095941053.png" alt="image-20240524095941053"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524100028900.png" alt="image-20240524100028900"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524100656851.png" alt="image-20240524100656851"></p>
<h5 id="合并计算"><a href="#合并计算" class="headerlink" title="合并计算"></a>合并计算</h5><p>对于放置在不同工作表中，却拥有部分相同行字段或列字段的数据，我们有时需要对他们进行合并统计。按传统的方式，首先我们得把它们复制到同一张工作表，再利用排序、求和、分类汇总等手段进行计算。</p>
<p>excel提供了“合并计算”的功能，可以直接调取多个工作表的数据进行计算。比如分类汇总的功能，要先排序后再进行，而“分并计算”功能可以直接搞定。</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240525140017397.png" alt="image-20240525140017397"></p>
<p>合并方式默认是求和</p>
<p>按类型合并时，数据源必须包含行和列标题，并在标签位置勾选</p>
<p>按位置合并，则不用在标签位置勾选</p>
<h5 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526155155394.png" alt="image-20240526155155394"></p>
<h5 id="获取外部数据"><a href="#获取外部数据" class="headerlink" title="获取外部数据"></a>获取外部数据</h5><h5 id="模拟分析"><a href="#模拟分析" class="headerlink" title="模拟分析"></a>模拟分析</h5><p>方案管理器，模拟运算表  （根据各组的输入值来确定可能的结果）</p>
<p>单变量求解（根据结果来确定可能的输入值）</p>
<h5 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h5><p>数据图表:是将单元格中的数据以各种统计图表的形式显示，以使得数据更直观。图表和建立图表的数据就建立了一种动态链接关系:当工作表中的数据发生改变时，图表中的对应项会自动变化。</p>
<p><strong>工作表中的数据发生变化时，图表中对应项的数据系列自动变化;改变图表中的数据系列时，与系列对应的工作表数据不会发生相应的变化。</strong></p>
<p><strong>图表分两种，一种是嵌入式图表，它和创建图表的数据源放置在同一张工作表中;另一种是独立图表，和数据分开打印。</strong></p>
<p>一个完整的图表通常由图表区、绘图区、图表标题和图例等几大部分组成。</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524170336508.png" alt="image-20240524170336508"></p>
<p><strong>在excel中，某图表和与其生成的数据相连接，当删除该图表中某一序列时  工作表中数据无变化</strong></p>
<ul>
<li>柱形图:柱形图用于显示一段时间内的数据变化或说明各项之间的比较情况，在柱形图中，通常沿横坐标轴组织类别，沿纵坐标轴组织值。</li>
<li>折线图:折线图可以显示随时间而变化的连续数据(根据常用比例设置)因此非常适用于显示在相等时间间隔下数据的趋势。</li>
<li>饼图:仅排列在工作表的一列或一行中的数据可以绘制到饼图中。饼图显示一个数据系列中各项的大小，与各项总和成比例。</li>
<li>条形图:条形图显示各项之间的比较情况。</li>
</ul>
<h6 id="创建图表"><a href="#创建图表" class="headerlink" title="创建图表"></a>创建图表</h6><p>alt+I+H或者单击插入-&gt;图表组的对话框启动器或者单击插入-&gt;图表组</p>
<h6 id="图表编辑"><a href="#图表编辑" class="headerlink" title="图表编辑"></a>图表编辑</h6><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524171329506.png" alt="image-20240524171329506"></p>
<p>改变图表存放位置：</p>
<p>图表工具-&gt;位置-&gt;移动图表    同时它也可以转换嵌入式图表和独立图表</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524171708013.png" alt="image-20240524171708013"></p>
<p>改变数据系列产生的方向：</p>
<p>图表工具-&gt;设计-&gt;数据-&gt;切换行/列    /   图表工具-&gt;设计-&gt;选择数据-&gt;切换行/列</p>
<p>右击图表-&gt;选择数据源-&gt;切换行/列</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524172022766.png" alt="image-20240524172022766"></p>
<p>(6)设置图表标题、坐标轴标题、图例、显示或隐藏数据标签及坐标轴:</p>
<p>单击“图表工具/设计”选项卡“图表布局”组中的“添加图表元素”,可设置图表标题、坐标轴标题、图例及显示或隐藏数据标签等。</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524171339907.png" alt="image-20240524171339907"></p>
<p>(7)改变图表大小:<br>要改变图表的大小,可先选定图表,然后使用下列方法之一:<br>① 将鼠标指针指向图表的四个角之一,当鼠标指针变成双向箭头时,按住左键进行拖动,即可改变图表的大小。<br>②)在“图表工具/格式”选项卡的“大小”组中设置图表的高度和宽度。</p>
<h5 id="迷你图"><a href="#迷你图" class="headerlink" title="迷你图"></a>迷你图</h5><p>折线图 柱形图 盈亏图</p>
<p>创建迷你图时不需要选择标题，只选择一行即可</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524172949436.png" alt="image-20240524172949436"></p>
<h4 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h4><h5 id="分页符"><a href="#分页符" class="headerlink" title="分页符"></a>分页符</h5><p>分页符：页面布局-&gt;页面设置-&gt;分隔符</p>
<p>分页符出现在选中的单元格上方，删除时选中分页符下方的单元格进行删除</p>
<p>只有在分页预览视图下才能调整分页符位置，把分页符调整到打印区域外后，分页符被删除</p>
<p>视图-&gt;工作簿视图-&gt;分页预览</p>
<h5 id="页面设置"><a href="#页面设置" class="headerlink" title="页面设置"></a>页面设置</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524173758131.png" alt="image-20240524173758131"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524173811707.png" alt="image-20240524173811707"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524173819829.png" alt="image-20240524173819829"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524173830236.png" alt="image-20240524173830236"></p>
<h5 id="打印-1"><a href="#打印-1" class="headerlink" title="打印"></a>打印</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524174022971.png" alt="image-20240524174022971"></p>
<h4 id="选项卡"><a href="#选项卡" class="headerlink" title="选项卡"></a>选项卡</h4><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524103635615.png" alt="image-20240524103635615"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524103700773.png" alt="image-20240524103700773"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524113123889.png" alt="image-20240524113123889"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526105741089.png" alt="image-20240526105741089"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526105833281.png" alt="image-20240526105833281"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526105854657.png" alt="image-20240526105854657"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527115206879.png" alt="image-20240527115206879"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527115218551.png" alt="image-20240527115218551"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527115229407.png" alt="image-20240527115229407"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527115237620.png" alt="image-20240527115237620"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526110005537.png" alt="image-20240526110005537"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526110037427.png" alt="image-20240526110037427"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526110106179.png" alt="image-20240526110106179"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526110121360.png" alt="image-20240526110121360"></p>
<h4 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h4><p><strong>1.公式中引用字符串，要加双引号</strong></p>
<p><strong>字符串包括文本、字母、符号以及文本型数值</strong></p>
<p>2.双引号里面什么也没有，在Excel中代表空值、空单元格。</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526111944636.png" alt="image-20240526111944636">excle数组</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240524103540626.png" alt="image-20240524103540626">  </p>
<p>trunc函数的语法为：</p>
<p>trunc（number，number_digits）  没有四舍五入</p>
<p>trunc函数有两个参数：</p>
<p>第一个参数number：指的是需要截尾取整的数字。</p>
<p>第二个参数number_digits：指定取整精度的数字。默认情况下，number_digits的值为0，也就是取整数了。</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526163545323.png" alt="image-20240526163545323"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526163642388.png" alt="image-20240526163642388"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526163701173.png" alt="image-20240526163701173"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240526163711506.png" alt="image-20240526163711506"></p>
<h5 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h5><p>引用【如:=SUM(F13:G14)】中的空白单元格、逻辑值、文本将被忽略，遇到错误值将会提示出错。<br>但 =SUM(1, TRUE,”2”),逻辑值 true 默认为 1,false 默认为 0;”2”自动转换为数值 2。</p>
<h5 id="average"><a href="#average" class="headerlink" title="average"></a>average</h5><p>如果引用区域中包含“0”值单元格，则计算在内;<br>如果引用区域中包含空白或字符、逻辑值的单元格，则不计算在内，遇到错误值将会提示出错。<br>但 =average(1,TRUE,”2”)，逻辑值 true 默认为 1,false 默认为 0:”2”自动转换为数值 2。</p>
<h5 id="count"><a href="#count" class="headerlink" title="count"></a>count</h5><p>实例:如果 A1=90、A2=人数、A3=””、A4=54、A5=36，则公式“=COUNT(A1:A5)”返回3。【文本、空格、逻辑型全部忽略】</p>
<p>但 =count(1,TRUE,”2”)，逻辑值 true 默认为 1，false 默认为 0;”2”自动转换为数值 2。</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527084006282.png" alt="image-20240527084006282"></p>
<h5 id="vlookup"><a href="#vlookup" class="headerlink" title="vlookup"></a>vlookup</h5><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527084828081.png" alt="image-20240527084828081"></p>
<h5 id="mod-被除数，除数"><a href="#mod-被除数，除数" class="headerlink" title="mod(被除数，除数)"></a>mod(被除数，除数)</h5><p>求余数,如果除数为0，那么显示  #div/0</p>
<h5 id="round"><a href="#round" class="headerlink" title="round"></a>round</h5><p>round（6.6445，2）=6.64   按指定的位数对数值进行四舍五入</p>
<h5 id="int"><a href="#int" class="headerlink" title="int"></a>int</h5><p>向下取整为最近的整数</p>
<h5 id="sqrt"><a href="#sqrt" class="headerlink" title="sqrt"></a>sqrt</h5><p>求平方根</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527090213274.png" alt="image-20240527090213274"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527090229088.png" alt="image-20240527090229088"></p>
<h5 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h5><p>简单的说就是可以产生一个 [0,1)之间的随机数函数。</p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ul>
<li><p>excel的三个主要功能：电子表格，图表，数据库</p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527110740900.png" alt="image-20240527110740900"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527111416804.png" alt="image-20240527111416804"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527111624582.png" alt="image-20240527111624582"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528200800616.png" alt="image-20240528200800616"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527112205409.png" alt="image-20240527112205409"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528201355683.png" alt="image-20240527112417438"></p>
</li>
<li></li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527112726534.png" alt="image-20240527112726534"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527113300056.png" alt="image-20240527113300056"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527113636389.png" alt="image-20240527113636389"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527113912987.png" alt="image-20240527113912987"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527114320349.png" alt="image-20240527114320349"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527114414758.png" alt="image-20240527114414758"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527142805952.png" alt="image-20240527142805952"></p>
</li>
<li><p>公式中的运算符类型：算术运算符，比较运算符，文本运算符，引用运算符</p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527143257904.png" alt="image-20240527143257904"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527143448829.png" alt="image-20240527143448829"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527144118851.png" alt="image-20240527144118851"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527144220203.png" alt="image-20240527144220203"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527144749617.png" alt="image-20240527144749617"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527144807944.png" alt="image-20240527144807944"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527145531778.png" alt="image-20240527145531778"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527145749569.png" alt="image-20240527145749569"></p>
</li>
<li><p>excel排序可以按照：列 行 拼音 笔划数</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527150012782.png" alt="image-20240527150012782"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527150026668.png" alt="image-20240527150026668"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527150439485.png" alt="image-20240527150439485"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527150453319.png" alt="image-20240527150453319"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527151038389.png" alt="image-20240527151038389"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527160108858.png" alt="image-20240527160108858"></p>
<p>除了插入页眉页脚也可以通过页面设置</p>
</li>
<li><p>excel不可以将所有工作表隐藏</p>
</li>
<li><p>创建数据透视表默认在新工作表</p>
</li>
<li><p>excel单元格不可以插入图片</p>
</li>
<li><p>数组区域的单元格不可以单独编辑，数组常量不能含有不同长度的行和列</p>
</li>
<li><p>数据库函数都以字母D开头</p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527161733233.png" alt="image-20240527161733233"></p>
</li>
<li><p>自动分页符无法删除，但可以改变位置</p>
</li>
<li><p>工作表中输入的数据分为常量和公式</p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527172954325.png" alt="image-20240527172954325"></p>
</li>
<li><p>运算符顺序：引用 算术  文本  比较</p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527192246807.png" alt="image-20240527192246807"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527193006426.png" alt="image-20240527193006426"></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527194638038.png" alt="image-20240527194638038"></p>
<p><strong>如果插入一条垂直分页符，活动单元格放在第一行a1单元格除外</strong></p>
</li>
<li><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527195125646.png" alt="image-20240527195125646"></p>
</li>
</ul>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527195311577.png" alt="image-20240527195311577"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527200544921.png" alt="image-20240527200544921"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527200550880.png" alt="image-20240527200550880"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527200523988.png"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527201324799.png" alt="image-20240527201324799"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527201625958.png" alt="image-20240527201625958"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527201809529.png" alt="image-20240527201809529"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527202417776.png" alt="image-20240527202417776"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527202431606.png" alt="image-20240527202431606"></p>
<p><strong>插入新行列会影响绝对引用（如果新插入行列在引用地址前）</strong></p>
<ul>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527205401012.png" alt="image-20240527205401012"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527210008337.png" alt="image-20240527210008337"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527211434445.png" alt="image-20240527211434445"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527211631076.png" alt="image-20240527211631076"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527211912914.png" alt="image-20240527211912914"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527212120886.png" alt="image-20240527212120886"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527212623816.png" alt="image-20240527212623816"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527213020739.png" alt="image-20240527213020739"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527213111254.png" alt="image-20240527213111254"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527213642484.png" alt="image-20240527213642484"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527213728112.png" alt="image-20240527213728112"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527213915425.png" alt="image-20240527213915425"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527213954570.png" alt="image-20240527213954570"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527214955613.png" alt="image-20240527214955613"></li>
</ul>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527215436218.png" alt="image-20240527215436218"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527220241478.png" alt="image-20240527220241478"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527220434443.png" alt="image-20240527220434443"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527220705842.png" alt="image-20240527220705842"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527220844108.png" alt="image-20240527220844108"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527220918564.png" alt="image-20240527220918564"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527221158303.png" alt="image-20240527221158303"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527221410328.png" alt="image-20240527221410328"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527222151654.png" alt="image-20240527222151654"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527222346394.png" alt="image-20240527222346394"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240527222407715.png" alt="image-20240527222407715"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528100207554.png" alt="image-20240528100207554"></p>
<p>exCel（圈释无效数据）数据有效性的功能’可以方便查找出错误或不符合条件的数据。</p>
<ul>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528114900732.png" alt="image-20240528114900732"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528115912759.png" alt="image-20240528115912759"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528162857639.png" alt="image-20240528162857639"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528163709805.png" alt="image-20240528163709805"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528163726948.png" alt="image-20240528163726948"></li>
<li></li>
</ul>
<p>打印批注</p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528194255834.png" alt="image-20240528194255834"></p>
<ul>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528194618115.png" alt="image-20240528194618115"></li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528194947856.png" alt="image-20240528194947856"></li>
<li>利用工作表数据建立图表，引用的数据区域是单元格绝对地址</li>
<li><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240528202940400.png" alt="image-20240528202940400"></li>
<li>单元格内的数据：常量和公式</li>
</ul>
<h4 id="真题"><a href="#真题" class="headerlink" title="真题"></a>真题</h4><p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240530192734894.png" alt="image-20240530192734894"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240530192815593.png" alt="image-20240530192815593"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240530192834167.png" alt="image-20240530192834167"><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240530192855611.png" alt="image-20240530192855611"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240530192922102.png" alt="image-20240530192922102"></p>
<p><img src="/2024/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80-excel/image-20240530192944396.png" alt="image-20240530192944396"></p>
]]></content>
      <tags>
        <tag>计算机文化基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机文化基础</title>
    <url>/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240514093859.jpg" alt="微信图片_20240514093859"></p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240514093922.jpg" alt="微信图片_20240514093922"></p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240514093935.jpg" alt="微信图片_20240514093935"></p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240514093948.jpg" alt="微信图片_20240514093948"></p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240514094004.jpg" alt="微信图片_20240514094004"></p>
<ul>
<li><input disabled type="checkbox"> <img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/微信图片_20240514094021.jpg" alt="微信图片_20240514094021" style="zoom:25%;transform: rotate(-90deg);"></li>
</ul>
<h2 id="word"><a href="#word" class="headerlink" title="word"></a>word</h2><ul>
<li><p>模板文件扩展名：.dotx  ，文档文件扩展名：.docx</p>
</li>
<li><p>启动word时，系统自动创建一个名为文档1的新文档</p>
</li>
<li><p>word可以打开html文件</p>
</li>
<li><p>word打开时在normal.dotx模板下创建文档，这个模板使用等线（中文正文）5号字体</p>
</li>
<li><p>第一次保存时无论按保存还是另存为打开的都是另存为对话框</p>
</li>
<li><p>选定文本</p>
<ol>
<li>鼠标直接拖动</li>
<li>鼠标点击起始位置，按住shift点击终止位置</li>
<li>选择一行：鼠标移动到左边选定栏，鼠标指针变为向右的箭头，单击</li>
<li>选择一句：按住ctrl，单击句中的任意位置</li>
<li>选择一段：鼠标移动到左边选定栏，鼠标指针变为向右的箭头，双击   / 或者在段内三击</li>
<li>选择全文：鼠标移动到左边选定栏，鼠标指针变为向右的箭头，三击   /或者在左边选定栏按住ctrl单击鼠标  / ctrl+a  /开始-&gt;编辑-&gt;选择-&gt;全选</li>
<li>通过样式进行选择 ：开始-&gt;编辑-&gt;选择-&gt;选择格式相似的文本</li>
</ol>
</li>
<li><p>剪贴板最多可以保存24次剪切和复制的内容，win10的剪贴板可以存放25次</p>
</li>
<li><p>中文字号初号最大，八号最小，数字字号5磅最小，72最大，用户最大输入1638磅</p>
</li>
<li><p>word拼写和语法检查：审阅-&gt;校对-&gt;拼写和语法</p>
</li>
<li><p>自动更正：文件-&gt;选项-&gt;校对-&gt;自动更正选项   既可以更正字符，也可以更正图形</p>
</li>
<li><p>word2016可以制作web网页</p>
</li>
<li><p>WORD中四大核心技术是<strong>样式、域、宏和模板</strong>。</p>
</li>
<li><p>文章中的段落指的是两个回车符之间的内容，包括回车符</p>
</li>
<li><p>shift+enter 手动换行符，换行但不是新起一段，本质上还是一段</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518113510153.png" alt="image-20240518113510153"></p>
</li>
<li><p>文本打印距离纸边界的距离等于页边距+缩进距离</p>
</li>
<li><p>删除段落标记后两端合为一段后，两端的格式同前一段，字体格式不变</p>
</li>
<li><p>格式刷可以复制项目符号</p>
</li>
<li><p>样式就是多个排版格式组合而成的集合，是一系列预制的排版指令</p>
<p>模板就是由多个特定的样式组合而成，是一种排版编辑文档的基本工具</p>
</li>
<li><p>数学公式在插入-&gt;符号-&gt;公式</p>
<p>右击公式可以更改显示和内嵌两种方式</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518152848835.png" alt="image-20240518152848835"></p>
</li>
<li><p>制表位：左对齐式制表符、居中对齐式制表符、右对齐式制表符、小数点对齐式制表符、竖线对齐式制表符</p>
</li>
<li><p>自动保存可取值范围[1,120]</p>
</li>
<li><p>页眉不可以分栏分节</p>
</li>
<li><p>如果要为文档的不同节设置不同的页眉和页脚，单击功能区导航组的上一节，下一节，并保证链接到前一条页眉选项不选。</p>
</li>
<li><p>新建的样式只适用于当前文档</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519085234465.png"></p>
<p>主题：设计-&gt;文档格式-&gt;主题-&gt;保存当前主题</p>
</li>
<li><p>屏幕截图是嵌入式，此处的截图不借助剪贴板</p>
</li>
<li><p>组合图形 shift  ctrl，必须保证图形为非嵌入式</p>
</li>
<li><p>对图片进行叠放次序需要保证图片是非嵌入式</p>
</li>
<li><p>艺术字可以通过选中文字在开始菜单文字组文本效果和版式命令  变为艺术字</p>
</li>
<li><p>生成目录的前提是生成大纲级别</p>
</li>
<li><p>快速清除格式不能清楚以不同颜色突出文本</p>
</li>
<li><p>页眉可以插入图片</p>
</li>
<li><p>设置字符格式时要先选中字符，如不选中，那么会对插入点及后续输入有效</p>
</li>
<li><p>图片，剪贴画，屏幕截图都是嵌入型，自选图形，艺术字，文本框都是浮于文字上方</p>
</li>
<li><p>页眉默认居中，页脚默认左对齐</p>
</li>
<li><p>保存当前打开的所有文件：快速访问工具栏-&gt;其他命令-&gt;word选项-&gt;全部命令-&gt;全部保存</p>
</li>
<li><p>选择性粘贴：<strong>保留原格式</strong>，<strong>合并格式</strong>，<strong>只保留文本</strong></p>
</li>
<li><p>ole图片插入到文档的方式有插入，链接到文件和插入和链接</p>
</li>
<li><p>新建的样式只能用于当前文档，可以将其保存为模板。</p>
</li>
<li><p>底纹只能设计颜色不能设计图案</p>
</li>
<li><p>把已经打开的多个文档全部显示在屏幕上，单击视图中的全部重排</p>
</li>
</ul>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><ul>
<li>alt+f4 关闭word</li>
<li>ctrl+w  关闭文档窗口不退出应用，word2016中文件选项卡没有退出</li>
<li>ctrl+o/ctrl+f12 打开文件</li>
<li>crtl+s/shift+f12 保存文件</li>
<li>ctrl+n 新建文档</li>
<li>home 快速移到行首 </li>
<li>end 快速移到行末</li>
<li>ctrl+home 移到文档开头</li>
<li>ctrl+end 移到文档末尾</li>
<li>ctrl+k 插入超链接</li>
<li>1.5倍行距的快捷键是ctrl+5</li>
<li>ctrl+y 如果可能，请重做上一个操作。</li>
<li>拆分文档窗口。    Ctrl+Alt+S</li>
<li>撤消拆分文档窗口。    Alt+Shift+C 或 Ctrl+Alt+S</li>
<li>展开或收起功能区。    Ctrl+F1</li>
<li>通过按一个屏幕向上滚动文档视图来移动光标。    Page up</li>
<li>通过将文档视图向下滚动一个屏幕来移动光标。    Page down</li>
<li>将光标移到下一页的顶部。    Ctrl+Page down</li>
<li>将光标移到上一页的顶部。    Ctrl+Page up</li>
<li>要选定插人点所在单元格可按快捷键shift +end</li>
<li>shift+左右光标键 左右方向扩展一个字符</li>
<li>shift+上下光标键 由插入点向上下扩展一行</li>
<li>如果要删除Word文档中选定文本块的格式设置’应按ctrl+shift+z</li>
<li>ctrl+shift+home  从当前位置选定到文档开头</li>
<li>ctrl+shift+end  从当前位置选定到文档结尾</li>
<li>ctrl+a/ctrl+5（小键盘）选择整篇文章</li>
<li>shift+enter 手动换行符，换行但不是新起一段，本质上还是一段</li>
<li>f5  /ctrl+g  定位</li>
<li>ctrl+enter   插入人工分页符，人工分页符可以删除，自动分页符不可以</li>
<li>f9 更新域     ctrl+f9 添加域括号    shift+f9更新域代码为值  </li>
<li>alt+shift+t  插入当前时间     alt+shift+d  插入当前日期 </li>
<li>ctrl+shift+enter 拆分表格   （插入点为新表第一行）</li>
<li>选定插入点所在的单元格   shift+end</li>
<li>f12 另存为</li>
<li>ctrl+shift+h  隐藏文字</li>
<li>ctrl+alt+s  拆分合并视图</li>
<li>ctrl+shift+c  复制格式     ctrl+shift+v   粘贴格式</li>
<li>ctrl+shift+g  字数统计</li>
<li>f7  拼音和语法检查</li>
<li>f1 帮助</li>
<li>页面视图  ctrl+alt+p</li>
<li>shift+home 快选到行首     shift+end  快选到行末</li>
<li>ctrl+shift+z/n 清除文本的段落格式</li>
<li>ctrl+shift+f9  可以取消链接</li>
<li>alt+=   输入公式</li>
<li>切换已经打开的文档   ctrl+f6 / alt+f6</li>
</ul>
<h4 id="选项卡"><a href="#选项卡" class="headerlink" title="选项卡"></a>选项卡</h4><h5 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h5><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240517215621647.png" alt="image-20240517215621647" style="zoom:50%;">

<ul>
<li>word2016中文件选项卡没有退出    </li>
<li>选项-&gt;保存-&gt;自动保存  副本扩展名为.wbk</li>
</ul>
<h6 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h6><p>ctrl+p   /快速访问工具栏-&gt;打印预览和打印（不是快速打印）</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518153331916.png" alt="image-20240518153331916"></p>
<p>页面范围：</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518153409149.png" alt="image-20240518153409149"></p>
<p>保存：<img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518202752290.png" alt="image-20240518202752290"></p>
<h5 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h5><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518110511946.png" alt="image-20240518110511946" style="zoom:50%;">

<h6 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h6><p>单个的带圈字符和文字边框区分：带圈字符放大后会和边框黏连</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519093807542.png" alt="image-20240519093807542"></p>
<img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213138820.png" alt="image-20240519213138820" style="zoom: 50%;">

<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521152543025.png" alt="image-20240521152543025"></p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518112358371.png" alt="image-20240518112358371" style="zoom: 50%;"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518112531299.png" alt="image-20240518112531299" style="zoom:50%;"></p>
<h6 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h6><p>对齐方式：左对齐，右对齐，居中对齐，两端对齐（默认），分散对齐。</p>
<p><strong>两端对齐和左对齐区别看每行最后的字符是否对齐</strong></p>
<img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213247521.png" alt="image-20240519213247521" style="zoom:200%;">

<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518112654622.png" alt="image-20240518112654622" style="zoom:50%;"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518113107499.png" alt="image-20240518113107499"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518113215088.png" alt="image-20240518113215088"></p>
<h6 id="边框和底纹"><a href="#边框和底纹" class="headerlink" title="边框和底纹"></a>边框和底纹</h6><p>开始-&gt;段落-&gt;边框和底纹</p>
<p>页面边框可以添加艺术型边框</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518114051240.png" alt="image-20240518114051240"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518114133660.png" alt="image-20240518114133660"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518114143926.png" alt="image-20240518114143926"></p>
<h6 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h6><p>开始-&gt;编辑-&gt;查找-&gt;高级查找</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518105343354.png" alt="image-20240518105343354"></p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519162558592.png" alt="image-20240519162558592"></p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519162545682.png" alt="image-20240519162545682"></p>
<h6 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h6><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518171528805.png" alt="image-20240518171528805"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518171555368.png" alt="image-20240518171555368"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518171612394.png" alt="image-20240518171612394"></p>
<h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518110531618.png" alt="image-20240518110531618"></p>
<ul>
<li>文本组-&gt;首字下沉</li>
<li>页眉和页脚和页码<ul>
<li>页眉和页脚可以进行文本格式设置和插入图片</li>
<li>页码最小值为0</li>
</ul>
</li>
</ul>
<h6 id="域"><a href="#域" class="headerlink" title="域"></a>域</h6><p>域是隐藏在文档中的由一组特殊代码组成的命令</p>
<p>更新域：</p>
<ol>
<li>右击域，快捷菜单，更新域</li>
<li>f9</li>
</ol>
<p>f9 更新域     ctrl+f9 添加域括号    shift+f9更新域代码为值  </p>
<h6 id="文本框和图文框"><a href="#文本框和图文框" class="headerlink" title="文本框和图文框"></a>文本框和图文框</h6><p><strong>word查找可以查找图文框</strong></p>
<p>文本框：插入-&gt;文本-&gt;文本框</p>
<p>​            文本框可以创建文本框之间的链接，可以做成三维效果（绘图工具-&gt;格式-&gt;形状样式-&gt;形状效果-&gt;三维旋转）</p>
<p>图文框:插入-&gt;插图-&gt;形状</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518152227665.png" alt="image-20240518152227665"></p>
<h6 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h6><p>插入-&gt;插图-&gt;图片</p>
<p>非嵌入式对象：可以放到任意位置，允许和其他对象组合</p>
<p>嵌入式对象：只能在有文档插入点的地方，不能和其他对象组合</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518151002485.png" alt="image-20240518151002485"></p>
<p><strong>插入图片的方式：</strong></p>
<p>插入：图片成为文档的一部分，和原图片没关系</p>
<p>链接到文件：当原始图片位置被移动或者图片被重命名时，不显示图片</p>
<p>插入和链接：当图片发生变化时，图片可以更新，图片找不到时会显示最后一版</p>
<h6 id="艺术字"><a href="#艺术字" class="headerlink" title="艺术字"></a>艺术字</h6><p>艺术字默认为非嵌入式</p>
<h6 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h6><p>组合图形：</p>
<ol>
<li>按住shift依次单击</li>
<li>选中图形后右键快捷菜单选择组合，/绘图工具-&gt;排列-&gt;组合</li>
</ol>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518151820643.png" alt="image-20240518151820643"></p>
<p>位置：</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518151937321.png" alt="image-20240518151937321"></p>
<h6 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h6><p>插入-&gt;插图-&gt;图表</p>
<p>可以自动更新数据</p>
<p>对象的链接：被链接的信息存在源文件中，链接信息会自动更新</p>
<p>对象的嵌入：嵌入的对象在目标文件中，不会更新</p>
<h5 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518165432384.png" alt="image-20240518165432384"></p>
<p>页面背景-&gt;页面颜色-&gt;填充效果</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519203707274.png" alt="image-20240519203707274"></p>
<h5 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518114708852.png" alt="image-20240518114708852"></p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521154120981.png" alt="image-20240521154120981"></p>
<p>word分栏最多可以分为11栏</p>
<h6 id="页面设置"><a href="#页面设置" class="headerlink" title="页面设置"></a>页面设置</h6><p>页边距：自定义页边距大小，设置装订线的位置，设置纸张的方向</p>
<p>纸张：设置纸张大小</p>
<p>版式：设置节的起始位置，页眉，页脚相关参数，页面的垂直对齐方式</p>
<p>文档网格：设置文字的排列方向，每页的行数，每行的字符数</p>
<p>装订线位置：左 上</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518153527963.png" alt="image-20240518153527963"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518153540372.png" alt="image-20240518153540372"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518153551021.png" alt="image-20240518153551021"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518153600847.png" alt="image-20240518153600847"></p>
<p>页边距的内侧和外侧，，左和右</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519110420906.png" alt="image-20240519110420906"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519110501236.png" alt="image-20240519110501236"></p>
<p>布局-&gt;页面设置-&gt;版式-&gt;垂直对齐方式</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519110820112.png" alt="image-20240519110820112"></p>
<h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518164725453.png" alt="image-20240518164725453"></p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519162339121.png" alt="image-20240519162339121"></p>
<h5 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519093057425.png" alt="image-20240519093057425"></p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519162835973.png" alt="image-20240519162835973"></p>
<p>邮件合并：创建主文挡，设置数据源，插入合并域，邮件合并</p>
<h5 id="审阅"><a href="#审阅" class="headerlink" title="审阅"></a>审阅</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518154314077.png" alt="image-20240518154314077"></p>
<p>批注：对某项内容进行注释，并且注释不会出现在文档中</p>
<p>修订：让文档作者跟踪多位审阅者对文档做的修改。</p>
<h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518110601071.png" alt="image-20240518110601071"></p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519210910657.png" alt="image-20240519210910657"></p>
<ul>
<li><p>页面视图：默认视图，所见即所得，页和页有明显的分割线，可以编辑页眉和页脚，调整页边距，处理分栏和编辑图形图像</p>
</li>
<li><p>阅读视图：分左右两栏（不是分栏操作），功能区元素被隐藏，可以看到分栏效果</p>
</li>
<li><p>web版式视图：以网页形式显示文档，适用于创建网页，没有分栏,可以适应窗口大小自动换行显示文本</p>
</li>
<li><p>大纲视图：没有分栏，查看大纲，不显示页边距，页眉，页脚，图片，背景</p>
</li>
<li><p>草稿：最节省计算机资源，只显示标题和正文，不显示页边距，页眉和页脚，背景，图片，分栏。</p>
<p>草稿视图是适合文本录入和编辑的视图，文档满一页时，出现一条虚线</p>
</li>
</ul>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ol>
<li>显示水平标尺：                                    草稿，页面，web版式</li>
<li>显示分栏，页眉，页脚：                     页面，阅读,打印预览</li>
<li>分页符：                                                草稿，页面</li>
<li>网格线：                                                页面视图</li>
</ol>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518214616651.png" alt="image-20240518214616651"></p>
<h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518143944462.png" alt="image-20240518143944462"></p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518143928185.png" alt="image-20240518143928185"></p>
<h6 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h6><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519204037521.png" alt="image-20240519204037521"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519204044941.png" alt="image-20240519204044941"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519204053965.png" alt="image-20240519204053965"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519204058991.png" alt="image-20240519204058991"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519204101801.png" alt="image-20240519204101801"></p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521154636315.png" alt="image-20240521154636315"></p>
<h6 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h6><p>插入-&gt;表格</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518142832104.png" alt="image-20240518142832104"></p>
<ol>
<li>使用虚拟表格创建10列8行</li>
<li>使用插入表格对话框：63列*32767行</li>
</ol>
<h6 id="选定表格"><a href="#选定表格" class="headerlink" title="选定表格"></a>选定表格</h6><ol>
<li>单元格：鼠标移入单元格内部左侧，指针变为向右的黑色箭头，单击。此时按住鼠标左键拖动可以选定多个单元格</li>
<li>表行：鼠标移到左选定栏，指针变为向右的箭头，单击选择一行，按住左键向上向下拖动可以选定多行</li>
<li>表列：鼠标移到表格顶端，指针变为向下的黑色箭头，单击可以选择某一列，按住鼠标左键向左向右拖动可以选择多列。</li>
<li>矩形块：从矩形块的左上角拖动到右下角</li>
<li>整个表格：鼠标移动到表格内，表格左上角的按钮就是全选，使用ctrl+a不行。</li>
<li>表格工具-&gt;布局-&gt;表-&gt;选择   （可以选单元格，列，行，表格）</li>
</ol>
<h6 id="表格居中"><a href="#表格居中" class="headerlink" title="表格居中"></a>表格居中</h6><ol>
<li><p>表格属性-&gt;对齐方式</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518155004043.png" alt="image-20240518155004043"></p>
</li>
<li><p>选中整个表格后，开始-&gt;段落-&gt;居中</p>
</li>
</ol>
<h6 id="行高和列宽"><a href="#行高和列宽" class="headerlink" title="行高和列宽"></a>行高和列宽</h6><p>表格工具-&gt;布局-&gt;表-&gt;属性    /  右键某个单元格选择表格属性</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518154757110.png" alt="image-20240518154757110"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518154814025.png" alt="image-20240518154814025"></p>
<h6 id="插入行和列"><a href="#插入行和列" class="headerlink" title="插入行和列"></a>插入行和列</h6><ol>
<li><p>选中一行或者多行，点击表格工具-&gt;布局-&gt;行和列</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518143959123.png" alt="image-20240518143959123"></p>
</li>
<li><p>选中行和列后右击，快捷菜单插入</p>
</li>
<li><p>在末尾插入新行：最后一个单元格内按tab，最后一个单元格外按tab，enter</p>
</li>
</ol>
<h6 id="删除行和列"><a href="#删除行和列" class="headerlink" title="删除行和列"></a>删除行和列</h6><ol>
<li><p>右击要删除的行和列，快捷菜单删除</p>
</li>
<li><p>点击表格工具-&gt;布局-&gt;行和列-&gt;删除  （单元格，行，列，表格）</p>
</li>
<li><p>选中后右键剪切  </p>
</li>
<li><p>删除单元格 </p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519085856470.png" alt="image-20240519085856470"></p>
</li>
</ol>
<h6 id="拆分和合并"><a href="#拆分和合并" class="headerlink" title="拆分和合并"></a>拆分和合并</h6><p>点击表格工具-&gt;布局-&gt;合并 </p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518144706371.png" alt="image-20240518144706371"></p>
<p>快捷键： ctrl+shift+enter  （选中的行为第二个表格的第一行）</p>
<p>表格拆分后当前行会变成新表格的首行</p>
<p>要把拆分的表格合并，保证两个合并表格没有文字环绕，然后把中间的段落标记删除，</p>
<p>或者选中下面的表格 shift+alt+上方向键 （这种方式只是让他们靠在一起，还是2个表格）</p>
<p>delete删除表格内容，backspace删除表格</p>
<h6 id="表格格式化"><a href="#表格格式化" class="headerlink" title="表格格式化"></a>表格格式化</h6><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518145708340.png" alt="image-20240518145708340"></p>
<p>水平：两端对齐，居中对齐，右对齐</p>
<p>垂直: 靠上，中部，靠下</p>
<p><strong>表格中的域不会自动更新</strong></p>
<p>表格工具-&gt;布局-&gt;单元格大小-&gt;自动调整</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519111633308.png" alt="image-20240519111633308"></p>
<p>根据窗口自动调整表格会根据页面的大小进行自动扩张和缩小表格</p>
<h6 id="文字和表格的转换"><a href="#文字和表格的转换" class="headerlink" title="文字和表格的转换"></a>文字和表格的转换</h6><p>插入-&gt;表格-&gt;将文字转换成表格</p>
<p>表格工具-&gt;布局-&gt;数据-&gt;转换为文本</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518150106909.png" alt="image-20240518150106909"></p>
<p>排序时只可以选择3个关键字</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518150332594.png" alt="image-20240518150332594"></p>
<h5 id="绘图工具-格式-（艺术字，文本框）"><a href="#绘图工具-格式-（艺术字，文本框）" class="headerlink" title="绘图工具/格式  （艺术字，文本框）"></a>绘图工具/格式  （艺术字，文本框）</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519113522259.png" alt="image-20240519113522259"></p>
<h5 id="图片工具-格式-（图片）"><a href="#图片工具-格式-（图片）" class="headerlink" title="图片工具/格式   （图片）"></a>图片工具/格式   （图片）</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519113554342.png" alt="image-20240519113554342"></p>
<h5 id="公式工具-设计"><a href="#公式工具-设计" class="headerlink" title="公式工具/设计"></a>公式工具/设计</h5><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519113819697.png" alt="image-20240519113819697"></p>
<h4 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h4><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518173555836.png" alt="image-20240518173555836"></p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518173607174.png" alt="image-20240518173607174"></p>
<p>字数统计：字符（空格） 字符 字 行  段落  页   中文字符和朝鲜语   非中文单词     （还可以选择是否包括文本框 脚注，尾注）</p>
<h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><ol>
<li><p>在书籍杂志的排版中，为了将页边距根据页面的内测，外侧进行设置，可以将页面设置为  对称页边距</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518162954787.png" alt="image-20240518162954787"></p>
</li>
<li><p>word2016中，默认的汉字字号是   等线（中文正文）五号</p>
</li>
<li><p>自动更正</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518163252553.png" alt="image-20240518163252553"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518163327750.png" alt="image-20240518163327750"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518163350570.png" alt="image-20240518163350570"></p>
</li>
<li><p>艺术字对象实际上是文字对象也是图形对象</p>
</li>
<li><p>审阅选项卡可以对不同版本的文档进行比较和合并</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518163840318.png" alt="image-20240518163840318"></p>
</li>
<li><p>表格  自动调整操作  表格工具-&gt;布局-&gt;单元格大小 </p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518164038212.png" alt="image-20240518164038212"></p>
</li>
<li><p>索引和书目不是通过标记引用项所在位置生成目录</p>
</li>
<li><p>文档模板中可以包括：样式，快捷键，页面设置信息，宏方案项，工具栏</p>
</li>
<li><p>word2016中，将图片作为字符来移动的版式是嵌入式</p>
</li>
<li><p>忘记了word2016文件的打开权限密码，则无法打开</p>
</li>
<li><p><strong>word文档三种加密方法</strong></p>
<p>​        打开密码：只有输对密码才能查看内容  信息-&gt;保护文档-&gt;用密码进行加密</p>
<p>​        限制编辑: 只能查看         审阅-&gt;保护-&gt;限制编辑</p>
<p>​        只读模式：编辑输密码，也可以只读     文件-&gt;另存为-&gt;工具-&gt;常规选项</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518171000958.png" alt="image-20240518171000958"></p>
</li>
<li><p>水印命令在设计-&gt;页面背景</p>
</li>
<li><p>alt+shift+t  插入当前时间     alt+shift+d  插入当前日期 </p>
</li>
<li><p>主文挡</p>
</li>
<li><p>翻译在 审阅-&gt;语言</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518165906282.png" alt="image-20240518165906282"></p>
</li>
<li><p>草稿视图中，多栏文本将显示为较窄的一栏</p>
</li>
<li><p>导航窗格可以浏览文档中的关键文字和词，没有脚注，尾注，题注</p>
</li>
<li><p>拼音指南的作用是给汉字添加汉语拼音</p>
</li>
<li><p>师大93</p>
</li>
<li><p>紧密型环绕：真环绕    四周型环绕：方块空白，矩形环绕</p>
</li>
<li><p>页码可以插入在页眉，页脚，左右页边距，当前位置</p>
</li>
<li><p>表格的单元格中可以添加表格，表格也可以添加在页眉</p>
</li>
<li><p>word在添加参考文献的源主列表时，可以来自  网络中知名网站，计算机的其他文档，自己录入</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518171241185.png" alt="image-20240518171241185"></p>
</li>
<li><p>段前间距最小值是   -0.2</p>
</li>
<li><p>布局可以设置段落的缩进和间距</p>
</li>
<li><p>word最大的缩放比例是 500%</p>
</li>
<li><p>改变文本框的文字方向可实现横排竖排的转换</p>
</li>
<li><p>同义词库可以帮助用户查找不熟悉单词的近义替换词</p>
</li>
<li><p>word两个单元格合并会保存所有内容</p>
</li>
<li><p>分布列和分布行 在所选列或行之间平均分布</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518174629816.png" alt="image-20240518174629816"></p>
</li>
<li><p>文字转表格，转换时行数根据文字行来确定</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518174819696.png" alt="image-20240518174819696"></p>
</li>
<li><p>带圈字符可以给字符加上</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518200324139.png" alt="image-20240518200324139"></p>
</li>
<li><p>隐藏文字  选中 开始-&gt;文字-&gt;隐藏 / ctrl+shift+h</p>
<p>隐藏的文字打印的时候不显示</p>
</li>
<li><p>拆分窗口</p>
<p>ctrl+alt+s</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518201503232.png" alt="image-20240518201503232"></p>
</li>
<li><p>重复标题行只能修改第一页的标题行，其他页面随着变</p>
</li>
<li><p>打印预览时不可以全屏显示</p>
</li>
<li><p>审阅-&gt;翻译   翻译文档，所选文字，屏幕提示</p>
</li>
<li><p>组织结构图，bmp图形，图像文档，写字板文档都可以插入word文档</p>
</li>
<li><p>另一种设置分栏的办法</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518203004496.png" alt="image-20240518203004496"></p>
</li>
<li><p>页码最小起始值是0</p>
</li>
<li><p>word默认样式可以修改不能删除</p>
</li>
<li><p>页面设置可以设置每一页的行数</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518203313753.png" alt="image-20240518203313753"></p>
</li>
<li><p>可以为创建的样式指定快捷键</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518203438029.png" alt="image-20240518203438029"></p>
</li>
<li><p>word中如果删除了某个分节符，其前面的文字将合并到后边的节中，并且采用前者的格式</p>
</li>
<li><p>在文档中点击构建基块库中已有的文档部件，会出现构建基块框架</p>
<p>插入-&gt;文本-&gt;文档部件</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518204156152.png" alt="image-20240518204156152"></p>
</li>
<li><p>草稿视图只能看到标题和正文</p>
</li>
<li><p>批注可以设置打印，也可以设置不打印</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518205245527.png" alt="image-20240518205245527"></p>
</li>
<li><p>dotx 模板格式    dotm  启用宏的模板格式</p>
</li>
<li><p>文章的任何位置都可以通过运用tc域标记为目录项后建立目录</p>
</li>
<li><p>在一个段落中只有开始的一行才可以加上项目符号和编号</p>
</li>
<li><p>复制的文本，可以粘贴为图片</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518210121446.png" alt="image-20240518210121446"></p>
</li>
<li><p>word的工具栏也可以在功能区下方显示</p>
</li>
<li><p>书签名字可以以字母，数字，汉字开头，可以有空格，下划线</p>
</li>
<li><p>英文字母大小写相互转换</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518212004648.png" alt="image-20240518212004648"></p>
</li>
<li><p>标尺上的移动表格列可以改变表格的宽度，调整表格行可以改变表格的高度</p>
</li>
<li><p>选定文本后会出现悬浮工具栏可以对字体进行快速设置</p>
</li>
<li><p>艺术字居中</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518212844251.png" alt="image-20240518212844251"></p>
</li>
<li><p>脚注和尾注可以相互转换</p>
</li>
<li><p>图片工具</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518213122009.png" alt="image-20240518213122009"></p>
</li>
<li><p>页边距的设置必定影响当前页，<strong>错误</strong></p>
</li>
</ol>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519084247549.png" alt="image-20240519084247549"></p>
<ol>
<li><p>公式工具选项卡不能通过插入-&gt;文本-&gt;对象这种方式打开，这种方式只是插入了一个公式</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519090801663.png" alt="image-20240519090801663"></p>
</li>
<li><p>word的页眉页脚不能设置文字方向，可以设置对齐方式，字符的字形，字号，设置页码格式</p>
<p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519170314629.png" alt="image-20240519170314629"></p>
</li>
<li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519171834190.png" alt="image-20240519171834190"></p>
</li>
<li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519173447431.png" alt="image-20240519173447431"></p>
</li>
<li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519173757852.png" alt="image-20240519173757852"></p>
</li>
<li><p>把剪贴板重大1内容粘贴到文档的插入点位置后，剪贴板的内容将继续存在</p>
</li>
<li><p>对象被链接后，如果更改源文件的数据，链接信息会自动更新</p>
</li>
<li></li>
<li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519211105053.png" alt="image-20240519211105053"></p>
</li>
<li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519211145166.png" alt="image-20240519211145166"></p>
</li>
<li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519211355670.png" alt="image-20240519211355670"></p>
</li>
<li><p>!(./计算机文化基础/image-20240519213016737.png)<img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521152018461.png"></p>
</li>
<li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521152712830.png" alt="image-20240521152712830"></p>
</li>
<li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213328518.png" alt="image-20240519213328518" style="zoom:200%;"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521153445529.png" alt="image-20240521153445529"></p>
</li>
<li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521153851150.png" alt="image-20240521153851150"></p>
</li>
<li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213458503.png" alt="image-20240519213458503"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521154257890.png" alt="image-20240519213528668"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213554342.png" alt="image-20240519213554342"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213611072.png" alt="image-20240519213611072"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213630012.png" alt="image-20240519213630012"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521155727399.png" alt="image-20240521155727399"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213707800.png" alt="image-20240519213707800"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240521160256431.png" alt="image-20240521160256431"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213727642.png" alt="image-20240519213727642"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213745659.png" alt="image-20240519213745659"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213813060.png" alt="image-20240519213813060"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213827123.png" alt="image-20240519213827123"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213842864.png" alt="image-20240519213842864"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213407496.png" alt="image-20240519213407496" style="zoom:200%;"></p>
</li>
<li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240519213427021.png" alt="image-20240519213427021"></p>
</li>
<li><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518213517783.png" alt="image-20240518213517783" style="zoom:200%;"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518213612322.png" alt="image-20240518213612322" style="zoom:200%;"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240518213718804.png" alt="image-20240518213718804" style="zoom:200%;"></p>
</li>
</ol>
<h4 id="考试题"><a href="#考试题" class="headerlink" title="考试题"></a>考试题</h4><p><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240523085253724.png" alt="image-20240523085253724"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240523085341111.png" alt="image-20240523085341111"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240523085402021.png" alt="image-20240523085402021"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240523085420397.png" alt="image-20240523085420397"><img src="/2024/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E5%8C%96%E5%9F%BA%E7%A1%80/image-20240523085444395.png" alt="image-20240523085444395"></p>
]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm</title>
    <url>/2024/03/01/Algorithm/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><img src="/2024/03/01/Algorithm/image-20240301155400055.png" alt="image-20240301155400055"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sunny on 24.03.01.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">10</span>; ++a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">10</span>; ++b) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">10</span>; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a*<span class="number">100</span>+b*<span class="number">10</span>+c+b*<span class="number">100</span>+c*<span class="number">10</span>+c==<span class="number">532</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img src="/2024/03/01/Algorithm/image-20240302144945929.png" alt="image-20240302144945929"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sunny on 24.03.02.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">10</span>; ++a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt;<span class="number">10</span> ; ++b) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">10</span>; ++c) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; <span class="number">10</span>; ++d) &#123;</span><br><span class="line">                    <span class="keyword">if</span>((a*<span class="number">1000</span>+b*<span class="number">100</span>+c*<span class="number">10</span>+d)*<span class="number">9</span>==(d*<span class="number">1000</span>+c*<span class="number">100</span>+b*<span class="number">10</span>+a))</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,a,b,c,d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2024/03/01/Algorithm/image-20240302145553655.png" alt="image-20240302145553655"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sunny on 24.03.02.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isreserves</span><span class="params">(<span class="type">int</span> sum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> sum=i*i;</span><br><span class="line">        <span class="type">int</span> reserves=isreserves(sum);</span><br><span class="line">        <span class="keyword">if</span>(i*i==reserves)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d的平方为%d,他的逆序数是%d\n&quot;</span>,i,i*i,reserves);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isreserves</span><span class="params">(<span class="type">int</span> sum)</span>&#123;</span><br><span class="line">    <span class="type">int</span> reserves=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sum!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> remain=sum%<span class="number">10</span>;</span><br><span class="line">        reserves=reserves*<span class="number">10</span>+remain;</span><br><span class="line">        sum=sum/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reserves;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2024/03/01/Algorithm/image-20240302154133137.png" alt="image-20240302154133137"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sunny on 24.03.02.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入梯形的高度:&quot;</span>);</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (num-i<span class="number">-1</span>)*<span class="number">2</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num+i*<span class="number">2</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb</title>
    <url>/2024/02/11/javaweb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="serlet"><a href="#serlet" class="headerlink" title="serlet"></a>serlet</h1><h2 id="tomcat安装"><a href="#tomcat安装" class="headerlink" title="tomcat安装"></a>tomcat安装</h2><p>解压安装包后配置环境变量：<br>CATALINA_HOME：tomcat根地址<br>JAVA_HOME：java根地址<br>path：CATALINA_HOME/bin   JAVA_HOME/bin</p>
<p><strong>配置成功后地址</strong>:<em><strong><a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></strong></em><br>cmd命令开启关闭:<br>开启服务器:startup.bat<br>关闭服务器:shutdown.bat</p>
<h2 id="协议规范"><a href="#协议规范" class="headerlink" title="协议规范"></a>协议规范</h2><p><img src="/2024/02/11/javaweb/%E5%8D%8F%E8%AE%AE.png" alt="?"></p>
<h2 id="测识程序"><a href="#测识程序" class="headerlink" title="测识程序"></a>测识程序</h2><p>将程序放入tomcat根目录下webapps目录下某个程序名文件夹下:<br><em><strong>CATALINA_HOME/webapps/程序名/</strong></em></p>
<p>测识程序地址：<em><strong><a href="https://github.com/codecodegogogo/javaweb/tree/main/hello">https://github.com/codecodegogogo/javaweb/tree/main/hello</a></strong></em></p>
<h3 id="控制台乱码"><a href="#控制台乱码" class="headerlink" title="控制台乱码"></a>控制台乱码</h3><p>将tomcat\conf\logging.properties中java.util.logging.ConsoleHandler.encoding<br>更改为java.util.logging.ConsoleHandler.encoding = GBK</p>
<h2 id="开发一个带有Servlet的webapp"><a href="#开发一个带有Servlet的webapp" class="headerlink" title="开发一个带有Servlet的webapp"></a>开发一个带有Servlet的webapp</h2><ol>
<li><p>第一步:在webapps目录下新建一个目录，起名crm(这个crm就是webapp的名字)。当然，也可以是其它项目，比如银行项目，可以创建一个目录bank，办公系统可以创建一个oa。注意: crm就是这个webapp的根</p>
</li>
<li><p>第二步: 在webapp的根下新建一个目录: WEB-INF注意: 这个目录的名字是Servlet规范中规定的，必须全部大写，必须一模一样。</p>
</li>
<li><p>第三步: 在WEB-INF目录下新建一个目录: classes,注意:这个目录的名字必须是全部小写的classes，这也是Servlet规范中规定的。另外这个目录下一定存放的是/ava程序编译之后的class文件 (这里存放的是字节码文件)。</p>
</li>
</ol>
<p>4.<br> 第四步:在WEB-INF目录下新建一个目录：lib</p>
<p>注意：这个目录不是必须的。但如果一个webapp需要第三方的jar包的话，这个jar包要放到这个lib目录下，这个目录的名字也不能随意编写，必须是全部小写的lib。例如java语言连接数据库需要数据库的驱动jar包。那么这个jar包就一定要放到lib目录下。这Servlet规范中规定的。</p>
<p>5.<br> 第五步：在WEB-INF目录下新建一个文件：web.xml</p>
<p>注意：这个文件是必须的，这个文件名必须叫做web.xml。这个文件必须放在这里。一个合法的webapp，web.xml文件是必须的，这个web.xml文件就是一个配置文件，在这个配置文件中描述了请求路径和Servlet类之间的对照关系。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">metadata-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>第六步：编写一个Java程序，这个小Java程序也不能随意开发，这个小java程序必须实现Servlet接口。</li>
</ol>
<p>这个Servlet接口不在JDK当中。（因为Servlet不是JavaSE了。Servlet属于JavaEE，是另外的一套类库。）</p>
<p>Servlet接口（Servlet.class文件）是Oracle提供的。（最原始的是sun公司提供的。）</p>
<p>Servlet接口是JavaEE的规范中的一员。</p>
<p>Tomcat服务器实现了Servlet规范，所以Tomcat服务器也需要使用Servlet接口。Tomcat服务器中应该有这个接口，Tomcat服务器的CATALINA_HOME\lib目录下有一个servlet-api.jar，解压这个servlet-api.jar之后，你会看到里面有一个Servlet.class文件。</p>
<p>重点：从JakartaEE9开始，Servlet接口的全名变了：jakarta.servlet.Servlet<br><strong>注意：编写这个Java小程序的时候，java源代码你愿意在哪里就在哪里，位置无所谓，你只需要将java源代码编译之后的class文件放到classes目录下即可。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.Servlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5个方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request,ServletResponse response)</span></span><br><span class="line">		<span class="keyword">throws</span> ServletException , IOException&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 向控制台打印输出</span></span><br><span class="line">		System.out.println(<span class="string">&quot;My First Servlet, Hello Servlet&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置响应的内容类型是普通文本或html代码</span></span><br><span class="line">		<span class="comment">// 需要在获取流对象之前设置，有效。</span></span><br><span class="line">		<span class="comment">//response.setContentType(&quot;text/html&quot;);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 怎么将一个信息直接输出到浏览器上？</span></span><br><span class="line">		<span class="comment">// 需要使用ServletResponse接口：response</span></span><br><span class="line">		<span class="comment">// response表示响应：从服务器向浏览器发送数据叫做响应。</span></span><br><span class="line">		<span class="comment">//PrintWriter out = response.getWriter();</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 设置响应的内容类型时不要在获取流之后设置。</span></span><br><span class="line">		<span class="comment">//response.setContentType(&quot;text/html&quot;);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//out.print(&quot;Hello Servlet, You are my first servlet!&quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">		<span class="comment">// 浏览器是能够识别html代码的，那我们是不是应该输出一段HTML代码呢？</span></span><br><span class="line">		<span class="comment">//out.print(&quot;&lt;h1&gt;hello servlet，你好Servlet&lt;/h1&gt;&quot;);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这是一个输出流，负责输出字符串到浏览器</span></span><br><span class="line">		<span class="comment">// 这个输出流不需要我们刷新，也不需要我们关闭，这些都由Tomcat来维护。</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//out.flush();</span></span><br><span class="line"><span class="comment">		//out.close();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>第七步：编译我们编写的HelloServlet</li>
</ol>
<p>重点：你怎么能让你的HelloServlet编译通过呢？配置环境变量CLASSPATH</p>
<p>CLASSPATH=apache-tomcat-10.0.12\lib\servlet-api.jar</p>
<p>思考问题：以上配置的CLASSPATH和Tomcat服务器运行有没有关系？</p>
<p>没有任何关系，以上配置这个环境变量只是为了让你的HelloServlet能够正常编译生成class文件。</p>
<p>8.<br>第八步：将以上编译之后的HelloServlet.class文件拷贝到WEB-INF\classes目录下。</p>
<p>9.<br>第九步：在web.xml文件中编写配置信息，让“请求路径”和“Servlet类名”关联在一起。</p>
<p>这一步用专业术语描述：在web.xml文件中注册Servlet类。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee</span></span></span><br><span class="line"><span class="string"><span class="tag">                      https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">metadata-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--servlet描述信息--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--任何一个servlet都对应一个servlet-mapping --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>fdsafdsagfdsafdsa<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--这个位置必须是带有包名的全限定类名--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--servlet映射信息--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--这个也是随便的，不过这里写的内容要和上面的一样。--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>fdsafdsagfdsafdsa<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--这里需要一个路径--&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--这个路径唯一的要求是必须以 / 开始--&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--当前这个路径可以随便写--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/fd/fd<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>11.<br>第十一步：打开浏览器，在浏览器地址栏上输入一个url，这个URL必须是：</p>
<p><a href="http://127.0.0.1:8080/crm/fd/fd">http://127.0.0.1:8080/crm/fd/fd</a><br><strong>注意class文件的包名路径</strong><br>非常重要的一件事：浏览器上的请求路径不能随便写，这个请求路径必须和web.xml文件中的url-pattern一致。<br>注意：浏览器上的请求路径和web.xml文件中的url-pattern的唯一区别就是：浏览器上的请求路径带项目名：/crm<br>浏览器上编写的路径太复杂，可以使用超链接。（非常重要：html页面只能放到WEB-INF目录外面。）</p>
<p>以后不需要我们编写main方法了。tomcat服务器负责调用main方法，Tomcat服务器启动的时候执行的就是main方法。我们javaweb程序员只需要编写Servlet接口的实现类，然后将其注册到web.xml文件中，即可。</p>
<h2 id="向浏览器输出信息"><a href="#向浏览器输出信息" class="headerlink" title="向浏览器输出信息"></a>向浏览器输出信息</h2><p>javac -d . *.java<br><strong>编译生成多级目录结构的class文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.Servlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5个方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request,ServletResponse response)</span></span><br><span class="line">		<span class="keyword">throws</span> ServletException , IOException&#123;</span><br><span class="line"></span><br><span class="line">		response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 怎么将一个信息直接输出到浏览器上？</span></span><br><span class="line">		<span class="comment">// 需要使用ServletResponse接口：response</span></span><br><span class="line">		<span class="comment">// response表示响应：从服务器向浏览器发送数据叫做响应。</span></span><br><span class="line">		<span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">		out.print(<span class="string">&quot;&lt;h1&gt;hello servlet，你好Servlet&lt;/h1&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这是一个输出流，负责输出字符串到浏览器</span></span><br><span class="line">		<span class="comment">// 这个输出流不需要我们刷新，也不需要我们关闭，这些都由Tomcat来维护。</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//out.flush();</span></span><br><span class="line"><span class="comment">		//out.close();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="servelet连接数据库"><a href="#servelet连接数据库" class="headerlink" title="servelet连接数据库"></a>servelet连接数据库</h2><p><strong>不要忘记在web.xml中配置新的项</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.Servlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request,ServletResponse response)</span></span><br><span class="line">		<span class="keyword">throws</span> ServletException , IOException&#123;</span><br><span class="line">		response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">		<span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">		Connection con=<span class="literal">null</span>;</span><br><span class="line">		Statement statement=<span class="literal">null</span>;</span><br><span class="line">		ResultSet res=<span class="literal">null</span>;</span><br><span class="line">		<span class="type">int</span> res2;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">			String host=<span class="string">&quot;jdbc:mysql://localhost:3306/java_mysql&quot;</span>;</span><br><span class="line">			String name=<span class="string">&quot;root&quot;</span>;</span><br><span class="line">			String password=<span class="string">&quot;&quot;</span>;</span><br><span class="line">			con=DriverManager.getConnection(host,name,password);</span><br><span class="line">			statement=con.createStatement();</span><br><span class="line">			String sql1=<span class="string">&quot;select * from emp&quot;</span>;</span><br><span class="line">			res=statement.executeQuery(sql1);</span><br><span class="line">			<span class="keyword">while</span> (res.next())&#123;</span><br><span class="line">				String ENAME=res.getString(<span class="string">&quot;ENAME&quot;</span>);</span><br><span class="line">				String JOB=res.getString(<span class="string">&quot;JOB&quot;</span>);</span><br><span class="line">				String MGR=res.getString(<span class="string">&quot;MGR&quot;</span>);</span><br><span class="line">				String HIREDATE=res.getString(<span class="string">&quot;HIREDATE&quot;</span>);</span><br><span class="line">				String SAL=res.getString(<span class="string">&quot;SAL&quot;</span>);</span><br><span class="line">				String COMM=res.getString(<span class="string">&quot;COMM&quot;</span>);</span><br><span class="line">				String DEPTNO=res.getString(<span class="string">&quot;DEPTNO&quot;</span>);</span><br><span class="line">				out.print(ENAME+<span class="string">&quot; &quot;</span>+JOB+<span class="string">&quot; &quot;</span>+MGR+<span class="string">&quot; &quot;</span>+HIREDATE+<span class="string">&quot; &quot;</span>+SAL+<span class="string">&quot; &quot;</span>+COMM+<span class="string">&quot; &quot;</span>+DEPTNO);</span><br><span class="line">				out.print(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">				System.out.println(ENAME+<span class="string">&quot; &quot;</span>+JOB+<span class="string">&quot; &quot;</span>+MGR+<span class="string">&quot; &quot;</span>+HIREDATE+<span class="string">&quot; &quot;</span>+SAL+<span class="string">&quot; &quot;</span>+COMM+<span class="string">&quot; &quot;</span>+DEPTNO);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;查询完毕&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(res!=<span class="literal">null</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span>&#123;</span><br><span class="line">					res.close();</span><br><span class="line">				&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(statement!=<span class="literal">null</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span>&#123;</span><br><span class="line">					statement.close();</span><br><span class="line">				&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(con!=<span class="literal">null</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span>&#123;</span><br><span class="line">					con.close();</span><br><span class="line">				&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IDEA中servelet连接数据库"><a href="#IDEA中servelet连接数据库" class="headerlink" title="IDEA中servelet连接数据库"></a>IDEA中servelet连接数据库</h2><p>1.<br>New Project后新建模块</p>
<p>2.<br>让Module变成JavaEE的模块。（让Module变成webapp的模块。符合webapp规范。符合Servlet规范的Module）</p>
<p>在Module上点击右键：Add Framework Support…（添加框架支持）</p>
<p>在弹出的窗口中，选择Web Application（选择的是webapp的支持）</p>
<p><strong>在IDEA工具中根据Web Application模板生成的目录中有一个web目录，这个目录就代表webapp的根</strong></p>
<p>3.<br>编写Servlet（StudentServlet）</p>
<p>发现Servlet.class文件没有？<br><strong>将CATALINA_HOME/lib/servlet-api.jar和jsp-api.jar添加到classpath当中（这里的classpath说的是IDEA的classpath）</strong><br>File –&gt; Project Structrue –&gt; Modules –&gt; + 加号 –&gt; Add JARS….</p>
<p>实现jakarta.servlet.Servlet接口中的5个方法。</p>
<p>4.<br>在Servlet当中的service方法中编写业务代码</p>
<p>5.<br>在WEB-INF目录下新建了一个子目录：lib（这个目录名可不能随意，必须是全部小写的lib），并且将连接数据库的驱动jar包放到lib目录下。</p>
<p>6.<br>在web.xml文件中完成StudentServlet类的注册。（请求路径和Servlet之间对应起来）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">	创建servlet</span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>StudyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>StudentServlte<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">	将servlet映射到该路径</span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>StudyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        这里的路径是项目根目录，/s就代表根目录下的s</span><br><span class="line">		<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>7.</p>
<p>给一个html页面，在HTML页面中编写一个超链接，用户点击这个超链接，发送请求，Tomcat执行后台的StudentServlet。</p>
<p>student.html</p>
<p>这个文件不能放到WEB-INF目录里面，只能放到WEB-INF目录外面。</p>
<p>student.html文件的内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>student page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里的项目名是 /StudyServlet ，无法动态获取，先写死--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/StudyServlet/s&quot;</span>&gt;</span>student list<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>8.<br>让IDEA工具去关联Tomcat服务器。关联的过程当中将webapp部署到Tomcat服务器当中。</p>
<p>IDEA工具右上角，绿色小锤子右边有一个：Add Configuration<br>左上角加号，点击Tomcat Server –&gt; local<br>在弹出的界面中设置服务器Server的参数（基本上不用动）<br>在当前窗口中有一个Deployment（点击这个用来部署webapp），继续点击加号，部署即可。<br>修改 Application context为：/StudyServlet</p>
<p>9.<br>启动Tomcat服务器</p>
<p>在右上角有绿色的箭头，或者绿色的小虫子，点击这个绿色的小虫子，可以采用debug的模式启动Tomcat服务器。<br>我们开发中建议适用debug模式启动Tomcat<br>第十二步：打开浏览器，在浏览器地址栏上输入：<a href="http://localhost:8080/StudyServlet/s.html">http://localhost:8080/StudyServlet/s.html</a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>vue脚手架结构</title>
    <url>/2024/02/08/vue%E8%84%9A%E6%89%8B%E6%9E%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/2024/02/08/vue%E8%84%9A%E6%89%8B%E6%9E%B6%E7%BB%93%E6%9E%84/1.png" alt="?"></p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue生命周期</title>
    <url>/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段"></a>初始阶段</h2><p><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E5%88%9D%E5%A7%8B%E9%98%B6%E6%AE%B5.png" alt="?"><br><em><strong>1.beforeCreate方法</strong></em><br>方法执行前，进行一些事件对象的初始化，此时还么有进行数据代理，使用方法会报错，方法完成后才可以进行方法调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="title function_">say</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="title function_">beforeCreate</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">say</span>()</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeCreate&quot;</span>)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue.js:5108 [Vue warn]: Error in beforeCreate hook: &quot;TypeError: this.say is not a function&quot;</span><br></pre></td></tr></table></figure>


<p><em><strong>2.created方法</strong></em><br>方法执行后，观察代码中是否有el配置项进行指定元素挂载，如果没有需要调用$mount(元素)进行挂载，如果没有报错。再查看template:&lt;标签&gt;&lt;/标签&gt;配置项是否存在，存在直接覆盖渲染，如果没有则使用元素本来的样式。</p>
<h2 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h2><p><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5.png" alt="?"><br><em><strong>3.beforeMount方法</strong></em><br>方法执行前，和上方法执行后没变化，但是如果此时修改html元素，短暂生效后立刻失效，以为此时要将虚拟dom映射为真实dom</p>
<p><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B52.png" alt="?"><br><strong>点击下一步后立刻失效</strong></p>
<p><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B53.png" alt="?"></p>
<p><em><strong>4.Mount方法</strong></em><br>方法执行前，此时修改html元素生效，此时已经将虚拟dom映射为真实dom</p>
<h2 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h2><p><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5.png" alt="?"></p>
<p><em><strong>beforeUpdata方法</strong></em><br>方法执行前数据发生变化，但页面没有变化。</p>
<p><em><strong>updated方法</strong></em><br>方法执行前将进行页面重新渲染，此时diff算法有可能执行（根据组件key选择是否需要重新渲染）</p>
<h2 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h2><p><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B5.png" alt="?"><br><em><strong>beforeDestroy()执行前</strong></em><br>虽然此时还没有进行销毁，但是一下监视器等也不能使用了</p>
<p><em><strong>destroy()执行时</strong></em><br>此时一些监视器等不能用了，但是一些方法还可以用，因为并不是将vm的内存释放了<br><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B52.png" alt="?"></p>
<p><strong>一图全览：</strong><br><img src="/2024/02/07/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="?"></p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的一些方法</title>
    <url>/2024/02/05/filter/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>0.filter()</p>
<p><strong>filter用于筛选数组中符合特定条件的元素，然后返回一个新的数组，包含符合条件的元素，他不会破坏原有的数组。</strong></p>
<p>filter 方法会对数组中的每个元素调用一次 callback 函数，并将返回值为 true 的元素添加到新数组中，最终返回这个新数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出大于等于3的元素</span></span><br><span class="line"><span class="keyword">const</span> filteredNumbers = numbers.<span class="title function_">filter</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num &gt;= <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filteredNumbers); <span class="comment">// 输出: [3, 4, 5]</span></span><br></pre></td></tr></table></figure>


<ol>
<li><p><code>push()</code>: 这个方法用于在数组的末尾添加一个或多个元素，并返回修改后数组的新长度。</p>
</li>
<li><p><code>pop()</code>: <code>pop()</code> 方法用于删除并返回数组的最后一个元素。</p>
</li>
<li><p><code>reverse()</code>: <code>reverse()</code> 方法用于颠倒数组中元素的顺序，即将数组中的元素倒序排列。</p>
</li>
<li><p><code>splice()</code>: <code>splice()</code> 方法可以用来插入、删除或替换数组的元素。它接受多个参数，包括要操作的起始位置、要删除的元素个数以及要插入的新元素。</p>
</li>
<li><p><code>shift()</code>: <code>shift()</code> 方法用于删除并返回数组的第一个元素。</p>
</li>
<li><p><code>unshift()</code>: <code>unshift()</code> 方法用于在数组的开头添加一个或多个元素，并返回修改后数组的新长度。</p>
</li>
<li><p><code>sort()</code>: <code>sort()</code> 方法用于对数组的元素进行排序，默认按照字母顺序排序。可选参数可以指定排序规则。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>箭头函数</title>
    <url>/2024/02/05/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>箭头函数是ES6（ECMAScript 2015）引入的一种新的函数声明方式，它提供了一种更简洁的语法形式。</strong></p>
<p><strong>和传统函数比较：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="comment">//括号中为参数，箭头后为方法体</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x, y</span>) =&gt; x + y;</span><br></pre></td></tr></table></figure>

<p>如果箭头函数体内只包含一个表达式，它将自动将该表达式的值作为函数的返回值。<br>如果箭头函数体内包含了多个语句，就需要使用花括号 {} 包裹起来，并显式地使用 return 语句来返回值。</p>
<p><strong>没有自己的this： 箭头函数不会创建自己的this，而是会继承外部作用域的this。这意味着箭头函数内部的this和外部的this是一致的。</strong></p>
<p>箭头函数有几个使用注意点：</p>
<p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。<br>不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
<p><strong>普通函数的上下文是调用使用才能确定的，并且规则很多，但是箭头函数的上下文是定义时候确定的。<br>箭头函数的上下文依靠的是父作用域函数的上下文，获取箭头函数的上下文this就是，就需要获取定义时候所处的普通函数的作用域，该普通函数的上下文就是箭头函数的上下文，如果所处环境没有普通函数上下文就是window.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TraditionalFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//setTimeout是由js引擎进行管理，他的this为window对象</span></span><br><span class="line">  <span class="comment">// 传统函数中的this</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>); <span class="comment">// undefined，因为this指向了全局对象</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ArrowFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 箭头函数中的this，继承了外部作用域的this</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>); <span class="comment">// 2，this指向了ArrowFunction的实例</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果需要多个语句，可以使用花括号{}包裹起来。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单一表达式的箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">double</span> = (<span class="params">x</span>) =&gt; x * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多语句的箭头函数，需要使用花括号</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">multiply</span> = (<span class="params">x, y</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = x * y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2024/02/02/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>函数套函数，内函数发生闭包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function makeFunc() &#123;</span><br><span class="line">  var name = &quot;Mozilla&quot;;</span><br><span class="line">  function displayName() &#123;</span><br><span class="line">    alert(name);</span><br><span class="line">  &#125;</span><br><span class="line">  return displayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myFunc = makeFunc();</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure>
<p>在本例子中，myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用。displayName 的实例维持了一个对它的词法环境（变量 name 存在于其中）的引用。因此，当 myFunc 被调用时，变量 name 仍然可用，其值 Mozilla 就被传递到alert中。</p>
<h3 id="使用闭包返回不同值"><a href="#使用闭包返回不同值" class="headerlink" title="使用闭包返回不同值"></a>使用闭包返回不同值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function makeAdder(x) &#123;</span><br><span class="line">  return function (y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add5 = makeAdder(5);</span><br><span class="line">var add10 = makeAdder(10);</span><br><span class="line"></span><br><span class="line">console.log(add5(2)); // 7</span><br><span class="line">console.log(add10(2)); // 12</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/2024/01/31/JVM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>jvm实现一次编写，跨平台到处使用。它有各种指令集和运行时的内存区域。</p>
<h2 id="JVM产品"><a href="#JVM产品" class="headerlink" title="JVM产品"></a>JVM产品</h2><p>Classic VM (早期 Sun 的 Java 虚拟机)<br>Exact VM (早期 Solaris 平台上)<br><strong>HotSpot(OracleDK与OpenJDK 默认)</strong><br>JRockit (BEA 的，被 Oracle 收购，并且整合到 HotSpot 里面)<br>J9 (IBM 商用)<br>Google Android Dalvik VM (Android 上的)<br>KVM、CDC、CLDC(嵌入式领域)<br>Microsof JVM(微软的)<br>Graal VM（跨语言全栈虚拟机 Run Programs Faster Anywhere）</p>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>jvm只和class文件相关，除了java外还有别的语言也可以产生class文件，如：kotlin,scala。他并不关心class文件是由什么语言产生的。</p>
<p>内存大小端<br>大端存储：数据低位存在高地址（人类阅读方式）<br>小端存储：数据低位存在低地址</p>
<p><strong>我们在存放的时候是以一个存储单元为单位来存放，存储单元内部不需要再转变顺序。</strong><br>例如：0001-0101存放在0号地址，不需要把它变成1010-1000！</p>
<p><strong>class字节码按照大端存储</strong></p>
<h2 id="class文件结构"><a href="#class文件结构" class="headerlink" title="class文件结构"></a>class文件结构</h2><p>Class文件数据结构采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”.</p>
<p><strong>无符号数</strong>：<br>定义了一组专用的数据类型来表示Class文件的内容，它们包括u1、u2、u4分别代表1、2和4个字节的无符号数。</p>
<p>无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p>
<p>每个无符号数严格按照顺序连续存放，它们之间没有用任何填充或对齐。</p>
<p><strong>表</strong>：<br>表用于描述有层次关系的复合结构的数据。</p>
<p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型。</p>
<p>表的命名都习惯性地以“_info”结尾。</p>
<p>整个Class文件本质上也可以视作是一张表。<br><img src="/2024/01/31/JVM/2.2.png" alt="?"></p>
<h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>文件内容起始几个字节使用固定的内容来描述该文件类型，因此这几个字节的内容称为魔数。</p>
<p><strong>class文件魔数：cafe babe</strong></p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>主版本（major version）记录每个大版本号，起始值为45.<br>次版本（minor version）记录每个小版本号，起始值为3.<br>jdk1.1.8=45.3<br>jdk8=52.0<br>jdk11=55.0</p>
<p><strong>JVM高版本可以执行低版本class，反之异常java.lang.UnsupportedClassVersionError</strong></p>
<h2 id="class文件数据结构"><a href="#class文件数据结构" class="headerlink" title="class文件数据结构"></a>class文件数据结构</h2><h2 id="class文件基本信息"><a href="#class文件基本信息" class="headerlink" title="class文件基本信息"></a>class文件基本信息</h2><h2 id="class文件常量池信息"><a href="#class文件常量池信息" class="headerlink" title="class文件常量池信息"></a>class文件常量池信息</h2><h2 id="class文件访问标志信息"><a href="#class文件访问标志信息" class="headerlink" title="class文件访问标志信息"></a>class文件访问标志信息</h2><h2 id="class文件类、接口信息"><a href="#class文件类、接口信息" class="headerlink" title="class文件类、接口信息"></a>class文件类、接口信息</h2><h2 id="class文件字段、属性、方法信息"><a href="#class文件字段、属性、方法信息" class="headerlink" title="class文件字段、属性、方法信息"></a>class文件字段、属性、方法信息</h2><h2 id="class文件字节码指令"><a href="#class文件字节码指令" class="headerlink" title="class文件字节码指令"></a>class文件字节码指令</h2>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>js原型和构造方法</title>
    <url>/2024/01/29/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><em>1。定义在构造函数内部的方法和定义在原型上的方法有什么区别？</em></p>
<p><strong>定义在构造函数内部的方法,会在它的每一个实例上都克隆这个方法;定义在构造函数的prototype属性上的方法会让它的所有示例都共享这个方法,但是不会在每个实例的内部重新定义这个方法.</strong> 如果我们的应用需要创建很多新的对象,并且这些对象还有许多的方法,为了节省内存,我们建议把这些方法都定义在构造函数的prototype属性上.</p>
<p>2.<em>如何互相访问</em></p>
<p>对象.<em>proto</em> 访问原型<br>构造方法.prototype 访问原型<br>原型.constructor 访问构造方法</p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>SnakeGame</title>
    <url>/2024/01/27/SnakeGame/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>java实现贪吃蛇</p>
<p>闲来无事写了一个小游戏，具体代码参见：</p>
<p><strong><a href="https://github.com/codecodegogogo/Snake_Game">https://github.com/codecodegogogo/Snake_Game</a></strong></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>程序是怎么跑起来的</title>
    <url>/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="cpu是什么"><a href="#cpu是什么" class="headerlink" title="cpu是什么"></a>cpu是什么</h1><p>CPU 是英文 Central Processing Unit( 中央处理器)的缩写，相当于计算机的大脑，它的内部由数百万至数亿个晶体管构成这些都是大家所熟知的。</p>
<h2 id="CPU-的内部结构解析"><a href="#CPU-的内部结构解析" class="headerlink" title="CPU 的内部结构解析"></a>CPU 的内部结构解析</h2><p>CPU和内存是由许多晶体管组成的电子部件，通常称为IC( Integrated Circuit，集成电路)。从功能方面来看，CPU的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。</p>
<p>寄存器可用来暂存指令、数据等处理对象，可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有20~100个寄存器。</p>
<p>控制器负责把内存上的指令、数据等读人寄存器并根据指令的执行结果来控制整个计算机。</p>
<p>运算器负责运算从内存读入寄存器的数据。</p>
<p>时钟负责发出 CPU 开始计时的时钟信号“。不过，也有些计算机的时钟位于CPU的外部。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q2.png" alt="?"><br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q1.png" alt="?"></p>
<p>通常所说的内存指的是计算机的主存储器( main memory,简称主存。主存通过控制芯片等与CPU相连主要负责存储指令和数据。主存由可读写的元素构成，每个字节(1字节 =8位)都带有一个地址编号。CPU 可以通过该地址读取主存中的指令和数据，当然也可以写入数据。主存中存储的指令和数据会随着计算机的关机而自动清除。</p>
<p><strong>程序启动后，根据时钟信号，控制器会从内存中读取指令和数据。通过对这些指令加以解释和运行，运算器就会对数据进行运算，控制器根据该运算结果来控制计算机。所谓的控制就是指数据运算以外的处理(主要是数据输入输出的时机控制 )。比如内存和磁盘等媒介的输入输出、键盘和鼠标的输人、显示器和打印机的输出等，这些都是控制的内容。</strong></p>
<h2 id="CPU-是寄存器的集合体"><a href="#CPU-是寄存器的集合体" class="headerlink" title="CPU 是寄存器的集合体"></a>CPU 是寄存器的集合体</h2><p><strong>程序是把寄存器作为对象来描述的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov  eax, dword ptr [ebp<span class="number">-8</span>]    …把数值从内存复制到eax</span><br><span class="line">add  eax, dword ptr [ebp<span class="number">-0</span>Ch]  …eax的数值和内存的数值相加</span><br><span class="line">mov  dword ptr [ebp<span class="number">-4</span>], eax    …把eax的数值（上一步的相加结果）存储在内存中</span><br></pre></td></tr></table></figure>
<p>汇编语言是80386以上的CPU所使用的语言。eax和ebp是CPU内部的寄存器的名称。内存的存储场所通过地址编号来区分，而寄存器的种类则通过名字来区分。使用高级语言编写的程序会在编译后转化成机器语言，然后再通过CPU内部的寄存器来处理。</p>
<p>寄存器中存储的内容既可以是指令也可以是数据。其中，数据分为“用于运算的数值”和“表示内存地址的数值”两种。数据种类不同，存储该数值的寄存器也不同。CPU中每个寄存器的功能都是不同的。用于运算的数值放在累加寄存器中存储，表示内存地址的数值则放在基址寄存器和变址寄存器中存储。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q3.png" alt="?"><br>CPU是具有各种功能的寄存器的集合体。其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器一般有多个。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q4.png" alt="?"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q5.png" alt="?"><br>地址0100是程序运行的开始位置。Windows等操作系统把程序从硬盘复制到内存后，会将程序计数器（CPU寄存器的一种）设定为0100，然后程序便开始运行。CPU每执行一个指令，程序计数器的值就会自动加1。例如，CPU执行0100地址的指令后，程序计数器的值就变成了0101（当执行的指令占据多个内存地址时，增加与指令长度相应的数值）。然后，CPU的控制器就会参照程序计数器的数值，从内存中读取命令并执行。也就是说，程序计数器决定着程序的流程。</p>
<h2 id="条件分支和循环机制"><a href="#条件分支和循环机制" class="headerlink" title="条件分支和循环机制"></a>条件分支和循环机制</h2><p>CPU在进行运算时，标志寄存器的数值会根据运算结果自动设定。条件分支在跳转指令前会进行比较运算。至于是否执行跳转指令，则由CPU在参考标志寄存器的数值后进行判断。运算结果的正、零、负三种状态由标志寄存器的三个位表示。图1-6是32位CPU（寄存器的长度是32位）的标志寄存器的示例。标志寄存器的第一个字节位、第二个字节位和第三个字节位的值为1时，表示运算结果分别为正数、零和负数。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q6.png" alt="?"><br>假设要比较累加寄存器中存储的XXX值和通用寄存器中存储的YYY值，执行比较的指令后，CPU的运算装置就会在内部（暗中）进行XXX-YYY的减法运算。而无论减法运算的结果是正数、零还是负数，都会保存到标志寄存器中。结果为正表示XXX比YYY大，零表示XXX和YYY相等，负表示XXX比YYY小。程序中的比较指令，就是在CPU内部做减法运算。</p>
<h2 id="函数的调用机制"><a href="#函数的调用机制" class="headerlink" title="函数的调用机制"></a>函数的调用机制</h2><p>哪怕是高级语言编写的程序，函数调用处理也是通过把程序计数器的值设定成函数的存储地址来实现的。</p>
<p>函数的调用需要在完成函数内部的处理后，处理流程再返回到函数调用点（函数调用指令的下一个地址）。因此，如果只是跳转到函数的入口地址，处理流程就不知道应该返回至哪里了。</p>
<p>给变量a和b分别代入123和456后，将其赋值给参数（parameter）来调用MyFunc函数的C语言程序。图中的地址是将C语言编译成机器语言后运行时的地址。由于1行C语言程序在编译后通常会变成多行的机器语言，所以图中的地址是离散的。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q7.png" alt="?"><br>此外，通过跳转指令把程序计数器的值设定成0260也可实现调用MyFunc函数。函数的调用原点（0132地址）和被调用函数（0260地址）之间的数据传递，可以通过内存或寄存器来实现。不过，当函数处理进行到最后的0354地址时，我们知道应该将程序计数器的值设定成函数调用后要执行的0154地址，但实际上这一操作根本无法实现。</p>
<p>机器语言的call指令和return指令能够解决这个问题。建议大家把二者结合起来来记忆。函数调用使用的是call指令，而不是跳转指令。在将函数的入口地址设定到程序计数器之前，call指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行return命令。return命令的功能是把保存在栈中的地址设定到程序计数器中。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w1.png" alt="?"></p>
<h2 id="通过地址和索引实现数组"><a href="#通过地址和索引实现数组" class="headerlink" title="通过地址和索引实现数组"></a>通过地址和索引实现数组</h2><p>基址寄存器和变址寄存器。通过这两个寄存器，我们可以对主内存上特定的内存区域进行划分，从而实现类似于数组的操作。</p>
<p>首先，我们用十六进制数将计算机内存上00000000～FFFFFFFF的地址划分出来。那么，凡是该范围的内存区域，只要有一个32位的寄存器，即可查看全部的内存地址。但如果想要像数组那样分割特定的内存区域以达到连续查看的目的，使用两个寄存器会更方便些。例如，查看10000000地址～1000FFFF地址时，可以将10000000存入基址寄存器，并使变址寄存器的值在00000000～0000FFFF变化。CPU则会把基址寄存器+变址寄存器的值解释为实际查看的内存地址。变址寄存器的值就相当于高级编程语言程序中数组的索引功能。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w2.png" alt="?"></p>
<h2 id="CPU的处理"><a href="#CPU的处理" class="headerlink" title="CPU的处理"></a>CPU的处理</h2><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w3.png" alt="?"></p>
<hr>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>计算机内部是由IC这种电子部件构成的。</p>
<p>CPU（微处理器）和内存也是IC的一种。IC有几种不同的形状，有的像一条黑色蜈蚣，在其两侧有数个乃至数百个引脚；有的则像插花用的针盘，引脚在IC内部并排排列着。IC的所有引脚，只有直流电压0V或5V两个状态。也就是说，IC的一个引脚，只能表示两个状态。</p>
<p>IC的这个特性，决定了计算机的信息数据只能用二进制数来处理。由于1位（一个引脚）只能表示两个状态，所以二进制的计数方式就变成了0、1、10、11、100…这种形式。</p>
<p>内存和磁盘都使用字节单位来存储和读写数据，使用位单位则无法读写数据。因此，字节是信息的基本单位。奔腾等32位微处理器，具有32个引脚以用于信息的输入和输出。也就是说，奔腾一次可以处理32位（32位=4字节）的二进制数信息。</p>
<h2 id="二进制数"><a href="#二进制数" class="headerlink" title="二进制数"></a>二进制数</h2><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w5.png" alt="?"><br>十进制数39用8位的二进制表示是00100111，左移两位后是10011100，再转换成十进制数就是156。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w6.png" alt="?"></p>
<h2 id="补数"><a href="#补数" class="headerlink" title="补数"></a>补数</h2><p>二进制数中表示负数值时，一般会把最高位作为符号来使用，因此我们把这个最高位称为符号位。符号位是0时表示正数，符号位是1时表示负数。那么-1用8位二进制数来表示的话是什么样的呢？</p>
<p>正确答案是11111111。</p>
<p>计算机在做减法运算时，实际上内部是在做加法运算。补数就是用正数来表示负数。</p>
<p>为了获得补数，我们需要将二进制数的各数位的数值全部取反，然后再将结果加1。例如，用8位二进制数表示- 1时，只需求得1，也就是00000001的补数即可。具体来说，就是将各数位的0取反成1, 1取反成0，然后再将取反的结果加1，最后就转化成了11111111。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w7.png" alt="?"></p>
<p>00000001+11111111确实为0（=00000000）。这个运算中出现了最高位溢出的情况，不过，正如之前所介绍的那样，对于溢出的位，计算机会直接忽略掉。在8位的范围内进行计算时，100000000这个9位二进制数就会被认为是00000000这一8位二进制数。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e1.png" alt="?"></p>
<p>当运算结果为负数时，计算结果的值也是以补数的形式来表示的。</p>
<p>比如3- 5这个运算，用8位二进制数表示3时为00000011，而5=00000101的补数为“取反+1”，也就是11111011。因此3- 5其实就是00000011+ 11111011的运算。00000011 + 11111011的运算结果为11111110，最高位变成了1。</p>
<p>C语言的数据类型中，既有不能处理负数的unsigned short类型，也有能处理负数的short类型。这两种类型，都是2字节（=16位）的变量，都能表示2的16次幂=65536种值，这一点是相同的。不过，值的范围有所不同，short类型是- 32768～32767,unsigned short类型是0～65535。</p>
<h2 id="逻辑右移和算术右移"><a href="#逻辑右移和算术右移" class="headerlink" title="逻辑右移和算术右移"></a>逻辑右移和算术右移</h2><p><strong>右移有移位后在最高位补0和补1两种情况。</strong></p>
<p>当二进制数的值表示图形模式而非数值时，移位后需要在最高位补0。</p>
<p>将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值（0或1）。这就称为算术右移。如果数值是用补数表示的负数值，那么右移后在空出来的最高位补1，就可以正确地实现1/2、1/4、1/8等的数值运算。如果是正数，只需在最高位补0即可。</p>
<p>现在我们来看一个右移的例子。将- 4（=11111100）右移两位。这时，逻辑右移的情况下结果就会变成00111111，也就是十进制数63，显然不是- 4的1/4。而算术右移的情况下，结果就会变成11111111，用补数表示就是- 1，即- 4的1/4。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e2.png" alt="?"></p>
<h2 id="符号扩充"><a href="#符号扩充" class="headerlink" title="符号扩充"></a>符号扩充</h2><p><strong>符号扩充就是指在保持值不变的前提下将其转换成16位和32位的二进制数。</strong></p>
<p>将01111111这个正的8位二进制数转换成16位二进制数时，很容易就能得出0000000001111111这个正确结果。</p>
<p>11111111这样用补数来表示的数值，该如何处理比较好呢？<br>实际上处理方法非常简单，将其表示成1111111111111111就可以了。也就是说，不管是正数还是用补数表示的负数，都只需用符号位的值（0或者1）填充高位即可。</p>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>计算机能处理的运算，大体可分为算术运算和逻辑运算。算术运算是指加减乘除四则运算。逻辑运算是指对二进制数各数字位的0和1分别进行处理的运算，包括逻辑非（NOT运算）、逻辑与（AND运算）、逻辑或（OR运算）和逻辑异或（XOR运算）四种。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e3.png" alt="?"></p>
<hr>
<h1 id="计算机进行小数运算时出错的原因"><a href="#计算机进行小数运算时出错的原因" class="headerlink" title="计算机进行小数运算时出错的原因"></a>计算机进行小数运算时出错的原因</h1><h2 id="将0-1累加100次也得不到10"><a href="#将0-1累加100次也得不到10" class="headerlink" title="将0.1累加100次也得不到10"></a>将0.1累加100次也得不到10</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> sum;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//将保存总和的变量清0</span></span><br><span class="line">    sum =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//0.1相加100次</span></span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">1</span>;  i &lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum +=<span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>10.000002</p>
</blockquote>
</blockquote>
<h2 id="用二进制数表示小数"><a href="#用二进制数表示小数" class="headerlink" title="用二进制数表示小数"></a>用二进制数表示小数</h2><p>由于计算机内部所有的信息都是以二进制数的形式来处理的，因此在这一点上，整数和小数并无差别。不过，使用二进制数来表示整数和小数的方法却有很大的不同。</p>
<p>把1011.0011这个有小数点的二进制数转换成十进制数。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w8.png" alt="?"></p>
<h2 id="计算机运算出错的原因"><a href="#计算机运算出错的原因" class="headerlink" title="计算机运算出错的原因"></a>计算机运算出错的原因</h2><p>计算机之所以会出现运算错误，是因为“有一些十进制数的小数无法转换成二进制数”。</p>
<p>小数点后4位用二进制数表示时的数值范围为0.0000～0.1111。因此，这里只能表示0.5、0.25、0.125、0.0625这四个二进制数小数点后面的位权组合而成（相加总和）的小数。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e4.png" alt="?"><br>因为无法正确表示的数值，最后都变成了近似值。计算机这个功能有限的机器设备，是无法处理无限循环的小数的。因此，在遇到循环小数时，计算机就会根据变量数据类型所对应的长度将数值从中间截断或者四舍五入。</p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>双精度浮点数类型用64位、单精度浮点数类型用32位来表示全体小数。</p>
<hr>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="内存的物理机制"><a href="#内存的物理机制" class="headerlink" title="内存的物理机制"></a>内存的物理机制</h2><p>内存实际上是一种名为内存IC的电子元件。虽然内存IC包括DRAM、SRAM、ROM等多种形式，但从外部来看，其基本机制都是一样的。内存IC中有电源、地址信号、数据信号、控制信号等用于输入输出的大量引脚（IC的引脚），通过为其指定地址（address），来进行数据的读写。</p>
<p>VCC和GND是电源，A0～A9是地址信号的引脚，D0～D7是数据信号的引脚，RD和WR是控制信号的引脚。将电源连接到VCC和GND后，就可以给其他引脚传递比如0或者1这样的信号。大多数情况下，+ 5V的直流电压表示1,0V表示0。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e5.png" alt="?"></p>
<p>首先，我们假设要往该内存IC中写入1字节的数据。为了实现该目的，可以给VCC接入+5V，给GND接入0V的电源，并使用A0～A9的地址信号来指定数据的存储场所，然后再把数据的值输入给D0～D7的数据信号，并把WR（write=写入的简写）信号设定成1。执行完这些操作，就可以在内存IC内部写入数据（图4-2 (a)）了。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e6.png" alt="?"><br>读出数据时，只需通过A0～A9的地址信号指定数据的存储场所，然后再将RD（read=读出的简写）信号设成1即可。</p>
<p><strong>当WR和RD同时为0时，写入和读出的操作都无法进行。</strong></p>
<h2 id="内存的逻辑模型"><a href="#内存的逻辑模型" class="headerlink" title="内存的逻辑模型"></a>内存的逻辑模型</h2><p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/r1.png" alt="?"><br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/r2.png" alt="?"></p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针也是一种变量，它所表示的不是数据的值，而是存储着数据的内存的地址。通过使用指针，就可以对任意指定地址的数据进行读写。</p>
<p>Windows计算机上使用的程序通常都是32位（4字节）的内存地址。这种情况下，指针变量的长度也是32位。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是指多个同样数据类型的数据在内存中连续排列的形式。作为数组元素的各个数据会通过连续的编号被区分开来，这个编号称为索引（index）。指定索引后，就可以对该索引所对应地址的内存进行读写操作。而索引和内存地址的变换工作则是由编译器自动实现的。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/R3.png" alt="?"></p>
<h2 id="栈、队列以及环形缓冲区"><a href="#栈、队列以及环形缓冲区" class="headerlink" title="栈、队列以及环形缓冲区"></a>栈、队列以及环形缓冲区</h2><p>栈和队列，都可以不通过指定地址和索引来对数组的元素进行读写。需要临时保存计算过程中的数据、连接在计算机上的设备或者输入输出的数据时，都可以通过这些方法来使用内存。如果每次保存临时数据都需指定地址和索引，程序就会变得比较麻烦，因此要加以改进。</p>
<p>队列一般是以环状缓冲区（ring buffer）的方式来实现的.<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/R4.png" alt="?"></p>
<hr>
<h1 id="内存和磁盘"><a href="#内存和磁盘" class="headerlink" title="内存和磁盘"></a>内存和磁盘</h1><h2 id="不读入内存就无法运行"><a href="#不读入内存就无法运行" class="headerlink" title="不读入内存就无法运行"></a>不读入内存就无法运行</h2><p>计算机中主要的存储部件是内存和磁盘。磁盘中存储的程序，必须要加载到内存后才能运行。在磁盘中保存的原始程序是无法直接运行的。</p>
<p>这是因为，负责解析和运行程序内容的CPU，需要通过内部程序计数器来指定内存地址，然后才能读出程序。即使CPU可以直接读出并运行磁盘中保存的程序，由于磁盘读取速度慢，程序的运行速度还是会降低。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/R5.png" alt="?"></p>
<h2 id="磁盘缓存加快了磁盘访问速度"><a href="#磁盘缓存加快了磁盘访问速度" class="headerlink" title="磁盘缓存加快了磁盘访问速度"></a>磁盘缓存加快了磁盘访问速度</h2><p>磁盘缓存指的是把从磁盘中读出的数据存储到内存空间中的方式。使用磁盘缓存可以大大改善磁盘数据的访问速度。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/R6.png" alt="?"></p>
<p><strong>把低速设备的数据保存在高速设备中，需要时可以直接将其从高速设备中读出，这种缓存的方式在其他情况下也会用到。</strong></p>
<p>其中的一个实例就是在Web浏览器中的使用。由于Web浏览器是通过网络来获取远程Web服务器的数据并将其显示出来的。因此，在显示较大的图片等文件时，会花费不少时间。于是，Web浏览器就可以把获取的数据暂时保存在磁盘中，然后在需要时再显示磁盘中的数据。也就是说，把低速的网络数据保存到相对高速的磁盘中。</p>
<h2 id="虚拟内存把磁盘作为部分内存来使用"><a href="#虚拟内存把磁盘作为部分内存来使用" class="headerlink" title="虚拟内存把磁盘作为部分内存来使用"></a>虚拟内存把磁盘作为部分内存来使用</h2><p>虚拟内存是指把磁盘的一部分作为假想的内存来使用。这与磁盘缓存是假想的磁盘（实际上是内存）相对，虚拟内存是假想的内存（实际上是磁盘）。</p>
<p>通过借助虚拟内存，在内存不足时也可以运行程序。</p>
<p>为了实现虚拟内存，就必须把实际内存（也可称为物理内存）的内容，和磁盘上的虚拟内存的内容进行部分置换（swap），并同时运行程序。</p>
<h2 id="节约内存的编程方法"><a href="#节约内存的编程方法" class="headerlink" title="节约内存的编程方法"></a>节约内存的编程方法</h2><p>由于使用虚拟内存时发生的Page In和Page Out往往伴随着低速的磁盘访问，因此在这个过程中应用的运行会变得迟钝起来。<br>也就是说，虚拟内存无法彻底解决内存不足的问题。</p>
<p>为了从根本上解决内存不足的问题，需要增加内存的容量，或者尽量把运行的应用文件变小。</p>
<h3 id="（1）通过DLL文件实现函数共有"><a href="#（1）通过DLL文件实现函数共有" class="headerlink" title="（1）通过DLL文件实现函数共有"></a>（1）通过DLL文件实现函数共有</h3><p>DLL（Dynamic Link Library）文件，顾名思义，是在程序运行时可以动态加载Library（函数和数据的集合）的文件。多个应用可以共有同一个DLL文件。而通过共有同一个DLL文件则可以达到节约内存的效果。</p>
<p>例如，假设我们编写了一个具有某些处理功能的函数MyFunc()。应用A和应用B都会使用这个函数。在各个应用的运行文件中内置函数MyFunc()（这个称为Static Link，静态链接）后同时运行这两个应用，内存中就存在了具有同一函数的两个程序。但这会导致内存的利用效率降低。所以，有两个同样的函数，还是有点浪费。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/r7.png" alt="?"></p>
<p>此内存中存在的函数MyFunc()的程序就只有1个。这样一来，内存的利用效率也就提高了。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/r8.png" alt="?"></p>
<p>Windows的操作系统本身也是多个DLL文件的集合体。有时在安装新应用时，DLL文件也会被追加。应用则会通过利用这些DLL文件的功能来运行。像这样，之所以要利用多个DLL文件，其中一个原因就是可以节约内存。而且DLL文件还有一个优点就是，在不变更EXE文件的情况下，只通过升级DLL文件就可以更新。</p>
<h3 id="（2）通过调用-stdcall来减小程序文件的大小"><a href="#（2）通过调用-stdcall来减小程序文件的大小" class="headerlink" title="（2）通过调用_stdcall来减小程序文件的大小"></a>（2）通过调用_stdcall来减小程序文件的大小</h3><p>C语言中，在调用函数后，需要执行栈清理处理指令。栈清理处理是指，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。该命令不是程序记述的，而是在程序编译时由编译器自动附加到程序中的。编译器默认将该处理附加在函数调用方。</p>
<h2 id="磁盘的物理结构"><a href="#磁盘的物理结构" class="headerlink" title="磁盘的物理结构"></a>磁盘的物理结构</h2><p>磁盘是通过把其物理表面划分成多个空间来使用的。划分的方式有扇区方式和可变长方式两种，前者是指将磁盘划分为固定长度的空间，后者则是指把磁盘划分为长度可变的空间。一般的Windows计算机所使用的硬盘和软盘，采用的都是扇区方式。扇区方式中，把磁盘表面分成若干个同心圆的空间就是磁道，把磁道按照固定大小（能存储的数据长度相同）划分而成的空间就是扇区。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/r9.png" alt="?"></p>
<p>扇区是对磁盘进行物理读写的最小单位。Windows中使用的磁盘，一般1个扇区是512字节。不过，Windows在逻辑方面（软件方面）对磁盘进行读写的单位是扇区整数倍簇。根据磁盘容量的不同，1簇可以是512字节（1簇=1扇区）、1KB（1簇=2扇区）、2KB、4KB、8KB、16KB、32KB（1簇=64扇区）。磁盘的容量越大，簇的容量也越大。不过，在软盘中，1簇=512字节=1扇区，簇和扇区的大小是相等的。</p>
<p><strong>不管是多么小的文件，都会占用1簇的空间。这样一来，所有的文件都会占用1簇的整数倍的磁盘空间。如果减少簇的容量，磁盘访问次数就会增加，就会导致读写文件的时间变长。</strong></p>
<hr>
<h1 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h1><h2 id="文件以字节为单位保存"><a href="#文件以字节为单位保存" class="headerlink" title="文件以字节为单位保存"></a>文件以字节为单位保存</h2><p>文件是将数据存储在磁盘等存储媒介中的一种形式。</p>
<h2 id="RLE算法的机制"><a href="#RLE算法的机制" class="headerlink" title="RLE算法的机制"></a>RLE算法的机制</h2><p>AAAAAABBCDDEEEEEF就可以用A6B2C1D2E5F1来表示。</p>
<p>把文件内容用“数据×重复次数”的形式来表示的压缩方法称为RLE（Run Length Encoding，行程长度编码）算法（图6-2）。RLE算法是一种很好的压缩方法，经常被用于压缩传真的图像等。因为图像文件本质上也是字节数据的集合体，所以可以用RLE算法来压缩。</p>
<h2 id="RLE算法的缺点"><a href="#RLE算法的缺点" class="headerlink" title="RLE算法的缺点"></a>RLE算法的缺点</h2><p>然而，在实际的文本文件中，同样字符多次重复出现的情况并不多见。虽然针对相同数据经常连续出现的图像、文件等，RLE算法可以发挥不错的效果，但它并不适合文本文件的压缩。不过，因为该压缩机制非常简单，因此使用RLE算法的程序也相对更容易编写。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t1.png" alt="?"></p>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>哈夫曼算法的关键就在于“多次出现的数据用小于8位的字节数来表示，不常用的数据则可以用超过8位的字节数来表示”。</p>
<p>不过有一点需要注意，不管是不满8位的数据，还是超过8位的数据，最终都要以8位为单位保存到文件中。这是因为磁盘是以字节（8位）为单位来保存数据的。为了实现这一处理，压缩程序的内容会复杂很多，不过作为回报，最终得到的压缩率也是相当高的。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t2.png" alt="?"></p>
<h2 id="可逆压缩和非可逆压缩"><a href="#可逆压缩和非可逆压缩" class="headerlink" title="可逆压缩和非可逆压缩"></a>可逆压缩和非可逆压缩</h2><p>图像文件的使用目的通常是把图像数据输出到显示器、打印机等设备上。Windows的标准图像数据形式为BMP，是完全未压缩的。</p>
<p>我们把能还原到压缩前状态的压缩称为可逆压缩，无法还原到压缩前状态的压缩称为非可逆压缩。</p>
<hr>
<h1 id="程序是在何种环境中运行的"><a href="#程序是在何种环境中运行的" class="headerlink" title="程序是在何种环境中运行的"></a>程序是在何种环境中运行的</h1><h2 id="运行环境-操作系统-硬件"><a href="#运行环境-操作系统-硬件" class="headerlink" title="运行环境=操作系统 + 硬件"></a>运行环境=操作系统 + 硬件</h2><p>CPU只能解释其自身固有的机器语言。不同的CPU能解释的机器语言的种类也是不同的。例如，CPU有x86、MIPS、SPARC、PowerPC等几种类型，它们各自的机器语言是完全不同的。</p>
<p>机器语言的程序称为本地代码（native code）。程序员用C语言等编写的程序，在编写阶段仅仅是文本文件。文本文件（排除文字编码的问题）在任何环境下都能显示和编辑。我们称之为源代码。通过对源代码进行编译，就可以得到本地代码。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t3.png" alt="?"></p>
<h2 id="Windows克服了CPU以外的硬件差异"><a href="#Windows克服了CPU以外的硬件差异" class="headerlink" title="Windows克服了CPU以外的硬件差异"></a>Windows克服了CPU以外的硬件差异</h2><p>计算机的硬件并不仅仅是由CPU构成的，还包括用于存储程序指令和数据的内存，以及通过I/O连接的键盘、显示器、硬盘、打印机等外围设备。</p>
<p>在Windows的应用软件中，键盘输入、显示器输出等并不是直接向硬件发送指令，而是通过向Windows发送指令来间接实现的。因此，程序员就不用注意内存和I/O地址的不同构成了。因为Windows操作的是硬件而非应用软件，而且针对不同的机型，这些硬件的构成也是有差异的。</p>
<p>MS-DOS应用大多都是不经过操作系统而直接控制硬件的，而Windows应用则基本上都由Windows来完成对硬件的控制</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t4.png" alt="?"></p>
<h2 id="不同操作系统的API不同"><a href="#不同操作系统的API不同" class="headerlink" title="不同操作系统的API不同"></a>不同操作系统的API不同</h2><p>同样机型的计算机，可安装的操作系统类型也会有多种选择。<br>当然，应用软件则必须根据不同的操作系统类型来专门开发。CPU的类型不同，所对应的机器语言也不同，同样的道理，操作系统的类型不同，应用程序向操作系统传递指令的途径也是不同的。</p>
<p>应用程序向操作系统传递指令的途径称为API（Application Programming Interface）。Windows及Unix系列操作系统的API，提供了任何应用程序都可以利用的函数组合。因为不同操作系统的API是有差异的，因此，将同样的应用程序移植到其他操作系统时，就必须要重写应用中利用到API的部分。像键盘输入、鼠标输入、显示器输出、文件输入输出等同外围设备进行输入输出操作的功能，都是通过API提供的。</p>
<p>在同类型操作系统下，不管硬件如何，API基本上没有差别。因而，针对某特定操作系统的API所编写的程序，在任何硬件上都可以运行。当然，由于CPU种类不同，机器语言也不相同，因此本地代码当然也是不同的。这种情况下，就需要利用能够生成各CPU专用的本地代码的编译器，来对源代码进行重新编译了。</p>
<h2 id="FreeBSD-Port"><a href="#FreeBSD-Port" class="headerlink" title="FreeBSD Port"></a>FreeBSD Port</h2><p>既然CPU类型不同会导致同样的本地代码无法重复利用，那么为何不直接把源代码分发给程序呢？</p>
<p>Unix系列操作系统FreeBSD中，存在一种名为Ports的机制。该机制能够结合当前运行的硬件环境来编译应用的源代码，进而得到可以运行的本地代码系统。如果目标应用的源代码没有在硬件上的话，Ports就会自动使用FTP连接到相关站点来下载代码。</p>
<p>FreeBSD上应用的源代码，大部分都是用C语言来记述的。FreeBSD等Unix系列操作系统中，都带有标准的C编译器。C编译器可以结合FreeBSD的运行环境生成合适的本地代码。</p>
<h2 id="提供相同运行环境的Java虚拟机"><a href="#提供相同运行环境的Java虚拟机" class="headerlink" title="提供相同运行环境的Java虚拟机"></a>提供相同运行环境的Java虚拟机</h2><p>有一种方法能够提供不依赖于特定硬件及操作系统的程序运行环境，那就是Java。</p>
<p>同其他编程语言相同，Java也是将Java语法记述的源代码编译后运行。不过，编译后生成的并不是特定CPU使用的本地代码，而是名为字节代码的程序。字节代码的运行环境就称为Java虚拟机（JavaVM, Java Virtual Machine）。Java虚拟机是一边把Java字节代码逐一转换成本地代码一边运行的。而Java虚拟机（java.exe）则会把字节代码变换成x86系列CPU适用的本地代码，然后由x86系列CPU负责实际的处理。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t5.png" alt="?"></p>
<p>Java虚拟机每次运行时都要把字节代码变换成本机代码，这一机制是造成运行速度慢的原因。</p>
<h2 id="BIOS和引导"><a href="#BIOS和引导" class="headerlink" title="BIOS和引导"></a>BIOS和引导</h2><p>BIOS存储在ROM中，是预先内置在计算机主机内部的程序。BIOS除了键盘、磁盘、显卡等基本控制程序外，还有启动“引导程序”的功能。引导程序是存储在启动驱动器起始区域的小程序。操作系统的启动驱动器一般是硬盘，不过有时也可以是CD-ROM或软盘。</p>
<p>开机后，BIOS会确认硬件是否正常运行，没有问题的话就会启动引导程序。引导程序的功能是把在硬盘等记录的OS加载到内存中运行。虽然启动应用是OS的功能，但OS并不能自己启动自己，而是通过引导程序来启动。</p>
<hr>
<h1 id="从源文件到可执行文件"><a href="#从源文件到可执行文件" class="headerlink" title="从源文件到可执行文件"></a>从源文件到可执行文件</h1><h2 id="计算机只能运行本地代码"><a href="#计算机只能运行本地代码" class="headerlink" title="计算机只能运行本地代码"></a>计算机只能运行本地代码</h2><p>CPU能直接解析并运行的不是源代码而是本地代码的程序。作为计算机大脑的Pentium等CPU，也只能解释已经转换成本地代码的程序内容。</p>
<h2 id="编译器负责转换源代码"><a href="#编译器负责转换源代码" class="headerlink" title="编译器负责转换源代码"></a>编译器负责转换源代码</h2><p>能够把C语言等高级编程语言编写的源代码转换成本地代码的程序称为编译器。每个编写源代码的编程语言都需要其专用的编译器。</p>
<p>编译器首先读入代码的内容，然后再把源代码转换成本地代码。编译器中就好像有一个源代码同本地代码的对应表。但实际上，仅仅靠对应表是无法生成本地代码的。读入的源代码还要经过语法解析、句法解析、语义解析等，才能生成本地代码。</p>
<p>根据CPU类型的不同，本地代码的类型也不同。因而，编译器不仅和编程语言的种类有关，和CPU的类型也是相关的。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t6.png" alt="?"></p>
<p>还有一种交叉编译器，它生成的是和运行环境中的CPU不同的CPU所使用的本地代码。</p>
<h2 id="仅靠编译是无法得到可执行文件的"><a href="#仅靠编译是无法得到可执行文件的" class="headerlink" title="仅靠编译是无法得到可执行文件的"></a>仅靠编译是无法得到可执行文件的</h2><p>编译器转换源代码后，就会生成本地文件。不过，本地文件是无法直接运行的。为了得到可以运行的EXE文件，编译之后还需要进行“链接”处理。</p>
<p>编译后生成的不是EXE文件，而是扩展名为“.obj”的目标文件。</p>
<p>把多个目标文件结合，生成1个EXE文件的处理就是链接，运行连接的程序就称为链接器（linkage editor或连结器）。</p>
<h2 id="DLL文件及导入库"><a href="#DLL文件及导入库" class="headerlink" title="DLL文件及导入库"></a>DLL文件及导入库</h2><p>Windows以函数的形式为应用提供了各种功能。这些形式的函数称为API（Application Programming Interface，应用程序接口）。</p>
<p>Windows中，API的目标文件，并不是存储在通常的库文件中，而是存储在名为DLL（Dynamic Link Library）文件的特殊库文件中。就如Dynamic这一名称所表示的那样，DLL文件是程序运行时动态结合的文件。</p>
<p>与此相反，存储着目标文件的实体，并直接和EXE文件结合的库文件形式称为静态链接库。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t7.png" alt="?"></p>
<hr>
<h1 id="系统调用和高级编程语言的移植性"><a href="#系统调用和高级编程语言的移植性" class="headerlink" title="系统调用和高级编程语言的移植性"></a>系统调用和高级编程语言的移植性</h1><p>操作系统的硬件控制功能，通常是通过一些小的函数集合体的形式来提供的。这些函数及调用函数的行为统称为系统调用（system call），也就是应用对操作系统（system）的功能进行调用（call）的意思。</p>
<p>高级编程语言的机制就是，使用独自的函数名，然后再在编译时将其转换成相应操作系统的系统调用（也有可能是多个系统调用的组合）。也就是说，用高级编程语言编写的应用在编译后，就转换成了利用系统调用的本地代码（图9-6）。</p>
<h2 id="操作系统和高级编程语言使硬件抽象化"><a href="#操作系统和高级编程语言使硬件抽象化" class="headerlink" title="操作系统和高级编程语言使硬件抽象化"></a>操作系统和高级编程语言使硬件抽象化</h2><p>通过使用高级编程语言，有时甚至也无需考虑系统调用的存在。这是因为操作系统和高级编程语言能够使硬件抽象化。</p>
<p>当前主流的32位版Windows API也称为 Win32 API。之所以这样命名，是为了便于和以前的16位版的Win16 API，以及更先进的64位版的Win64 API区分开来。Win32 API中，各函数的参数及返回值的数据大小，基本上都是32位。</p>
<hr>
<h1 id="通过汇编语言了解程序的实际构成"><a href="#通过汇编语言了解程序的实际构成" class="headerlink" title="通过汇编语言了解程序的实际构成"></a>通过汇编语言了解程序的实际构成</h1><h2 id="汇编语言和本地代码是一一对应的"><a href="#汇编语言和本地代码是一一对应的" class="headerlink" title="汇编语言和本地代码是一一对应的"></a>汇编语言和本地代码是一一对应的</h2><p>通过调查本地代码的内容，可以了解程序最终是以何种形式来运行的。但是，如果直接打开本地代码来看的话，只能看到数值的罗列。如果直接使用这些数值来编写程序的话，还真是不太容易理解。因而就产生了这样一种想法，那就是在各本地代码中，附带上表示其功能的英语单词缩写。例如，在加法运算的本地代码中加上add（addition的缩写）、在比较运算的本地代码中加上cmp（compare的缩写）等。</p>
<p><strong>这些缩写称为助记符，使用助记符的编程语言称为汇编语言。</strong></p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t8.png" alt="?"></p>
<p>哪怕是用C语言编写的源代码，编译后也会转换成特定CPU用的本地代码。而将其反汇编的话，就可以得到汇编语言的源代码，并对其内容进行调查。不过，<strong>本地代码变换成C语言源代码的反编译，则要比反汇编困难。这是因为，C语言的源代码同本地代码不是一一对应的，因此完全还原到原始的源代码是不太可能的</strong></p>
<h2 id="通过编译器输出汇编语言的源代码"><a href="#通过编译器输出汇编语言的源代码" class="headerlink" title="通过编译器输出汇编语言的源代码"></a>通过编译器输出汇编语言的源代码</h2><p><strong>汇编语言源文件的扩展名，通常用“.asm”来表示。</strong></p>
<h2 id="不会转换成本地代码的伪指令"><a href="#不会转换成本地代码的伪指令" class="headerlink" title="不会转换成本地代码的伪指令"></a>不会转换成本地代码的伪指令</h2><p>汇编语言的源代码，是由转换成本地代码的指令（后面讲述的操作码）和针对汇编器的伪指令构成的。伪指令负责把程序的构造及汇编的方法指示给汇编器（转换程序）。不过伪指令本身是无法汇编转换成本地代码的。</p>
<p>伪指令proc和endp围起来的部分，表示的是过程（procedure）的范围。在汇编语言中，这种相当于C语言的函数的形式称为过程。</p>
<h2 id="汇编语言的语法是“操作码-操作数”"><a href="#汇编语言的语法是“操作码-操作数”" class="headerlink" title="汇编语言的语法是“操作码+操作数”"></a>汇编语言的语法是“操作码+操作数”</h2><p>在汇编语言中，1行表示对CPU的一个指令。汇编语言指令的语法结构是操作码+操作数（也存在只有操作码没有操作数的指令）。</p>
<p>能够使用何种形式的操作码，是由CPU的种类决定的。<br><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t9.png" alt="?"></p>
<p>本地代码加载到内存后才能运行。内存中存储着构成本地代码的指令和数据。程序运行时，CPU会从内存中把指令和数据读出，然后再将其存储在CPU内部的寄存器中进行处理。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/y1.png" alt="?"><br>寄存器是CPU中的存储区域。不过，寄存器并不仅仅具有存储指令和数据的功能，也有运算功能。寄存器的名称会通过汇编语言的源代码指定给操作数。内存中的存储区域是用地址编号来区分的。CPU内的寄存器是用eax及ebx这些名称来区分的。此外，CPU内部也有程序员无法直接操作的寄存器。例如，表示运算结果正负及溢出状态的标志寄存器及操作系统专用的寄存器等，都无法通过程序员编写的程序直接进行操作。</p>
<p><img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/y2.png" alt="?"></p>
<p> x86系列32位CPU的寄存器名称中，开头都带了一个字母e，例如eax、ebx、ecx、edx等。这是因为16位CPU的寄存器名称是ax、bx、cx、dx等。32位CPU寄存器的名称中的e，有扩展（extended）的意思。我们也可以仅利用32位寄存器的低16位，此时只需把要指定的寄存器名开头的字母e去掉即可。</p>
<h2 id="mov指令"><a href="#mov指令" class="headerlink" title="mov指令"></a>mov指令</h2><p> mov指令的两个操作数，分别用来指定数据的存储地和读出源。操作数中可以指定寄存器、常数、标签（附加在地址前），以及用方括号（[]）围起来的这些内容。如果指定了没有用方括号围起来的内容，就表示对该值进行处理；如果指定了用方括号围起来的内容，方括号中的值则会被解释为内存地址，然后就会对该内存地址对应的值进行读写操作。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> mov ebp, esp</span><br><span class="line">mov eax, dword ptr [ebp+<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p> mov ebp, esp中，esp寄存器中的值被直接存储在了ebp寄存器中。esp寄存器的值是100时ebp寄存器的值也是100。而在mov eax, dword ptr [ebp+8]的情况下，ebp寄存器的值加8后得到的值会被解释为内存地址。如果ebp寄存器的值是100的话，那么eax寄存器中存储的就是100+ 8=108地址的数据。dword ptr（double word pointer）表示的是从指定内存地址读出4字节的数据。</p>
<blockquote>
<blockquote>
<p>16位cpu一个字是两个字节，这里是32位所以是双字，4字节</p>
</blockquote>
</blockquote>
<h2 id="push和pop"><a href="#push和pop" class="headerlink" title="push和pop"></a>push和pop</h2><p> <img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/y3.png" alt="?"><br> 栈是存储临时数据的区域，它的特点是通过push指令和pop指令进行数据的存储和读出。往栈中存储数据称为“入栈”，从栈中读出数据称为“出栈”。32位x86系列的CPU中，进行1次push或pop，即可处理32位（4字节）的数据。</p>
<p> push指令和pop指令中只有一个操作数。该操作数表示的是“push的是什么及pop的是什么”，而不需要指定“对哪一个地址编号的内存进行push或pop”。这是因为，对栈进行读写的内存地址是由esp寄存器（栈指针）进行管理的。push指令和pop指令运行后，esp寄存器的值会自动进行更新（push指令是-4, pop命令是+4），因而程序员就没有必要指定内存地址了。</p>
<h2 id="函数调用机制"><a href="#函数调用机制" class="headerlink" title="函数调用机制"></a>函数调用机制</h2><p> 函数的参数是通过栈来传递，返回值是通过寄存器来返回的</p>
<hr>
<h1 id="硬件控制方法"><a href="#硬件控制方法" class="headerlink" title="硬件控制方法"></a>硬件控制方法</h1><h2 id="应用和硬件无关？"><a href="#应用和硬件无关？" class="headerlink" title="应用和硬件无关？"></a>应用和硬件无关？</h2><p> Windows提供了通过应用来间接控制硬件的方法。利用操作系统提供的系统调用功能就可以实现对硬件的控制。在Windows中，系统调用称为API（图11-1）。各API就是应用调用的函数。这些函数的实体被存储在DLL文件中。</p>
<p> <img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/y4.png" alt="?"></p>
<p> 例如，假设要在窗口中显示字符串，就可以使用Windows API中的TextOut函数。</p>
<h2 id="支撑硬件输入输出的IN指令和OUT指令"><a href="#支撑硬件输入输出的IN指令和OUT指令" class="headerlink" title="支撑硬件输入输出的IN指令和OUT指令"></a>支撑硬件输入输出的IN指令和OUT指令</h2><p> 这是Pentium等x86系列CPU用的IN指令和OUT指令的语法。IN指令通过指定端口号的端口输入数据，并将其存储在CPU内部的寄存器中。OUT指令则是把CPU寄存器中存储的数据，输出到指定端口号的端口。</p>
<p> 计算机主机中，附带了用来连接显示器及键盘等外围设备的连接器。而各连接器的内部，都连接有用来交换计算机主机同外围设备之间电流特性的IC。这些IC，统称为I/O 控制器。由于电压不同，数字信号及模拟信号的电流特性也不同，计算机主机和外围设备是无法直接连接的。为了解决这个问题，I/O控制器就很有必要了。</p>
<p> I/O是Input/Output的缩写。显示器、键盘等外围设备都有各自专用的I/O控制器。I/O控制器中有用于临时保存输入输出数据的内存。这个内存就是端口。端口（port）的字面意思是“港口”。由于端口就像是在计算机主机和外围设备之间进行货物（数据）装卸的港口，所以因此得名。I/O控制器内部的内存，也称为寄存器。虽然都是寄存器，但它和CPU内部的寄存器在功能上是不同的。CPU内部的寄存器是用来进行数据运算处理的，而I/O寄存器则主要是用来临时存储数据的。</p>
<p> <img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/y5.png" alt="?"></p>
<h2 id="DMA可以实现短时间内传送大量数据"><a href="#DMA可以实现短时间内传送大量数据" class="headerlink" title="DMA可以实现短时间内传送大量数据"></a>DMA可以实现短时间内传送大量数据</h2><p> DMA是指在不通过CPU的情况下，外围设备直接和主内存进行数据传送。磁盘等都用到了这个DMA机制。通过利用DMA，大量数据就可以在短时间内转送到主内存。之所以这么快速，是因为CPU作为中介的时间被节省了。</p>
<h2 id="文字及图片的显示机制"><a href="#文字及图片的显示机制" class="headerlink" title="文字及图片的显示机制"></a>文字及图片的显示机制</h2><p> 用一句话来简单地概括该机制，那就是显示器中显示的信息一直存储在某内存中。该内存称为VRAM（Video RAM）。在程序中，只要往VRAM中写入数据，该数据就会在显示器中显示出来。实现该功能的程序，是由操作系统或BIOS提供，并借助中断来进行处理的。</p>
<p> <img src="/2023/07/30/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/y6.png" alt="?"><br> 在现在的计算机中，显卡等专用硬件中一般都配置有与主内存相独立的VRAM和GPU（Graphics Processing Unit，图形处理器，也称为图形芯片）。这是因为，对经常需要描绘图形的Windows来说，数百兆的VRAM是必需的。而为了提升图形的描绘速度，有时还需要专用的图形处理器。但不管怎样，内存VRAM中存储的数据就是显示器上显示的信息，这一机制是不变的。</p>
<hr>
]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机是怎样跑起来的</title>
    <url>/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机的三大原则"><a href="#计算机的三大原则" class="headerlink" title="计算机的三大原则"></a>计算机的三大原则</h1><p>硬件和软件的区别是什么？</p>
<blockquote>
<p>硬件是看得见摸得着的设备，比如计算机主机、显示器、键盘等。而软件是计算机所执行的程序，即指令和数据。软件本身是看不见的。</p>
</blockquote>
<p>存储字符串“中国”需要几个字节？</p>
<blockquote>
<p>在GBK字符编码下，一个汉字占用2个字节。而在UTF-8字符编码下，一个汉字占用3个字节。</p>
</blockquote>
<p>什么是编码（Code）？</p>
<blockquote>
<p>通常将为了便于计算机处理而经过数字化处理的信息称作编码。</p>
</blockquote>
<h2 id="输入、运算、输出是硬件的基础"><a href="#输入、运算、输出是硬件的基础" class="headerlink" title="输入、运算、输出是硬件的基础"></a>输入、运算、输出是硬件的基础</h2><p>计算机的硬件由大量的IC（Integrated Circuit，集成电路）组成（如 图1.1所示）。每块IC上都带有许多引脚。这些引脚有的用于输入，有的用于输出。IC会在其内部对外部输入的信息进行运算，并把运算结果输出到外部。<br><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q1.png" alt="?"></p>
<p><strong>计算机只会输入、运算、输出</strong></p>
<h2 id="软件是指令和数据的集合"><a href="#软件是指令和数据的集合" class="headerlink" title="软件是指令和数据的集合"></a>软件是指令和数据的集合</h2><p>所谓指令，就是控制计算机进行输入、运算、输出的命令。把向计算机发出的指令一条条列出来，就得到了程序。</p>
<hr>
<h1 id="试着制造一台计算机"><a href="#试着制造一台计算机" class="headerlink" title="试着制造一台计算机"></a>试着制造一台计算机</h1><p>CPU 是 Central Processing Unit（中央处理器）的缩写。<br>Hz（赫兹）是频率的单位<br>Z80 CPU 是 8 比特的 CPU</p>
<h2 id="制作微型计算机所必需的元件"><a href="#制作微型计算机所必需的元件" class="headerlink" title="制作微型计算机所必需的元件"></a>制作微型计算机所必需的元件</h2><p>首先让我们来收集元件吧。制作微型计算机所需的基础元件只有3个，CPU、内存和I/O。CPU是计算机的大脑，负责解释、执行程序。内存负责存储程序和数据。I/O是Input/Output（输入／输出）的缩写，负责将计算机和外部设备（周边设备）连接在一起。</p>
<p>为了驱动CPU运转，称为“时 钟信号”的电信号必不可少。这种电信号就好像带有一个时钟，滴答滴答地每隔一定时间就变换一次电压的高低（如 图2.2所示）。输出时钟信号的元件叫作“时 钟发生器”。时钟发生器中带有晶振，根据其自身的频率（振 动的次数）产生时钟信号。时钟信号的频率可以衡量CPU的运转速度。这里使用的是2.5MHz（兆赫兹）的时钟发生器。</p>
<p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q2.png" alt="?"></p>
<p>用于输入程序的装置也是必不可少的。在这里我们通过拨动指拨开关来输入程序，指拨开关是一种由8个开关并排连在一起构成的元件（如 照片2.1(a)所示）。输出程序执行结果的装置是8个LED（发   光二极管）</p>
<h2 id="电路图的读法"><a href="#电路图的读法" class="headerlink" title="电路图的读法"></a>电路图的读法</h2><p>在电路图中，用连接着各种元件符号的直线表示如何布线。电路中有些地方有交叉，但若只是交叉在一起的话，并不表示电路在交叉处构成通路。只有在交叉处再画上一个小黑点才表示构成通路。</p>
<p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q3.png" alt="?"></p>
<p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q4.png" alt="?"><br>IC的引脚（所 谓引脚就是IC边缘露出的像蜈蚣腿一样的部分）按照逆时针方向依次带有一个从1开始递增的序号。数引脚序号时，要先把表示正方向的标志，比如半圆形的缺口，朝向左侧。举例来说，带有14个引脚的7404，其引脚序号就如图2.5所示。<br><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q5.png" alt="?"></p>
<h2 id="连接电源、数据和地址总线"><a href="#连接电源、数据和地址总线" class="headerlink" title="连接电源、数据和地址总线"></a>连接电源、数据和地址总线</h2><p>首先连接电源。IC与普通的电器一样，只有接通了电源才能工作。Z80    CPU、TC5517和Z80    PIO上都分别带有Vcc引脚和GND引脚。Vcc和GND这一对儿引脚用于为IC供电。</p>
<p>将+5V电源连接到各个IC的Vcc引脚上，然后将0V电源连接到各个IC的GND引脚上。接下来还需要将+5V和0V连接到时钟发生器上。接通电源后这些IC和时钟发生器就可以工作了。</p>
<p>微型计算机所使用的IC属于数字IC。在数字IC中，每个引脚上的电压要么是0V、要么是+5V，通过这两个电压与其他的IC进行电信号的收发。用于给IC供电的Vcc引脚和GND引脚上的电压是恒定不变的+5V和0V，但是其他引脚上的电压，会随着计算机的操作在+5V和0V之间不断地变化。</p>
<p><strong>只要想成0V表示数字0、+5V表示数字1，那么数字IC就是在用二进制数的形式收发信息。</strong></p>
<h3 id="地址总线引脚"><a href="#地址总线引脚" class="headerlink" title="地址总线引脚"></a>地址总线引脚</h3><p>CPU可以与内存或I/O进行数据的输入输出。为了指定输入输出数据时的源头或目的地，CPU上备有“地址总线引脚”。Z80 CPU的地址总线引脚共有16个，用代号A0～A15表示，其中的A表示Address（地址）。后面的数字0～15表示一个16位的二进制数中各个数字的位置，0对应最后一位、15对应第一位。16个地址总线引脚所能指定的地址共有65536个，用二进制数表示的话就是0000000000000000～1111111111111111。因此Z80    CPU可以指定65536个数据存取单元（内 存存储单元或I/O地址），进行信息的输入输出。</p>
<h3 id="数据总线引脚"><a href="#数据总线引脚" class="headerlink" title="数据总线引脚"></a>数据总线引脚</h3><p>一旦指定了存取数据的地址，就可以使用数据总线引脚进行数据的输入输出了。Z80 CPU的数据总线引脚共有8个，用代号D0～D7表示。其中的D表示Data（数据），后面的数字0～7与地址总线引脚代号的规则相同，也表示二进制数中各个数字的位置。Z80 CPU可以一次性地输入输出8比特的数据，这就意味着如果想要输入输出位数（比特数）大于8比特的数据，就要以8比特为单位切分这个数据。</p>
<p>作为内存的TC5517上也有地址总线引脚（A0～A10）和数据总线引脚（D0～D7） 。这些引脚需要同Z80    CPU上带有相同代号的引脚相连。<br><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q6.png" alt="?"></p>
<h2 id="连接-I-O"><a href="#连接-I-O" class="headerlink" title="连接 I/O"></a>连接 I/O</h2><p>寄存器是位于CPU和I/O中的数据存储器。Z80 PIO上共有4个寄存器。2个用于设定PIO本身的功能，2个用于存储与外部设备进行输入输出的数据。</p>
<p>这4个寄存器分别叫作端口A控制、端口A数据、端口B控制和端口B数据。所谓端口就是I/O与外部设备之间输入输出数据的场所，可以把端口（Port）想象成是轮船装卸货物的港口。Z80 PIO有2个端口，端口A和端口B，最多可以连接2个用于输入输出8比特数据的外部设备（如图2.7所示）</p>
<p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q7.png" alt="?"></p>
<p>下面就开始布线吧。因为Z80    PIO上也有D0～D7的数据总线引脚，所以先把它们和Z80 CPU中带有同样代号的引脚连接起来。这样CPU和PIO就能使用这8个引脚交换数据了。</p>
<h2 id="连接时钟信号"><a href="#连接时钟信号" class="headerlink" title="连接时钟信号"></a>连接时钟信号</h2><p>Z80 CPU和Z80    PIO的运转离不开时钟信号。为了传输时钟信号，就需要把时钟发生器的8号引脚和Z80    CPU的CLK（CLK即Clock，时钟）引脚、Z80 PIO的CLK引脚分别连接起来。时钟发生器的8号引脚与+5V之间的电阻用于清理时钟信号。</p>
<p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/1.png" alt="?"></p>
<h2 id="连接用于区分读写对象是内存还是-I-O-的引脚"><a href="#连接用于区分读写对象是内存还是-I-O-的引脚" class="headerlink" title="连接用于区分读写对象是内存还是 I/O 的引脚"></a>连接用于区分读写对象是内存还是 I/O 的引脚</h2><p>至此，我们已经先后把Z80 CPU连接到了TC5517和Z80 PIO上，这两次连接都使用了地址总线引脚A0和A1。如果仅仅这样连接，就会导致一个问题，当地址的最后两位是00、01、10和11时，CPU就无法区分访问的是TC5517中的存储单元，还是Z80 PIO中的寄存器了。</p>
<p>Z80    CPU上的MREQ（即Memory Request，内存请求）引脚和IORQ（即I/O Request，I/O请求）引脚解决了这个问题。当Z80 CPU和内存之间有数据输入输出时，MREQ引脚上的值是0，反之则是1。当Z80 CPU和I/O之间有数据输入输出时，IORQ引脚上的值是0，反之则是1。</p>
<p>对内存和I/O而言，还必须要分清CPU是要输入数据还是输出数据。为此就要用到Z80    CPU的RD引脚（即Read，表示输入，为0时执行输入操作）和WR引脚（即Write，表示输出，为0时执行输出操作）了。请把这两个引脚与TC5517上同名的引脚连接起来。Z80 PIO虽然只有RD引脚，但由于数字IC引脚上的值要么是0要么是1，所以只用1个RD引脚也能区分是输入还是输出，0的话是输入，1的话就是输出<br><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/q8.png" alt="?"></p>
<h2 id="连接剩余的控制引脚"><a href="#连接剩余的控制引脚" class="headerlink" title="连接剩余的控制引脚"></a>连接剩余的控制引脚</h2><p>CPU、内存、I/O中不但有地址总线引脚、数据总线引脚，还有其他引脚，通常把这些引脚统称为“控 制引脚”。之所以这样命名是因为这些引脚上输入输出的电信号具有控制IC的功能。</p>
<p>首先把Z80    CPU的M1引脚（即Machine Cycle 1，机器周期1）和INT引脚（即Interrupt，中断）与Z80    PIO上标有相同代号的引脚连接起来。M1是用于同步的引脚，INT引脚是用于从Z80    PIO向Z80    CPU发出中断请求的引脚。所谓中断就是让CPU根据外部输入的数据执行特定的程序。</p>
<p>一旦把Z80    CPU的RESET引脚（即Reset，重置）上的值先设成0再还原成1，CPU就会被重置，重新从内存0号地址上的指令开始顺序往下执行。重置CPU可以通过按键开关完成。</p>
<p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w1.png" alt="?"></p>
<p>总线是连接到CPU中数据引脚、地址引脚、控制引脚上的电路的统称。使用快动开关可以使Z80    CPU的BUSRQ引脚（即Bus    Request，总线请求）上的值在0和1之间切换。若将BUSRQ引脚的值设为0，则Z80    CPU从电路中隔离。当处于这种隔离状态时，就可以不通过CPU，手动地向内存写入程序了。像这样不经过CPU而直接从外部设备读写内存的行为叫作DMA（Direct Memory Access，直接存储器访问）。在个人计算机里，硬盘等设备要读写内存时使用的就是DMA。</p>
<p>当Z80    CPU从电路中隔离后，BUSAK引脚（即Bus    Acknowledge，响应总线请求）上的值就会变成0。也就是说，把BUSRQ引脚上的值设成0以后，还要确认BUSAK引脚上的值已经变成了0，然后才能进行DMA。</p>
<h2 id="连接外部设备，通过-DMA-输入程序"><a href="#连接外部设备，通过-DMA-输入程序" class="headerlink" title="连接外部设备，通过 DMA 输入程序"></a>连接外部设备，通过 DMA 输入程序</h2><p>这次将计算机主机系统和外部设备连接起来。我们要使用2个指拨开关和1个按键开关，向地址总线引脚和数据总线引脚发送电信号，然后通过DMA将数据总线上的数据存储到内存。</p>
<hr>
<h1 id="手工汇编"><a href="#手工汇编" class="headerlink" title="手工汇编"></a>手工汇编</h1><p>什么是机器语言？</p>
<blockquote>
<p>由二进制数字构成的程序，CPU 可以直接对其解释、执行。</p>
</blockquote>
<p>通常把标识内存或 I/O 中存储单元的数字称作什么？</p>
<blockquote>
<p>标识内存或 I/O 中存储单元的数字叫作“地址”。</p>
</blockquote>
<p>CPU 中的标志寄存器（Flags Register）有什么作用？</p>
<blockquote>
<p>用于在运算指令执行后，存储运算结果的某些状态。</p>
</blockquote>
<h2 id="从程序员的角度看硬件"><a href="#从程序员的角度看硬件" class="headerlink" title="从程序员的角度看硬件"></a>从程序员的角度看硬件</h2><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w2.png" alt="?"><br>即便是相同的机器语言，例如01010011，只要CPU的种类不同，对它的解释也就不同。有的CPU会把它解释成是执行加法运算，有的CPU会把它解释成是向I/O输出。</p>
<p>所谓时钟信号的频率，就是由时钟发生器发送给CPU的电信号的频率。表示时钟信号频率的单位是MHz（兆赫兹= 100万回／秒）。微型计算机使用的是2.5MHz的时钟信号。时钟信号是在0和1两个数之间反复变换的电信号，就像滴答滴答左右摆动的钟摆一样。通常把发出一次滴答的时间称作一个时钟周期。</p>
<p>所谓I/O的地址空间，是指用于指定I/O寄存器的地址范围。在Z80 PIO上，地址空间为0～3，每一个地址对应一个寄存器。</p>
<p>在内存中，每个地址的功能都一样，既可用于存储指令又可用于存储数据。而I/O则不同，地址编号不同（即 寄存器的类型不同），功能也就不同。在微型计算机中，是这样分配Z80 PIO上的寄存器的：端口A数据寄存器对应0号地址，端口B数据寄存器对应1号地址，端口A控制寄存器对应2号地址，端口B控制寄存器对应3号地址。端口A数据寄存器和端口B数据寄存器存储的是与周边设备进行输入输出时所需的数据。其中，端口A连接用于输入数据的指拨开关，端口B连接用于输出数据的LED。而端口A控制寄存器和端口B控制寄存器则存储的是用于设定Z80 PIO功能的参数。</p>
<h2 id="机器语言和汇编语言"><a href="#机器语言和汇编语言" class="headerlink" title="机器语言和汇编语言"></a>机器语言和汇编语言</h2><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w3.png" alt="?"><br>标签的作用是为该行代码对应的内存地址起一个名字。<br>操作码就是表示“做什么”的指令,比如LD是Load（加载）的缩写。<br>操作数表示的是指令执行的对象。CPU的寄存器、内存地址、I/O地址或者直接给出的数字都可以作为操作数。</p>
<p>Z80    CPU的MREQ引脚和IORQ引脚实现了一种能区分输入输出对象的机制，可以区分出使用着相同内存地址的内存和I/O。在汇编语言中，读写内存的指令不同于读写I/O的指令。一旦执行了读写内存的指令，比如LD指令，MREQ引脚上的值就会变为0，于是内存被选为输入输出的对象；而一旦执行了读写I/O的指令，比如IN或OUT指令，IORQ引脚上的值就会变为0，于是I/O（这  里用的是Z80    PIO）被选为输入输出的对象。</p>
<p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w5.png" alt="?"><br>num：表示1个数值，(num)：表示值为num的地址reg、reg1、reg2：名为reg、reg1、reg2的寄存器，(reg)：存储在名为reg的寄存器中的地址</p>
<h2 id="Z80-CPU-的寄存器结构"><a href="#Z80-CPU-的寄存器结构" class="headerlink" title="Z80 CPU 的寄存器结构"></a>Z80 CPU 的寄存器结构</h2><p>既然数据的运算是在CPU中进行的，那么在CPU内部就应该有存储数据的地方。这种存储数据的地方叫作“寄 存器”。虽然也叫寄存器，但是与I/O的寄存器不同，CPU的寄存器不仅能存储数据，还具备对数据进行运算的能力。CPU带有什么样的寄存器取决于CPU的种类。Z80 CPU所带有的寄存器如图3.2所示A。A、B、C、D等字母是寄存器的名字。在汇编语言当中，可以将寄存器的名字指定为操作数。</p>
<p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w6.png" alt="?"></p>
<p>A、B、C、D、E、F、H、L每个寄存器都带有一个辅助寄存器<br>IX、IY、SP、PC这4个寄存器的大小是16比特，其余寄存器的大小都是8比特。寄存器的用途取决于它的类型。有的指令只能将特定的寄存器指定为操作数。</p>
<p>A寄存器也叫作“累 加器”，是运算的核心。所以连接到它上面的导线也一定会比其他寄存器的多。F寄存器也叫作“标 志寄存器”，用于存储运算结果的状态，比如是否发生了进位，数字大小的比较结果等。PC寄存器也叫作“程 序指针”，存储着指向CPU接下来要执行的指令的地址。PC寄存器的值会随着滴答滴答的时钟信号自动更新，可以说程序就是依靠不断变化的PC寄存器的值运行起来的。SP寄存器也叫作“栈 顶指针”，用于在内存中创建出一块称为“栈”的临时数据存储区域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LD  A, <span class="number">207</span></span><br><span class="line">OUT (<span class="number">2</span>),A</span><br><span class="line">LD  A,<span class="number">255</span> </span><br><span class="line"> OUT (<span class="number">2</span>), A</span><br></pre></td></tr></table></figure>
<p>这里的207和255是连续向Z80    PIO的端口A控制寄存器（对 应该I/O的地址编号为2）写入的两个数据。虽然使用OUT指令可以向I/O写入数据，但是不能直接把207、255这样的数字作为OUT指令的操作数。<strong>操作数必须是已存储在CPU寄存器中的数字，这是汇编语言的规定.</strong></p>
<p>完成了Z80 PIO的设定后，就进入了一段死循环处理，用于把由指拨开关输入的数据输出到LED。为了实现这个功能，需要如下的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LOOP: </span><br><span class="line">IN  A, (<span class="number">0</span>)</span><br><span class="line"> OUT (<span class="number">1</span>), A</span><br><span class="line">  JP  LOOP</span><br></pre></td></tr></table></figure>
<p>“IN   A,   (0)”的作用是把数据由端口A数据寄存器（连 接在指拨开关上，对应的I/O地址为0号）输入到CPU的寄存器A。“OUT    (1),    A的作用是把寄存器A的值输出到端口B数据寄存器上（连 接在LED上，对应的I/O地址为1号）</p>
<p>“JP  LOOP”的作用是使程序的流程跳转到LOOP（笔者随意起的一个标签名）标签所标识的指令上。JP是Jump的缩写。   “IN   A,   (0)”所在行的开头有一个标签“LOOP:”  ，代表着这一行的内存地址。</p>
<h2 id="追踪程序的运行过程"><a href="#追踪程序的运行过程" class="headerlink" title="追踪程序的运行过程"></a>追踪程序的运行过程</h2><p>用汇编语言编写的程序是不能直接运行的，必须先转换成机器语言。机器语言是唯一一种CPU能直接理解的编程语言。</p>
<p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w7.png" alt="?"><br>一旦重置了CPU，00000000就会被自动存储到PC寄存器中，这意味着接下来CPU将要从00000000号地址读出程序。首先CPU会从00000000号地址读出指令001  11110，判断出这是一条由2个字节构成的指令，于是接下来会从下一个地址（即00000001，1号地址，代码清单3.3中并没有标记出该地址本身）读出数据11001   111，把这两个数据汇集到一起解释、执行。执行的指令是把数值207写入到寄存器A，用汇编语言表示的话就是“LD   A,   207” 。这时，由于刚刚从内存读出了一条2字节的指令（占 用2个内存地址），所以PC寄存器的值要增加2，并接着从00000010号地址读出指令，解释并执行。</p>
<p>接下来的流程与此类似，通过反复进行“读 取指令”“解 释、执行指令”“更 新PC寄存器的值”这3个操作，程序就能运行起来了。一旦执行完最后一行的JP  LOOP所对应的机器语言，PC寄存器的值就会被设为标签LOOP对应的地址00010000，这样就可以循环执行同样的操作。请诸位重点观察PC寄存器是如何控制程序流程的。</p>
<h2 id="尝试手工汇编"><a href="#尝试手工汇编" class="headerlink" title="尝试手工汇编"></a>尝试手工汇编</h2><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/w8.png" alt="?"><br>下面就从汇编语言的第1行开始转换。第一行的“LD   A,   207”匹配“LD   A,   num”这个模式，所以可以先转换成“00111110   num” 。然后将十进制数的207转换成8比特的二进制数，用这个二进制数替换num。<br><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e1.png" alt="?"></p>
<p>第2条指令“OUT    (2),    A”匹配“OUT    (num), A”这个模式，所以可以先转换成“1  1010011  num” 。然后把num的部分替换成00000010，即用8比特的二进制数表示的十进制数2，最终就得到了机器语言“1  1010011  00000010”。因为内存中已经存储了2字节的机器语言，所以这条机器语言要从00000010号地址（用 十进制表示的话就是2号地址）开始记录。</p>
<p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/e2.png" alt="?"></p>
<p><strong>机器语言中每条语句的字节数是多少，内存地址就相应地增加多少。</strong></p>
<p>接下来是“IN A, (0)”匹配“IN A, (num)”这个模式，所以可以先转换成“11011011 num”。然后把num替换成00000000，即用8比特的二进制数表示的十进制数0，最终就得到了机器语言“11011011 00000000”。对于接下来的“OUT (1), A”，也可以按照同样的方法转换</p>
<p>最后一句的JP  LOOP匹配模式“JP  num” ，所以可以先转换成“1  1000011  num” 。请注意这里要用16比特的二进制数替代作为内存地址的num。在微型计算机中是以8比特为单位指定内存地址的，但在Z80    CPU中用于设定内存地址的引脚却有16个，所以在机器语言中也要用16比特的二进制数设定内存地址。JP指令跳转的目的地为00010000，即“LOOP:”标签所标示的语句“LD   A,   0”对应的内存地址。把这个地址扩充为16比特就是“00000000 00010000”。要扩充到16位，只需要把高8位全部设为0就可以了。</p>
<p>在将一个2字节的数据存储到内存时，存储顺序是低8位在前、高8位在后（也 就是逆序存储）。这样的存储顺序叫作“小 端序”（Little Endian）  ，与此相反，将数据由高位到低位顺序地存储到内存的存储顺序则叫作“大 端序”（Big    Endian）  。根据CPU种类的不同，有的CPU使用大端序，有的CPU使用小端序。Z80 CPU使用的是小端序，因此JP  LOOP对应的机器语言为“1  1000011 00010000 00000000”。</p>
<hr>
<h1 id="程序像河水一样流动着"><a href="#程序像河水一样流动着" class="headerlink" title="程序像河水一样流动着"></a>程序像河水一样流动着</h1><h2 id="程序的流程分为三种"><a href="#程序的流程分为三种" class="headerlink" title="程序的流程分为三种"></a>程序的流程分为三种</h2><p>计算机的硬件系统由CPU、I/O和内存三部分构成。内存中存储着程序，也就是指令和数据。CPU配合着由时钟发生器发出的滴答滴答的时钟信号，从内存中读出指令，然后再依次对其进行解释和执行。</p>
<p>CPU中有各种各样的各司其职的寄存器。其中有一个被称为PC（Program Counter，程序计数器）的寄存器，负责存储内存地址，该地址指向下一条即将执行的指令。每解释执行完一条指令，PC寄存器的值就会自动被更新为下一条指令的地址。</p>
<p>在计算机硬件上的操作中，循环是通过当满足条件时就返回到之前处理过的步骤来实现的。一旦使用了机器语言或汇编语言所提供的跳转指令，就可以将PC寄存器的值设置为任意的内存地址。如果将它的值设为之前执行过的步骤所对应的内存地址，那么就构成了循环。</p>
<h2 id="特殊的程序流程——中断处理"><a href="#特殊的程序流程——中断处理" class="headerlink" title="特殊的程序流程——中断处理"></a>特殊的程序流程——中断处理</h2><p>中断处理是指计算机使程序的流程突然跳转到程序中的特定地方，这样的地方被称为中断处理例程（Routine）或是中断处理程序（Handler）   ，而这种跳转是通过CPU所具备的硬件功能实现的。</p>
<p>在Z80    CPU中有INT和NMI两个引脚，它们可以接收从I/O设备发出的中断请求信号A。以硬件形式连接到CPU上的I/O模块会发出中断请求信号，CPU根据该信号执行相应的中断处理程序。</p>
<p>每当用户按下键盘上的按键，键盘上的I/O模块就会把中断请求信号发送给CPU。CPU通过这种方式就可以知道有按键被按下，于是就会从I/O设备读入数据（如 图4.14所示）。CPU并不会时刻监控键盘是否有按键被按下。<br><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t1.png" alt="?"></p>
<h2 id="特殊的程序流程——事件驱动"><a href="#特殊的程序流程——事件驱动" class="headerlink" title="特殊的程序流程——事件驱动"></a>特殊的程序流程——事件驱动</h2><p>通常把用户在应用程序中点击鼠标或者敲击键盘这样的操作称作“事 件”（Event）  。负责检测事件的是Windows。Windows通过调用应用程序的WndProc()函数通知应用程序事件的发生。而应用程序则根据事件的类型做出相应的处理。这种机制就是事件驱动。</p>
<p>程序的流程还是只有顺序执行、条件分支和循环这三种，这一点是没有改变的。其中的顺序执行是最基本的程序流程，这是因为CPU中的PC寄存器的值会自动更新。条件分支和循环，在高级语言中用程序块表示，在机器语言和汇编语言中用跳转指令表示，在硬件上是通过把PC寄存器的值设为要跳转到的目的地的内存地址来实现。</p>
<p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t2.png" alt="?"></p>
<hr>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>哨兵”指的是一种含有特殊值的数据，可用于标识数据的结尾等。字符串的末尾用0表示，链表的末尾用－1表示，像这种特殊的数据就是哨兵。</p>
<h2 id="算法是程序设计的“熟语"><a href="#算法是程序设计的“熟语" class="headerlink" title="算法是程序设计的“熟语"></a>算法是程序设计的“熟语</h2><h2 id="算法中解决问题的步骤是明确且有限的"><a href="#算法中解决问题的步骤是明确且有限的" class="headerlink" title="算法中解决问题的步骤是明确且有限的"></a>算法中解决问题的步骤是明确且有限的</h2><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/t4.png" alt="?"></p>
<h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>假设有100个箱子，里面分别装有一个写有任意数字的纸条，箱子上面标有1～100的序号。现在要从这100个箱子当中查找是否有箱子装有写着要查找数字的纸条。</p>
<p>首先看看不使用哨兵的方法。从第一个箱子开始依次检查每个箱子中的纸条。每检查完一个纸条，还要再检查箱子的编号（用 变量N表示），并进一步确认编号是否已超过最后一个编号了。</p>
<p>为了消除这种不必要的处理，于是添加了一个101号箱子，其中预先放入的纸条上写有正要查找的数字。这种数据就被称为“哨 兵”。通过放入哨兵，就一定能找到要找的数据了。找到要找的数据后，如果该箱子的编号还没有到101就意味着找到了实际的数据；如果该箱子的编号是101，则意味着找到的是哨兵，而没有找到实际的数据。</p>
<hr>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="了解内存和变量的关系"><a href="#了解内存和变量的关系" class="headerlink" title="了解内存和变量的关系"></a>了解内存和变量的关系</h2><p>计算机所处理的数据都存储在了被称为内存的IC（Integrated Circuit，集成电路）中。在一般的个人计算机中，内存内部被分割成了若干个数据存储单元，每个单元可以存储8比特的数据（8比特= 1字节）。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是数据结构的基础，之所以这么说是因为数组反映了内存的物理结构本身。在内存中存储数据的空间是连续分布的。而在程序中，往往要从内存整体中分配出一块连续的空间以供使用。如果用程序中的语句表示这种分配使用方式的话，就要用到数组（如图6.2所示）</p>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈和队列的相似点在于，它们都可以把不能立刻处理的数据暂时存储起来；不同点在于，栈对所存储数据的存取方式是LIFO的，而队列对所存储数据的存取方式是FIFO的。</p>
<hr>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>面向对象编程（OOP，Object Oriented Programming）是一种编写程序的方法，旨在提升开发大型程序的效率，使程序易于维护。</p>
<h2 id="对-OOP-的多种理解方法"><a href="#对-OOP-的多种理解方法" class="headerlink" title="对 OOP 的多种理解方法"></a>对 OOP 的多种理解方法</h2><p>面向对象编程是一种基于以下思路的程序设计方法：将关注点置于对象（Object）本身，对象的构成要素包含对象的行为及操作B，以此为基础进行编程。这种方法使程序易于复用，软件的生产效率因而得以提升。其中所使用的主要编程技巧有继承、封装、多态三种。</p>
<h2 id="观点-1：面向对象编程通过把组件拼装到一起构建程序"><a href="#观点-1：面向对象编程通过把组件拼装到一起构建程序" class="headerlink" title="观点 1：面向对象编程通过把组件拼装到一起构建程序"></a>观点 1：面向对象编程通过把组件拼装到一起构建程序</h2><p>在面向对象编程中，使用了一种称为“类”的要素，通过把若干个类组装到一起构建一个完整的程序。从这一点来看，可以说类就是程序的组件（Component）。面向对象编程的关键在于能否灵活地运用类。</p>
<p>在大型程序中需要用到大量的函数和变量。假设要用非面向对象的编程方法编写一个由10000个函数和20000个变量构成的程序，那么结果就很容易是代码凌乱不堪，开发效率低到令人吃惊，维护起来也十分困难。</p>
<p>于是一种新的编程方法就被发明出来了，即把程序中有关联的函数和变量汇集到一起编成组。这里的组就是类。</p>
<h2 id="观点-2：面向对象编程能够提升程序的开发效率和可维护性"><a href="#观点-2：面向对象编程能够提升程序的开发效率和可维护性" class="headerlink" title="观点 2：面向对象编程能够提升程序的开发效率和可维护性"></a>观点 2：面向对象编程能够提升程序的开发效率和可维护性</h2><h2 id="观点-3：面向对象编程是适用于大型程序的开发方法"><a href="#观点-3：面向对象编程是适用于大型程序的开发方法" class="headerlink" title="观点 3：面向对象编程是适用于大型程序的开发方法"></a>观点 3：面向对象编程是适用于大型程序的开发方法</h2><h2 id="观点-5：面向对象编程可以借助-UML-设计程序"><a href="#观点-5：面向对象编程可以借助-UML-设计程序" class="headerlink" title="观点 5：面向对象编程可以借助 UML 设计程序"></a>观点 5：面向对象编程可以借助 UML 设计程序</h2><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/a1.png" alt="?"></p>
<h2 id="观点-6：面向对象编程通过在对象间传递消息驱动程序"><a href="#观点-6：面向对象编程通过在对象间传递消息驱动程序" class="headerlink" title="观点 6：面向对象编程通过在对象间传递消息驱动程序"></a>观点 6：面向对象编程通过在对象间传递消息驱动程序</h2><h2 id="观点-7：在面向对象编程中使用继承、封装和多态"><a href="#观点-7：在面向对象编程中使用继承、封装和多态" class="headerlink" title="观点 7：在面向对象编程中使用继承、封装和多态"></a>观点 7：在面向对象编程中使用继承、封装和多态</h2><h2 id="在-Java-和-NET-中有关-OOP-的知识不能少"><a href="#在-Java-和-NET-中有关-OOP-的知识不能少" class="headerlink" title="在 Java 和 .NET 中有关 OOP 的知识不能少"></a>在 Java 和 .NET 中有关 OOP 的知识不能少</h2><p>Java和.NET其实是位于操作系统（Windows或Linux等）之上，旨在通过隐藏操作系统的复杂性从而提升开发效率的程序集，这样的程序集也被称作“框 架”（Framework）。框架由两部分构成，一部分是负责安全执行程序的“执 行引擎”，另一部分是作为程序组件集合的“类库”   （如图7.8所示）</p>
<p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/a2.png" alt="?"></p>
<hr>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库是数据的基地"><a href="#数据库是数据的基地" class="headerlink" title="数据库是数据的基地"></a>数据库是数据的基地</h2><p>适合存储大规模数据的是关系型数据库（Relational Database）。在关系型数据库中，数据被拆分整理到多张表中，同时表与表之间的关系也可以被记录下来。</p>
<h2 id="数据文件、DBMS-和数据库应用程序"><a href="#数据文件、DBMS-和数据库应用程序" class="headerlink" title="数据文件、DBMS 和数据库应用程序"></a>数据文件、DBMS 和数据库应用程序</h2><p>数据库的实质虽然是某种数据文件，但是诸位编写的应用程序并不是直接去读写这些数据文件，而是以DBMS作为中介间接地读写（如 图8.3所示）。DBMS不但可以使应用程序轻松地读写数据文件，而且还具有一致并且安全地存储数据的功能。</p>
<p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/a3.png" alt="?"><br>数据库系统的构成要素包括“数据文件”“DBMS”  “应用程序”三部分。</p>
<p>在小型系统中，把三个要素全部部署在一台计算机上，称作“独立型系统”。在中型系统中，把数据文件部署在一台计算机上，并且使数据文件被部署了DBMS和应用程序的多台计算机共享，这样的系统被称为“文件共享型系统”。在大型系统中，把数据文件和DBMS部署在一台（或者多台）计算机上，然后用户从另外一些部署着应用程序的计算机上访问，这样的系统被称作“客户端／服务器型系统”。</p>
<p>其中部署着数据文件和DBMS的计算机是服务器（Server），即服务的提供者；部署着应用程序的计算机是客户端（Client），即服务的使用者。如果把服务器和客户端之间用互联网联结起来，就形成了Web系统。在Web系统中，一般情况下应用程序也是部署在服务器中的，在客户端只部署Web浏览器.</p>
<h2 id="设计数据库"><a href="#设计数据库" class="headerlink" title="设计数据库"></a>设计数据库</h2><p>在关系型数据库中，把录入到表中的每一行数据都称为记录，把构成一条记录中的各个数据项（在本例中是商品名称、单价等）所在的列都称作字段。记录有时也被称为行或元组（Tuple） ，字段有时也被称为列或属性（Attribute）。上面提到的属性（数 据的类型）就是设置在字段上的。为了代表字段所存储数据的内容还要为每个字段起一个名字。</p>
<h2 id="索引能够提升数据的检索速度"><a href="#索引能够提升数据的检索速度" class="headerlink" title="索引能够提升数据的检索速度"></a>索引能够提升数据的检索速度</h2><p>可以在表的各个字段上设置索引（Index）  ，这也是DBMS所具备的功能之一。虽然索引和键这两个概念容易让人混淆，但其实两者是完全不同的。索引仅仅是提升数据检索和排序速度的内部机制。一旦在字段上设置了索引，DBMS就会自动为这个字段创建索引表。</p>
<p>索引表是一种数据结构，存储着字段的值以及字段所对应记录的位置。例如，如果在顾客表的顾客姓名字段上设置了索引，DBMS就会创建一张索引表（如 图8.13所示），表中有两个字段，分别存储着顾客姓名和位置（所 对应的记录在数据文件中的位置）。与原来的顾客表相比，索引表中的字段数更少，所以可以更快地进行数据的检索和排序。当查询数据时，DBMS先在索引表中进行数据的检索和排序，然后再根据位置信息从原来的数据表中把完整的记录取出来。索引所起的就是“目 录”的作用。与图书的目录一样，数据库的索引也是一种能够高效地查找目标数据的机制。</p>
<h2 id="事务控制也可以交给-DBMS-处理"><a href="#事务控制也可以交给-DBMS-处理" class="headerlink" title="事务控制也可以交给 DBMS 处理"></a>事务控制也可以交给 DBMS 处理</h2><p><strong>事务由若干条SQL语句构成，表示对数据库一系列相关操作的集合。</strong></p>
<blockquote>
<p>为了从顾客A的账户中给顾客B的账户汇入1万元，就需要将以下两条SQL语句依次发送给DBMS：1.把A的账户余额更新（UPDATE语句）为现有余额减去1万元；2.把B的账户余额更新（UPDATE语句）为现有余额加上1万元。此时这两条SQL语句就构成了一个事务。</p>
</blockquote>
<p>假设在第一条SQL语句执行后，网络或计算机发生了故障，第二条SQL语句无法执行，那么会发生什么呢？A的账户余额虽然减少了1万日元，但是B的账户余额却没有相应地增加1万日元，这就导致了数据不一致。</p>
<p>为了防止出现这种问题，在SQL语言中设计了以下三条语句：1.  BEGIN TRANSACTION（开启事务）语句，用于通知DBMS开启事务；2.  COMMIT（提交事务）语句，用于通知DBMS提交事务；3.  ROLL BACK（事务回滚）语句，用于在事务进行中发生问题时，把数据库中的数据恢复到事务开始前的状态。</p>
<hr>
<h1 id="TCP-IP-网络"><a href="#TCP-IP-网络" class="headerlink" title="TCP/IP 网络"></a>TCP/IP 网络</h1><h2 id="实验-1：查看网卡的-MAC-地址"><a href="#实验-1：查看网卡的-MAC-地址" class="headerlink" title="实验 1：查看网卡的 MAC 地址"></a>实验 1：查看网卡的 MAC 地址</h2><p>以太网使用了一种略显粗糙的方法连接LAN内的计算机（如图9.2所示）。以太网中的每台计算机都需要先确认一件事：在网线上有没有其他的计算机正在传输电信号，也就是说要先确保没有人在占用网络，然后才能发送自己想传输的电信号。谁先抢到了网线的使用权，谁就先发送。万一遇到了多台计算机同时都想发送电信号的情况，只需要让这些计算机等待一段长度随机的时间后再重新发送相同的电信号即可。这套机制叫作CSMA/CD（Career Sense Multiple Access with Collision Detection，带冲突检测的载波监听多路访问）。所谓载波监听（Career Sense）  ，指的是这套机制会去监听（Sense）表示网络是否正在使用的电信号（Career）  。而多路复用（Multiple Access）指的是多个（Multiple）设备可以同时访问（Access）传输介质。带冲突检测（with Collision Detection）则表示这套机制会去检测（Detection）因同一时刻的传输而导致的电信号冲突（Collision）。在小规模的LAN中，像这样略显粗躁的CSMA/CD机制是可以正常运转的。因为CSMA/CD归根结底也只是一种适用于LAN的机制。</p>
<p>在以太网中，发送给一台计算机的电信号也可以被其他所有的计算机收到。一台计算机收到了电信号以后会先做判断，如果是发送给自己的则选择接收，反之则选择忽略。可以用被称作MAC（Media Access Control）地址的编号来指定电信号的接收者。在每一块网卡所带有的ROM（Read Only Memory，只读存储器）中，都预先烧录了一个唯一的MAC地址。</p>
<p><strong>因为MAC地址是由制造厂商的编号和产品编号两部分组成的，所以世界上的每一个MAC地址都是独一无二的。</strong></p>
<p><strong>使用 ipconfig /all 命令查看 MAC 地址</strong></p>
<h2 id="实验-2：查看计算机的-IP-地址"><a href="#实验-2：查看计算机的-IP-地址" class="headerlink" title="实验 2：查看计算机的 IP 地址"></a>实验 2：查看计算机的 IP 地址</h2><p>在TCP/IP网络中，除了硬件上的MAC地址，还需要为每台计算机设定一个软件上的编号。这个编号就是众所周知的IP地址。通常把设定了IP地址的计算机称为“主 机”（Host） 。因为路由器也算是计算机的一种，所以它们也有IP地址。在TCP/IP网络中，传输的数据都会携带MAC地址和IP地址两个地址。</p>
<p><strong>使用 ipconfig /all 命令查看 IP 地址</strong></p>
<h2 id="实验-3：了解-DHCP-服务器的作用"><a href="#实验-3：了解-DHCP-服务器的作用" class="headerlink" title="实验 3：了解 DHCP 服务器的作用"></a>实验 3：了解 DHCP 服务器的作用</h2><p>DHCP的全称是Dynamic Host    Configuration Protocol（动态主机设置协议）。</p>
<p>DHCP服务器上记录着可以被分配到LAN内计算机的IP地址范围和子网掩码的值。作为DHCP客户端的计算机在启动时，就可以从中知道哪些IP地址还没有分配给其他计算机。</p>
<p>有一个叫作“默 认网关”的配置项。通常会把路由器的IP地址设置在这里。也就是说路由器就是从LAN通往互联网世界的入口（Gateway）。路由器的IP地址也可以从DHCP服务器获取。</p>
<h2 id="实验-4：路由器是数据传输过程中的指路人"><a href="#实验-4：路由器是数据传输过程中的指路人" class="headerlink" title="实验 4：路由器是数据传输过程中的指路人"></a>实验 4：路由器是数据传输过程中的指路人</h2><p>与LAN内的其他计算机一样，路由器也是连接在集线器上的。因为LAN内采用了CSMA/CD机制，所以所有发送出去的数据也都会发到路由器上。当从公司内的计算机向另一家公司的计算机发送数据时会发生什么呢？首先，一个不属于LAN内计算机的IP地址会被附加到数据的发送目的地字段上。这样的数据虽然会被LAN内的计算机所忽略，但是不会被路由器忽略。因为路由器的工作原理就是查看附加到数据上的IP地址中的网络地址部分，只要发现这个数据不是发送给LAN内计算机的，就把它发送到LAN外，即互联网的世界中。</p>
<p>分布在世界各地的LAN中的路由器相互交换着信息，互联网正是由于这种信息的交换才得以联通。这种信息被称作“路 由表”，用来记录应该把数据转发到哪里。在像互联网这样的网络中，传输路径错综复杂，而路由器就是站在各个岔路口的指路人（如 图9.6所示）。在一台路由器的路由表中，只会记录通往与之相邻的路由器的路径，而并不会记录世界范围内的所有传输路径。</p>
<p>路由表由5列构成。Network Destination、Netmask、Gateway、Interface这四列记录着数据发送的目的地和路由器的IP地址等信息。Metric这一列记录着路径的权重，这个值由某种算法决定，比如数据传输过程中经过的路由器的数量。如果遇到有多条候选路径都可以通往目的地的情况，路由器就会选择Metric值较小的那条路径。在路由表中还有如下的规则：如果数据的发送目的地就在本LAN中，则可以直接发送数据而无需经过路由器转发；反之如果在LAN外（或 发送目的地的IP地址不在路由表中），则需要经过路由器转发。</p>
<h2 id="实验-5：查看路由器的路由过程"><a href="#实验-5：查看路由器的路由过程" class="headerlink" title="实验 5：查看路由器的路由过程"></a>实验 5：查看路由器的路由过程</h2><p>在命令提示符窗口中执行tracert命令后，就可以查看路由的过程了。</p>
<blockquote>
<p>tracert <a href="http://www.google.com/">www.google.com</a></p>
</blockquote>
<h2 id="9-7-实验-6：DNS-服务器可以把主机名解析成-IP-地址"><a href="#9-7-实验-6：DNS-服务器可以把主机名解析成-IP-地址" class="headerlink" title="9.7 实验 6：DNS 服务器可以把主机名解析成 IP 地址"></a>9.7 实验 6：DNS 服务器可以把主机名解析成 IP 地址</h2><p>在互联网中，难以记忆的IP地址使用起来很麻烦。于是人们就发明出了DNS服务器，这样只需要使用FQDN，DNS服务器就可以自动地把它解析为IP地址了（这 个过程叫作“域 名解析”）。DNS服务器通常被部署在各个LAN中，里面记录着FQDN和IP地址的对应关系表。世界范围内的DNS服务器是通过相互合作运转起来的。如果一台DNS服务器无法解析域名，它就会去询问其他的DNS服务器。这套流程是自动进行的，诸位并不会意识到。</p>
<p>计算机都有一个主机名，每个LAN也都有一个域名。举例来说，笔者所使用的计算机的主机名是ma50j（源于这台计算机的型号），所在的LAN的域名是yzw  .co.jp。把主机名和域名组合起来所形成的ma50j.yze.co.jp，就是能够标识笔者这台计算机的一个世界范围内独一无二的名字，这个名字与IP地址的作用是等价的。通常把这种由主机名和域名组合起来形成的名字称作FQDN（Fully Qualified Domain Name，完整限定域名）。</p>
<p>在互联网中，难以记忆的IP地址使用起来很麻烦。于是人们就发明出了DNS服务器，这样只需要使用FQDN，DNS服务器就可以自动地把它解析为IP地址了（这 个过程叫作“域 名解析”）。DNS服务器通常被部署在各个LAN中，里面记录着FQDN和IP地址的对应关系表。世界范围内的DNS服务器是通过相互合作运转起来的。如果一台DNS服务器无法解析域名，它就会去询问其他的DNS服务器。这套流程是自动进行的。</p>
<h2 id="实验-7：查看-IP-地址和-MAC-地址的对应关系"><a href="#实验-7：查看-IP-地址和-MAC-地址的对应关系" class="headerlink" title="实验 7：查看 IP 地址和 MAC 地址的对应关系"></a>实验 7：查看 IP 地址和 MAC 地址的对应关系</h2><hr>
<h1 id="加密数据"><a href="#加密数据" class="headerlink" title="加密数据"></a>加密数据</h1><h2 id="什么是加密"><a href="#什么是加密" class="headerlink" title="什么是加密"></a>什么是加密</h2><p>文本数据可以由各种各样的字符构成。其中每个字符都被分配了一个数字，我们称之为“字 符编码”。定义了应该把哪个编码分配给哪个字符的字符编码体系叫作字符集。字符集分为ASCII字符集、JIS字符集、Shift-JIS字符集，EUC字符集、Unicode字符集等若干种。</p>
<h2 id="错开字符编码的加密方式"><a href="#错开字符编码的加密方式" class="headerlink" title="错开字符编码的加密方式"></a>错开字符编码的加密方式</h2><p><img src="/2023/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/a5.png" alt="?"></p>
<h2 id="密钥越长，解密越困难"><a href="#密钥越长，解密越困难" class="headerlink" title="密钥越长，解密越困难"></a>密钥越长，解密越困难</h2><h2 id="适用于互联网的公开密钥加密技术"><a href="#适用于互联网的公开密钥加密技术" class="headerlink" title="适用于互联网的公开密钥加密技术"></a>适用于互联网的公开密钥加密技术</h2><p><strong>对称密钥加密技</strong><br>这种加密技术的特征是在加密和解密的过程中使用数值相同的密钥。因此，要使用这种技术，就必须事先把密钥的值作为只有发送者和接收者才知道的秘密保护好。</p>
<p>在公开密钥加密技术中，用于加密的密钥可以公开给全世界，因此称为“公 钥”，而用于解密的密钥是只有自己才知道的秘密，因此称为“私 钥”。</p>
<p>1、消息接收方准备好公钥和私钥</p>
<p>2、私钥接收方自己留存、公钥发布给消息发送方</p>
<p>3、消息发送方使用接收方公钥对消息进行加密</p>
<p>4、消息接收方用自己的私钥对消息解密</p>
<h2 id="数字签名可以证明数据的发送者是谁"><a href="#数字签名可以证明数据的发送者是谁" class="headerlink" title="数字签名可以证明数据的发送者是谁"></a>数字签名可以证明数据的发送者是谁</h2><p>【文本数据的发送者】<br>（1）选取一段明文例：NIKKEI<br>（2）计算出明文内容的信息摘要例：(78＋73＋75＋75＋69＋73)÷100的余数= 43<br>（3）用私钥对计算出的信息摘要进行加密例：43→66（字母B的编码）<br>（4）把步骤（3）得出的值附加到明文后面再发送给接收者例：NIKKEI B</p>
<p>【文本数据的接收者】<br>（1）用发送者的公钥对信息摘要进行解密例：B = 66→43<br>（2）计算出明文部分的信息摘要例：(78＋73＋75＋75＋69＋73)÷100的余数= 43<br>（3）比较在步骤（1）和（2）中求得的值，二者相同则证明接收的信息有效</p>
<hr>
<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="XML-是标记语言"><a href="#XML-是标记语言" class="headerlink" title="XML 是标记语言"></a>XML 是标记语言</h2><p>XML是eXtensible Markup Language的缩写，译为可扩展标记语言。</p>
<p>&lt;html&gt;是用于表示这是HTML文件的标签。同样，其他标签也分别被赋予了意义.</p>
<p>通常把通过添加标签为数据赋予意义的行为称为“标 记”。为这种给数据赋予意义的行为定义规则的语言就是“标 记语言”。HTML是用于编写网页的标记语言，更简单地说法就是HTML决定了可用于编写网页的标签。</p>
<h2 id="XML-是可扩展的语言"><a href="#XML-是可扩展的语言" class="headerlink" title="XML 是可扩展的语言"></a>XML 是可扩展的语言</h2><p>在iuhist.xml中就有&lt;publisherName&gt;和&lt;processorArchitecture&gt;等标签，而且很有可能这两个标签表示的就是“发行者的名字”和“处理器的架构”</p>
<p>那么是XML规定了这些标签吗？答案是否定的。XML本身并不会限定标签的种类，反倒是允许XML的使用者随心所欲地创建标签。也就是说，在“&lt;”和“&gt;”中的单词可以是任意的。这就是所谓的“可扩展”。在HTML中，我们只能使用由HTML定义出的那若干种标签，因此HTML是固定的标记语言。</p>
<h2 id="XML-是元语言"><a href="#XML-是元语言" class="headerlink" title="XML 是元语言"></a>XML 是元语言</h2><p>通过定义要使用的标签种类，就可以创造出一门新的标记语言。通常把这种用于创造语言的语言称作“元 语言”。例如，我们可以使用&lt;dog&gt;和&lt;cat&gt;等标签，创造一种属于自己的标记语言——宠物语言。</p>
<p>XML的数据是纯文本格式的，也就是说只包含字符。通常把遵循了XML的约束编写出的文档称为“XML文档”；把保存着XML文档的文件称为“XML文件”。可以使用记事本等文本编辑器编写XML文件。</p>
<h2 id="XML-可以为信息赋予意义"><a href="#XML-可以为信息赋予意义" class="headerlink" title="XML 可以为信息赋予意义"></a>XML 可以为信息赋予意义</h2><p>如果网站只提供了HTML，那么这个程序几乎不可能完成。因为HTML中规定的各种标签只能用来指定信息的呈现样式，而不能表示信息的含义。</p>
<h2 id="xML-是通用的数据交换格式"><a href="#xML-是通用的数据交换格式" class="headerlink" title="xML 是通用的数据交换格式"></a>xML 是通用的数据交换格式</h2><p>如果某家厂商的某个应用程序把数据保存到了XML文件中，那么其他厂商的另一个应用程序就应该可以通过加载这个XML文件来使用数据。</p>
<h2 id="可以为-XML-标签设定命名空间"><a href="#可以为-XML-标签设定命名空间" class="headerlink" title="可以为 XML 标签设定命名空间"></a>可以为 XML 标签设定命名空间</h2><p>在XML文档中，通过把“xmlns=”命名空间的名字””作为标签的一个属性记述，就可以为标签设定命名空间。xmlns即XML    NameSpace（命名空间）的缩写。通常用全世界唯一的标识符作为命名空间的名称。</p>
]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统导论-虚拟机</title>
    <url>/2023/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="虚拟机监视器"><a href="#虚拟机监视器" class="headerlink" title="虚拟机监视器"></a>虚拟机监视器</h1><p><strong>希望同时在机器上运行不同的操作系统，该怎么办？</strong></p>
<p>IBM以虚拟机监视器（Virtual Machine Monitor，VMM）（也称为管理程序，hypervisor）[G74]的形式，引入了另一个间接层。</p>
<p>监视器位于一个或多个操作系统和硬件之间，并为每个运行的操作系统提供控制机器的假象。然而，在幕后，实际上是监视器在控制硬件，并必须在机器的物理资源上为运行的OS提供多路复用。实际上，VMM作为操作系统的操作系统，但在低得多层次上。操作系统仍然认为它与物理硬件交互。因此，透明度（transparency）是VMM的主要目标。</p>
<h2 id="虚拟化-CPU"><a href="#虚拟化-CPU" class="headerlink" title="虚拟化 CPU"></a>虚拟化 CPU</h2><p>如果想在VMM之上“启动”新操作系统，只需跳转到第一条指令的地址，并让操作系统开始运行，就这么简单。</p>
<p>假设我们在单个处理器上运行，并且希望在两个虚拟机之间进行多路复用，即在两个操作系统和它们各自的应用程序之间进行多路复用。非常类似于操作系统在运行进程之间切换的方式（上下文切换，context  switch），虚拟机监视器必须在运行的虚拟机之间执行机器切换（machine  switch）。因此，当执行这样的切换时，VMM必须保存一个OS的整个机器状态（包括寄存器，PC，并且与上下文切换不同，包括所有特权硬件状态），恢复待运行虚拟机的机器状态，然后跳转到待运行虚拟机的PC，完成切换。注意，待运行VM的PC可能在OS本身内（系统正在执行系统调用），或可能就在该OS上运行的进程内（用户模式应用程序）。</p>
<p><img src="/2023/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%99%9A%E6%8B%9F%E6%9C%BA/q1.png" alt="?"></p>
<h2 id="虚拟化内存"><a href="#虚拟化内存" class="headerlink" title="虚拟化内存"></a>虚拟化内存</h2><p>每个操作系统通常将物理内存视为一个线性的页面数组，并将每个页面分配给自己或用户进程。当然，操作系统本身已经为其运行的进程虚拟化了内存，因此每个进程都有自己的私有地址空间的假象。现在我们必须添加另一层虚拟化，以便多个操作系统可以共享机器的实际物理内存，我们必须透明地这样做。</p>
<p>这个额外的虚拟化层使“物理”内存成为一个虚拟化层，在VMM所谓的机器内存（machine  memory）之上，机器内存是系统的真实物理内存。因此，我们现在有一个额外的间接层：每个操作系统通过其每个进程的页表映射虚拟到物理地址，VMM通过它的每个OS页面表，将生成的物理地址映射到底层机器地址。图B.1描述了这种额外的间接层。</p>
<p><img src="/2023/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%99%9A%E6%8B%9F%E6%9C%BA/q2.png" alt="?"></p>
]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统导论-分布式</title>
    <url>/2023/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><p>Web浏览器连接到地球上其他地方的We b服务器时，它就会参与似乎是简单形式的客户端/服务器（client/server）分布式系统。当你连上Google和Facebook等现代网络服务时，不只是与一台机器进行交互。在幕后，这些复杂的服务是利用大量机器（成千上万台）来提供的，每台机器相互合作，以提供站点的特定服务。</p>
<h2 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h2><p>通信基本是不可靠的。无论是在广域Internet，还是Infiniband等局域高速网络中，数据包都会经常丢失、损坏，或无法到达目的地</p>
<h2 id="不可靠的通信层"><a href="#不可靠的通信层" class="headerlink" title="不可靠的通信层"></a>不可靠的通信层</h2><p>UDP是不可靠通信层的一个很好的例子。如果你使用它，就会遇到数据包丢失（丢弃），从而无法到达目的地的情况。发送方永远不会被告知丢失。但是，这并不意味着UDP根本不能防止任何故障。例如，UDP包含校验和（checksum），以检测某些形式的数据包损坏。</p>
<h2 id="可靠的通信层"><a href="#可靠的通信层" class="headerlink" title="可靠的通信层"></a>可靠的通信层</h2><p><img src="/2023/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%88%86%E5%B8%83%E5%BC%8F/q1.png" alt="?"><br><img src="/2023/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%88%86%E5%B8%83%E5%BC%8F/q2.png" alt="?"></p>
<p>常用的可靠通信层称为TCP/IP，或简称为TCP。TCP比上面描述的要复杂得多，包括处理网络拥塞的机制[VJ88]，多个未完成的请求，以及数百个其他的小调整和优化。</p>
<h2 id="通信抽象"><a href="#通信抽象" class="headerlink" title="通信抽象"></a>通信抽象</h2><p>分布式共享内存（Distributed Shared Memory，DSM）系统使不同机器上的进程能够共享一个大的虚拟地址空间[LH89]。这种抽象将分布式计算变成貌似多线程应用程序。唯一的区别是这些线程在不同的机器上运行，而不是在同一台机器上的不同处理器上。</p>
<p>在DSM系统中，一些访问是便宜的，但是其他访问导致页面错误和远程机器的昂贵提取。</p>
<h2 id="远程过程调用（RPC）"><a href="#远程过程调用（RPC）" class="headerlink" title="远程过程调用（RPC）"></a>远程过程调用（RPC）</h2><p>操作系统抽象对于构建分布式系统来说是一个糟糕的选择，但编程语言（PL）抽象要有意义得多。最主要的抽象是基于远程过程调用（Remote  Procedure  Call），或简称RPC [BN84]①。</p>
<p>远程过程调用包都有一个简单的目标：使在远程机器上执行代码的过程像调用本地函数一样简单直接。因此，对于客户端来说，进行一个过程调用，并在一段时间后返回结果。服务器只是定义了一些它希望导出的例程。其余的由RPC系统处理，RPC系统通常有两部分：存根生成器（stub generator，有时称为协议编译器，protocol compiler）和运行时库（run-time library）。</p>
<h3 id="存根生成器"><a href="#存根生成器" class="headerlink" title="存根生成器"></a>存根生成器</h3><p>存根生成器的工作很简单：通过自动化，消除将函数参数和结果打包成消息的一些痛苦。这有许多好处：通过设计避免了手工编写此类代码时出现的简单错误。此外，存根生成器也许可以优化此类代码，从而提高性能。</p>
]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统导论-持久性</title>
    <url>/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h1><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>CPU通过某种内存总线（memory bus）或互连电缆连接到系统内存。图像或者其他高性能I/O设备通过常规的I/O总线（I/O bus）连接到系统，在许多现代系统中会是PCI或它的衍生形式。最后，更下面是外围总线（peripheral bus），比如SCSI、SATA或者USB。它们将最慢的设备连接到系统，包括磁盘、鼠标及其他类似设备。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q1.png" alt="?"></p>
<p><strong>为什么要用这样的分层架构？</strong></p>
<p>因为物理布局及造价成本。<br>越快的总线越短，因此高性能的内存总线没有足够的空间连接太多设备。另外，在工程上高性能总线的造价非常高。所以，系统的设计采用了这种分层的方式，这样可以让要求高性能的设备（比如显卡）离CPU更近一些，低性能的设备离CPU远一些。将磁盘和其他低速设备连到外围总线的好处很多，其中较为突出的好处就是你可以在外围总线上连接大量的设备。</p>
<h2 id="标准设备"><a href="#标准设备" class="headerlink" title="标准设备"></a>标准设备</h2><p>一个标准设备（不是真实存在的）<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q2.png" alt="?"><br>第一部分是向系统其他部分展现的硬件接口（interface）。同软件一样，硬件也需要一些接口，让系统软件来控制它的操作。因此，所有设备都有自己的特定接口以及典型交互的协议。</p>
<p>第2部分是它的内部结构（internal  structure）。这部分包含设备相关的特定实现，负责具体实现设备展示给系统的抽象接口。非常简单的设备通常用一个或几个芯片来实现它们的功能。更复杂的设备会包含简单的CPU、一些通用内存、设备相关的特定芯片，来完成它们的工作。例如，现代RAID控制器通常包含成百上千行固件（firmware，即硬件设备中的软件），以实现其功能。</p>
<h2 id="标准协议"><a href="#标准协议" class="headerlink" title="标准协议"></a>标准协议</h2><p>一个（简化的）设备接口包含3个寄存器：一个状态（status）寄存器，可以读取并查看设备的当前状态；一个命令（command）寄存器，用于通知设备执行某个具体任务；一个数据（data）寄存器，将数据传给设备或从设备接收数据。通过读写这些寄存器，操作系统可以控制设备的行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">While (STATUS == BUSY)</span><br><span class="line">; <span class="comment">// wait until device is not busy</span></span><br><span class="line">Write data to DATA <span class="keyword">register</span></span><br><span class="line">Write command to COMMAND <span class="title function_">register</span></span><br><span class="line"><span class="params">(Doing so starts the device and executes the command)</span></span><br><span class="line"><span class="title function_">While</span> <span class="params">(STATUS == BUSY)</span></span><br><span class="line">; <span class="comment">// wait until device is done with your request</span></span><br></pre></td></tr></table></figure>

<p>该协议包含4步。第1步，操作系统通过反复读取状态寄存器，等待设备进入可以接收命令的就绪状态。我们称之为轮询（polling）设备（基本上，就是问它正在做什么）。第2步，操作系统下发数据到数据寄存器。例如，你可以想象如果这是一个磁盘，需要多次写入操作，将一个磁盘块（比如4KB）传递给设备。如果主CPU参与数据移动（就像这个示例协议一样），我们就称之为编程的I/O（programmed I/O，PIO）。第3步，操作系统将命令写入命令寄存器；这样设备就知道数据已经准备好了，它应该开始执行命令。最后一步，操作系统再次通过不断轮询设备，等待并判断设备是否执行完成命令（有可能得到一个指示成功或失败的错误码）。</p>
<p><strong>简单有效但效率低（在等待设备执行完成命令时浪费大量CPU时间）</strong></p>
<h2 id="利用中断减少-CPU-开销"><a href="#利用中断减少-CPU-开销" class="headerlink" title="利用中断减少 CPU 开销"></a>利用中断减少 CPU 开销</h2><p>常见的中断（interrupt）来减少CPU开销。有了中断后，CPU 不再需要不断轮询设备，而是向设备发出一个请求，然后就可以让对应进程睡眠，切换执行其他任务。当设备完成了自身操作，会抛出一个硬件中断，引发CPU跳转执行操作系统预先定义好的中断服务例程（Interrupt  Service  Routine，ISR），或更为简单的中断处理程序（interrupt  handler）。中断处理程序是一小段操作系统代码，它会结束之前的请求（比如从设备读取到了数据或者错误码）并且唤醒等待I/O的进程继续执行。</p>
<p><strong>中断允许计算与I/O重叠（overlap），这是提高CPU利用率的关键。</strong></p>
<p>其中，进程1在CPU上运行一段时间（对应CPU那一行上重复的1），然后发出一个读取数据的I/O请求给磁盘。如果没有中断，那么操作系统就会简单自旋，不断轮询设备状态，直到设备完成I/O操作（对应其中的p）。当设备完成请求的操作后，进程1又可以继续运行。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q3.png" alt="?"></p>
<p>如果我们利用中断并允许重叠，操作系统就可以在等待磁盘操作时做其他事情：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q4.png" alt="?"><br>在这个例子中，在磁盘处理进程1的请求时，操作系统在CPU上运行进程2。磁盘处理完成后，触发一个中断，然后操作系统唤醒进程1继续运行。这样，在这段时间，无论CPU还是磁盘都可以有效地利用。</p>
<p><strong>如果设备非常快，那么最好的办法反而是轮询。如果设备比较慢，那么采用允许发生重叠的中断更好。</strong></p>
<h2 id="利用-DMA-进行更高效的数据传送"><a href="#利用-DMA-进行更高效的数据传送" class="headerlink" title="利用 DMA 进行更高效的数据传送"></a>利用 DMA 进行更高效的数据传送</h2><p>如果使用编程的I/O将一大块数据传给设备，CPU又会因为琐碎的任务而变得负载很重，浪费了时间和算力，本来更好是用于运行其他进程。下面的时间线展示了这个问题：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q5.png" alt="?"><br>进程1在运行过程中需要向磁盘写一些数据，所以它开始进行I/O操作，将数据从内存拷贝到磁盘（其中标示c的过程）(<strong>从内存拷贝到磁盘缓冲区</strong>)。拷贝结束后，磁盘上的I/O操作开始执行，此时CPU才可以处理其他请求。</p>
<p><strong>使用PIO的方式，CPU的时间会浪费在向设备传输数据或从设备传出数据的过程中。如何才能分离这项工作，从而提高CPU的利用率？</strong></p>
<p>解决方案就是使用DMA（Direct Memory Access）。DMA引擎是系统中的一个特殊设备，它可以协调完成内存和设备间的数据传递，不需要CPU介入。</p>
<p>DMA工作过程如下。为了能够将数据传送给设备，操作系统会通过编程告诉DMA引擎数据在内存的位置，要拷贝的大小以及要拷贝到哪个设备。在此之后，操作系统就可以处理其他请求了。当DMA的任务完成后，DMA控制器会抛出一个中断来告诉操作系统自己已经完成数据传输。修改后的时间线如下：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q6.png" alt="?"></p>
<p>从时间线中可以看到，数据的拷贝工作都是由DMA控制器来完成的。因为CPU在此时是空闲的，所以操作系统可以让它做一些其他事情，比如此处调度进程2到CPU来运行。因此进程2在进程1再次运行之前可以使用更多的CPU。</p>
<blockquote>
<p>PIO通过在计算机系统的总线上进行并行数据传输来完成输入和输出操作。在PIO模式下，数据是逐位地在系统总线上传输的，需要使用多个时钟周期完成一个数据传输操作。此外，PIO通常涉及主处理器的直接参与，主处理器负责控制和协调数据传输操作。</p>
</blockquote>
<blockquote>
<p>相比之下，DMA（Direct Memory Access，直接内存访问）是另一种数据传输模式。在DMA模式下，数据传输由DMA控制器负责，而不再需要主处理器直接参与。这种方式可以降低主处理器的负载，并提高数据传输效率。</p>
</blockquote>
<h2 id="设备交互的方法"><a href="#设备交互的方法" class="headerlink" title="设备交互的方法"></a>设备交互的方法</h2><p>硬件如何如与设备通信？是否需要一些明确的指令？或者其他的方式？</p>
<p>主要有两种方式来实现与设备的交互。第一种办法相对老一些（在IBM主机中使用了多年），就是<strong>用明确的I/O指令</strong>。这些指令规定了操作系统将数据发送到特定设备寄存器的方法，从而允许构造上文提到的协议。</p>
<p>例如在x86上，in和out指令可以用来与设备进行交互。当需要发送数据给设备时，调用者指定一个存入数据的特定寄存器及一个代表设备的特定端口。执行这个指令就可以实现期望的行为。</p>
<p>这些指令通常是特权指令（privileged）。操作系统是唯一可以直接与设备交互的实体。</p>
<p><strong>第二种方法是内存映射I/O（memory- mapped I/O）</strong>。通过这种方式，硬件将设备寄存器作为内存地址提供。当需要访问设备寄存器时，操作系统装载（读取）或者存入（写入）到该内存地址；然后硬件会将装载/存入转移到设备上，而不是物理内存。</p>
<h2 id="纳入操作系统：设备驱动程序"><a href="#纳入操作系统：设备驱动程序" class="headerlink" title="纳入操作系统：设备驱动程序"></a>纳入操作系统：设备驱动程序</h2><p>如何保持操作系统的大部分与设备无关，从而对操作系统的主要子系统隐藏设备交互的细节？</p>
<p>在最底层，操作系统的一部分软件清楚地知道设备如何工作，我们将这部分软件称为<strong>设备驱动程序（device driver）</strong>，所有设备交互的细节都封装在其中。</p>
<p>文件系统（当然也包括在其之上的应用程序）完全不清楚它使用的是什么类型的磁盘。它只需要简单地向通用块设备层发送读写请求即可，块设备层会将这些请求路由给对应的设备驱动，然后设备驱动来完成真正的底层操作。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q7.png" alt="?"></p>
<hr>
<h1 id="磁盘驱动器"><a href="#磁盘驱动器" class="headerlink" title="磁盘驱动器"></a>磁盘驱动器</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>驱动器由大量扇区（512字节块）组成，每个扇区都可以读取或写入。在具有n个扇区的磁盘上，扇区从0到n−1编号。因此，我们可以将磁盘视为一组扇区，0到n−1是驱动器的地址空间（address space）。</p>
<p>多扇区操作是可能的。实际上，许多文件系统一次读取或写入4KB（或更多）。但是，在更新磁盘时，驱动器制造商唯一保证的是单个512字节的写入是原子的（atomic，即它将完整地完成或者根本不会完成）。</p>
<h2 id="基本几何形状"><a href="#基本几何形状" class="headerlink" title="基本几何形状"></a>基本几何形状</h2><p>让我们开始了解现代磁盘的一些组件。我们从一个盘片（platter）开始，它是一个圆形坚硬的表面，通过引入磁性变化来永久存储数据。磁盘可能有一个或多个盘片。每个盘片有两面，每面都称为表面。这些盘片通常由一些硬质材料（如铝）制成，然后涂上薄薄的磁性层，即使驱动器断电，驱动器也能持久存储数据位。</p>
<p>所有盘片都围绕主轴（spindle）连接在一起，主轴连接到一个电机，以一个恒定（固定）的速度旋转盘片（当驱动器接通电源时）。旋转速率通常以每分钟转数（Rotations Per Minute，RPM）来测量，典型的现代数值在7200～15000 RPM范围内。请注意，我们经常会对单次旋转的时间感兴趣，例如，以10000 RPM旋转的驱动器意味着一次旋转需要大约6ms。</p>
<p>数据在扇区的同心圆中的每个表面上被编码。我们称这样的同心圆为一个磁道（track）。一个表面包含数以千计的磁道，紧密地排在一起，数百个磁道只有头发的宽度。</p>
<p>要从表面进行读写操作，我们需要一种机制，使我们能够感应（即读取）磁盘上的磁性图案，或者让它们发生变化（即写入）。读写过程由磁头（disk  head）完成；驱动器的每个表面有一个这样的磁头。磁头连接到单个磁盘臂（disk arm）上，磁盘臂在表面上移动，将磁头定位在期望的磁道上。</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q9.png" alt="?"><br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/q8.png" alt="?"><br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w1.png" alt="?"></p>
<h2 id="简单的磁盘驱动器"><a href="#简单的磁盘驱动器" class="headerlink" title="简单的磁盘驱动器"></a>简单的磁盘驱动器</h2><p>该磁道只有12个扇区，每个扇区的大小为512字节（典型的扇区大小，回忆一下），因此用0到11的数字表示。这里的单个盘片围绕主轴旋转，电机连接到主轴。当然，磁道本身并不太有趣，我们希望能够读取或写入这些扇区，因此需要一个连接到磁盘臂上的磁头:<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w2.png" alt="?"></p>
<h3 id="单磁道延迟：旋转延迟"><a href="#单磁道延迟：旋转延迟" class="headerlink" title="单磁道延迟：旋转延迟"></a>单磁道延迟：旋转延迟</h3><p>现在收到读取块0的请求。磁盘应如何处理该请求？</p>
<p>简单磁盘中，磁盘不必做太多工作。具体来说，它必须等待期望的扇区旋转到磁头下。这种等待在现代驱动器中经常发生，并且是I/O服务时间的重要组成部分，它有一个特殊的名称：旋转延迟（rotational delay，有时称为rotation delay，尽管听起来很奇怪）</p>
<h3 id="多磁道：寻道时间"><a href="#多磁道：寻道时间" class="headerlink" title="多磁道：寻道时间"></a>多磁道：寻道时间</h3><p>到目前为止，我们的磁盘只有一条磁道，这是不太现实的。现代磁盘当然有数以百万计的磁道。因此，我们来看看更具现实感的磁盘表面，这个表面有3条磁道（见图37.3左图）。在该图中，磁头当前位于最内圈的磁道上（它包含扇区24～35）。下一个磁道包含下一组扇区（12～23），最外面的磁道包含最前面的扇区（0～11）。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w4.png" alt="?"></p>
<p>读取扇区11。为了服务这个读取请求，驱动器必须首先将磁盘臂移动到正确的磁道（在这种情况下，是最外面的磁道），通过一个所谓的寻道（seek）过程。寻道，以及旋转，是最昂贵的磁盘操作之一。</p>
<p>寻道有许多阶段：首先是磁盘臂移动时的加速阶段。然后随着磁盘臂全速移动而惯性滑动。然后随着磁盘臂减速而减速。最后，在磁头小心地放置在正确的磁道上时停下来。停放时间（settling  time）通常不小，例如0.5～2ms，因为驱动器必须确定找到正确的磁道（想象一下，如果它只是移到附近！）。</p>
<p>寻道之后，磁盘臂将磁头定位在正确的磁道上。</p>
<p>在这个例子中，大约旋转了3个扇区。因此，扇区9即将通过磁头下方，我们只能承受短暂的转动延迟，以便完成传输。</p>
<p>当扇区11经过磁盘磁头时，I/O的最后阶段将发生，称为传输（transfer），数据从表面读取或写入表面。因此，我们得到了完整的I/O时间图：首先寻道，然后等待转动延迟，最后传输。</p>
<h3 id="一些其他细节"><a href="#一些其他细节" class="headerlink" title="一些其他细节"></a>一些其他细节</h3><p>许多驱动器采用某种形式的磁道偏斜（track skew）(轻微错位)，以确保即使在跨越磁道边界时，顺序读取也可以方便地服务。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w5.png" alt="?"><br>扇区往往会偏斜，因为从一个磁道切换到另一个磁道时，磁盘需要时间来重新定位磁头（即便移到相邻磁道）。如果没有这种偏斜，磁头将移动到下一个磁道，但所需的下一个块已经旋转到磁头下，因此驱动器将不得不等待整个旋转延迟，才能访问下一个块。</p>
<p>任何现代磁盘驱动器都有一个重要组成部分，即它的缓存（cache），由于历史原因有时称为磁道缓冲区（track buffer）。该缓存只是少量的内存（通常大约8MB或16MB），驱动器可以使用这些内存来保存从磁盘读取或写入磁盘的数据。例如，当从磁盘读取扇区时，驱动器可能决定读取该磁道上的所有扇区并将其缓存在其存储器中。这样做可以让驱动器快速响应所有后续对同一磁道的请求。</p>
<p>在写入时，驱动器面临一个选择：是先写入缓存再写入磁盘？还是边写缓存边写入磁盘？前者被称为后写（write back）缓存（有时称为立即报告，immediate reporting），后者则称为直写（write through）。后写缓存有时会使驱动器看起来“更快”，但可能有危险。</p>
<h2 id="I-O-时间：用数学"><a href="#I-O-时间：用数学" class="headerlink" title="I/O 时间：用数学"></a>I/O 时间：用数学</h2><p>现在可以将I/O时间表示为3个主要部分之和：</p>
<p>TI/O  =  T寻道+ T旋转+ T传输</p>
<p>为了更好地感受I/O时间，我们执行以下计算。假设有两个我们感兴趣的工作负载。第一个工作负载称为随机（random）工作负载，它向磁盘上的随机位置发出小的（例如4KB）读取请求。随机工作负载在许多重要的应用程序中很常见，包括数据库管理系统。第二种称为顺序（sequential）工作负载，只是从磁盘连续读取大量的扇区，不会跳过。顺序访问模式很常见，因此也很重要。</p>
<blockquote>
<p>提示：顺序地使用磁盘<br>尽可能以顺序方式将数据传输到磁盘，并从磁盘传输数据。如果顺序不可行，至少应考虑以大块传输数据：越大越好。如果I/O是以小而随机方式完成的，则I/O性能将受到显著影响。而且，用户也会痛苦。而且，你也会痛苦，因为你知道正是你不小心的随机I/O让你痛苦。</p>
</blockquote>
<h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p>与任务调度不同，每个任务的长度通常是不知道的，对于磁盘调度，我们可以很好地猜测“任务”（即磁盘请求）需要多长时间。通过估计请求的查找和可能的旋转延迟，磁盘调度程序可以知道每个请求将花费多长时间，因此（贪婪地）选择先服务花费最少时间的请求。因此，磁盘调度程序将尝试在其操作中遵循SJF（最短任务优先）的原则（principle of SJF，shortest job first）。</p>
<h3 id="SSTF：最短寻道时间优先"><a href="#SSTF：最短寻道时间优先" class="headerlink" title="SSTF：最短寻道时间优先"></a>SSTF：最短寻道时间优先</h3><p>SSTF按磁道对I/O请求队列排序，选择在最近磁道上的请求先完成。例如，假设磁头当前位置在内圈磁道上，并且我们请求扇区21（中间磁道）和2（外圈磁道），那么我们会首先发出对21的请求，等待它完成，然后发出对2的请求。</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w6.png" alt="?"></p>
<p>第一个问题，主机操作系统无法利用驱动器的几何结构，而是只会看到一系列的块。幸运的是，这个问题很容易解决。操作系统可以简单地实现最近块优先（Nearest-Block-First，NBF），而不是SSTF，然后用最近的块地址来调度请求。</p>
<p>第二个问题更为根本：饥饿（starvation）。想象一下，在我们上面的例子中，是否有对磁头当前所在位置的内圈磁道有稳定的请求。然后，纯粹的SSTF方法将完全忽略对其他磁道的请求。</p>
<h3 id="电梯（又称-SCAN-或-C-SCAN）"><a href="#电梯（又称-SCAN-或-C-SCAN）" class="headerlink" title="电梯（又称 SCAN 或 C-SCAN）"></a>电梯（又称 SCAN 或 C-SCAN）</h3><p>简单地以跨越磁道的顺序来服务磁盘请求。我们将一次跨越磁盘称为扫一遍。因此，如果请求的块所属的磁道在这次扫一遍中已经服务过了，它就不会立即处理，而是排队等待下次扫一遍。</p>
<p>SCAN有许多变种，所有这些变种都是一样的。例如，Coffman等人引入了F-SCAN，它在扫一遍时冻结队列以进行维护[CKR72]。这个操作会将扫一遍期间进入的请求放入队列中，以便稍后处理。这样做可以避免远距离请求饥饿，延迟了迟到（但更近）请求的服务。</p>
<p>C-SCAN是另一种常见的变体，即循环SCAN（Circular  SCAN）的缩写。不是在一个方向扫过磁盘，该算法从外圈扫到内圈，然后从内圈扫到外圈，如此下去。</p>
<p><strong>它们忽视了旋转。</strong></p>
<h3 id="SPTF：最短定位时间优先"><a href="#SPTF：最短定位时间优先" class="headerlink" title="SPTF：最短定位时间优先"></a>SPTF：最短定位时间优先</h3><p><strong>8还是16?</strong></p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w7.png" alt="?"><br>这里的情况是旋转与寻道相比的相对时间。如果在我们的例子中，寻道时间远远高于旋转延迟，那么SSTF（和变体）就好了。但是，想象一下，如果寻道比旋转快得多。然后，在我们的例子中，寻道远一点的、在外圈磁道的服务请求8，比寻道近一点的、在中间磁道的服务请求16更好，后者必须旋转很长的距离才能移到磁头下。</p>
<p>因此SPTF是有用的，它提高了性能。然而，它在操作系统中实现起来更加困难，操作系统通常不太清楚磁道边界在哪，也不知道磁头当前的位置（旋转到了哪里）。因此，SPTF通常在驱动器内部执行.</p>
<h3 id="其他调度问题"><a href="#其他调度问题" class="headerlink" title="其他调度问题"></a>其他调度问题</h3><p>磁盘可以接受多个分离的请求，它们本身具有复杂的内部调度程序（它们可以准确地实现SPTF。在磁盘控制器内部，所有相关细节都可以得到，包括精确的磁头位置）。因此，操作系统调度程序通常会选择它认为最好的几个请求（如16），并将它们全部发送到磁盘。磁盘然后利用其磁头位置和详细的磁道布局信息等内部知识，以最佳可能（SPTF）顺序服务于这些请求。</p>
<p>磁盘调度程序执行的另一个重要相关任务是I/O合并（I/O merging）。例如，设想一系列请求读取块33，然后是8，然后是34，如图37.8所示。在这种情况下，调度程序应该将块33和34的请求合并（merge）为单个两块请求。调度程序执行的所有请求都基于合并后的请求。合并在操作系统级别尤其重要，因为它减少了发送到磁盘的请求数量，从而降低了开销。</p>
<hr>
<h1 id="廉价冗余磁盘阵列-RAID"><a href="#廉价冗余磁盘阵列-RAID" class="headerlink" title="廉价冗余磁盘阵列(RAID)"></a>廉价冗余磁盘阵列(RAID)</h1><p>如何得到大型、快速、可靠的磁盘?</p>
<p><strong>廉价冗余磁盘阵列(RAID)这种技术使用多个磁盘一起构建更快、更大、更可靠的磁盘系统。</strong></p>
<p>在内部，RAID是一个复杂的庞然大物，由多个磁盘、内存（包括易失性和非易失性）以及一个或多个处理器来管理系统。硬件RAID非常像一个计算机系统，专门用于管理一组磁盘。</p>
<h2 id="接口和-RAID-内部"><a href="#接口和-RAID-内部" class="headerlink" title="接口和 RAID 内部"></a>接口和 RAID 内部</h2><p>当文件系统向RAID发出逻辑I/O请求时，RAID内部必须计算要访问的磁盘（或多个磁盘）以完成请求，然后发出一个或多个物理I/O来执行此操作。这些物理I/O的确切性质取决于RAID级别。</p>
<p>考虑一个RAID，它保留每个块的两个副本（每个都在一个单独的磁盘上）。当写入这种镜像（mirrored）RAID系统时，RAID必须为它发出的每一个逻辑I/O执行两个物理I/O。</p>
<p>RAID系统通常构建为单独的硬件盒，并通过标准连接（例如，SCSI或SATA）接入主机。然而，在内部，RAID相当复杂。它包括一个微控制器，运行固件以指导RAID的操作。它还包括DRAM这样的易失性存储器，在读取和写入时缓冲数据块。在某些情况下，还包括非易失性存储器，安全地缓冲写入。它甚至可能包含专用的逻辑电路，来执行奇偶校验计算（在某些RAID级别中非常有用，下面会提到）。在很高的层面上，RAID是一个非常专业的计算机系统：它有一个处理器，内存和磁盘。然而，它不是运行应用程序，而是运行专门用于操作RAID的软件。</p>
<h2 id="故障模型"><a href="#故障模型" class="headerlink" title="故障模型"></a>故障模型</h2><p>故障—停止（fail-stop）故障模型</p>
<p>磁盘可以处于两种状态之一：工作状态或故障状态。使用工作状态的磁盘时，所有块都可以读取或写入。相反，当磁盘出现故障时，我们认为它永久丢失。</p>
<h2 id="如何评估-RAID"><a href="#如何评估-RAID" class="headerlink" title="如何评估 RAID"></a>如何评估 RAID</h2><p>第一个方面是容量（capacity）。在给定一组N个磁盘的情况下，RAID的客户端可用的容量有多少？没有冗余，答案显然是N。不同的是，如果有一个系统保存每个块的两个副本，我们将获得N/2的有用容量。不同的方案（例如，基于校验的方案）通常介于两者之间。</p>
<p>第二个方面是可靠性（reliability）。给定设计允许有多少磁盘故障？根据我们的故障模型，我们只假设整个磁盘可能会故障。在后面的章节（例如，关于数据完整性的第44章）中，我们将考虑如何处理更复杂的故障模式。</p>
<p>最后，第三个方面是性能（performance）。性能有点难以评估，因为它在很大程度上取决于磁盘阵列提供的工作负载。因此，在评估性能之前，我们将首先提出一组应该考虑的典型工作负载。</p>
<h2 id="RAID-0-级：条带化"><a href="#RAID-0-级：条带化" class="headerlink" title="RAID 0 级：条带化"></a>RAID 0 级：条带化</h2><p>第一个RAID级别实际上不是RAID级别，因为没有冗余。</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w8.png" alt="?"></p>
<p>以轮转方式将磁盘阵列的块分布在磁盘上。这种方法的目的是在对数组的连续块进行请求时，从阵列中获取最大的并行性（例如，在一个大的顺序读取中）。我们将同一行中的块称为条带，因此，上面的块0、1、2和3在相同的条带中。</p>
<blockquote>
<p>补充：RAID映射问题<br><strong>简单地说，给定一个逻辑块来读或写，RAID如何确切地知道要访问哪个物理磁盘和偏移量？</strong></p>
</blockquote>
<blockquote>
<p>以上面的第一个条带为例（大块大小=  1块=  4KB）。在这种情况下，给定逻辑块地址A，RAID可以使用两个简单的公式轻松计算要访问的磁盘和偏移量：<br><strong>磁盘= A % 磁盘数<br>偏移量  =  A  /  磁盘数</strong></p>
</blockquote>
<blockquote>
<p>假设在上面的第一个RAID中，对块15的请求到达。鉴于有4个磁盘，这意味着我们感兴趣的磁盘是（14 % 4 = 2）：磁盘2。确切的块计算为（14 / 4 = 3）：块3。因此，应在第三个磁盘（磁盘2，从0开始）的第四个块（块3，从0开始）处找到块14，该块恰好位于该位置</p>
</blockquote>
<h3 id="大块大小"><a href="#大块大小" class="headerlink" title="大块大小"></a>大块大小</h3><p>一方面，大块大小主要影响阵列的性能。例如，大小较小的大块意味着许多文件将跨多个磁盘进行条带化，从而增加了对单个文件的读取和写入的并行性。但是，跨多个磁盘访问块的定位时间会增加，因为整个请求的定位时间由所有驱动器上请求的最大定位时间决定。</p>
<p>另一方面，较大的大块大小减少了这种文件内的并行性，因此依靠多个并发请求来实现高吞吐量。但是，较大的大块大小减少了定位时间。例如，如果一个文件放在一个块中并放置在单个磁盘上，则访问它时发生的定位时间将只是单个磁盘的定位时间。</p>
<h3 id="RAID-0-分析"><a href="#RAID-0-分析" class="headerlink" title="RAID-0 分析"></a>RAID-0 分析</h3><p>从容量的角度来看，它是顶级的：给定N个磁盘，条件化提供N个磁盘的有用容量。从可靠性的角度来看，条带化也是顶级的，但是最糟糕：任何磁盘故障都会导致数据丢失。最后，性能非常好：通常并行使用所有磁盘来为用户I/O请求提供服务。</p>
<h2 id="RAID-1-级：镜像"><a href="#RAID-1-级：镜像" class="headerlink" title="RAID 1 级：镜像"></a>RAID 1 级：镜像</h2><p>第一个超越条带化的RAID级别称为RAID 1级，即镜像。对于镜像系统，我们只需生成系统中每个块的多个副本。当然，每个副本应该放在一个单独的磁盘上。通过这样做，我们可以容许磁盘故障。</p>
<p>在一个典型的镜像系统中，我们将假设对于每个逻辑块，RAID保留两个物理副本。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/e1.png" alt="?"></p>
<p>从镜像阵列读取块时，RAID有一个选择：它可以读取任一副本。例如，如果对RAID发出对逻辑块5的读取，则可以自由地从磁盘2或磁盘3读取它。但是，在写入块时，不存在这样的选择：RAID必须更新两个副本的数据，以保持可靠性。但请注意，这些写入可以并行进行。例如，对逻辑块5的写入可以同时在磁盘2和3上进行。</p>
<h3 id="RAID-1-分析"><a href="#RAID-1-分析" class="headerlink" title="RAID-1 分析"></a>RAID-1 分析</h3><p>从容量的角度来看，RAID-1价格昂贵。在镜像级别=2的情况下，我们只能获得峰值有用容量的一半。因此，对于N个磁盘，镜像的有用容量为N/2。</p>
<p>从可靠性的角度来看，RAID-1表现良好。它可以容许任何一个磁盘的故障。</p>
<p>最后，我们分析性能。从单个读取请求的延迟角度来看，我们可以看到它与单个磁盘上的延迟相同。所有RAID-1都会将读取导向一个副本。写入有点不同：在完成写入之前，需要完成两次物理写入。这两个写入并行发生，因此时间大致等于单次写入的时间。然而，因为逻辑写入必须等待两个物理写入完成，所以它遭遇到两个请求中最差的寻道和旋转延迟，因此（平均而言）比写入单个磁盘略高。</p>
<blockquote>
<p>补充：RAID一致更新问题</p>
</blockquote>
<blockquote>
<p>我们假设对磁盘0的请求已完成（但对磁盘1的请求显然没有完成，因为它从未发出）。</p>
</blockquote>
<blockquote>
<p>这种不合时宜的掉电，导致现在数据块的两个副本不一致（inconsistent）。磁盘0上的副本是新版本，而磁盘1上的副本是旧的。我们希望的是两个磁盘的状态都原子地（atomically）改变，也就是说，两者都应该最终成为新版本或者两者都不是。</p>
</blockquote>
<blockquote>
<p>解决此问题的一般方法，是使用某种预写日志（write-ahead log），在做之前首先记录RAID将要执行的操作（即用某个数据更新两个磁盘）。通过采取这种方法，我们可以确保在发生崩溃时，会发生正确的事情。通过运行一个恢复（recovery）过程，将所有未完成的事务重新在RAID上执行，我们可以确保两个镜像副本（在RAID-1情况下）同步。</p>
</blockquote>
<blockquote>
<p>最后一个注意事项：每次写入都在磁盘上记录日志，这个代价昂贵得不行，因此大多数RAID硬件都包含少量非易失性RAM（例如电池有备份的），用于执行此类记录。因此，既提供了一致的更新，又不需要花费高昂的代价，将日志记录到磁盘。</p>
</blockquote>
<h2 id="RAID-4-级：通过奇偶校验节省空间"><a href="#RAID-4-级：通过奇偶校验节省空间" class="headerlink" title="RAID 4 级：通过奇偶校验节省空间"></a>RAID 4 级：通过奇偶校验节省空间</h2><p>我们现在展示一种向磁盘阵列添加冗余的不同方法，称为奇偶校验（parity）。基于奇偶校验的方法试图使用较少的容量，从而克服由镜像系统付出的巨大空间损失。不过，这样做的代价是——性能。</p>
<p>这是5个磁盘的RAID-4系统的例子（见表38.4）。对于每一条数据，我们都添加了一个奇偶校验（parity）块，用于存储该条块的冗余信息。例如，奇偶校验块P1具有从块4、5、6和7计算出的冗余信息。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/e2.png" alt="?"><br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/w9.png" alt="?"></p>
<p><strong>任何一行中的1的数量必须是偶数（而不是奇数）。这是RAID必须保持的不变性（invariant），以便奇偶校验正确。</strong></p>
<p><strong>如何利用奇偶校验信息从故障中恢复?</strong></p>
<p>标为C2的列丢失了。要找出该列中肯定存在的值，我们只需读取该行中的所有其他值（包括XOR的奇偶校验位）并重构（reconstruct）正确的答案。</p>
<p>假设C2列中第一行的值丢失（它是1）。通过读取该行中的其他值（C0中的0，C1中的0，C3中的1以及奇偶校验列P中的0），我们得到值0、0、1和0。因为我们知道XOR保持每行有偶数个1，所以就知道丢失的数据肯定是什么——1。这就是重构在基于异或的方案中的工作方式！还要注意如何计算重构值：只要将数据位和奇偶校验位异或，就像开始计算奇偶校验一样。</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/e3.png" alt="?"></p>
<p><strong>可以看出，每个块的每个比特计算奇偶校验，结果放在奇偶校验块中。</strong></p>
<h3 id="RAID-4-分析"><a href="#RAID-4-分析" class="headerlink" title="RAID-4 分析"></a>RAID-4 分析</h3><p>RAID-4使用1个磁盘作为它所保护的每组磁盘的奇偶校验信息。因此，RAID组的有用容量是（N−1）。</p>
<p>可靠性也很容易理解：RAID-4容许1个磁盘故障，不容许更多。如果丢失多个磁盘，则无法重建丢失的数据。</p>
<p>改写数据？</p>
<p>存在两种方法。第一种称为加法奇偶校验（additive  parity），要求我们做以下工作。为了计算新奇偶校验块的值，并行读取条带中所有其他数据块（在本例中为块0、2和3），并与新块（1）进行异或。结果是新的校验块。为了完成写操作，你可以将新数据和新奇偶校验写入其各自的磁盘，也是并行写入。</p>
<p>这种技术的问题在于它随磁盘数量而变化，因此在较大的RAID中，需要大量的读取来计算奇偶校验。因此，导致了减法奇偶校验（subtractive parity）方法。</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/e4.png" alt="?"></p>
<p>想象一下，我们希望用一个新值来覆盖C2位，称之为C2new。减法方法分三步工作。首先，我们读入C2（C2old = 1）和旧数据（Pold = 0）的旧数据。然后，比较旧数据和新数据。如果它们相同（例如，C2new  =  C2old），那么我们知道奇偶校验位也将保持相同（即Pnew  =  Pold）。但是，如果它们不同，那么我们必须将旧的奇偶校验位翻转到其当前状态的相反位置，也就是说，如果（Pold == 0），Pnew将被设置为0。如果（Pold == 0），Pnew将被设置为1。我们可以用XOR（⊕是XOR运算符）漂亮地表达完整的复杂情况：</p>
<p><strong>Pnew = (Cold⊕ Cnew) ⊕ Pold</strong></p>
<p>对于每次写入，RAID必须执行4次物理I/O（两次读取和两次写入）</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/e6.png" alt="?"><br>现在想象几乎同时向RAID-4提交2个小的请求，写入块4和块13（在表38.8中标出）。这些磁盘的数据位于磁盘0和1上，因此对数据的读写操作可以并行进行，这很好。出现的问题是奇偶校验磁盘。这两个请求都必须读取4和13的奇偶校验块，即奇偶校验块1和3（用+标记）。估计你已明白了这个问题：在这种类型的工作负载下，奇偶校验磁盘是瓶颈。因此我们有时将它称为基于奇偶校验的RAID的小写入问题（small-write problem）。</p>
<h2 id="RAID-5-级：旋转奇偶校验"><a href="#RAID-5-级：旋转奇偶校验" class="headerlink" title="RAID 5 级：旋转奇偶校验"></a>RAID 5 级：旋转奇偶校验</h2><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/e5.png" alt="?"></p>
<p>每个条带的奇偶校验块现在都在磁盘上旋转，以消除RAID-4的奇偶校验磁盘瓶颈。</p>
<h2 id="RAID-比较：总结"><a href="#RAID-比较：总结" class="headerlink" title="RAID 比较：总结"></a>RAID 比较：总结</h2><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/e8.png" alt="?"><br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/r1.png" alt="?"></p>
<hr>
<h1 id="插叙：文件和目录"><a href="#插叙：文件和目录" class="headerlink" title="插叙：文件和目录"></a>插叙：文件和目录</h1><p>到目前为止，我们看到了两项关键操作系统技术的发展：<br><strong>进程，它是虚拟化的CPU；地址空间，它是虚拟化的内存。</strong></p>
<p>在这两种抽象共同作用下，程序运行时就好像它在自己的私有独立世界中一样，好像它有自己的处理器（或多处理器），好像它有自己的内存。</p>
<p>持久存储（persistent storage）。永久存储设备永久地（或至少长时间地）存储信息，如传统硬盘驱动器（hard  disk  drive）或更现代的固态存储设备（solid-state storage device）。持久存储设备与内存不同。内存在断电时，其内容会丢失，而持久存储设备会保持这些数据不变。因此，操作系统必须特别注意这样的设备：用户用它们保存真正关心的数据。</p>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>随着时间的推移，存储虚拟化形成了两个关键的抽象。第一个是文件（file）。文件就是一个线性字节数组，每个字节都可以读取或写入。每个文件都有某种低级名称（low-level name），通常是某种数字。用户通常不知道这个名字（我们稍后会看到）。由于历史原因，文件的低级名称通常称为inode号（inode  number）。</p>
<p>第二个抽象是目录（directory）。一个目录，像一个文件一样，也有一个低级名字（即inode号），但是它的内容非常具体：它包含一个（用户可读名字，低级名字）对的列表。例如，假设存在一个低级别名称为“10”的文件，它的用户可读的名称为“foo”。“foo”所在的目录因此会有条目（“foo”，“10”），将用户可读名称映射到低级名称。目录中的每个条目都指向文件或其他目录。通过将目录放入其他目录中，用户可以构建任意的目录树（directory tree，或目录层次结构，directory hierarchy），在该目录树下存储所有文件和目录。</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/r2.png" alt="?"></p>
<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>通过调用open()并传入O_CREAT标志，程序可以创建一个新文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;foo&quot;</span>, O_CREAT | O_WRONLY | O_TRUNC);</span><br></pre></td></tr></table></figure>

<p>open()的一个重要方面是它的返回值：文件描述符（file descriptor）。文件描述符只是一个整数，是每个进程私有的，在UNIX系统中用于访问文件。因此，一旦文件被打开，你就可以使用文件描述符来读取或写入文件，假定你有权这样做。这样，一个文件描述符就是一种权限（capability）[L84]，即一个不透明的句柄，它可以让你执行某些操作。另一种看待文件描述符的方法，是将它作为指向文件类型对象的指针。一旦你有这样的对象，就可以调用其他“方法”来访问文件，如read()和write()。</p>
<blockquote>
<p>句柄（Handle）是计算机科学中的一个术语，用于表示对资源或对象的引用。在操作系统中，句柄通常是一个整数或指针，用于标识和跟踪分配给进程的资源，例如文件、内存、设备或其他系统对象。</p>
</blockquote>
<blockquote>
<p>句柄可以看作是对实际对象的间接引用，类似于人们使用门牌号码来访问房屋。通过使用句柄，程序可以在需要的时候引用和操作特定的资源，而不需要了解其具体的内部表示或实现细节。</p>
</blockquote>
<blockquote>
<p>句柄在编程中非常常见，特别是在底层操作系统编程、图形用户界面(GUI)开发和资源管理方面。通过使用句柄，程序可以更有效地管理和控制系统资源，并提高代码的可读性和维护性。</p>
</blockquote>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><blockquote>
<p>使用strace（和类似工具）strace工具提供了一种非常棒的方式，来查看程序在做什么。通过运行它，你可以跟踪程序生成的系统调用，查看参数和返回代码，通常可以很好地了解正在发生的事情。</p>
</blockquote>
<p>下面是一个例子，使用strace来找出cat在做什么（为了可读性删除了一些调用）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prompt&gt; strace cat foo</span><br><span class="line">...</span><br><span class="line">open(<span class="string">&quot;foo&quot;</span>, O_RDONLY|O_LARGEFILE)</span><br><span class="line">= <span class="number">3</span></span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;hello\n&quot;</span>, <span class="number">4096</span>)</span><br><span class="line">= <span class="number">6</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello\n&quot;</span>, <span class="number">6</span>)</span><br><span class="line">= <span class="number">6</span></span><br><span class="line">hello</span><br><span class="line">read(<span class="number">3</span>, <span class="string">&quot;&quot;</span>, <span class="number">4096</span>) = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>) = <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>

<p>cat做的第一件事是打开文件准备读取。我们应该注意几件事情。首先，该文件仅为读取而打开（不写入），如O_RDONLY标志所示。其次，使用64位偏移量（O_LARGEFILE）。最后，open()调用成功并返回一个文件描述符，其值为3。</p>
<p><strong>为什么第一次调用open()会返回3，而不是0或1？</strong></p>
<p>每个正在运行的进程已经打开了3个文件：标准输入（进程可以读取以接收输入），标准输出（进程可以写入以便将信息显示到屏幕），以及标准错误（进程可以写入错误消息）。这些分别由文件描述符0、1和2表示。因此，当你第一次打开另一个文件时（如上例所示），它几乎肯定是文件描述符3。</p>
<p>打开成功后，cat使用read()系统调用重复读取文件中的一些字节。read()的第一个参数是文件描述符，从而告诉文件系统读取哪个文件。一个进程当然可以同时打开多个文件，因此描述符使操作系统能够知道某个特定的读取引用了哪个文件。第二个参数指向一个用于放置read()结果的缓冲区。在上面的系统调用跟踪中，strace显示了这时的读取结果（“hello”）。第三个参数是缓冲区的大小，在这个例子中是4KB。对read()的调用也成功返回，这里返回它读取的字节数（6，其中包括“hello”中的5个字母和一个行尾标记）。</p>
<p>write()系统调用的一次调用，针对文件描述符1。如上所述，此描述符被称为标准输出，因此用于将单词“Hello”写到屏幕上，这正是cat程序要做的事。但是它直接调用write()吗？也许（如果它是高度优化的）。但是，如果不是，那么可能会调用库例程printf()。在内部，printf()会计算出传递给它的所有格式化细节，并最终对标准输出调用write，将结果显示到屏幕上。</p>
<p>然后，cat程序试图从文件中读取更多内容，但由于文件中没有剩余字节，read()返回0，程序知道这意味着它已经读取了整个文件。因此，程序调用close()，传入相应的文件描述符，表明它已用完文件“foo”。该文件因此被关闭，对它的读取完成了。</p>
<h2 id="读取和写入，但不按顺序"><a href="#读取和写入，但不按顺序" class="headerlink" title="读取和写入，但不按顺序"></a>读取和写入，但不按顺序</h2><p>有时能够读取或写入文件中的特定偏移量是有用的。例如，如果你在文本文件上构建了索引并利用它来查找特定单词，最终可能会从文件中的某些随机（random）偏移量中读取数据。为此，我们将使用lseek()系统调用。下面是函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fildes, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数是熟悉的（一个文件描述符）。第二个参数是偏移量，它将文件偏移量定位到文件中的特定位置。第三个参数，由于历史原因而被称为whence，明确地指定了搜索的执行方式。</p>
<p>从这段描述中可见，对于每个进程打开的文件，操作系统都会跟踪一个“当前”偏移量，这将决定在文件中读取或写入时，下一次读取或写入开始的位置。因此，打开文件的抽象包括它具有当前偏移量，偏移量的更新有两种方式。第一种是当发生N个字节的读或写时，N被添加到当前偏移。因此，每次读取或写入都会隐式更新偏移量。第二种是明确的lseek，它改变了上面指定的偏移量。</p>
<blockquote>
<p>调用lseek()不会执行磁盘寻道<br>lseek()调用只是在OS内存中更改一个变量，该变量跟踪特定进程的下一个读取或写入开始的偏移量。如果发送到磁盘的读取或写入与最后一次读取或写入不在同一磁道上，就会发生磁盘寻道，因此需要磁头移动。</p>
</blockquote>
<h2 id="用-fsync-立即写入"><a href="#用-fsync-立即写入" class="headerlink" title="用 fsync()立即写入"></a>用 fsync()立即写入</h2><p>大多数情况下，当程序调用write()时，它只是告诉文件系统：请在将来的某个时刻，将此数据写入持久存储。出于性能的原因，文件系统会将这些写入在内存中缓冲（buffer）一段时间（例如5s或30s）。在稍后的时间点，写入将实际发送到存储设备。从调用应用程序的角度来看，写入似乎很快完成，并且只有在极少数情况下（例如，在write()调用之后但写入磁盘之前，机器崩溃）数据会丢失。</p>
<p><strong>在数据库管理系统（DBMS）中，开发正确的恢复协议要求能够经常强制写入磁盘。</strong></p>
<p>当进程针对特定文件描述符调用fsync()时，文件系统通过强制将所有脏（dirty）数据（即尚未写入的）写入磁盘来响应，针对指定文件描述符引用的文件。一旦所有这些写入完成，fsync()例程就会返回。</p>
<p>以下是如何使用fsync()的简单示例。代码打开文件foo，向它写入一个数据块，然后调用fsync()以确保立即强制写入磁盘。一旦fsync()返回，应用程序就可以安全地继续前进，知道数据已被保存（如果fsync()实现正确，那就是了）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;foo&quot;</span>, O_CREAT | O_WRONLY | O_TRUNC);</span><br><span class="line">assert(fd &gt; <span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> rc = write(fd, buffer, size);</span><br><span class="line">assert(rc == size);</span><br><span class="line">rc = fsync(fd);</span><br><span class="line">assert(rc == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在某些情况下，还需要fsync()包含foo文件的目录。添加此步骤不仅可以确保文件本身位于磁盘上，而且可以确保文件（如果新创建）也是目录的一部分。</p>
<h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2><p>有时需要给一个文件一个不同的名字。在命令行键入时，这是通过mv命令完成的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prompt&gt; mv foo bar</span><br></pre></td></tr></table></figure>
<p>利用strace，我们可以看到mv使用了系统调用rename(char  *  old,  char  *  new)，它只需要两个参数：文件的原来名称（old）和新名称（new）。</p>
<p>rename()调用提供了一个有趣的保证：它（通常）是一个原子（atomic）调用，不论系统是否崩溃。如果系统在重命名期间崩溃，文件将被命名为旧名称或新名称，不会出现奇怪的中间状态。因此，对于支持某些需要对文件状态进行原子更新的应用程序，rename()非常重要。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;foo.txt.tmp&quot;</span>, O_WRONLY|O_CREAT|O_TRUNC);</span><br><span class="line">write(fd, buffer, size); <span class="comment">// write out new version of file</span></span><br><span class="line">fsync(fd);</span><br><span class="line">close(fd);</span><br><span class="line">rename(<span class="string">&quot;foo.txt.tmp&quot;</span>, <span class="string">&quot;foo.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>编辑器做的事很简单：将文件的新版本写入临时名称（foot.txt.tmp），使用fsync()将其强制写入磁盘。然后，当应用程序确定新文件的元数据和内容在磁盘上，就将临时文件重命名为原有文件的名称。最后一步自动将新文件交换到位，同时删除旧版本的文件，从而实现原子文件更新。</strong></p>
<h2 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h2><p>除了文件访问之外，我们还希望文件系统能够保存关于它正在存储的每个文件的大量信息。我们通常将这些数据称为文件元数据（metadata）。要查看特定文件的元数据，我们可以使用stat()或fstat()系统调用。这些调用将一个路径名（或文件描述符）添加到一个文件中，并填充一个stat结构，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line"><span class="type">dev_t</span> st_dev; <span class="comment">/* ID of device containing file */</span></span><br><span class="line"><span class="type">ino_t</span> st_ino; <span class="comment">/* inode number */</span></span><br><span class="line"><span class="type">mode_t</span> st_mode; <span class="comment">/* protection */</span></span><br><span class="line"><span class="type">nlink_t</span> st_nlink; <span class="comment">/* number of hard links */</span></span><br><span class="line"><span class="type">uid_t</span> st_uid; <span class="comment">/* user ID of owner */</span></span><br><span class="line"><span class="type">gid_t</span> st_gid; <span class="comment">/* group ID of owner */</span></span><br><span class="line"><span class="type">dev_t</span> st_rdev; <span class="comment">/* device ID (if special file) */</span></span><br><span class="line"><span class="type">off_t</span> st_size; <span class="comment">/* total size, in bytes */</span></span><br><span class="line"><span class="type">blksize_t</span> st_blksize; <span class="comment">/* blocksize for filesystem I/O */</span></span><br><span class="line"><span class="type">blkcnt_t</span> st_blocks; <span class="comment">/* number of blocks allocated */</span></span><br><span class="line"><span class="type">time_t</span> st_atime; <span class="comment">/* time of last access */</span></span><br><span class="line"><span class="type">time_t</span> st_mtime; <span class="comment">/* time of last modification */</span></span><br><span class="line"><span class="type">time_t</span> st_ctime; <span class="comment">/* time of last status change */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要查看此信息，可以使用命令行工具stat：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prompt&gt; echo hello &gt; file</span><br><span class="line">prompt&gt; stat file</span><br><span class="line">File: <span class="string">&#x27;file&#x27;</span></span><br><span class="line">Size: <span class="number">6</span> Blocks: <span class="number">8</span> IO Block: <span class="number">4096</span> regular file</span><br><span class="line">Device: <span class="number">811</span>h/<span class="number">2065</span>d Inode: <span class="number">67158084</span> Links: <span class="number">1</span></span><br><span class="line">Access: (<span class="number">0640</span>/-rw-r-----) Uid: (<span class="number">30686</span>/ remzi) Gid: (<span class="number">30686</span>/ remzi)</span><br><span class="line">Access: <span class="number">2011</span><span class="number">-05</span><span class="number">-03</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">20.157594748</span> <span class="number">-0500</span></span><br><span class="line">Modify: <span class="number">2011</span><span class="number">-05</span><span class="number">-03</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">20.157594748</span> <span class="number">-0500</span></span><br><span class="line">Change: <span class="number">2011</span><span class="number">-05</span><span class="number">-03</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">20.157594748</span> <span class="number">-0500</span></span><br></pre></td></tr></table></figure>

<p>事实表明，每个文件系统通常将这种类型的信息保存在一个名为 inode<br>①的结构中。应该将 inode看作是由文件系统保存的持久数据结构，包含上述信息。</p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prompt&gt; strace rm foo</span><br><span class="line">...</span><br><span class="line">unlink(<span class="string">&quot;foo&quot;</span>) = <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>unlink()只需要待删除文件的名称，并在成功时返回零。</p>
<h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>除了文件外，还可以使用一组与目录相关的系统调用来创建、读取和删除目录。永远不能直接写入目录。因为目录的格式被视为文件系统元数据，所以你只能间接更新目录，例如，通过在其中创建文件、目录或其他对象类型。通过这种方式，文件系统可以确保目录的内容始终符合预期。</p>
<p>要创建目录，可以用系统调用mkdir()。同名的mkdir程序可以用来创建这样一个目录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prompt&gt; strace mkdir foo</span><br><span class="line">...</span><br><span class="line">mkdir(<span class="string">&quot;foo&quot;</span>, <span class="number">0777</span>) = <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>

<p>这样的目录创建时，它被认为是“空的”，尽管它实际上包含最少的内容。具体来说，空目录有两个条目：一个引用自身的条目，一个引用其父目录的条目。前者称为“.”（点）目录，后者称为“..”（点-点）目录。你可以通过向程序ls传递一个标志（-a）来查看这些目录：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prompt&gt; ls -a</span><br><span class="line">./ ../</span><br><span class="line">prompt&gt; ls -al</span><br><span class="line">total <span class="number">8</span></span><br><span class="line">drwxr-x--- <span class="number">2</span> remzi remzi <span class="number">6</span> Apr <span class="number">30</span> <span class="number">16</span>:<span class="number">17</span> ./</span><br><span class="line">drwxr-x--- <span class="number">26</span> remzi remzi <span class="number">4096</span> Apr <span class="number">30</span> <span class="number">16</span>:<span class="number">17</span> ../</span><br></pre></td></tr></table></figure>

<h2 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h2><p>创建了目录，也可能希望读取目录。实际上，这正是ls程序做的事。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">DIR *dp = opendir(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">assert(dp != <span class="literal">NULL</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">d</span>;</span></span><br><span class="line"><span class="keyword">while</span> ((d = readdir(dp)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, (<span class="type">int</span>) d-&gt;d_ino, d-&gt;d_name);</span><br><span class="line">&#125;</span><br><span class="line">closedir(dp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h2><p>可以通过调用rmdir()来删除目录（它由相同名称的程序rmdir使用）。然而，与删除文件不同，删除目录更加危险，因为你可以使用单个命令删除大量数据。因此，rmdir()要求该目录在被删除之前是空的（只有“.”和“..”条目）。如果你试图删除一个非空目录，那么对rmdir()的调用就会失败。</p>
<h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p><strong>理解在文件系统树中创建条目的新方法，即通过所谓的link()系统调用。</strong></p>
<p>link()系统调用有两个参数：一个旧路径名和一个新路径名。当你将一个新的文件名“链接”到一个旧的文件名时，你实际上创建了另一种引用同一个文件的方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prompt&gt; echo hello &gt; file</span><br><span class="line">prompt&gt; cat file</span><br><span class="line">hello</span><br><span class="line">prompt&gt; ln file file2</span><br><span class="line">prompt&gt; cat file2</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>link只是在要创建链接的目录中创建了另一个名称，并将其指向原有文件的相同inode号（即低级别名称）。该文件不以任何方式复制。相反，你现在就有了两个人类可读的名称（file和file2），都指向同一个文件。通过打印每个文件的inode号，我们甚至可以在目录中看到这一点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prompt&gt; ls -i file file2</span><br><span class="line"><span class="number">67158084</span> file</span><br><span class="line"><span class="number">67158084</span> file2</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>

<p>创建一个文件时，实际上做了两件事。首先，要构建一个结构（inode），它将跟踪几乎所有关于文件的信息，包括其大小、文件块在磁盘上的位置等等。其次，将人类可读的名称链接到该文件，并将该链接放入目录中。</p>
<p>在创建文件的硬链接之后，在文件系统中，原有文件名（file）和新创建的文件名（file2）之间没有区别。实际上，它们都只是指向文件底层元数据的链接，可以在inode编号67158084中找到。</p>
<p>这样的结果是因为当文件系统取消链接文件时，它检查inode号中的引用计数（reference count）。该引用计数（有时称为链接计数，link count）允许文件系统跟踪有多少不同的文件名已链接到这个inode。调用unlink()时，会删除人类可读的名称（正在删除的文件）与给定inode号之间的“链接”，并减少引用计数。只有当引用计数达到零时，文件系统才会释放inode和相关数据块，从而真正“删除”该文件。</p>
<p>可以使用stat()来查看文件的引用计数。让我们看看创建和删除文件的硬链接时，引用计数是什么。在这个例子中，我们将为同一个文件创建 3 个链接，然后删除它们。仔细看链接计数！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prompt&gt; echo hello &gt; file</span><br><span class="line">prompt&gt; stat file</span><br><span class="line">... Inode: <span class="number">67158084</span> Links: <span class="number">1</span> ...</span><br><span class="line">prompt&gt; ln file file2</span><br><span class="line">prompt&gt; stat file</span><br><span class="line">... Inode: <span class="number">67158084</span> Links: <span class="number">2</span> ...</span><br><span class="line">prompt&gt; stat file2</span><br><span class="line">... Inode: <span class="number">67158084</span> Links: <span class="number">2</span> ...</span><br><span class="line">prompt&gt; ln file2 file3</span><br><span class="line">prompt&gt; stat file</span><br><span class="line">... Inode: <span class="number">67158084</span> Links: <span class="number">3</span> ...</span><br><span class="line">prompt&gt; rm file</span><br><span class="line">prompt&gt; stat file2</span><br><span class="line">... Inode: <span class="number">67158084</span> Links: <span class="number">2</span> ...</span><br><span class="line">prompt&gt; rm file2</span><br><span class="line">prompt&gt; stat file3</span><br><span class="line">... Inode: <span class="number">67158084</span> Links: <span class="number">1</span> ...</span><br><span class="line">prompt&gt; rm file3</span><br></pre></td></tr></table></figure>

<h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><p>还有一种非常有用的链接类型，称为符号链接（symbolic link），有时称为软链接（soft link）。事实表明，硬链接有点局限：你不能创建目录的硬链接（因为担心会在目录树中创建一个环）。你不能硬链接到其他磁盘分区中的文件（因为inode号在特定文件系统中是唯一的，而不是跨文件系统），等等。因此，人们创建了一种称为符号链接的新型链接。</p>
<p>要创建这样的链接，可以使用相同的程序ln，但使用-s标志。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prompt&gt; echo hello &gt; file</span><br><span class="line">prompt&gt; ln -s file file2</span><br><span class="line">prompt&gt; cat file2</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>如你所见，创建软链接看起来几乎相同，现在可以通过文件名称file以及符号链接名称file2来访问原始文件。但是，除了表面相似之外，符号链接实际上与硬链接完全不同。第一个区别是符号链接本身实际上是一个不同类型的文件。我们已经讨论过常规文件和目录。符号链接是文件系统知道的第三种类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prompt&gt; stat file</span><br><span class="line">... regular file ...</span><br><span class="line">prompt&gt; stat file2</span><br><span class="line">... symbolic link ...</span><br></pre></td></tr></table></figure>

<p>如果仔细观察 ls 输出的长格式的第一个字符，可以看到常规文件最左列中的第一个字符是“-”，目录是“d”，软链接是“l”。你还可以看到符号链接的大小（本例中为 4 个字节），以及链接指向的内容（名为 file 的文件）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prompt&gt; ls -al</span><br><span class="line">drwxr-x--- <span class="number">2</span> remzi remzi <span class="number">29</span> May <span class="number">3</span> <span class="number">19</span>:<span class="number">10</span> ./</span><br><span class="line">drwxr-x--- <span class="number">27</span> remzi remzi <span class="number">4096</span> May <span class="number">3</span> <span class="number">15</span>:<span class="number">14</span> ../</span><br><span class="line">-rw-r----- <span class="number">1</span> remzi remzi <span class="number">6</span> May <span class="number">3</span> <span class="number">19</span>:<span class="number">10</span> file</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> remzi remzi <span class="number">4</span> May <span class="number">3</span> <span class="number">19</span>:<span class="number">10</span> file2 -&gt; file</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prompt&gt; echo hello &gt; file</span><br><span class="line">prompt&gt; ln -s file file2</span><br><span class="line">prompt&gt; cat file2</span><br><span class="line">hello</span><br><span class="line">prompt&gt; rm file</span><br><span class="line">prompt&gt; cat file2</span><br><span class="line">cat: file2: No such file or directory</span><br></pre></td></tr></table></figure>

<p>符号链接与硬链接完全不同，删除名为file的原始文件会导致符号链接指向不再存在的路径名。</p>
<h2 id="创建并挂载文件系统"><a href="#创建并挂载文件系统" class="headerlink" title="创建并挂载文件系统"></a>创建并挂载文件系统</h2><p>如何从许多底层文件系统组建完整的目录树。这项任务的实现是先制作文件系统，然后挂载它们，使其内容可以访问。</p>
<p>为了创建一个文件系统，大多数文件系统提供了一个工具，通常名为mkfs（发音为“make fs”），它就是完成这个任务的。思路如下：作为输入，为该工具提供一个设备（例如磁盘分区，例如/dev/sda1），一种文件系统类型（例如ext3），它就在该磁盘分区上写入一个空文件系统，从根目录开始。mkfs说，要有文件系统！</p>
<p>但是，一旦创建了这样的文件系统，就需要在统一的文件系统树中进行访问。这个任务是通过mount程序实现的（它使底层系统调用mount()完成实际工作）。mount的作用很简单：以现有目录作为目标挂载点（mount  point），本质上是将新的文件系统粘贴到目录树的这个点上。</p>
<p>因此mount的美妙之处在于：它将所有文件系统统一到一棵树中，而不是拥有多个独立的文件系统，这让命名统一而且方便。</p>
<p>要查看系统上挂载的内容，以及在哪些位置挂载，只要运行mount程序。你会看到类似下面的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dev/sda1 on / type <span class="title function_">ext3</span> <span class="params">(rw)</span></span><br><span class="line">proc on /proc type <span class="title function_">proc</span> <span class="params">(rw)</span></span><br><span class="line">sysfs on /sys type <span class="title function_">sysfs</span> <span class="params">(rw)</span></span><br><span class="line">/dev/sda5 on /tmp type <span class="title function_">ext3</span> <span class="params">(rw)</span></span><br><span class="line">/dev/sda7 on /var/vice/cache type <span class="title function_">ext3</span> <span class="params">(rw)</span></span><br><span class="line">tmpfs on /dev/shm type <span class="title function_">tmpfs</span> <span class="params">(rw)</span></span><br><span class="line">AFS on /afs type <span class="title function_">afs</span> <span class="params">(rw)</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h1><p>VSFS（Very Simple File System，简单文件系统）。它是典型UNIX文件系统的简化版本，用于介绍一些基本磁盘结构、访问方法和各种策略。</p>
<p>文件系统是纯软件。与CPU和内存虚拟化的开发不同，我们不会添加硬件功能来使文件系统的某些方面更好地工作。</p>
<h2 id="思考方式"><a href="#思考方式" class="headerlink" title="思考方式"></a>思考方式</h2><p>考虑文件系统时，考虑它们的两个不同方面。</p>
<p>第一个方面是文件系统的数据结构（data structure）。文件系统在磁盘上使用哪些类型的结构来组织其数据和元数据？我们即将看到的第一个文件系统（包括下面的VSFS）使用简单的结构，如块或其他对象的数组，而更复杂的文件系统（如SGI的XFS）使用更复杂的基于树的结构。</p>
<p>文件系统的第二个方面是访问方法（access method）。如何将进程发出的调用，如open()、read()、write()等，映射到它的结构上？在执行特定系统调用期间读取哪些结构？改写哪些结构？所有这些步骤的执行效率如何？</p>
<h2 id="整体组织"><a href="#整体组织" class="headerlink" title="整体组织"></a>整体组织</h2><p>VSFS文件系统在磁盘上的数据结构的整体组织。我们需要做的第一件事是将磁盘分成块（block）。简单的文件系统只使用一种块大小，这里正是这样做的。我们选择常用的4KB。</p>
<p>我们对构建文件系统的磁盘分区的看法很简单：一系列块，每块大小为4KB。在大小为N个4KB块的分区中，这些块的地址为从0到N−1。假设我们有一个非常小的磁盘，只有64块。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/r3.png" alt="?"></p>
<p>实际上，任何文件系统中的大多数空间都是（并且应该是）用户数据。我们将用于存放用户数据的磁盘区域称为数据区域（data region），简单起见，将磁盘的固定部分留给这些块，例如磁盘上64个块的最后56个：</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/r5.png" alt="?"></p>
<p>文件系统必须记录每个文件的信息。该信息是元数据（metadata）的关键部分，并且记录诸如文件包含哪些数据块（在数据区域中）、文件的大小，其所有者和访问权限、访问和修改时间以及其他类似信息的事情。</p>
<p>为了存储这些信息，文件系统通常有一个名为inode的结构。为了存放inode，我们还需要在磁盘上留出一些空间。我们将这部分磁盘称为inode表（inode table），它只是保存了一个磁盘上inode的数组。因此，假设我们将64个块中的5块用于inode，磁盘映像现在看起来如下：</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/r6.png" alt="?"></p>
<p>还需要某种方法来记录inode或数据块是空闲还是已分配。因此，这种分配结构（allocation structure）是所有文件系统中必需的部分。</p>
<p>我们可以用一个空闲列表（free list），指向第一个空闲块，然后它又指向下一个空闲块，依此类推。我们选择一种简单而流行的结构，称为位图（bitmap），一种用于数据区域（数据位图，data bitmap），另一种用于inode表（inode位图，inode bitmap）。位图是一种简单的结构：每个位用于指示相应的对象/块是空闲（0）还是正在使用（1）。因此新的磁盘布局如下，包含inode位图（i）和数据位图（d）：</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/r7.png" alt="?"></p>
<p>在极简文件系统的磁盘结构设计中，还有一块。我们将它保留给超级块（superblock），在下图中用S表示。超级块包含关于该特定文件系统的信息，包括例如文件系统中有多少个inode和数据块（在这个例子中分别为80和56）、inode表的开始位置（块3）等等。它可能还包括一些幻数，来标识文件系统类型（在本例中为VSFS）<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/r8.png" alt="?"><br>因此，在挂载文件系统时，操作系统将首先读取超级块，初始化各种参数，然后将该卷添加到文件系统树中。当卷中的文件被访问时，系统就会知道在哪里查找所需的磁盘上的结构。</p>
<h2 id="文件组织：inode"><a href="#文件组织：inode" class="headerlink" title="文件组织：inode"></a>文件组织：inode</h2><p>文件系统最重要的磁盘结构之一是inode，几乎所有的文件系统都有类似的结构。名称inode是index node（索引节点）的缩写，它是由UNIX开发人员Ken Thompson [RT74]给出的历史性名称，因为这些节点最初放在一个数组中，在访问特定inode时会用到该数组的索引。</p>
<blockquote>
<p>补充：数据结构—— inode<br> inode是许多文件系统中使用的通用名称，用于描述保存给定文件的元数据的结构，例如其长度、权限以及其组成块的位置。这个名称至少可以追溯到UNIX（如果不是早期的系统，可能还会追溯到Multics）。它是index  node（索引节点）的缩写，因为inode号用于索引磁盘上的inode数组，以便查找该inode号对应的inode。我们将看到，inode的设计是文件系统设计的一个关键部分。大多数现代系统对于它们记录的每个文件都有这样的结构，但也许用了不同的名字（如dnodes、fnodes等）。</p>
</blockquote>
<p> 每个inode都由一个数字（称为inumber）隐式引用，我们之前称之为文件的低级名称（low-level name）。在VSFS（和其他简单的文件系统）中，给定一个inumber，你应该能够直接计算磁盘上相应节点的位置。例如，如上所述，获取VSFS的inode表：大小为20KB（5个4KB块），因此由80个inode（假设每个inode为256字节）组成。进一步假设inode区域从12KB开始（即超级块从0KB开始，inode位图在4KB地址，数据位图在8KB，因此inode表紧随其后）。因此，在VSFS中，我们为文件系统分区的开头提供了以下布局（特写视图）：<br> <img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/t1.png" alt="?"></p>
<p> 要读取inode号32，文件系统首先会计算inode区域的偏移量（32×inode的大小，即8192），将它加上磁盘inode表的起始地址（inodeStartAddr  =  12KB），从而得到希望的inode块的正确字节地址：20KB。</p>
<p>在每个inode中，实际上是所有关于文件的信息：文件类型（例如，常规文件、目录等）、大小、分配给它的块数、保护信息（如谁拥有该文件以及谁可以访问它）、一些时间信息（包括文件创建、修改或上次访问的时间文件下），以及有关其数据块驻留在磁盘上的位置的信息（如某种类型的指针）。我们将所有关于文件的信息称为元数据（metadata）。实际上，文件系统中除了纯粹的用户数据外，其他任何信息通常都称为元数据。</p>
<h3 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h3><p>为了支持更大的文件，文件系统设计者必须在inode中引入不同的结构。一个常见的思路是有一个称为间接指针（indirect  pointer）的特殊指针。它不是指向包含用户数据的块，而是指向包含更多指针的块，每个指针指向用户数据。因此，inode可以有一些固定数量（例如 12个）的直接指针和一个间接指针。如果文件变得足够大，则会分配一个间接块（来自磁盘的数据块区域），并将inode的间接指针设置为指向它。假设一个块是4KB，磁盘地址是4字节，那就增加了1024个指针。文件可以增长到（12 + 1024）×4KB，即4144KB。</p>
<p>这种不平衡树被称为指向文件块的多级索引（multi-level  index）方法。我们来看一个例子，它有12个直接指针，以及一个间接块和一个双重间接块。假设块大小为4KB，并且指针为4字节，则该结构可以容纳一个刚好超过4GB的文件，即（12  +  1024  +  10242）×4KB。</p>
<h2 id="目录组织"><a href="#目录组织" class="headerlink" title="目录组织"></a>目录组织</h2><p>在VSFS中（像许多文件系统一样），目录的组织很简单。一个目录基本上只包含一个二元组（条目名称，inode号）的列表。对于给定目录中的每个文件或目录，目录的数据块中都有一个字符串和一个数字。</p>
<p>删除一个文件（例如调用unlink()）会在目录中间留下一段空白空间，因此应该有一些方法来标记它（例如，用一个保留的inode号，比如0）。这种删除是使用记录长度的一个原因：新条目可能会重复使用旧的、更大的条目，从而在其中留有额外的空间。</p>
<p>通常，文件系统将目录视为特殊类型的文件。因此，目录有一个inode，位于inode表中的某处（inode表中的inode标记为“目录”的类型字段，而不是“常规文件”）。该目录具有由inode指向的数据块（也可能是间接块）。这些数据块存在于我们的简单文件系统的数据块区域中。我们的磁盘结构因此保持不变。</p>
<h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><p>文件系统必须记录哪些inode和数据块是空闲的，哪些不是，这样在分配新文件或目录时，就可以为它找到空间。因此，空闲空间管理（free space management）对于所有文件系统都很重要。在VSFS中，我们用两个简单的位图来完成这个任务。</p>
<p>例如，当我们创建一个文件时，我们必须为该文件分配一个inode。文件系统将通过位图搜索一个空闲的内容，并将其分配给该文件。文件系统必须将inode标记为已使用（用1），并最终用正确的信息更新磁盘上的位图。分配数据块时会发生类似的一组活动。</p>
<h2 id="访问路径：读取和写入"><a href="#访问路径：读取和写入" class="headerlink" title="访问路径：读取和写入"></a>访问路径：读取和写入</h2><p>我们假设文件系统已经挂载，因此超级块已经在内存中。其他所有内容（如inode、目录）仍在磁盘上。</p>
<h3 id="从磁盘读取文件"><a href="#从磁盘读取文件" class="headerlink" title="从磁盘读取文件"></a>从磁盘读取文件</h3><p>想打开一个文件（例如/foo/bar，读取它，然后关闭它）。对于这个简单的例子，假设文件的大小只有4KB（即1块）。</p>
<p>当你发出一个open(“/foo/bar”, O_RDONLY)调用时，文件系统首先需要找到文件bar的inode，从而获取关于该文件的一些基本信息（权限信息、文件大小等等）,必须能够找到inode，但它现在只有完整的路径名。文件系统必须遍历（traverse）路径名，从而找到所需的inode。</p>
<p>所有遍历都从文件系统的根开始，即根目录（root  directory），它就记为/。因此，文件系统的第一次磁盘读取是根目录的inode。但是这个inode在哪里？要找到inode，我们必须知道它的i-number。通常，我们在其父目录中找到文件或目录的i-number。根没有父目录（根据定义）。因此，根的inode号必须是“众所周知的”。在挂载文件系统时，文件系统必须知道它是什么。在大多数UNIX文件系统中，根的inode号为2。因此，要开始该过程，文件系统会读入inode号2的块（第一个inode块）。</p>
<p>一旦inode被读入，文件系统可以在其中查找指向数据块的指针，数据块包含根目录的内容。因此，文件系统将使用这些磁盘上的指针来读取目录，在这个例子中，寻找foo的条目。通过读入一个或多个目录数据块，它将找到foo的条目。一旦找到，文件系统也会找到下一个需要的foo的inode号（假定是44）。</p>
<p>下一步是递归遍历路径名，直到找到所需的inode。在这个例子中，文件系统读取包含foo的inode及其目录数据的块，最后找到bar的inode号。open()的最后一步是将bar的inode读入内存。然后文件系统进行最后的权限检查，在每个进程的打开文件表中，为此进程分配一个文件描述符，并将它返回给用户。</p>
<p>打开后，程序可以发出read()系统调用，从文件中读取。第一次读取（除非lseek()已被调用，则在偏移量0处）将在文件的第一个块中读取，查阅inode以查找这个块的位置。它也会用新的最后访问时间更新inode。读取将进一步更新此文件描述符在内存中的打开文件表，更新文件偏移量，以便下一次读取会读取第二个文件块，等等。</p>
<h3 id="写入磁盘"><a href="#写入磁盘" class="headerlink" title="写入磁盘"></a>写入磁盘</h3><p>写入文件是一个类似的过程。首先，文件必须打开（如上所述）。其次，应用程序可以发出write()调用以用新内容更新文件。最后，关闭该文件。</p>
<p>要创建一个文件，文件系统不仅要分配一个inode，还要在包含新文件的目录中分配空间。这样做的I/O工作总量非常大：一个读取inode位图（查找空闲inode），一个写入inode位图（将其标记为已分配），一个写入新的inode本身（初始化它），一个写入目录的数据（将文件的高级名称链接到它的inode号），以及一个读写目录inode以便更新它。如果目录需要增长以容纳新条目，则还需要额外的I/O（即数据位图和新目录块）。所有这些只是为了创建一个文件！</p>
<h2 id="缓存和缓冲"><a href="#缓存和缓冲" class="headerlink" title="缓存和缓冲"></a>缓存和缓冲</h2><p>读取和写入文件可能是昂贵的，会导致（慢速）磁盘的许多I/O。这显然是一个巨大的性能问题，为了弥补，大多数文件系统积极使用系统内存（DRAM）来缓存重要的块。</p>
<p>早期的文件系统因此引入了一个固定大小的缓存（fixed-size cache）来保存常用的块。正如我们在讨论虚拟内存时一样，LRU及不同变体策略会决定哪些块保留在缓存中。</p>
<p>现代系统采用动态划分（dynamic  partitioning）方法。具体来说，许多现代操作系统将虚拟内存页面和文件系统页面集成到统一页面缓存中（unified page cache）[S00]。通过这种方式，可以在虚拟内存和文件系统之间更灵活地分配内存，具体取决于在给定时间哪种内存需要更多的内存。</p>
<hr>
<h1 id="局部性和快速文件系统"><a href="#局部性和快速文件系统" class="headerlink" title="局部性和快速文件系统"></a>局部性和快速文件系统</h1><p>当UNIX操作系统首次引入时，Ken Thompson编写了第一个文件系统。我们称之为“老UNIX文件系统”，它非常简单，基本上，它的数据结构在磁盘上看起来像这样：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/u1.png" alt="?"></p>
<p>超级块（S）包含有关整个文件系统的信息：卷的大小、有多少inode、指向空闲列表块的头部的指针等等。磁盘的inode区域包含文件系统的所有inode。最后，大部分磁盘都被数据块占用。</p>
<p>老文件系统的好处在于它很简单，支持文件系统试图提供的基本抽象：文件和目录层次结构。</p>
<h2 id="问题：性能不佳"><a href="#问题：性能不佳" class="headerlink" title="问题：性能不佳"></a>问题：性能不佳</h2><p><strong>老UNIX文件系统将磁盘当成随机存取内存。</strong> 数据遍布各处，而不考虑保存数据的介质是磁盘的事实.</p>
<p>例如，文件的数据块通常离其inode非常远，因此每当第一次读取inode然后读取文件的数据块（非常常见的操作）时，就会导致昂贵的寻道。</p>
<p>更糟糕的是，文件系统最终会变得非常碎片化（fragmented），因为空闲空间没有得到精心管理。空闲列表最终会指向遍布磁盘的一堆块，并且随着文件的分配，它们只会占用下一个空闲块。结果是在磁盘上来回访问逻辑上连续的文件，从而大大降低了性能。</p>
<h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><p>假设以下数据块区域包含4个文件（A、B、C和D），每个文件大小为两个块：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/u2.png" alt="?"><br>如果删除B和D，则生成的布局为：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/u3.png" alt="?"><br>如你所见，可用空间被分成两块构成的两大块，而不是很好的连续4块。假设我们现在希望分配一个大小为4块的文件E：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/u4.png" alt="?"></p>
<p>E分散在磁盘上，因此，在访问E时，无法从磁盘获得峰值（顺序）性能。你首先读取E1和E2，然后寻道，再读取E3和E4。这个碎片问题一直发生在老UNIX文件系统中，并且会影响性能。</p>
<blockquote>
<p>这个问题正是磁盘碎片整理工具要解决的。它们将重新组织磁盘数据以连续放置文件，并为让空闲空间成为一个或几个连续的区域，移动数据，然后重写inode等以反映变化。</p>
</blockquote>
<p>另一个问题：原始块大小太小（512字节）。因此，从磁盘传输数据本质上是低效的。较小的块是好的，因为它们最大限度地减少了内部碎片（internal fragmentation，块内的浪费），但是由于每个块可能需要一个定位开销来访问它，因此传输不佳。</p>
<h2 id="快速文件系统（Fast-File-System，FFS）：磁盘意识是解决方案"><a href="#快速文件系统（Fast-File-System，FFS）：磁盘意识是解决方案" class="headerlink" title="快速文件系统（Fast File System，FFS）：磁盘意识是解决方案"></a>快速文件系统（Fast File System，FFS）：磁盘意识是解决方案</h2><h2 id="组织结构：柱面组"><a href="#组织结构：柱面组" class="headerlink" title="组织结构：柱面组"></a>组织结构：柱面组</h2><p>第一步是更改磁盘上的结构。FFS将磁盘划分为一些分组，称为柱面组（cylinder group，而一些现代文件系统，如Linux ext2和ext3，就称它们为块组，即block group）。因此，我们可以想象一个具有10个柱面组的磁盘：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/u5.png" alt="?"><br>这些分组是FFS用于改善性能的核心机制。通过在同一组中放置两个文件，FFS可以确保先后访问两个文件不会导致穿越磁盘的长时间寻道。</p>
<p>因此，FFS需要能够在每个组中分配文件和目录。每个组看起来像这样：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/u6.png" alt="?"></p>
<p>出于可靠性原因，每个组中都有超级块（super block）的一个副本（例如，如果一个被损坏或划伤，你仍然可以通过使用其中一个副本来挂载和访问文件系统）。</p>
<p>在每个组中，我们需要记录该组的inode和数据块是否已分配。每组的inode位图（inode bitmap，ib）和数据位图（data bitmap，db）起到了这个作用，分别针对每组中的inode和数据块。位图是管理文件系统中可用空间的绝佳方法，因为很容易找到大块可用空间并将其分配给文件，这可能会避免旧文件系统中空闲列表的某些碎片问题。</p>
<p>最后，inode和数据块区域就像之前的极简文件系统一样。像往常一样，每个柱面组的大部分都包含数据块。</p>
<h2 id="策略：如何分配文件和目录"><a href="#策略：如何分配文件和目录" class="headerlink" title="策略：如何分配文件和目录"></a>策略：如何分配文件和目录</h2><p><strong>相关的东西放一起</strong></p>
<p>首先是目录的放置。FFS采用了一种简单的方法：找到分配数量少的柱面组（因为我们希望跨组平衡目录）和大量的自由inode（因为我们希望随后能够分配一堆文件），并将目录数据和inode放在该分组中。</p>
<p>对于文件，FFS做两件事。首先，它确保（在一般情况下）将文件的数据块分配到与其inode相同的组中，从而防止inode和数据之间的长时间寻道（如在老文件系统中）。其次，它将位于同一目录中的所有文件，放在它们所在目录的柱面组中。因此，如果用户创建了4个文件，/dir1/1.txt、/dir1/2.txt、/dir1/3.txt和/dir99/4.txt，FFS会尝试将前3个放在一起（同一组），与第四个远离（它在另外某个组中）。</p>
<h2 id="测量文件的局部性"><a href="#测量文件的局部性" class="headerlink" title="测量文件的局部性"></a>测量文件的局部性</h2><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/u7.png" alt="?"></p>
<h2 id="大文件例外"><a href="#大文件例外" class="headerlink" title="大文件例外"></a>大文件例外</h2><p>在FFS中，文件放置的一般策略有一个重要的例外，它出现在大文件中。如果没有不同的规则，大文件将填满它首先放入的块组（也可能填满其他组）。以这种方式填充块组是不符合需要的，因为它妨碍了随后的“相关”文件放置在该块组内，因此可能破坏文件访问的局部性。</p>
<p>因此，对于大文件，FFS执行以下操作。在将一定数量的块分配到第一个块组（例如，12个块，或inode中可用的直接指针的数量）之后，FFS将文件的下一个“大”块（即第一个间接块指向的那些部分）放在另一个块组中（可能因为它的利用率低而选择）。然后，文件的下一个块放在另一个不同的块组中，依此类推。</p>
<p>让我们看一些图片，更好地理解这个策略。如果没有大文件例外，单个大文件会将其所有块放入磁盘的一部分。我们使用一个包含10个块的文件的小例子，来直观地说明该行为。</p>
<p>FFS没有大文件例外时的图景：</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/i1.png" alt="?"><br>有了大文件例外，我们可能会看到像这样的情形，文件以大块的形式分布在磁盘上：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/i2.png" alt="?"></p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/i3.png" alt="?"></p>
<h2 id="关于-FFS-的其他几件事"><a href="#关于-FFS-的其他几件事" class="headerlink" title="关于 FFS 的其他几件事"></a>关于 FFS 的其他几件事</h2><p>当时许多文件大小为2KB左右，使用4KB块虽然有利于传输数据，但空间效率却不太好。因此，在典型的文件系统上，这种内部碎片（internal fragmentation）可能导致大约一半的磁盘浪费。</p>
<p>FFS设计人员采用很简单的解决方案解决了这个问题。他们决定引入子块（sub-block），这些子块有512字节，文件系统可以将它们分配给文件。因此，如果你创建了一个小文件（比如大小为1KB），它将占用两个子块，因此不会浪费整个4KB块。随着文件的增长，文件系统将继续为其分配512字节的子块，直到它达到完整的4KB数据。此时，FFS将找到一个4KB块，将子块复制到其中，并释放子块以备将来使用。</p>
<hr>
<h1 id="崩溃一致性：FSCK和日志"><a href="#崩溃一致性：FSCK和日志" class="headerlink" title="崩溃一致性：FSCK和日志"></a>崩溃一致性：FSCK和日志</h1><p>文件系统管理一组数据结构以实现预期的抽象：文件、目录，以及所有其他元数据，它们支持我们期望从文件系统获得的基本抽象。</p>
<p><strong>文件系统面临的一个主要挑战在于，如何在出现断电（power loss）或系统崩溃（system crash）的情况下，更新持久数据结构。</strong></p>
<h2 id="一个详细的例子"><a href="#一个详细的例子" class="headerlink" title="一个详细的例子"></a>一个详细的例子</h2><p>先看一个例子。我们需要一种工作负载（workload），它以某种方式更新磁盘结构。这里假设工作负载很简单：将单个数据块附加到原有文件。通过打开文件，调用lseek()将文件偏移量移动到文件末尾，然后在关闭文件之前，向文件发出单个4KB写入来完成追加。</p>
<p>假定磁盘上使用标准的简单文件系统结构，类似于之前看到的文件系统。这个小例子包括一个inode位图（inode bitmap，只有8位，每个inode一个），一个数据位图（data bitmap，也是8位，每个数据块一个），inode（总共8个，编号为0到7，分布在4个块上），以及数据块（总共8个，编号为0～7）。以下是该文件系统的示意图：</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/a1.png" alt="?"></p>
<p>查看图中的结构，可以看到分配了一个inode（inode号为2），它在inode位图中标记，单个分配的数据块（数据块4）也在数据中标记位图。inode表示为I [v1]，因为它是此inode的第一个版本。它将很快更新（由于上述工作负载）。</p>
<p>再来看看这个简化的inode。</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/a2.png" alt="?"><br>在这个简化的inode中，文件的大小为1（它有一个块位于其中），第一个直接指针指向块4（文件的第一个数据块，Da），并且所有其他3个直接指针都被设置为null（表示它们未被使用）。当然，真正的inode有更多的字段。</p>
<p>向文件追加内容时，要向它添加一个新数据块，因此必须更新3个磁盘上的结构：inode（必须指向新块，并且由于追加而具有更大的大小），新数据块Db和新版本的数据位图（称之为B[v2]）表示新数据块已被分配。</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/a3.png" alt="?"></p>
<p>更新的数据位图（B[v2]）现在看起来像这样：00001100。最后，有数据块（Db），它只是用户放入文件的内容。我们希望文件系统的最终磁盘映像如下所示：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/a4.png" alt="?"></p>
<p>要实现这种转变，文件系统必须对磁盘执行3次单独写入，分别针对inode（I[v2]），位图（B[v2]）和数据块（Db）。请注意，当用户发出write()系统调用时，这些写操作通常不会立即发生。脏的inode、位图和新数据先在内存（页面缓存，page cache，或缓冲区缓存，buffer  cache）中存在一段时间。然后，当文件系统最终决定将它们写入磁盘时（比如说5s或30s），文件系统将向磁盘发出必要的写入请求。遗憾的是，可能会发生崩溃，从而干扰磁盘的这些更新。特别是，如果这些写入中的一个或两个完成后发生崩溃，而不是全部 3个，则文件系统可能处于有趣的状态。</p>
<h3 id="崩溃场景"><a href="#崩溃场景" class="headerlink" title="崩溃场景"></a>崩溃场景</h3><ol>
<li><p>只将数据块（Db）写入磁盘。在这种情况下，数据在磁盘上，但是没有指向它的inode，也没有表示块已分配的位图。因此，就好像写入从未发生过一样。从文件系统崩溃一致性的角度来看，这种情况根本不是问题①。</p>
</li>
<li><p>只有更新的inode（I[v2]）写入了磁盘。在这种情况下，inode指向磁盘地址（5），其中Db即将写入，但Db尚未写入。因此，如果我们信任该指针，我们将从磁盘读取垃圾数据（磁盘地址5的旧内容）。</p>
</li>
</ol>
<p>遇到了一个新问题，我们将它称为文件系统不一致（file-system inconsistency）。磁盘上的位图告诉我们数据块5尚未分配，但是inode说它已经分配了。文件系统数据结构中的这种不同意见，是文件系统的数据结构不一致。要使用文件系统，我们必须以某种方式解决这个问题。</p>
<ol start="3">
<li>只有更新后的位图（B  [v2]）写入了磁盘。在这种情况下，位图指示已分配块5，但没有指向它的inode。因此文件系统再次不一致。如果不解决，这种写入将导致空间泄露（space leak），因为文件系统永远不会使用块5。</li>
</ol>
<p>在这个向磁盘写入3次的尝试中，还有3种崩溃场景。在这些情况下，两次写入成功，最后一次失败。</p>
<ol>
<li><p>inode（I[v2]）和位图（B[v2]）写入了磁盘，但没有写入数据（Db）。在这种情况下，文件系统元数据是完全一致的：inode有一个指向块5的指针，位图指示5正在使用，因此从文件系统的元数据的角度来看，一切看起来都很正常。但是有一个问题：5中又是垃圾。</p>
</li>
<li><p>写入了inode（I[v2]）和数据块（Db），但没有写入位图（B[v2]）。在这种情况下，inode指向了磁盘上的正确数据，但同样在inode和位图（B1）的旧版本之间存在不一致。因此，我们在使用文件系统之前，又需要解决问题。</p>
</li>
<li><p>写入了位图（B[v2]）和数据块（Db），但没有写入inode（I[v2]）。在这种情况下，inode和数据位图之间再次存在不一致。但是，即使写入块并且位图指示其使用，我们也不知道它属于哪个文件，因为没有inode指向该块。</p>
</li>
</ol>
<h2 id="解决方案-1：文件系统检查程序"><a href="#解决方案-1：文件系统检查程序" class="headerlink" title="解决方案 1：文件系统检查程序"></a>解决方案 1：文件系统检查程序</h2><p>早期的文件系统采用了一种简单的方法来处理崩溃一致性。基本上，它们决定让不一致的事情发生，然后再修复它们（重启时）。这种偷懒方法的典型例子可以在一个工具中找到：fsck①。fsck是一个UNIX工具，用于查找这些不一致并修复它们[M86]。</p>
<p><strong>它在文件系统挂载并可用之前运行（fsck假定在运行时没有其他文件系统活动正在进行）。一旦完成，磁盘上的文件系统应该是一致的，因此可以让用户访问。</strong></p>
<ol>
<li><p>超级块：fsck首先检查超级块是否合理，主要是进行健全性检查，例如确保文件系统大小大于分配的块数。通常，这些健全性检查的目的是找到一个可疑的（冲突的）超级块。在这种情况下，系统（或管理员）可以决定使用超级块的备用副本。</p>
</li>
<li><p>空闲块：接下来，fsck扫描inode、间接块、双重间接块等，以了解当前在文件系统中分配的块。它利用这些知识生成正确版本的分配位图。因此，如果位图和inode之间存在任何不一致，则通过信任inode内的信息来解决它。对所有inode执行相同类型的检查，确保所有看起来像在用的inode，都在inode位图中有标记。</p>
</li>
<li><p>inode状态：检查每个inode是否存在损坏或其他问题。例如，fsck确保每个分配的inode具有有效的类型字段（即常规文件、目录、符号链接等）。如果inode字段存在问题，不易修复，则inode被认为是可疑的，并被fsck清除，inode位图相应地更新。</p>
</li>
<li><p>fsck还会验证每个已分配的inode的链接数。你可能还记得，链接计数表示包含此特定文件的引用（即链接）的不同目录的数量。为了验证链接计数，fsck从根目录开始扫描整个目录树，并为文件系统中的每个文件和目录构建自己的链接计数。如果新计算的计数与inode中找到的计数不匹配，则必须采取纠正措施，通常是修复inode中的计数。如果发现已分配的inode但没有目录引用它，则会将其移动到lost + found目录。</p>
</li>
<li><p>重复：fsck还检查重复指针，即两个不同的inode引用同一个块的情况。如果一个inode明显不好，可能会被清除。或者，可以复制指向的块，从而根据需要为每个inode提供其自己的副本。</p>
</li>
<li><p>坏块：在扫描所有指针列表时，还会检查坏块指针。如果指针显然指向超出其有效范围的某个指针，则该指针被认为是“坏的”，例如，它的地址指向大于分区大小的块。在这种情况下，fsck不能做任何太聪明的事情。它只是从inode或间接块中删除（清除）该指针</p>
</li>
<li><p>目录检查：fsck不了解用户文件的内容。但是，目录包含由文件系统本身创建的特定格式的信息。因此，fsck对每个目录的内容执行额外的完整性检查，确保“.”和“..”是前面的条目，目录条目中引用的每个inode都已分配，并确保整个层次结构中没有目录的引用超过一次。</p>
</li>
</ol>
<p><strong>fsck（和类似的方法）有一个更大的、也许更根本的问题：它们太慢了。对于非常大的磁盘卷，扫描整个磁盘，以查找所有已分配的块并读取整个目录树，可能需要几分钟或几小时。</strong></p>
<h2 id="解决方案-2：日志（或预写日志）"><a href="#解决方案-2：日志（或预写日志）" class="headerlink" title="解决方案 2：日志（或预写日志）"></a>解决方案 2：日志（或预写日志）</h2><p><strong>基本思路如下。更新磁盘时，在覆写结构之前，首先写下一点小注记（在磁盘上的其他地方，在一个众所周知的位置），描述你将要做的事情。写下这个注记就是“预写”部分，我们把它写入一个结构，并组织成“日志”。因此，就有了预写日志。</strong></p>
<p>通过将注释写入磁盘，可以保证在更新（覆写）正在更新的结构期间发生崩溃时，能够返回并查看你所做的注记，然后重试。因此，你会在崩溃后准确知道要修复的内容（以及如何修复它），而不必扫描整个磁盘。</p>
<p>现在将描述Linux ext3（一种流行的日志文件系统）如何将日志记录到文件系统中。大多数磁盘上的结构与Linux  ext2相同，例如，磁盘被分成块组，每个块组都有一个inode和数据位图以及inode和数据块。新的关键结构是日志本身，它占用分区内或其他设备上的少量空间。因此，ext2文件系统（没有日志）看起来像这样：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/s1.png" alt="?"></p>
<p>假设日志放在同一个文件系统映像中（虽然有时将它放在单独的设备上，或作为文件系统中的文件），带有日志的ext3文件系统如下所示：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/s2.png" alt="?"></p>
<h3 id="数据日志"><a href="#数据日志" class="headerlink" title="数据日志"></a>数据日志</h3><p>假设再次进行标准的更新，我们再次希望将inode（I[v2]）、位图（B[v2]）和数据块（Db）写入磁盘。在将它们写入最终磁盘位置之前，现在先将它们写入日志。这就是日志中的样子：</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/s3.png" alt="?"><br>事务开始（TxB）告诉我们有关此更新的信息，包括对文件系统即将进行的更新的相关信息（例如，块I[v2]、B[v2]和Db的最终地址），以及某种事务标识符（transaction identifier，TID）。中间的3个块只包含块本身的确切内容，这被称为物理日志（physical logging），因为我们将更新的确切物理内容放在日志中（另一种想法，逻辑日志（logical  logging），在日志中放置更紧凑的更新逻辑表示，例如，“这次更新希望将数据块Db追加到文件X”，这有点复杂，但可以节省日志中的空间，并可能提高性能）。最后一个块（TxE）是该事务结束的标记，也会包含TID。</p>
<p>一旦这个事务安全地存在于磁盘上，我们就可以覆写文件系统中的旧结构了。这个过程称为加检查点（checkpointing）。因此，为了对文件系统加检查点（checkpoint，即让它与日志中即将进行的更新一致），我们将I[v2]、B[v2]和Db写入其磁盘位置，如上所示。如果这些写入成功完成，我们已成功地为文件系统加上了检查点，基本上完成了。因此，我们的初始操作顺序如下。</p>
<ol>
<li><p>日志写入：将事务（包括事务开始块，所有即将写入的数据和元数据更新以及事务结束块）写入日志，等待这些写入完成。</p>
</li>
<li><p>加检查点：将待处理的元数据和数据更新写入文件系统中的最终位置。</p>
</li>
</ol>
<p>在我们的例子中，先将TxB、I[v2]、B[v2]、Db和TxE写入日志。这些写入完成后，我们将加检查点，将I[v2]、B[v2]和Db写入磁盘上的最终位置，完成更新。</p>
<p><strong>在写入日志期间发生崩溃时，事情变得有点棘手。</strong></p>
<p>为避免该问题，文件系统分两步发出事务写入。首先，它将除TxE块之外的所有块写入日志，同时发出这些写入。当这些写入完成时，日志将看起来像这样（假设又是文件追加的工作负载）：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/s4.png" alt="?"><br>当这些写入完成时，文件系统会发出TxE块的写入，从而使日志处于最终的安全状态：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/s5.png" alt="?"></p>
<p>此过程的一个重要方面是磁盘提供的原子性保证。事实证明，磁盘保证任何512字节写入都会发生或不发生（永远不会半写）。因此，为了确保TxE的写入是原子的，应该使它成为一个512字节的块。因此，我们当前更新文件系统的协议如下，3个阶段中的每一个都标上了名称。</p>
<ol>
<li>日志写入：将事务的内容（包括TxB、元数据和数据）写入日志，等待这些写入完成。</li>
<li>日志提交：将事务提交块（包括TxE）写入日志，等待写完成，事务被认为已提交（committed）。</li>
<li>加检查点：将更新内容（元数据和数据）写入其最终的磁盘位置。</li>
</ol>
<h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>如果崩溃发生在事务被安全地写入日志之前（在上面的步骤2完成之前），那么我们的工作很简单：简单地跳过待执行的更新。如果在事务已提交到日志之后但在加检查点完成之前发生崩溃，则文件系统可以按如下方式恢复（recover）更新。系统引导时，文件系统恢复过程将扫描日志，并查找已提交到磁盘的事务。然后，这些事务被重放（replayed，按顺序），文件系统再次尝试将事务中的块写入它们最终的磁盘位置。</p>
<h3 id="批处理日志更新"><a href="#批处理日志更新" class="headerlink" title="批处理日志更新"></a>批处理日志更新</h3><p>为了解决这个问题，一些文件系统不会一次一个地向磁盘提交每个更新（例如，Linux ext3）。与此不同，可以将所有更新缓冲到全局事务中。在上面的示例中，当创建两个文件时，文件系统只将内存中的inode位图、文件的inode、目录数据和目录inode标记为脏，并将它们添加到块列表中，形成当前的事务。当最后应该将这些块写入磁盘时（例如，在超时5s之后），会提交包含上述所有更新的单个全局事务。因此，通过缓冲更新，文件系统在许多情况下可以避免对磁盘的过多的写入流量。</p>
<h3 id="使日志有限"><a href="#使日志有限" class="headerlink" title="使日志有限"></a>使日志有限</h3><p>日志的大小有限。如果不断向它添加事务（如下所示），它将很快填满。</p>
<p>日志越大，恢复时间越长，因为恢复过程必须重放日志中的所有事务（按顺序）才能恢复。第二个问题更重要：当日志已满（或接近满）时，不能向磁盘提交进一步的事务，从而使文件系统“不太有用”（即无用）。</p>
<p><strong>日志文件系统将日志视为循环数据结构，一遍又一遍地重复使用。</strong><br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/s6.png" alt="?"></p>
<p>1．日志写入：将事务的内容（包括TxB和更新内容）写入日志，等待这些写入完成。2．日志提交：将事务提交块（包括TxE）写入日志，等待写完成，事务被认为已提交（committed）。3．加检查点：将更新内容写入其最终的磁盘位置。4．释放：一段时间后，通过更新日志超级块，在日志中标记该事务为空闲。</p>
<blockquote>
<p>补充：优化日志写入<br>写入日志的效率特别低。也就是说，文件系统首先必须写出事务开始块和事务的内容。只有在这些写入完成后，文件系统才能将事务结束块发送到磁盘。</p>
</blockquote>
<blockquote>
<p>将事务写入日志时，在开始和结束块中包含日志内容的校验和。这样做可以使文件系统立即写入整个事务，而不会产生等待。如果在恢复期间，文件系统发现计算的校验和与事务中存储的校验和不匹配，则可以断定在写入事务期间发生了崩溃，从而丢弃了文件系统更新。因此，通过写入协议和恢复系统中的小调整，文件系统可以实现更快的通用情况性能。最重要的是，系统更可靠了，因为来自日志的任何读取现在都受到校验和的保护。</p>
</blockquote>
<h3 id="元数据日志"><a href="#元数据日志" class="headerlink" title="元数据日志"></a>元数据日志</h3><p>我们上面描述的日志模式通常称为数据日志（data journaling，如在Linux ext3中），因为它记录了所有用户数据（除了文件系统的元数据之外）。一种更简单（也更常见）的日志形式有时称为有序日志（ordered  journaling，或称为元数据日志，metadata  journaling）<strong>它几乎相同，只是用户数据没有写入日志。</strong></p>
<p>1．数据写入：将数据写入最终位置，等待完成（等待是可选的，详见下文）。<br>2．日志元数据写入：将开始块和元数据写入日志，等待写入完成。<br>3．日志提交：将事务提交块（包括TxE）写入日志，等待写完成，现在认为事务（包括数据）已提交（committed）。<br>4．加检查点元数据：将元数据更新的内容写入文件系统中的最终位置。<br>5．释放：稍后，在日志超级块中将事务标记为空闲。</p>
<h3 id="棘手的情况：块复用"><a href="#棘手的情况：块复用" class="headerlink" title="棘手的情况：块复用"></a>棘手的情况：块复用</h3><p>假设你有一个名为foo的目录。用户向foo添加一个条目（例如通过创建文件），因此foo的内容（因为目录被认为是元数据）被写入日志。假设foo目录数据的位置是块1000。因此日志包含如下内容：</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/d1.png" alt="?"><br>此时，用户删除目录中的所有内容以及目录本身，从而释放块1000以供复用。最后，用户创建了一个新文件（比如foobar），结果复用了过去属于foo的相同块（1000）。foobar的inode提交给磁盘，其数据也是如此。但是，请注意，因为正在使用元数据日志，所以只有foobar的inode被提交给日志，文件foobar中块1000中新写入的数据没有写入日志。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/d2.png" alt="?"></p>
<p>现在假设发生了崩溃，所有这些信息仍然在日志中。在重放期间，恢复过程简单地重放日志中的所有内容，包括在块1000中写入目录数据。因此，重放会用旧目录内容覆盖当前文件foobar的用户数据！</p>
<h3 id="总结日志：时间线"><a href="#总结日志：时间线" class="headerlink" title="总结日志：时间线"></a>总结日志：时间线</h3><p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/d3.png" alt="?"><br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/d4.png" alt="?"></p>
<h1 id="日志结构文件系统"><a href="#日志结构文件系统" class="headerlink" title="日志结构文件系统"></a>日志结构文件系统</h1><p>LFS永远不会覆写现有数据，而是始终将段写入空闲位置。由于段很大，因此可以有效地使用磁盘，并且文件系统的性能接近其峰值。</p>
<h2 id="按顺序写入磁盘"><a href="#按顺序写入磁盘" class="headerlink" title="按顺序写入磁盘"></a>按顺序写入磁盘</h2><p>我们正在将数据块D写入文件。将数据块写入磁盘可能会导致以下磁盘布局，其中D写在磁盘地址A0：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z1.png" alt="?"><br>但是，当用户写入数据块时，不仅是数据被写入磁盘；还有其他需要更新的元数据（metadata）。在这个例子中，让我们将文件的inode（I）也写入磁盘，并将其指向数据块D。写入磁盘时，数据块和inode看起来像这样（注意inode看起来和数据块一样大，但通常情况并非如此。在大多数系统中，数据块大小为4KB，而inode小得多，大约128B）<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z2.png" alt="?"></p>
<h2 id="顺序而高效地写入"><a href="#顺序而高效地写入" class="headerlink" title="顺序而高效地写入"></a>顺序而高效地写入</h2><p>例如，假设我们在时间T向地址A写入一个块。然后等待一会儿，再向磁盘写入地址A+1（下一个块地址按顺序），但是在时间T+δ。遗憾的是，在第一次和第二次写入之间，磁盘已经旋转。</p>
<p><strong>实际上，你必须向驱动器发出大量连续写入（或一次大写入）才能获得良好的写入性能。</strong></p>
<p>为了达到这个目的，LFS使用了一种称为写入缓冲①（write buffering）的古老技术。在写入磁盘之前，LFS会跟踪内存中的更新。收到足够数量的更新时，会立即将它们写入磁盘，从而确保有效使用磁盘。</p>
<p>LFS一次写入的大块更新被称为段（segment）。</p>
<p>下面是一个例子，其中LFS将两组更新缓冲到一个小段中。实际段更大（几MB）。第一次更新是对文件j的4次块写入，第二次是添加到文件k的一个块。然后，LFS立即将整个七个块的段提交到磁盘。这些块的磁盘布局如下：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z3.png" alt="?"></p>
<h2 id="要缓冲多少"><a href="#要缓冲多少" class="headerlink" title="要缓冲多少"></a>要缓冲多少</h2><p>取决于磁盘本身，特别是与传输速率相比定位开销有多高。</p>
<h2 id="问题：查找-inode"><a href="#问题：查找-inode" class="headerlink" title="问题：查找 inode"></a>问题：查找 inode</h2><p><strong>老UNIX文件系统将所有inode保存在磁盘的固定位置。因此，给定一个inode号和起始地址，要查很特定的inode，只需将inode号乘以inode的大小，然后将其加上磁盘数组的起始地址，即可计算其确切的磁盘地址。给定一个inode号，基于数组的索引是快速而直接的。因为它们以数组形式组织，并放在磁盘的固定位置上。</strong></p>
<p>在FFS中查很给定inode号的inode仅稍微复杂一些，因为FFS将inode表拆分为块并在每个柱面组中放置一组inode。因此，必须知道每个inode块的大小和每个inode的起始地址。</p>
<p>我们已经设法将inode分散在整个磁盘上！更糟糕的是，我们永远不会覆盖，<strong>因此最新版本的inode（即我们想要的那个）会不断移动。</strong></p>
<h2 id="通过间接解决方案：inode-映射"><a href="#通过间接解决方案：inode-映射" class="headerlink" title="通过间接解决方案：inode 映射"></a>通过间接解决方案：inode 映射</h2><p>为了解决这个问题，LFS的设计者通过名为inode映射（inode map，imap）的数据结构，在inode号和inode之间引入了一个间接层（level of indirection）。imap是一个结构，它将inode号作为输入，并生成最新版本的inode的磁盘地址。因此，你可以想象它通常被实现为一个简单的数组，每个条目有4个字节（一个磁盘指针）。每次将inode写入磁盘时，imap都会使用其新位置进行更新。</p>
<p>LFS将inode映射的块放在它写入所有其他新信息的位置旁边。因此，当将数据块追加到文件k时，LFS实际上将新数据块，其inode和一段inode映射一起写入磁盘<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z4.png" alt="?"></p>
<p>在该图中，imap数组存储在标记为imap的块中，它告诉LFS，inode  k位于磁盘地址A1。接下来，这个inode告诉LFS它的数据块D在地址A0。</p>
<h2 id="检查点区域"><a href="#检查点区域" class="headerlink" title="检查点区域"></a>检查点区域</h2><p>LFS在磁盘上只有这样一个固定的位置，称为检查点区域（checkpoint  region，CR）。检查点区域包含指向最新的inode映射片段的指针（即地址），因此可以通过首先读取CR来很到inode映射片段。请注意，检查点区域仅定期更新（例如每30s左右），因此性能不会受到影响。因此，磁盘布局的整体结构包含一个检查点区域（指向内部映射的最新部分），每个inode映射块包含inode的地址，inode指向文件（和目录），就像典型的UNIX文件系统一样。</p>
<p><strong>inode映射在LFS中的意义是将文件或目录与其对应的inode号码进行关联，通过inode号码可以快速访问文件或目录的元数据信息，从而实现文件系统的高效管理和访问。</strong></p>
<p>下面的例子是检查点区域（注意它始终位于磁盘的开头，地址为0），以及单个imap块，inode和数据块。一个真正的文件系统当然会有一个更大的CR（事实上，它将有两个，我们稍后会理解），许多imap块，当然还有更多的inode、数据块等。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z5.png" alt="?"></p>
<h2 id="从磁盘读取文件：回顾"><a href="#从磁盘读取文件：回顾" class="headerlink" title="从磁盘读取文件：回顾"></a>从磁盘读取文件：回顾</h2><p>假设从内存中没有任何东西开始。我们必须读取的第一个磁盘数据结构是检查点区域。检查点区域包含指向整个inode映射的指针（磁盘地址），因此LFS读入整个inode映射并将其缓存在内存中。在此之后，当给定文件的inode号时，LFS只是在imap中查很inode号到inode磁盘地址的映射，并读入最新版本的inode。要从文件中读取块，此时，LFS完全按照典型的UNIX文件系统进行操作，方法是使用直接指针或间接指针或双重间接指针。在通常情况下，从磁盘读取文件时，LFS应执行与典型文件系统相同数量的I/O，整个imap被缓存，因此LFS在读取过程中所做的额外工作是在imap中查很inode的地址。</p>
<h2 id="目录如何"><a href="#目录如何" class="headerlink" title="目录如何"></a>目录如何</h2><p>目录结构与传统的UNIX文件系统基本相同，因为目录只是（名称，inode号）映射的集合。例如，在磁盘上创建文件时，LFS必须同时写入新的inode，一些数据，以及引用此文件的目录数据及其inode。请记住，LFS将在磁盘上按顺序写入（在缓冲更新一段时间后）。因此，在目录中创建文件foo，将导致磁盘上的以下新结构：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z6.png" alt="?"><br>inode映射的片段包含目录文件dir以及新创建的文件f的位置信息。因此，访问文件foo（具有inode号f）时，你先要查看inode映射（通常缓存在内存中），很到目录dir（A3）的inode的位置。然后读取目录的inode，它给你目录数据的位置（A2）。读取此数据块为你提供名称到inode号的映射（foo，k）。然后再次查阅inode映射，很到inode号k（A1）的位置，最后在地址A0处读取所需的数据块。</p>
<h2 id="一个新问题：垃圾收集"><a href="#一个新问题：垃圾收集" class="headerlink" title="一个新问题：垃圾收集"></a>一个新问题：垃圾收集</h2><p>LFS会在整个磁盘中分散旧版本的文件结构。我们（毫不客气地）将这些旧版本称为垃圾（garbage）。<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z7.png" alt="?"><br>在图中，可以看到inode和数据块在磁盘上有两个版本，一个是旧的（左边那个），一个是当前的，因此是活的（live，右边那个）。对于覆盖数据块的简单行为，LFS必须持久许多新结构，从而在磁盘上留下上述块的旧版本。</p>
<p>另外举个例子，假设我们将一块添加到该原始文件k中。在这种情况下，会生成新版本的inode，但旧数据块仍由旧inode指向。因此，它仍然存在，并且与当前文件系统分离：<br><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z8.png" alt="?"></p>
<p><strong>可以保留那些旧版本并允许用户恢复旧文件版本（例如，当他们意外覆盖或删除文件时，这样做可能非常方便）。这样的文件系统称为版本控制文件系统（versioning file system），因为它跟踪文件的不同版本。</strong></p>
<p>但是，LFS只保留文件的最新活版本。</p>
<p>LFS清理程序定期读入许多旧的（部分使用的）段，确定哪些块在这些段中存在，然后写出一组新的段，只包含其中活着的块，从而释放旧块用于写入。具体来说，我们预期清理程序读取M个现有段，将其内容打包（compact）到N个新段（其中N  &lt;  M），然后将N段写入磁盘的新位置。然后释放旧的M段，文件系统可以使用它们进行后续写入。</p>
<h2 id="确定块的死活"><a href="#确定块的死活" class="headerlink" title="确定块的死活"></a>确定块的死活</h2><p>对于每个数据块D，LFS包括其inode号（它属于哪个文件）及其偏移量（这是该文件的哪一块）。该信息记录在一个数据结构中，位于段头部，称为段摘要块（segment summary block）。</p>
<p>对于位于地址A的磁盘上的块D，查看段摘要块并很到其inode号N和偏移量T。接下来，查看imap以很到N所在的位置，并从磁盘读取N（可能它已经在内存中，这更好）。最后，利用偏移量T，查看inode（或某个间接块），看看inode认为此文件的第T个块在磁盘上的位置。如果它刚好指向磁盘地址A，则LFS可以断定块D是活的。如果它指向其他地方，LFS可以断定D未被使用（即它已经死了），因此知道不再需要该版本。</p>
<p><img src="/2023/07/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%8C%81%E4%B9%85%E6%80%A7/z9.png" alt="?"></p>
<h2 id="策略问题：要清理哪些块，何时清理"><a href="#策略问题：要清理哪些块，何时清理" class="headerlink" title="策略问题：要清理哪些块，何时清理"></a>策略问题：要清理哪些块，何时清理</h2><h2 id="崩溃恢复和日志"><a href="#崩溃恢复和日志" class="headerlink" title="崩溃恢复和日志"></a>崩溃恢复和日志</h2><p>为了确保CR更新以原子方式发生，LFS实际上保留了两个CR，每个位于磁盘的一端，并交替写入它们。当使用最新的指向inode映射和其他信息的指针更新CR时，LFS还实现了一个谨慎的协议。具体来说，它首先写出一个头（带有时间戳），然后写出CR的主体，然后最后写出最后一部分（也带有时间戳）。如果系统在CR更新期间崩溃，LFS可以通过查看一对不一致的时间戳来检测到这一点。LFS将始终选择使用具有一致时间戳的最新CR，从而实现CR的一致更新。</p>
<p>我们现在关注第一种情况。由于LFS每隔30s左右写入一次CR，因此文件系统的最后一致快照可能很旧。因此，在重新启动时，LFS可以通过简单地读取检查点区域、它指向的imap片段以及后续文件和目录，从而轻松地恢复。但是，最后许多秒的更新将会丢失。</p>
<hr>
<h1 id="数据完整性和保护"><a href="#数据完整性和保护" class="headerlink" title="数据完整性和保护"></a>数据完整性和保护</h1><h2 id="磁盘故障模式"><a href="#磁盘故障模式" class="headerlink" title="磁盘故障模式"></a>磁盘故障模式</h2><p>在早期的RAID系统中，故障模型非常简单：要么整个磁盘都在工作，要么完全失败，而且检测到这种故障很简单。</p>
<p>具体来说，两种类型的单块故障是常见的，值得考虑：潜在扇区错误（Latent-Sector Errors，LSE）和块讹误（block corruption）</p>
<p>当磁盘扇区（或扇区组）以某种方式讹误时，会出现LSE。例如，如果磁头由于某种原因接触到表面（磁头碰撞，head crash，在正常操作期间不应发生的情况），则可能会讹误表面，使得数据位不可读。宇宙射线也会导致数据位翻转，使内容不正确。幸运的是，驱动器使用磁盘内纠错码（Error Correcting Code，ECC）来确定块中的磁盘位是否良好，并且在某些情况下，修复它们。如果它们不好，并且驱动器没有足够的信息来修复错误，则在发出请求读取它们时，磁盘会返回错误。</p>
<h2 id="处理潜在的扇区错误"><a href="#处理潜在的扇区错误" class="headerlink" title="处理潜在的扇区错误"></a>处理潜在的扇区错误</h2>]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程,多进程,并发,并行,cpu</title>
    <url>/2023/07/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C-cpu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>首先，要先了解几个概念：</p>
<p>1、进程是程序的一次执行。</p>
<p>2、进程是资源分配的基本单位（调度单位）。</p>
<p>3、一个进程可以包括多个线程。</p>
<p>4、在单CPU计算机中，有一个资源是无法被多个程序并行使用的：CPU。</p>
<p>5、操作系统调度器：拆分CPU为一段段时间的运行片，轮流分配给不同的程序。</p>
<p>6、操作系统内存管理模块：管理物理内存、虚拟内存相关的事务。
　　</p>
<p><strong>由于CPU同时刻只能执行一个进程，如果我们不加以控制的话，一个进程可能使用CPU直到运行结束，于是出现了操作系统调度器，而进程也成为了调度单位。</strong> 进程的运行不仅仅需要CPU，还需要很多其他资源，如内存啊，显卡啊，GPS啊，磁盘啊等等，统称为程序的执行环境，也就是程序上下文。</p>
<p>在这里就出现了并发的概念，调度器切换CPU给不同进程使用的速度非常快，于是在使用者看来程序是在同时运行，<strong>这就是并发，而实际上CPU在同一时刻只在运行一个进程。</strong></p>
<h2 id="CPU进程无法同时刻共享，但是出现一定要共享CPU的需求呢？"><a href="#CPU进程无法同时刻共享，但是出现一定要共享CPU的需求呢？" class="headerlink" title="CPU进程无法同时刻共享，但是出现一定要共享CPU的需求呢？"></a>CPU进程无法同时刻共享，但是出现一定要共享CPU的需求呢？</h2><p>此时线程的概念就出现了。线程被包含在进程当中，进程的不同线程间共享CPU和程序上下文。（共享进程分配到的资源）</p>
<p><strong>单CPU进行进程调度的时候，</strong> 需要读取上下文+执行程序+保存上下文，即进程切换。如果这个CPU是单核的话，那么在进程中的不同线程为了使用CPU核心，则会进行线程切换，但是由于共享了程序执行环境，这个线程切换比进程切换开销少了很多。<strong>在这里依然是并发，唯一核心同时刻只能执行一个线程。</strong></p>
<p><strong>如果这个CPU是多核的话，那么进程中的不同线程可以使用不同核心，真正的并行出现了。</strong></p>
<p><strong>线程是CPU调度和分配的基本单位，进程是操作系统进行资源分配（包括cpu、内存、磁盘IO等）的最小单位。</strong></p>
<p>CPU只能看到线程</p>
<p>另外在有的操作系统里，进程不是调度单位，线程是最基本的调度单位，调度器只调度线程，不调度进程，如VxWorks。</p>
<p>总结：</p>
<p>1、单CPU中进程只能是并发，多CPU计算机中进程可以并行。</p>
<p>2、单CPU单核中线程只能并发，单CPU多核中线程可以并行。</p>
<p>3、无论是并发还是并行，使用者来看，看到的是多进程，多线程。</p>
<h2 id="CPU的几核几线程是什么意思？"><a href="#CPU的几核几线程是什么意思？" class="headerlink" title="CPU的几核几线程是什么意思？"></a>CPU的几核几线程是什么意思？</h2><p>“8核16线程”是指一款处理器的核心数和线程数配置。在这种情况下，该处理器有8个物理核心和16个逻辑线程。</p>
<p>具体解释如下：</p>
<p>核心数：指处理器内部的物理核心数量。每个物理核心都可以独立地执行指令和运算操作。<br>线程数：指处理器能够同时处理的线程数量。</p>
<p>逻辑线程是通过超线程（Hyper-Threading）技术实现的。在超线程中，每个物理核心被模拟成两个逻辑核心，使得处理器可以同时执行两个线程。</p>
<p>因此，对于一个有8核16线程的处理器，它具有8个物理核心和每个核心能够模拟出2个逻辑核心，总共能够同时处理16个线程。这样的配置可以提高处理器的并发性和多任务处理能力，增加系统的整体性能表现。</p>
]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统导论-进阶</title>
    <url>/2023/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="多处理器调度（高级）"><a href="#多处理器调度（高级）" class="headerlink" title="多处理器调度（高级）"></a>多处理器调度（高级）</h1><p>多核处理器（multicore）将多个CPU核组装在一块芯片上，是这种扩散的根源。<br>多线程应用可以将工作分散到多个CPU上，因此CPU资源越多就运行越快。</p>
<h2 id="背景：多处理器架构"><a href="#背景：多处理器架构" class="headerlink" title="背景：多处理器架构"></a>背景：多处理器架构</h2><p>为了理解多处理器调度带来的新问题，必须先知道它与单CPU之间的基本区别。区别的核心在于对硬件缓存（cache）的使用，以及多处理器之间共享数据的方式。</p>
<p>在单CPU系统中，存在多级的硬件缓存（hardware  cache），一般来说会让处理器更快地执行程序。缓存是很小但很快的存储设备，通常拥有内存中最热的数据的备份。相比之下，内存很大且拥有所有的数据，但访问速度较慢。通过将频繁访问的数据放在缓存中，系统似乎拥有又大又快的内存。</p>
<p>假设一个程序需要从内存中加载指令并读取一个值，系统只有一个CPU，拥有较小的缓存（如64KB）和较大的内存。程序第一次读取数据时，数据在内存中，因此需要花费较长的时间（可能数十或数百纳秒）。处理器判断该数据很可能会被再次使用，因此将其放入CPU缓存中。如果之后程序再次需要使用同样的数据，CPU会先查找缓存。因为在缓存中找到了数据，所以取数据快得多（比如几纳秒），程序也就运行更快。</p>
<blockquote>
<p>缓存是基于局部性（locality）的概念，局部性有两种，即时间局部性和空间局部性。时间局部性是指当一个数据被访问后，它很有可能会在不久的将来被再次访问，比如循环代码中的数据或指令本身。而空间局部性指的是，当程序访问地址为x的数据时，很有可能会紧接着访问x周围的数据，比如遍历数组或指令的顺序执行。由于这两种局部性存在于大多数的程序中，硬件系统可以很好地预测哪些数据可以放入缓存，从而运行得很好。</p>
</blockquote>
<p><img src="/2023/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E9%98%B6/q1.png" alt="?"></p>
<p><strong>缓存一致性（cache coherence）问题</strong></p>
<p>事实证明，多CPU的情况下缓存要复杂得多。例如，假设一个运行在CPU 1上的程序从内存地址A读取数据。由于不在CPU  1的缓存中，所以系统直接访问内存，得到值D。程序然后修改了地址A处的值，只是将它的缓存更新为新值D’。将数据写回内存比较慢，因此系统（通常）会稍后再做。假设这时操作系统中断了该程序的运行，并将其交给CPU 2，重新读取地址A的数据，由于CPU 2的缓存中并没有该数据，所以会直接从内存中读取，得到了旧值D，而不是正确的值D’。</p>
<p>硬件提供了这个问题的基本解决方案：通过监控内存访问，硬件可以保证获得正确的数据，并保证共享内存的唯一性。在基于总线的系统中，一种方式是使用总线窥探（bussnooping）[G83]。每个缓存都通过监听链接所有缓存和内存的总线，来发现内存访问。如果CPU发现对它放在缓存中的数据的更新，会作废（invalidate）本地副本（从缓存中移除），或更新（update）它（修改为新值）。</p>
<h2 id="别忘了同步"><a href="#别忘了同步" class="headerlink" title="别忘了同步"></a>别忘了同步</h2><p>跨CPU访问（尤其是写入）共享数据或数据结构时，需要使用互斥原语（比如锁），才能保证正确性。</p>
<p>为了更具体，我们设想这样的代码序列，用于删除共享链表的一个元素，如图10.3所示。假设两个CPU上的不同线程同时进入这个函数。如果线程1执行第一行，会将head的当前值存入它的tmp变量。如果线程2接着也执行第一行，它也会将同样的head值存入它自己的私有tmp变量（tmp在栈上分配，因此每个线程都有自己的私有存储）。因此，两个线程会尝试删除同一个链表头，而不是每个线程移除一个元素，这导致了各种问题（比如在第4行重复释放头元素，以及可能两次返回同一个数据）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">Node_t</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> value;</span><br><span class="line"><span class="number">3</span> <span class="class"><span class="keyword">struct</span> __<span class="title">Node_t</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="number">4</span> &#125; Node_t;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="type">int</span> <span class="title function_">List_Pop</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">7</span> Node_t *tmp = head; <span class="comment">// remember old head ...</span></span><br><span class="line"><span class="number">8</span> <span class="type">int</span> value = head-&gt;value; <span class="comment">// ... and its value</span></span><br><span class="line"><span class="number">9</span> head = head-&gt;next; <span class="comment">// advance head to next pointer</span></span><br><span class="line"><span class="number">10</span> <span class="built_in">free</span>(tmp); <span class="comment">// free old head</span></span><br><span class="line"><span class="number">11</span> <span class="keyword">return</span> value; <span class="comment">// return value at head</span></span><br><span class="line"><span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure>

<p>当然，让这类函数正确工作的方法是加锁（locking）。这里只需要一个互斥锁（即pthread_mutex_t m;），然后在函数开始时调用lock(&amp;m)，在结束时调用unlock(&amp;m)，确保代码的执行如预期。这里依然有问题，尤其是性能方面。具体来说，<strong>随着CPU数量的增加，访问同步共享的数据结构会变得很慢。</strong></p>
<h2 id="最后一个问题：缓存亲和度"><a href="#最后一个问题：缓存亲和度" class="headerlink" title="最后一个问题：缓存亲和度"></a>最后一个问题：缓存亲和度</h2><p>一个进程在某个CPU上运行时，会在该CPU的缓存中维护许多状态。下次该进程在相同CPU上运行时，由于缓存中的数据而执行得更快。相反，在不同的CPU上执行，会由于需要重新加载数据而很慢（好在硬件保证的缓存一致性可以保证正确执行）。因此多处理器调度应该考虑到这种缓存亲和性，并尽可能将进程保持在同一个CPU上。</p>
<h2 id="单队列调度"><a href="#单队列调度" class="headerlink" title="单队列调度"></a>单队列调度</h2><p>最基本的方式是简单地复用单处理器调度的基本架构，将所有需要调度的工作放入一个单独的队列中，我们称之为单队列多处理器调度（Single Queue Multiprocessor Scheduling，SQMS）。这个方法最大的优点是简单。它不需要太多修改，就可以将原有的策略用于多个CPU，选择最适合的工作来运行（例如，如果有两个CPU，它可能选择两个最合适的工作）。</p>
<p>SQMS有几个明显的短板。<br>第一个是缺乏可扩展性（scalability）。<br>通过加锁来确保原子性，就需要找到下一个将要执行的进程，并且加锁损失性能.</p>
<p>第二个主要问题是缓存亲和性。比如，假设我们有5个工作（A、B、C、D、E）和4个处理器。调度队列如下：<br><img src="/2023/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E9%98%B6/q2.png" alt="?"></p>
<p>一段时间后，假设每个工作依次执行一个时间片，然后选择另一个工作，下面是每个CPU可能的调度序列：<br><img src="/2023/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E9%98%B6/w3.png" alt="?"><br>由于每个CPU都简单地从全局共享的队列中选取下一个工作执行，因此每个工作都不断在不同CPU之间转移，这与缓存亲和的目标背道而驰。</p>
<p>大多数SQMS调度程序都引入了一些亲和度机制，尽可能让进程在同一个CPU上运行。保持一些工作的亲和度的同时，可能需要牺牲其他工作的亲和度来实现负载均衡。例如，针对同样的5个工作的调度如下：<br><img src="/2023/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E9%98%B6/q3.png" alt="?"><br>这种调度中，A、B、C、D 这4个工作都保持在同一个CPU上，只有工作E不断地来回迁移（migrating），从而尽可能多地获得缓存亲和度。为了公平起见，之后我们可以选择不同的工作来迁移。</p>
<h2 id="多队列调度"><a href="#多队列调度" class="headerlink" title="多队列调度"></a>多队列调度</h2><p>每个CPU一个队列。我们称之为多队列多处理器调度（Multi-Queue Multiprocessor Scheduling，MQMS）</p>
<p>在MQMS中，基本调度框架包含多个调度队列，每个队列可以使用不同的调度规则，比如轮转或其他任何可能的算法。当一个工作进入系统后，系统会依照一些启发性规则（如随机或选择较空的队列）将其放入某个调度队列。这样一来，每个CPU调度之间相互独立，就避免了单队列的方式中由于数据共享及同步带来的问题。</p>
<p>例如，假设系统中有两个CPU（CPU 0和CPU 1）。这时一些工作进入系统：A、B、C和D。由于每个CPU都有自己的调度队列，操作系统需要决定每个工作放入哪个队列。可能像下面这样做：<br><img src="/2023/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E9%98%B6/q4.png" alt="?"></p>
<p>根据不同队列的调度策略，每个CPU从两个工作中选择，决定谁将运行。例如，利用轮转，调度结果可能如下所示：<br><img src="/2023/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E9%98%B6/q5.png" alt="?"></p>
<p>MQMS比SQMS有明显的优势，它天生更具有可扩展性。队列的数量会随着CPU的增加而增加，因此锁和缓存争用的开销不是大问题。此外，MQMS天生具有良好的缓存亲和度。所有工作都保持在固定的CPU上，因而可以很好地利用缓存数据。</p>
<p><strong>负载不均（load imbalance）</strong><br>假定和上面设定一样（4个工作，2个CPU），但假设一个工作（如C）这时执行完毕。现在调度队列如下：<br><img src="/2023/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E9%98%B6/w6.png" alt="?"><br>从图中可以看出，A获得了B和D两倍的CPU时间，这不是期望的结果。更糟的是，假设A和C都执行完毕，系统中只有B和D。调度队列看起来如下:<br><img src="/2023/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E9%98%B6/w7.png" alt="?"></p>
<p><strong>通过工作的跨CPU迁移，可以真正实现负载均衡。</strong></p>
<p>同样，有一个CPU空闲，另一个CPU有一些工作。<br><img src="/2023/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E9%98%B6/w8.png" alt="?"><br>在这种情况下，期望的迁移很容易理解：操作系统应该将B或D迁移到CPU0。这次工作迁移导致负载均衡，皆大欢喜。更棘手的情况是较早一些的例子，A独自留在CPU 0上，B和D在CPU 1上交替运行。<br><img src="/2023/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E9%98%B6/e1.png" alt="?"><br>在这种情况下，单次迁移并不能解决问题。应该怎么做呢？答案是不断地迁移一个或多个工作。一种可能的解决方案是不断切换工作，如下面的时间线所示。可以看到，开始的时候A独享CPU 0，B和D在CPU 1。一些时间片后，B迁移到CPU 0与A竞争，D则独享CPU 1一段时间。这样就实现了负载均衡。<br><img src="/2023/07/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E9%98%B6/e2.png" alt="?"></p>
<p><strong>基本的方法是采用一种技术，名为工作窃取（work stealing）。</strong></p>
<p>工作量较少的（源）队列不定期地“偷看”其他（目标）队列是不是比自己的工作多。如果目标队列比源队列（显著地）更满，就从目标队列“窃取”一个或多个工作，实现负载均衡。当然，这种方法也有让人抓狂的地方——如果太频繁地检查其他队列，就会带来较高的开销，可扩展性不好，而这是多队列调度最初的全部目标！相反，如果检查间隔太长，又可能会带来严重的负载不均。找到合适的阈值仍然是黑魔法，这在系统策略设计中很常见。</p>
<h2 id="Linux-多处理器调度"><a href="#Linux-多处理器调度" class="headerlink" title="Linux 多处理器调度"></a>Linux 多处理器调度</h2><p>3种不同的调度程序：O(1)调度程序、完全公平调度程序（CFS）以及BF调度程序（BFS）。</p>
<p>O(1) CFS采用多队列，而BFS采用单队列，这说明两种方法都可以成功。当然它们之间还有很多不同的细节。例如，O(1)调度程序是基于优先级的（类似于之前介绍的MLFQ），随时间推移改变进程的优先级，然后调度最高优先级进程，来实现各种调度目标。交互性得到了特别关注。与之不同，CFS是确定的比例调度方法（类似之前介绍的步长调度）。BFS作为三个算法中唯一采用单队列的算法，也基于比例调度，但采用了更复杂的方案，称为最早最合适虚拟截止时间优先算法（EEVEF）。</p>
<hr>
<h1 id="基于事件的并发（进阶）"><a href="#基于事件的并发（进阶）" class="headerlink" title="基于事件的并发（进阶）"></a>基于事件的并发（进阶）</h1><p>一些基于图形用户界面（GUI）的应用，或某些类型的网络服务器，常常采用另一种并发方式。这种方式称为基于事件的并发（event-based concurrency），在一些现代系统中较为流行，比如node.js，但它源自于C/UNIX系统。</p>
<p>基于事件的并发针对两方面的问题。一方面是多线程应用中，正确处理并发很有难度。正如我们讨论的，忘加锁、死锁和其他烦人的问题会发生。另一方面，开发者无法控制多线程在某一时刻的调度。程序员只是创建了线程，然后就依赖操作系统能够合理地调度线程。要实现一个在各种不同负载下，都能够良好运行的通用调度程序，是极有难度的。因此，某些时候操作系统的调度并不是最优的。</p>
<p><strong>不用线程，同时保证对并发的控制，避免多线程应用中出现的问题，我们应该如何构建一个并发服务器？</strong></p>
<h2 id="基本想法：事件循环"><a href="#基本想法：事件循环" class="headerlink" title="基本想法：事件循环"></a>基本想法：事件循环</h2><p>基本方法就是基于事件的并发（event-based concurrency）。该方法很简单：我们等待某事（即“事件”）发生；当它发生时，检查事件类型，然后做少量的相应工作（可能是I/O请求，或者调度其他事件准备后续处理）。这就好了！</p>
<p>一个典型的基于事件的服务器。这种应用都是基于一个简单的结构，称为事件循环（event loop）。事件循环的伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">events = getEvents();</span><br><span class="line"><span class="keyword">for</span> (e in events)</span><br><span class="line">processEvent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它确实如此简单。主循环等待某些事件发生（通过getEvents()调用），然后依次处理这些发生的事件。处理事件的代码叫作事件处理程序（event handler）。重要的是，处理程序在处理一个事件时，它是系统中发生的唯一活动。因此，调度就是决定接下来处理哪个事件。这种对调度的显式控制，是基于事件方法的一个重要优点。</p>
<h2 id="重要-API：select-（或-poll-）"><a href="#重要-API：select-（或-poll-）" class="headerlink" title="重要 API：select()（或 poll()）"></a>重要 API：select()（或 poll()）</h2><p>这些接口对程序的支持很简单：检查是否有任何应该关注的进入I/O。例如，假定网络应用程序（如We b服务器）希望检查是否有网络数据包已到达，以便为它们提供服务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds,</span></span><br><span class="line"><span class="params">fd_set *<span class="keyword">restrict</span> readfds,</span></span><br><span class="line"><span class="params">fd_set *<span class="keyword">restrict</span> writefds,</span></span><br><span class="line"><span class="params">fd_set *<span class="keyword">restrict</span> errorfds,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>手册页中的实际描述：select()检查I/O描述符集合，它们的地址通过readfds、writefds和errorfds传入，分别查看它们中的某些描述符是否已准备好读取，是否准备好写入，或有异常情况待处理。在每个集合中检查前nfds个描述符，即检查描述符集合中从0到nfds-1的描述符。返回时，select()用给定请求操作准备好的描述符组成的子集替换给定的描述符集合。select()返回所有集合中就绪描述符的总数。</p>
<blockquote>
<p>补充：阻塞与非阻塞接口<br>阻塞（或同步，synchronous）接口在返回给调用者之前完成所有工作。</p>
</blockquote>
<blockquote>
<p>非阻塞（或异步，asynchronous）接口开始一些工作，但立即返回，从而让所有需要完成的工作都在后台完成。</p>
</blockquote>
<blockquote>
<p>通常阻塞调用的主犯是某种I/O。例如，如果一个调用必须从磁盘读取才能完成，它可能会阻塞，等待发送到磁盘的I / O请求返回。</p>
</blockquote>
<blockquote>
<p>非阻塞接口可用于任何类型的编程（例如，使用线程），但在基于事件的方法中非常重要，因为阻塞的调用会阻止所有进展。</p>
</blockquote>
<p>关于select()有几点要注意。首先，请注意，它可以让你检查描述符是否可以读取和写入。前者让服务器确定新数据包已到达并且需要处理，而后者则让服务知道何时可以回复（即出站队列未满）。</p>
<p>超时参数。这里的一个常见用法是将超时设置为NULL，这会导致select()无限期地阻塞，直到某个描述符准备就绪。但是，更健壮的服务器通常会指定某种超时。一种常见的技术是将超时设置为零，因此让调用select()立即返回。</p>
<p>无论哪种方式，<strong>这些基本原语</strong>为我们提供了一种构建非阻塞事件循环的方法，它可以简单地检查传入数据包，从带有消息的套接字中读取数据，并根据需要进行回复。</p>
<h2 id="使用-select"><a href="#使用-select" class="headerlink" title="使用 select()"></a>使用 select()</h2><p>如何使用select()来查看哪些网络描述符在它们上面有传入消息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="number">4</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="number">5</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="number">8</span> <span class="comment">// open and set up a bunch of sockets (not shown)</span></span><br><span class="line"><span class="number">9</span> <span class="comment">// main loop</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="number">11</span> <span class="comment">// initialize the fd_set to all zero</span></span><br><span class="line"><span class="number">12</span> fd_set readFDs;</span><br><span class="line"><span class="number">13</span> FD_ZERO(&amp;readFDs);</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span> <span class="comment">// now set the bits for the descriptors</span></span><br><span class="line"><span class="number">16</span> <span class="comment">// this server is interested in</span></span><br><span class="line"><span class="number">17</span> <span class="comment">// (for simplicity, all of them from min to max)</span></span><br><span class="line"><span class="number">18</span> <span class="type">int</span> fd;</span><br><span class="line"><span class="number">19</span> <span class="keyword">for</span> (fd = minFD; fd &lt; maxFD; fd++)</span><br><span class="line"><span class="number">20</span> FD_SET(fd, &amp;readFDs);</span><br><span class="line"><span class="comment">//使用 FD_SET 宏后，它会将指定的文件描述符 fd 对应的位设置为 1，表示将该文件描述符添加到文件描述符集合中。这意味着程序对该文件描述符对应的资源感兴趣。</span></span><br><span class="line"><span class="comment">//通俗表示文件描述符就是人的身份证，除去默认输出默认输入默认错误等一些预定义的描述符外，可以使用open() socket()等函数为某个文件分配文件描述符。</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> <span class="comment">// do the select</span></span><br><span class="line"><span class="number">23</span> <span class="type">int</span> rc = select(maxFD+<span class="number">1</span>, &amp;readFDs, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span> <span class="comment">// check which actually have data using FD_ISSET()</span></span><br><span class="line"><span class="number">26</span> <span class="type">int</span> fd;</span><br><span class="line"><span class="number">27</span> <span class="keyword">for</span> (fd = minFD; fd &lt; maxFD; fd++)</span><br><span class="line"><span class="number">28</span> <span class="keyword">if</span> (FD_ISSET(fd, &amp;readFDs))</span><br><span class="line"><span class="number">29</span> processFD(fd);</span><br><span class="line"><span class="number">30</span> &#125;</span><br><span class="line"><span class="number">31</span> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“文件描述符”（file descriptor）是一个用于标识和操作文件或套接字的整数值。它是操作系统提供给应用程序的一种机制，用于表示打开的文件、网络套接字等。文件描述符在不同的操作系统和编程语言中有不同的表示方式，通常是一个非负整数。</p>
</blockquote>
<blockquote>
<p>fd_set：是一个数据结构，用于表示一个文件描述符集合。它是一个位图，每个位（bit）对应一个文件描述符。</p>
</blockquote>
<blockquote>
<p>FD_ZERO(&amp;readFDs)：该宏将一个文件描述符集合（如readFDs）清零，即将所有位都设置为0。</p>
</blockquote>
<blockquote>
<p>FD_SET(fd, &amp;readFDs)：该宏将指定文件描述符（如fd）对应的位设置为1，表示对该文件描述符感兴趣。</p>
</blockquote>
<blockquote>
<p>select(maxFD+1, &amp;readFDs, NULL, NULL, NULL)：调用select函数等待文件描述符上的事件。其中，maxFD+1表示需要监视的最大文件描述符值加1；readFDs是一个文件描述符集合，表示需要监视的读事件；后面三个参数分别表示对写事件、异常事件和超时时间的设置。</p>
</blockquote>
<blockquote>
<p>FD_ISSET(fd, &amp;readFDs)：该宏检查指定文件描述符（如fd）对应位是否为1，即该文件描述符是否有数据到达，返回非零值表示有数据到达。</p>
</blockquote>
<p>这些函数和宏都是在C语言的 &lt;sys/select.h&gt; 头文件中定义的。</p>
<h2 id="为何更简单？无须锁"><a href="#为何更简单？无须锁" class="headerlink" title="为何更简单？无须锁"></a>为何更简单？无须锁</h2><p>使用单个CPU和基于事件的应用程序，并发程序中发现的问题不再存在。具体来说，因为一次只处理一个事件，所以不需要获取或释放锁。基于事件的服务器不能被另一个线程中断，因为它确实是单线程的。因此，线程化程序中常见的并发性错误并没有出现在基本的基于事件的方法中。</p>
<h2 id="一个问题：阻塞系统调用"><a href="#一个问题：阻塞系统调用" class="headerlink" title="一个问题：阻塞系统调用"></a>一个问题：阻塞系统调用</h2><p>例如，假定一个请求从客户端进入服务器，要从磁盘读取文件并将其内容返回给发出请求的客户端（很像简单的HTTP请求）。为了处理这样的请求，某些事件处理程序最终将不得不发出open()系统调用来打开文件，然后通过一系列read()调用来读取文件。当文件被读入内存时，服务器可能会开始将结果发送到客户端。open()和read()调用都可能向存储系统发出I/O请求（当所需的元数据或数据不在内存中时），因此可能需要很长时间才能提供服务。使用基于线程的服务器时，这不是问题：在发出I/O请求的线程挂起（等待I/O完成）时，其他线程可以运行，从而使服务器能够取得进展。事实上，I/O和其他计算的自然重叠（overlap）使得基于线程的编程非常自然和直接。但是，使用基于事件的方法时，没有其他线程可以运行：只是主事件循环。这意味着如果一个事件处理程序发出一个阻塞的调用，整个服务器就会这样做：阻塞直到调用完成。当事件循环阻塞时，系统处于闲置状态，因此是潜在的巨大资源浪费。因此，<strong>我们在基于事件的系统中必须遵守一条规则：不允许阻塞调用。</strong></p>
<h2 id="解决方案：异步-I-O"><a href="#解决方案：异步-I-O" class="headerlink" title="解决方案：异步 I/O"></a>解决方案：异步 I/O</h2><p>许多现代操作系统已经引入了新的方法来向磁盘系统发出I/O请求，一般称为异步I/O（asynchronous I/O）。这些接口使应用程序能够发出I/O请求，并在I/O完成之前立即将控制权返回给调用者，另外的接口让应用程序能够确定各种I/O是否已完成。</p>
<h3 id="macOS-X上提供的接口"><a href="#macOS-X上提供的接口" class="headerlink" title="macOS  X上提供的接口"></a>macOS  X上提供的接口</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> &#123;</span></span><br><span class="line"><span class="type">int</span> aio_fildes; <span class="comment">/* File descriptor */</span></span><br><span class="line"><span class="type">off_t</span> aio_offset; <span class="comment">/* File offset */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span> *aio_buf; <span class="comment">/* Location of buffer */</span></span><br><span class="line"><span class="type">size_t</span> aio_nbytes; <span class="comment">/* Length of transfer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要向文件发出异步读取，应用程序应首先用相关信息填充此结构：要读取文件的文件描述符（aio_fildes），文件内的偏移量（ai_offset）以及长度的请求（aio_nbytes），最后是应该复制读取结果的目标内存位置（aio_buf）。</p>
<p>在填充此结构后，应用程序必须发出异步调用来读取文件。在macOS X上，此API就是异步读取（asynchronous read）API：</p>
<p><code>int aio_read(struct aiocb *aiocbp);</code></p>
<p>该调用尝试发出I/O。如果成功，它会立即返回并且应用程序（即基于事件的服务器）可以继续其工作。</p>
<h3 id="如何知道I-O何时完成，并且缓冲区（由aio-buf指向）现在有了请求的数据？"><a href="#如何知道I-O何时完成，并且缓冲区（由aio-buf指向）现在有了请求的数据？" class="headerlink" title="如何知道I/O何时完成，并且缓冲区（由aio buf指向）现在有了请求的数据？"></a>如何知道I/O何时完成，并且缓冲区（由aio buf指向）现在有了请求的数据？</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aio_error</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> aiocb *aiocbp)</span>;</span><br></pre></td></tr></table></figure>
<p>该系统调用检查aiocbp引用的请求是否已完成。如果有，则函数返回成功（用零表示）。如果不是，则返回EINPROGRESS。因此，对于每个未完成的异步I/O，应用程序可以通过调用aio_error()来周期性地轮询（poll）系统，以确定所述I/O是否尚未完成。</p>
<p>检查一个I/O是否已经完成是很痛苦的。,一些系统提供了基于中断（interrupt）的方法。此方法使用UNIX信号（signal）在异步I/O完成时通知应用程序，从而消除了重复询问系统的需要。</p>
<blockquote>
<p>补充：UNIX信号</p>
</blockquote>
<blockquote>
<p>所有现代UNIX变体都有一个称为信号（signal）的巨大而迷人的基础设施。最简单的信号提供了一种与进程进行通信的方式。具体来说，可以将信号传递给应用程序。这样做会让应用程序停止当前的任何工作，开始运行信号处理程序（signal handler），即应用程序中某些处理该信号的代码。完成后，该进程就恢复其先前的行为。</p>
</blockquote>
<blockquote>
<p>每个信号都有一个名称，如HUP（挂断）、INT（中断）、SEGV（段违规）等。例如，当你的程序遇到段违规时，操作系统发送一个SIGSEGV（在信号名称之前加上SIG是很常见的）。如果你的程序配置为捕获该信号，则实际上可以运行一些代码来响应这种错误的程序行为（这可能对调试有用）。当一个信号被发送到一个没有配置处理该信号的进程时，一些默认行为就会生效。对于SEGV来说，这个进程会被杀死。</p>
</blockquote>
<blockquote>
<p>下面一个进入无限循环的简单程序，但首先设置一个信号处理程序来捕捉SIGHUP：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;stop wakin&#x27; me up...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">signal(SIGHUP, handle);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">; <span class="comment">// doin&#x27; nothin&#x27; except catchin&#x27; some sigs</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你可以用 kill 命令行工具向其发送信号（是的，这是一个奇怪而富有攻击性的名称）。这样做会中断程序中的主 while 循环并运行处理程序代码 handle()：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prompt&gt; ./main &amp;</span><br><span class="line">[<span class="number">3</span>] <span class="number">36705</span></span><br><span class="line">prompt&gt; kill -HUP <span class="number">36705</span></span><br><span class="line">stop wakin<span class="number">&#x27;</span> me up...</span><br><span class="line">prompt&gt; kill -HUP <span class="number">36705</span></span><br><span class="line">stop wakin<span class="number">&#x27;</span> me up...</span><br><span class="line">prompt&gt; kill -HUP <span class="number">36705</span></span><br><span class="line">stop wakin<span class="number">&#x27;</span> me up...</span><br></pre></td></tr></table></figure>

<p>在没有异步 I/O 的系统中，纯基于事件的方法无法实现。</p>
<p><strong>但是Pai等人使用事件处理网络数据包的混合方法，并且使用线程池来管理未完成的I/O。</strong></p>
<h2 id="另一个问题：状态管理"><a href="#另一个问题：状态管理" class="headerlink" title="另一个问题：状态管理"></a>另一个问题：状态管理</h2><p>当事件处理程序发出异步I/O时，它必须打包一些程序状态，以便下一个事件处理程序在I/O最终完成时使用。这个额外的工作在基于线程的程序中是不需要的，因为程序需要的状态在线程栈中。</p>
<p>在这个例子中，一个基于线程的服务器需要从文件描述符（fd）中读取数据，一旦完成，将从文件中读取的数据写入网络套接字描述符SD）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rc = read(fd, buffer, size);  </span><br><span class="line">rc = write(sd, buffer, size);</span><br></pre></td></tr></table></figure>
<p>在一个多线程程序中，做这种工作很容易。当read()最终返回时，代码立即知道要写入哪个套接字，因为该信息位于线程堆栈中（在变量sd中）。</p>
<p>在基于事件的系统中，,基本上，在某些数据结构中，记录完成处理该事件需要的信息。当事件发生时（即磁盘I/O完成时），查找所需信息并处理事件。在这个特定例子中，解决方案是将套接字描述符（sd）记录在由文件描述符（fd）索引的某种数据结构（例如，散列表）中。当磁盘I/O完成时，事件处理程序将使用文件描述符来查找延续，这会将套接字描述符的值返回给调用者。此时（最后），服务器可以完成最后的工作将数据写入套接字。</p>
<h2 id="什么事情仍然很难"><a href="#什么事情仍然很难" class="headerlink" title="什么事情仍然很难"></a>什么事情仍然很难</h2><p>为了利用多个CPU，事件服务器必须并行运行多个事件处理程序。发生这种情况时，就会出现常见的同步问题（例如临界区），并且必须采用通常的解决方案（例如锁定）。因此，在现代多核系统上，无锁的简单事件处理已不再可能。</p>
]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统导论-并发</title>
    <url>/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="并发-介绍"><a href="#并发-介绍" class="headerlink" title="并发:介绍"></a>并发:介绍</h1><p>经典观点是一个程序只有一个执行点（一个程序计数器，用来存放要执行的指令），但多线程（multi-threaded）程序会有多个执行点（多个程序计数器，每个都用于取指令和执行）。<strong>每个线程类似于独立的进程，只有一点区别：它们共享地址空间，从而能够访问相同的数据。</strong></p>
<p>单个线程的状态与进程状态非常类似。线程有一个程序计数器（PC），记录程序从哪里获取指令。每个线程有自己的一组用于计算的寄存器。所以，如果有两个线程运行在一个处理器上，<strong>从运行一个线程（T1）切换到另一个线程（T2）时，必定发生上下文切换（context switch）</strong>。线程之间的上下文切换类似于进程间的上下文切换。<strong>对于进程，我们将状态保存到进程控制块（Process Control Block，PCB）。现在，我们需要一个或多个线程控制块（Thread Control Block，TCB）</strong>，保存每个线程的状态。但是，<strong>与进程相比，线程之间的上下文切换有一点主要区别：地址空间保持不变（即不需要切换当前使用的页表</strong>）。</p>
<p>线程和进程之间的另一个主要区别在于栈。在简单的传统进程地址空间模型 [我们现在可以称之为单线程（single-threaded）进程] 中，只有一个栈，通常位于地址空间的底部。<br><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/q1.png" alt="?"><br>然而，在多线程的进程中，每个线程独立运行，当然可以调用各种例程来完成正在执行的任何工作。不是地址空间中只有一个栈，而是每个线程都有一个栈。</p>
<h2 id="实例：线程创建"><a href="#实例：线程创建" class="headerlink" title="实例：线程创建"></a>实例：线程创建</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mythread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *) arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="type">pthread_t</span> p1, p2;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: begin\n&quot;</span>);</span><br><span class="line">    rc = pthread_create(&amp;p1, <span class="literal">NULL</span>, mythread, <span class="string">&quot;A&quot;</span>); assert(rc == <span class="number">0</span>);</span><br><span class="line">    rc = pthread_create(&amp;p2, <span class="literal">NULL</span>, mythread, <span class="string">&quot;B&quot;</span>); assert(rc == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// join waits for the threads to finish</span></span><br><span class="line">    rc = pthread_join(p1, <span class="literal">NULL</span>); assert(rc == <span class="number">0</span>);</span><br><span class="line">    rc = pthread_join(p2, <span class="literal">NULL</span>); assert(rc == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/q2.png" alt="?"><br><strong>这种排序不是唯一可能的顺序。实际上，给定一系列指令，有很多可能的<br>顺序，这取决于调度程序决定在给定时刻运行哪个线程。</strong><br><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/q3.png" alt="?"></p>
<p><strong>即使先前创建了线程 1，如果调度程序决定先运行线程 2，没有理由认为先创建的线程先运行。</strong><br><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/q4.png" alt="?"></p>
<h2 id="核心问题：不可控的调度"><a href="#核心问题：不可控的调度" class="headerlink" title="核心问题：不可控的调度"></a>核心问题：不可控的调度</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 0x8049a1c, %eax</span><br><span class="line">add $0x1, %eax</span><br><span class="line">mov %eax, 0x8049a1c</span><br></pre></td></tr></table></figure>
<p>变量 counter 位于地址 0x8049a1c。在这 3 条指令中，先用 x86 的 mov指令，从内存地址处取出值，放入 eax。然后，给 eax 寄存器的值加 1（0x1）。最后，eax的值被存回内存中相同的地址。</p>
<p>设想我们的两个线程之一（线程 1）进入这个代码区域，并且因此将要增加一个计数器。它将 counter 的值（假设它这时是 50）加载到它的寄存器 eax 中。因此，线程 1 的 eax = 50。然后它向寄存器加 1，因此 eax = 51。现在，一件不幸的事情发生了：<strong>时钟中断发生。因此，操作系统将当前正在运行的线程（它的程序计数器、寄存器，包括 eax 等）的状态保存到线程的 TCB。</strong></p>
<p>现在更糟的事发生了：线程 2 被选中运行，并进入同一段代码。它也执行了第一条指令，获取计数器的值并将其放入其 eax 中 [<strong>请记住：运行时每个线程都有自己的专用寄存器。上下文切换代码将寄存器虚拟化（virtualized），保存并恢复它们的值</strong>]。此时 counter 的值仍为 50，因此线程 2 的 eax = 50。假设线程 2 执行接下来的两条指令，将 eax 递增 1（因此 eax= 51），然后将 eax 的内容保存到 counter（地址 0x8049a1c）中。因此，全局变量 counter 现在的值是 51。</p>
<p>最后，又发生一次上下文切换，线程 1 恢复运行。还记得它已经执行过 mov 和 add 指令，现在准备执行最后一条 mov 指令。回忆一下，eax=51。因此，最后的 mov 指令执行，将值保存到内存，counter 再次被设置为 51。</p>
<p>简单来说，发生的情况是：增加 counter 的代码被执行两次，初始值为 50，但是结果为51。这个程序的“正确”版本应该导致变量 counter 等于 52。</p>
<p><strong>由于执行这段代码的多个线程可能导致竞争状态，因此我们将此段代码称为临界区（critical section）。临界区是访问共享变量（或更一般地说，共享资源）的代码片段，一定不能由多个线程同时执行。</strong><br><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/q6.png" alt="?"></p>
<p><strong>我们真正想要的代码就是所谓的互斥（mutual exclusion）。这个属性保证了如果一个线程在临界区内执行，其他线程将被阻止进入临界区。</strong></p>
<h2 id="原子性愿望"><a href="#原子性愿望" class="headerlink" title="原子性愿望"></a>原子性愿望</h2><p>原子方式的意思是“作为一个单元”,当指令执行时，它会像期望那样执行更新。它不能在指令中间中断，因为这正是我们从硬件获得的保证：发生中断时，指令根本没有运行，或者运行完成，没有中间状态。</p>
<p>如果有一条指令来做到这一点，我们可以发出这条指令然后完事。但在一般情况下，不会有这样的指令。</p>
<p>因此，我们要做的是要求硬件提供一些有用的指令，可以在这些指令上构建一个通用的集合，即所谓的同步原语（synchronization primitive）。通过使用这些硬件同步原语，加上操作系统的一些帮助，我们将能够构建多线程代码，以同步和受控的方式访问临界区，从而可靠地产生正确的结果</p>
<h3 id="补充：关键并发术语"><a href="#补充：关键并发术语" class="headerlink" title="补充：关键并发术语"></a>补充：关键并发术语</h3><blockquote>
<p><strong>临界区、竞态条件、不确定性、互斥执行</strong></p>
</blockquote>
<blockquote>
<p><strong>临界区（critical section）是访问共享资源的一段代码，资源通常是一个变量或数据结构。</strong></p>
</blockquote>
<blockquote>
<p><strong>竞态条件（race condition）出现在多个执行线程大致同时进入临界区时，它们都试图更新共享的数据结构，导致了令人惊讶的（也许是不希望的）结果。</strong></p>
</blockquote>
<blockquote>
<p><strong>不确定性（indeterminate）程序由一个或多个竞态条件组成，程序的输出因运行而异，具体取决于哪些线程在何时运行。这导致结果不是确定的（deterministic），而我们通常期望计算机系统给出确定的结果。</strong></p>
</blockquote>
<blockquote>
<p><strong>为了避免这些问题，线程应该使用某种互斥（mutual exclusion）原语。这样做可以保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的程序输出。</strong></p>
</blockquote>
<h2 id="还有一个问题：等待另一个线程"><a href="#还有一个问题：等待另一个线程" class="headerlink" title="还有一个问题：等待另一个线程"></a>还有一个问题：等待另一个线程</h2><p>线程之间有一种交互，即<strong>访问共享变量</strong>，因此需要为临界区支持原子性。事实证明，还有另一种常见的交互，即<strong>一个线程在继续之前必须等待另一个线程完成某些操作</strong>。例如，当进程执行磁盘 I/O 并进入睡眠状态时，会产生这种交互。当 I/O 完成时，该进程需要从睡眠中唤醒，以便继续进行。</p>
<hr>
<h1 id="插叙：线程API"><a href="#插叙：线程API" class="headerlink" title="插叙：线程API"></a>插叙：线程API</h1><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pthread_create</span><span class="params">( </span></span><br><span class="line"><span class="params">    <span class="type">pthread_t</span> * thread,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">pthread_attr_t</span> * attr,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> * (*start_routine)(<span class="type">void</span>*),</span></span><br><span class="line"><span class="params">    <span class="type">void</span> * arg</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数 thread 是指向 pthread_t 结构类型的指针，我们将利用这个结构与该线程交互，因此需要将它传入pthread_create()，以便将它初始化。</p>
<p>第二个参数 attr 用于指定该线程可能具有的任何属性。一些例子包括设置栈大小，或关于该线程调度优先级的信息。一个属性通过单独调用 pthread_attr_init()来初始化。在大多数情况下，默认值就行。在这个例子中，我们只需传入 NULL。</p>
<p>第三个参数最复杂，但它实际上只是问：这个线程应该在哪个函数中运行？在 C 中，我们把它称为一个函数指针（function pointer），这个指针告诉我们需要以下内容：一个函数名称（start_routine），它被传入一个类型为 void *的参数（start_routine 后面的括号表明了这一点），并且它返回一个 void *类型的值（即一个 void 指针）。</p>
<p>最后，第四个参数 arg 就是要传递给线程开始执行的函数的参数。你可能会问：为什么我们需要这些 void 指针？好吧，答案很简单：将 void 指针作为函数的参数 start_routine，允许我们传入任何类型的参数，将它作为返回值，允许线程返回任何类型的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">myarg_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125; <span class="type">myarg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mythread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">myarg_t</span> *m = (<span class="type">myarg_t</span> *) arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, m-&gt;a, m-&gt;b);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span></span><br><span class="line"> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="type">myarg_t</span> args;</span><br><span class="line">    args.a = <span class="number">10</span>;</span><br><span class="line">    args.b = <span class="number">20</span>;</span><br><span class="line">    rc = pthread_create(&amp;p, <span class="literal">NULL</span>, mythread, &amp;args);</span><br><span class="line">    ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程完成"><a href="#线程完成" class="headerlink" title="线程完成"></a>线程完成</h2><p>如果你想等待线程完成,你必须调用函数 pthread_join()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> ** retval)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数有两个参数。第一个是 pthread_t 类型，用于指定要等待的线程。这个变量是由线程创建函数初始化的（当你将一个指针作为参数传递给 pthread_create()时）。如果你保留了它，就可以用它来等待该线程终止。</p>
<p>第二个参数是一个指针，指向你希望得到的返回值。因为函数可以返回任何东西，所以它被定义为返回一个指向 void 的指针。因为 pthread_join()函数改变了传入参数的值，所以你需要传入一个指向该值的指针，而不只是该值本身。</p>
<p><strong>gcc -o test1 test1.c  -pthread</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">myarg_t</span> &#123;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125; <span class="type">myarg_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">myret_t</span> &#123;</span></span><br><span class="line"> <span class="type">int</span> x;</span><br><span class="line"> <span class="type">int</span> y;</span><br><span class="line"> &#125; <span class="type">myret_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> *<span class="title function_">mythread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"> <span class="type">myarg_t</span> *m = (<span class="type">myarg_t</span> *) arg;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, m-&gt;a, m-&gt;b);</span><br><span class="line"> <span class="type">myret_t</span> *r = Malloc(<span class="keyword">sizeof</span>(<span class="type">myret_t</span>));</span><br><span class="line"> r-&gt;x = <span class="number">1</span>;</span><br><span class="line"> r-&gt;y = <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">return</span> (<span class="type">void</span> *) r;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span></span><br><span class="line"> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> rc;</span><br><span class="line"> <span class="type">pthread_t</span> p;</span><br><span class="line"> <span class="type">myret_t</span> *m;</span><br><span class="line"></span><br><span class="line"> <span class="type">myarg_t</span> args;</span><br><span class="line"> args.a = <span class="number">10</span>;</span><br><span class="line"> args.b = <span class="number">20</span>;</span><br><span class="line"> Pthread_create(&amp;p, <span class="literal">NULL</span>, mythread, &amp;args);</span><br><span class="line"> Pthread_join(p, (<span class="type">void</span> **) &amp;m);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;returned %d %d\n&quot;</span>, m-&gt;x, m-&gt;y);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们应该注注，并非所有多线程代码都使用 join 函数。例如，多线程 Web 服务器可能会创建大量工作线程，然后使用主线程接受请求，并将其无限期地传递给工作线程。因此这样的长期程序可能不需要 join。然而，创建线程来（并行）执行特定任务的并行程序，很可能会使用 join 来确保在退出或进入下一阶段计算之前完成所有这些工作。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>除了线程创建和 join 之外，POSIX 线程库提供的最有用的函数集，可能是通过锁（lock）来提供互斥进入临界区的那些函数。这方面最基本的一对函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>有一段代码是一个临界区，就需要通过锁来保护，以便像需要的那样运行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">x = x + <span class="number">1</span>; <span class="comment">// or whatever your critical section is</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>第一个问题是缺乏正确的初始化（lack of proper initialization）。所有锁必须正确初始化，以确保它们具有正确的值，并在锁和解锁被调用时按照需要工作。</strong></li>
</ol>
<p>对于 POSIX 线程，有两种方法来初始化锁。一种方法是使用 PTHREAD_MUTEX_INITIALIZER，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>

<p>这样做会将锁设置为默认值，从而使锁可用。初始化的动态方法（即在运行时）是调用 pthread_mutex_init()，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rc = pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">assert(rc == <span class="number">0</span>); <span class="comment">// always check success!</span></span><br></pre></td></tr></table></figure>
<p>用完锁时，还应该相应地调用 pthread_mutex_destroy()</p>
<ol start="2">
<li><strong>上述代码的第二个问题是在调用获取锁和释放锁时没有检查错误代码。</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use this to keep your code clean but check for failures</span></span><br><span class="line"><span class="comment">// Only use if exiting program is OK upon failure</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span> &#123;</span><br><span class="line"><span class="type">int</span> rc = pthread_mutex_lock(mutex);</span><br><span class="line">assert(rc == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取锁和释放锁函数不是 pthread 与锁进行交互的仅有的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_timedlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure>
<p>这两个调用用于获取锁。如果锁已被占用，则 trylock 版本将失败。获取锁的 timedlock定版本会在超时或获取锁后返回，以先发生者为准。因此，具有零超时的 timedlock 退化为trylock 的情况。通常应避免使用这两种版本，但有些情况下，避免卡在（可能无限期的）获取锁的函数中会很有用。</p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>当线程之间必须发生某种信号时，如果一个线程在等待另一个线程继续执行某些操作，条件变量就很有用。希望以这种方式进行交互的程序使用两个主要函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure>

<p>要使用条件变量，必须另外有一个与此条件相关的锁。在调用上述任何一个函数时，应该持有这个锁。</p>
<p>第一个函数 pthread_cond_wait()使调用线程进入休眠状态，因此等待其他线程发出信号，通常当程序中的某些内容发生变化时，现在正在休眠的线程可能会关心它。典型的用法如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">Pthread_mutex_lock(&amp;lock);</span><br><span class="line"><span class="keyword">while</span> (ready == <span class="number">0</span>)</span><br><span class="line">    Pthread_cond_wait(&amp;cond, &amp;lock);</span><br><span class="line">Pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>
<p>在这段代码中，在初始化相关的锁和条件之后，一个线程检查变量 ready 是否已经被设置为零以外的值。如果没有，那么线程只是简单地调用等待函数以便休眠，直到其他线程唤醒它。</p>
<p>唤醒线程的代码运行在另外某个线程中，像下面这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pthread_mutex_lock(&amp;lock);</span><br><span class="line">ready = <span class="number">1</span>;</span><br><span class="line">Pthread_cond_signal(&amp;cond);</span><br><span class="line">Pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>

<p>首先，在发出信号时（以及修改全局变量 ready 时），我们始终确保持有锁。这确保我们不会在代码中注外引入竞态条件。</p>
<p>等待调用将锁作为其第二个参数，而信号调用仅需要一个条件。造成这种差异的原因在于，<strong>等待调用除了使调用线程进入睡眠状态外，还会让调用者睡眠时释放锁</strong>。想象一下，如果不是这样：其他线程如何获得锁并将其唤醒？但是，在被唤醒之后返回之前，pthread_cond_wait()会重新获取该锁，从而确保等待线程在等待序列开始时获取锁与结束时释放锁之间运行的任何时间，它持有锁。</p>
<h2 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h2><p>本章所有代码很容易运行。代码需要包括头文件 pthread.h 才能编译。链接时需要 pthread库，增加-pthread 标记。<br>例如，要编译一个简单的多线程程序，只需像下面这样做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o main main.c -Wall -pthread</span><br></pre></td></tr></table></figure>


<blockquote>
<p>补充：线程 API 指导<br>当你使用 POSIX 线程库（或者实际上，任何线程库）来构建多线程程序时，需要记住一些小而重要的事情：</p>
</blockquote>
<blockquote>
<p>保持简洁。最重要的一点，线程之间的锁和信号的代码应该尽可能简洁。复杂的线程交互容易产生缺陷。</p>
</blockquote>
<blockquote>
<p>让线程交互减到最少。尽量减少线程之间的交互。每次交互都应该想清楚，并用验证过的、正确的方法来实现（很多方法会在后续章节中学习）。</p>
</blockquote>
<blockquote>
<p>初始化锁和条件变量。未初始化的代码有时工作正常，有时失败，会产生奇怪的结果。</p>
</blockquote>
<blockquote>
<p>检查返回值。当然，任何 C 和 UNIX 的程序，都应该检查返回值，这里也是一样。否则会导致古怪而难以理解的行为，让你尖叫，或者痛苦地揪自己的头发。</p>
</blockquote>
<blockquote>
<p>注意传给线程的参数和返回值。具体来说，如果传递在栈上分配的变量的引用，可能就是在犯错误。</p>
</blockquote>
<blockquote>
<p>每个线程都有自己的栈。类似于上一条，记住每一个线程都有自己的栈。因此，线程局部变量应该是线程私有的，其他线程不应该访问。线程之间共享数据，值要在堆（heap）或者其他全局可访问的位置。</p>
</blockquote>
<blockquote>
<p>线程之间总是通过条件变量发送信号。切记不要用标记变量来同步。</p>
</blockquote>
<hr>
<h1 id="锁-1"><a href="#锁-1" class="headerlink" title="锁"></a>锁</h1><p>我们希望原子式执行一系列指令，但由于单处理器上的中断（或者多个线程在多处理器上并发执行），我们做不到。</p>
<p>程序员在源代码中加锁，放在临界区周围，保证临界区能够像单条原子指令一样执行。</p>
<h2 id="锁的基本思想"><a href="#锁的基本思想" class="headerlink" title="锁的基本思想"></a>锁的基本思想</h2><p>多个线程同时共享的资源——临界区:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">balance = balance + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>加锁:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">lock_t</span> mutex; <span class="comment">// some globally-allocated lock &#x27;mutex&#x27;</span></span><br><span class="line">...</span><br><span class="line">lock(&amp;mutex);</span><br><span class="line">balance = balance + <span class="number">1</span>;</span><br><span class="line">unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>锁就是一个变量，因此我们需要声明一个某种类型的锁变量,才能使用。这个锁变量（简称锁）保存了锁在某一时刻的状态。它要么是可用的（available，或 unlocked，或 free），表示没有线程持有锁，要么是被占用的（acquired，或 locked，或 held），表示有一个线程持有锁，正处于临界区。</p>
<p>ock()和 unlock()函数的语义很简单。调用 lock()尝试获取锁，如果没有其他线程持有锁（即它是可用的），该线程会获得锁，进入临界区。这个线程有时被称为锁的持有者（owner）。</p>
<p>如果另外一个线程对相同的锁变量（本例中的 mutex）调用 lock()，因为锁被另一线程持有，该调用不会返回。这样，当持有锁的线程在临界区时，其他线程就无法进入临界区。</p>
<p>锁的持有者一旦调用 unlock()，锁就变成可用了。如果没有其他等待线程（即没有其他线程调用过 lock()并卡在那里），锁的状态就变成可用了。如果有等待线程（卡在 lock()里），其中一个会（最终）注意到（或收到通知）锁状态的变化，获取该锁，进入临界区。</p>
<h2 id="Pthread-锁"><a href="#Pthread-锁" class="headerlink" title="Pthread 锁"></a>Pthread 锁</h2><p>POSIX 库将锁称为互斥量（mutex），因为它被用来提供线程之间的互斥。</p>
<p>下面的POSIX 线程代码，应该理解它和上面的代码段执行相同的任务</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> Pthread_mutex_lock(&amp;lock); <span class="comment">// wrapper for pthread_mutex_lock()</span></span><br><span class="line"><span class="number">4</span> balance = balance + <span class="number">1</span>;</span><br><span class="line"><span class="number">5</span> Pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>

<p>POSIX 的 lock 和 unlock 函数会传入一个变量，因为我们可能用不<br>同的锁来保护不同的变量。这样可以增加并发。</p>
<h2 id="实现一个锁"><a href="#实现一个锁" class="headerlink" title="实现一个锁"></a>实现一个锁</h2><p>我们需要硬件和操作系统的帮助来实现一个可用的锁。近些年来，各种计算机体系结构的指令集都增加了一些不同的硬件原语。</p>
<h2 id="评价锁"><a href="#评价锁" class="headerlink" title="评价锁"></a>评价锁</h2><p>最基本的，锁是否有效，能够阻止多个线程进入临界区？<br>当锁可用时，是否每一个竞争线程有公平的机会抢到锁？<br>最后是性能（performance），具体来说，是使用锁之后增加的时间开销。</p>
<h2 id="控制中断"><a href="#控制中断" class="headerlink" title="控制中断"></a>控制中断</h2><p>最早提供的互斥解决方案之一，就是在临界区关闭中断。这个解决方案是为单处理器系统开发的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">2</span> DisableInterrupts();</span><br><span class="line"><span class="number">3</span> &#125;</span><br><span class="line"><span class="number">4</span> <span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">5</span> EnableInterrupts();</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这种方法要求我们允许所有调用线程执行特权操作（打开关闭中断），即信任这种机制不会被滥用。</strong></p>
<p><strong>缺点：</strong><br>第一，一个贪婪的程序可能在它开始时就调用 lock()，从而独占处理器。更糟的情况是，恶意程序调用 lock()后，一直死循环。后一种情况，系统无法重新获得控制，只能重启系统。关闭中断对应用要求太多，不太适合作为通用的同步解决方案。</p>
<p>第二，这种方案不支持多处理器。如果多个线程运行在不同的 CPU 上，每个线程都试图进入同一个临界区，关闭中断也没有作用。线程可以运行在其他处理器上，因此能够进入临界区。多处理器已经很普遍了，我们的通用解决方案需要更好一些。</p>
<p>第三，关闭中断导致中断丢失，可能会导致严重的系统问题。假如磁盘设备完成了读取请求，但 CPU 错失了这一事实，那么，操作系统如何知道去唤醒等待读取的进程？</p>
<p>最后一个不太重要的原因就是效率低。与正常指令执行相比，现代 CPU 对于关闭和打开中断的代码执行得较慢。</p>
<p>load 和 store（早期的硬件上，它们是原子的）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flag[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> turn;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">flag[<span class="number">0</span>] = flag[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 1-&gt;thread wants to grab lock</span></span><br><span class="line">turn = <span class="number">0</span>; <span class="comment">// whose turn? (thread 0 or 1?)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">flag[self] = <span class="number">1</span>; <span class="comment">// self: thread ID of caller</span></span><br><span class="line">turn = <span class="number">1</span> - self; <span class="comment">// make it other thread&#x27;s turn</span></span><br><span class="line"><span class="keyword">while</span> ((flag[<span class="number">1</span>-self] == <span class="number">1</span>) &amp;&amp; (turn == <span class="number">1</span> - self))</span><br><span class="line">; <span class="comment">// spin-wait</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">flag[self] = <span class="number">0</span>; <span class="comment">// simply undo your intent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>情况1：线程0想锁，线程1不想<br>lock函数内：flag[0]=1，turn=1<br>进入循环：flag[1]≠1，突破循环，成功锁上。</p>
</blockquote>
<blockquote>
<p>情况2：线程0，1都想锁<br>lock函数内，flag[0]=1，flag[1]=1，0、1进程肯定有一个先执行，0先时turn=1，进入循环，第二个条件满足，锁住。此时1执行到turn=0，进入循环条件满足，卡住，但是此时turn=0不满足0线程的循环条件，0线程突破。</p>
</blockquote>
<blockquote>
<p>情况3：线程0锁住将要解锁，线程1循环卡住<br>线程0解锁将flag=0，线程1不满足第一个条件，突破循环获得锁。</p>
</blockquote>
<blockquote>
<p><strong>turn变量在两个线程竞争锁时起到了让给对方的作用。flag是在判断另一个线程是否也想要获取锁</strong></p>
</blockquote>
<h2 id="测试并设置指令（原子交换）"><a href="#测试并设置指令（原子交换）" class="headerlink" title="测试并设置指令（原子交换）"></a>测试并设置指令（原子交换）</h2><p>因为关闭中断的方法无法工作在多处理器上，所以系统设计者开始让硬件支持锁。</p>
<p>最简单的硬件支持是测试并设置指令（test-and-set instruction），也叫作原子交换（atomic exchange）。</p>
<p>我们首先实现一个不依赖它的锁，用一个变量标记锁是否被持有。<br>在第一次尝试中，想法很简单：用一个变量来标志锁是否被某些线程占用。<br>第一个线程进入临界区，调用 lock()，检查标志是否为 1（这里不是 1），然后设置标志为 1，表明线程持有该锁。结束临界区时，线程调用 unlock()，清除标志，表示锁未被持有。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span> <span class="type">int</span> flag; &#125; <span class="type">lock_t</span>;</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123;</span><br><span class="line"><span class="number">4</span> <span class="comment">// 0 -&gt; lock is available, 1 -&gt; held</span></span><br><span class="line"><span class="number">5</span> mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line"><span class="number">6</span> &#125;</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span> <span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123;</span><br><span class="line"><span class="number">9</span> <span class="keyword">while</span> (mutex-&gt;flag == <span class="number">1</span>) <span class="comment">// TEST the flag</span></span><br><span class="line"><span class="number">10</span> ; <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line"><span class="number">11</span> mutex-&gt;flag = <span class="number">1</span>; <span class="comment">// now SET it!</span></span><br><span class="line"><span class="number">12</span> &#125;</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> <span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123;</span><br><span class="line"><span class="number">15</span> mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line"><span class="number">16</span> &#125;</span><br></pre></td></tr></table></figure>
<p>当第一个线程正处于临界区时，如果另一个线程调用 lock()，它会在 while 循环中自旋等待（spin-wait)，直到第一个线程调用 unlock()清空标志。然后等待的线程会退出 while 循环，设置标志，执行临界区代码。<br><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/q7.png" alt="?"><br><strong>在没有设置flag之前发生中断另一个线程也到达这一步</strong><br>通过适时的中断，我们很容易构造出两个线程都将标志设置为 1，都能进入临界区的场景。这种行为就是专家所说的“不好”，我们显然没有满足最基本的要求：互斥。</p>
<p>性能问题（稍后会有更多讨论）主要是线程在等待已经被持有的锁时，采用了自旋等待（spin-waiting）的技术，就是不停地检查标志的值。</p>
<h2 id="实现可用的自旋锁"><a href="#实现可用的自旋锁" class="headerlink" title="实现可用的自旋锁"></a>实现可用的自旋锁</h2><p><strong>尽管上面例子的想法很好，但没有硬件的支持是无法实现的(没办法保证用于互斥的语句为原子操作不可打断)。</strong><br>在 SPARC上，这个指令叫 ldstub（load/store unsigned byte，加载/保存无符号字节）；<br>在 x86 上，是 xchg（atomic exchange，原子交换）指令。但它们基本上在不同的平台上做同样的事，通常称为测试并设置指令（test-and-set）。</p>
<p><strong>将测试（test 旧的锁值）和设置（set 新的值）合并为一个原子操作之后，我们保证了只有一个线程能获取锁。这就实现了一个有效的互斥原语！</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">int</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">int</span> *old_ptr, <span class="type">int</span> new)</span> &#123;</span><br><span class="line"><span class="number">2</span> <span class="type">int</span> old = *old_ptr; <span class="comment">// fetch old value at old_ptr</span></span><br><span class="line"><span class="number">3</span> *old_ptr = new; <span class="comment">// store &#x27;new&#x27; into old_ptr</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">return</span> old; <span class="comment">// return the old value</span></span><br><span class="line"><span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure>
<p>它返回 old_ptr 指向的旧值，同时更新为 new 的新值。<br>当然，关键是这些代码是原子地（atomically）执行。因为既可以测试旧值，又可以设置新值，所以我们把这条指令叫作“测试并设置”。这一条指令完全可以实现一个简单的自旋锁（spin lock）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> flag;</span><br><span class="line"><span class="number">3</span> &#125; <span class="type">lock_t</span>;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line"><span class="number">6</span> <span class="comment">// 0 indicates that lock is available, 1 that it is held</span></span><br><span class="line"><span class="number">7</span> lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line"><span class="number">8</span> &#125;</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line"><span class="number">11</span> <span class="keyword">while</span> (TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line"><span class="number">12</span> ; <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line"><span class="number">13</span> &#125;</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span> <span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line"><span class="number">16</span> lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line"><span class="number">17</span> &#125;</span><br></pre></td></tr></table></figure>
<p>第二种场景是，当某一个线程已经持有锁（即 flag 为 1）。本线程调用 lock()，然后调用TestAndSet(flag, 1)，这一次返回 1。只要另一个线程一直持有锁，TestAndSet()会重复返回 1，本线程会一直自旋。当 flag 终于被改为 0，本线程会调用 TestAndSet()，返回 0 并且原子地设置为 1，从而获得锁，进入临界区。</p>
<p>在单处理器上，需要抢占式的调度器（preemptive scheduler，即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</p>
<h2 id="评价自旋锁"><a href="#评价自旋锁" class="headerlink" title="评价自旋锁"></a>评价自旋锁</h2><p>自旋锁一次只允许一个线程进入临界区。因此，这是正确的锁。</p>
<p>自旋的线程在竞争条件下可能会永远自旋。自旋锁没有公平性，可能会导致饿死。</p>
<p>在单 CPU 的情况下，性能开销相当大。假设一个线程持有锁进入临界区时被抢占。调度器可能会运行其他每一个线程（假设有 N−1 个这种线程）。而其他线程都在竞争锁，都会在放弃 CPU 之前，自旋一个时间片，浪费 CPU 周期。<br>但是，在多 CPU 上，自旋锁性能不错（如果线程数大致等于 CPU 数）。假设线程 A 在CPU 1，线程 B 在 CPU 2 竞争同一个锁。线程 A（CPU 1）占有锁时，线程 B 竞争锁就会自旋（在 CPU 2 上）。然而，临界区一般都很短，因此很快锁就可用，然后线程 B 获得锁。自旋等待其他处理器上的锁，并没有浪费很多 CPU 周期，因此效果不错。</p>
<h2 id="比较并交换"><a href="#比较并交换" class="headerlink" title="比较并交换"></a>比较并交换</h2><p>某些系统提供了另一个硬件原语，即比较并交换指令（SPARC 系统中是 compare-and-swap，x86 系统是 compare-and-exchange）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">int</span> <span class="title function_">CompareAndSwap</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> expected, <span class="type">int</span> new)</span> &#123;</span><br><span class="line"><span class="number">2</span> <span class="type">int</span> actual = *ptr;</span><br><span class="line"><span class="number">3</span> <span class="keyword">if</span> (actual == expected)</span><br><span class="line"><span class="number">4</span> *ptr = new;</span><br><span class="line"><span class="number">5</span> <span class="keyword">return</span> actual;</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure>
<p>比较并交换的基本思路是检测 ptr 指向的值是否和 expected 相等；如果是，更新 ptr 所指的值为新值。否则，什么也不做。不论哪种情况，都返回该内存地址的实际值，让调用者能够知道执行是否成功。</p>
<p>我们只要用下面的代码替换 lock()函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line"><span class="number">2</span> <span class="keyword">while</span> (CompareAndSwap(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line"><span class="number">3</span> ; <span class="comment">// spin</span></span><br><span class="line"><span class="number">4</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="链接的加载和条件式存储指令"><a href="#链接的加载和条件式存储指令" class="headerlink" title="链接的加载和条件式存储指令"></a>链接的加载和条件式存储指令</h2><p>一些平台提供了实现临界区的一对指令。例如 MIPS 架构[H93]中，链接的加载（load-linked）和条件式存储（store-conditional）可以用来配合使用，实现其他并发结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">int</span> <span class="title function_">LoadLinked</span><span class="params">(<span class="type">int</span> *ptr)</span> &#123;</span><br><span class="line"><span class="number">2</span> <span class="keyword">return</span> *ptr;</span><br><span class="line"><span class="number">3</span> &#125;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="type">int</span> <span class="title function_">StoreConditional</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="number">6</span> <span class="keyword">if</span> (no one has updated *ptr since the LoadLinked to this address) &#123;</span><br><span class="line">    <span class="number">7</span> *ptr = value;</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// success!</span></span><br><span class="line"><span class="number">9</span> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// failed to update</span></span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure>
<p>链接的加载指令和典型加载指令类似，都是从内存中取出值存入一个寄存器。关键区别来自条件式存储（store-conditional）指令，只有上一次加载的地址在期间都没有更新时，才会成功，（同时更新刚才链接的加载的地址的值）。成功时，条件存储返回 1，并将 ptr 指的值更新为 value。失败时，返回 0，并且不会更新值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line"><span class="number">2</span> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="number">3</span> <span class="keyword">while</span> (LoadLinked(&amp;lock-&gt;flag) == <span class="number">1</span>)</span><br><span class="line"><span class="number">4</span> ; <span class="comment">// spin until it&#x27;s zero</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">if</span> (StoreConditional(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line"><span class="number">6</span> <span class="keyword">return</span>; <span class="comment">// if set-it-to-1 was a success: all done</span></span><br><span class="line"><span class="number">7</span> <span class="comment">// otherwise: try it all over again</span></span><br><span class="line"><span class="number">8</span> &#125;</span><br><span class="line"><span class="number">9</span> &#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span> <span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line"><span class="number">12</span> lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取并增加"><a href="#获取并增加" class="headerlink" title="获取并增加"></a>获取并增加</h2><p>它能原子地返回特定地址的旧值，并且让该值自增一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">int</span> <span class="title function_">FetchAndAdd</span><span class="params">(<span class="type">int</span> *ptr)</span> &#123;</span><br><span class="line"><span class="number">2</span> <span class="type">int</span> old = *ptr;</span><br><span class="line"><span class="number">3</span> *ptr = old + <span class="number">1</span>;</span><br><span class="line"><span class="number">4</span> <span class="keyword">return</span> old;</span><br><span class="line"><span class="number">5</span> &#125;</span><br><span class="line"><span class="number">1</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> ticket;</span><br><span class="line"><span class="number">3</span> <span class="type">int</span> turn;</span><br><span class="line"><span class="number">4</span> &#125; <span class="type">lock_t</span>;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line"><span class="number">7</span> lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line"><span class="number">8</span> lock-&gt;turn = <span class="number">0</span>;</span><br><span class="line"><span class="number">9</span> &#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span> <span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line"><span class="number">12</span> <span class="type">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line"><span class="number">13</span> <span class="keyword">while</span> (lock-&gt;turn != myturn)</span><br><span class="line"><span class="number">14</span> ; <span class="comment">// spin</span></span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span> <span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line"><span class="number">18</span> FetchAndAdd(&amp;lock-&gt;turn);</span><br><span class="line"><span class="number">19</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何让锁不会不必要地自旋，浪费-CPU-时间？"><a href="#如何让锁不会不必要地自旋，浪费-CPU-时间？" class="headerlink" title="如何让锁不会不必要地自旋，浪费 CPU 时间？"></a>如何让锁不会不必要地自旋，浪费 CPU 时间？</h2><h3 id="第一种简单友好的方法就是，在要自旋的时候，放弃-CPU。"><a href="#第一种简单友好的方法就是，在要自旋的时候，放弃-CPU。" class="headerlink" title="第一种简单友好的方法就是，在要自旋的时候，放弃 CPU。"></a>第一种简单友好的方法就是，在要自旋的时候，放弃 CPU。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">2</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="number">3</span> &#125;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">6</span> <span class="keyword">while</span> (TestAndSet(&amp;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line"><span class="number">7</span> yield(); <span class="comment">// give up the CPU</span></span><br><span class="line"><span class="number">8</span> &#125;</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">11</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="number">12</span> &#125;</span><br></pre></td></tr></table></figure>

<p>假定操作系统提供原语 yield()，线程可以调用它主动放弃 CPU，让其他线程运行。线程可以处于 3 种状态之一（运行、就绪和阻塞）。yield()系统调用能够让运行（running）态变为就绪（ready）态，从而允许其他线程运行。因此，让出线程本质上取消调度（deschedules）了它自己。</p>
<h3 id="使用队列：休眠替代自旋"><a href="#使用队列：休眠替代自旋" class="headerlink" title="使用队列：休眠替代自旋"></a>使用队列：休眠替代自旋</h3><p>我们必须显式地施加某种控制，决定锁释放时，谁能抢到锁，我们需要操作系统的更多支持，并需要一个队列来保存等待锁的线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> flag;</span><br><span class="line"><span class="number">3</span> <span class="type">int</span> guard;</span><br><span class="line"><span class="number">4</span> <span class="type">queue_t</span> *q;</span><br><span class="line"><span class="number">5</span> &#125; <span class="type">lock_t</span>;</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123;</span><br><span class="line"><span class="number">8</span> m-&gt;flag = <span class="number">0</span>;</span><br><span class="line"><span class="number">9</span> m-&gt;guard = <span class="number">0</span>;</span><br><span class="line"><span class="number">10</span> queue_init(m-&gt;q);</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123;</span><br><span class="line"><span class="number">14</span> <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line"><span class="number">15</span> ; <span class="comment">//acquire guard lock by spinning</span></span><br><span class="line"><span class="number">16</span> <span class="keyword">if</span> (m-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">17</span> m-&gt;flag = <span class="number">1</span>; <span class="comment">// lock is acquired</span></span><br><span class="line"><span class="number">18</span> m-&gt;guard = <span class="number">0</span>;</span><br><span class="line"><span class="number">19</span> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">20</span> queue_add(m-&gt;q, gettid());</span><br><span class="line"><span class="number">21</span> m-&gt;guard = <span class="number">0</span>;</span><br><span class="line"><span class="number">22</span> park();</span><br><span class="line"><span class="number">23</span> &#125;</span><br><span class="line"><span class="number">24</span> &#125;</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span> <span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *m)</span> &#123;</span><br><span class="line"><span class="number">27</span> <span class="keyword">while</span> (TestAndSet(&amp;m-&gt;guard, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line"><span class="number">28</span> ; <span class="comment">//acquire guard lock by spinning</span></span><br><span class="line"><span class="number">29</span> <span class="keyword">if</span> (queue_empty(m-&gt;q))</span><br><span class="line"><span class="number">30</span> m-&gt;flag = <span class="number">0</span>; <span class="comment">// let go of lock; no one wants it</span></span><br><span class="line"><span class="number">31</span> <span class="keyword">else</span></span><br><span class="line"><span class="number">32</span> unpark(queue_remove(m-&gt;q)); <span class="comment">// hold lock (for next thread!)</span></span><br><span class="line"><span class="number">33</span> m-&gt;guard = <span class="number">0</span>;</span><br><span class="line"><span class="number">34</span> &#125;</span><br></pre></td></tr></table></figure>


<h1 id="基于锁的并发数据结构"><a href="#基于锁的并发数据结构" class="headerlink" title="基于锁的并发数据结构"></a>基于锁的并发数据结构</h1><h2 id="并发计数器"><a href="#并发计数器" class="headerlink" title="并发计数器"></a>并发计数器</h2><p>定义了一个非并发的计数器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">counter_t</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> value;</span><br><span class="line"><span class="number">3</span> &#125; <span class="type">counter_t</span>;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">counter_t</span> *c)</span> &#123;</span><br><span class="line"><span class="number">6</span> c-&gt;value = <span class="number">0</span>;</span><br><span class="line"><span class="number">7</span> &#125;</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">counter_t</span> *c)</span> &#123;</span><br><span class="line"><span class="number">10</span> c-&gt;value++;</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="type">void</span> <span class="title function_">decrement</span><span class="params">(<span class="type">counter_t</span> *c)</span> &#123;</span><br><span class="line"><span class="number">14</span> c-&gt;value--;</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">counter_t</span> *c)</span> &#123;</span><br><span class="line"><span class="number">18</span> <span class="keyword">return</span> c-&gt;value;</span><br><span class="line"><span class="number">19</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如何让这段代码线程安全（thread safe）？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">counter_t</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> value;</span><br><span class="line"><span class="number">3</span> <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"><span class="number">4</span> &#125; <span class="type">counter_t</span>;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">counter_t</span> *c)</span> &#123;</span><br><span class="line"><span class="number">7</span> c-&gt;value = <span class="number">0</span>;</span><br><span class="line"><span class="number">8</span> Pthread_mutex_init(&amp;c-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">9</span> &#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span> <span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">counter_t</span> *c)</span> &#123;</span><br><span class="line"><span class="number">12</span> Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line"><span class="number">13</span> c-&gt;value++;</span><br><span class="line"><span class="number">14</span> Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span> <span class="type">void</span> <span class="title function_">decrement</span><span class="params">(<span class="type">counter_t</span> *c)</span> &#123;</span><br><span class="line"><span class="number">18</span> Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line"><span class="number">19</span> c-&gt;value--;</span><br><span class="line"><span class="number">20</span> Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line"><span class="number">21</span> &#125;</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">counter_t</span> *c)</span> &#123;</span><br><span class="line"><span class="number">24</span> Pthread_mutex_lock(&amp;c-&gt;lock);</span><br><span class="line"><span class="number">25</span> <span class="type">int</span> rc = c-&gt;value;</span><br><span class="line"><span class="number">26</span> Pthread_mutex_unlock(&amp;c-&gt;lock);</span><br><span class="line"><span class="number">27</span> <span class="keyword">return</span> rc;</span><br><span class="line"><span class="number">28</span> &#125;</span><br></pre></td></tr></table></figure>
<p>它只是加了一把锁，在调用函数操作该数据结构时获取锁，从调用返回时<br>释放锁。</p>
<h2 id="并发链表"><a href="#并发链表" class="headerlink" title="并发链表"></a>并发链表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">// basic node structure</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> &#123;</span></span><br><span class="line"><span class="number">3</span> <span class="type">int</span> key;</span><br><span class="line"><span class="number">4</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="number">5</span> &#125; <span class="type">node_t</span>;</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="comment">// basic list structure (one used per list)</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_t</span> &#123;</span></span><br><span class="line"><span class="number">9</span> <span class="type">node_t</span> *head;</span><br><span class="line"><span class="number">10</span> <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"><span class="number">11</span> &#125; <span class="type">list_t</span>;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="type">void</span> <span class="title function_">List_Init</span><span class="params">(<span class="type">list_t</span> *L)</span> &#123;</span><br><span class="line"><span class="number">14</span> L-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">15</span> pthread_mutex_init(&amp;L-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span> <span class="type">int</span> <span class="title function_">List_Insert</span><span class="params">(<span class="type">list_t</span> *L, <span class="type">int</span> key)</span> &#123;</span><br><span class="line"><span class="number">19</span> pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line"><span class="number">20</span> <span class="type">node_t</span> *new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line"><span class="number">21</span> <span class="keyword">if</span> (new == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">22</span> perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line"><span class="number">23</span> pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line"><span class="number">24</span> <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// fail</span></span><br><span class="line"><span class="number">25</span> &#125;</span><br><span class="line"><span class="number">26</span> new-&gt;key = key;</span><br><span class="line"><span class="number">27</span> new-&gt;next = L-&gt;head;</span><br><span class="line"><span class="number">28</span> L-&gt;head = new;</span><br><span class="line"><span class="number">29</span> pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line"><span class="number">30</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// success</span></span><br><span class="line"><span class="number">31</span> &#125;</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">33</span> <span class="type">int</span> <span class="title function_">List_Lookup</span><span class="params">(<span class="type">list_t</span> *L, <span class="type">int</span> key)</span> &#123;</span><br><span class="line"><span class="number">34</span> pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line"><span class="number">35</span> <span class="type">node_t</span> *curr = L-&gt;head;</span><br><span class="line"><span class="number">36</span> <span class="keyword">while</span> (curr) &#123;</span><br><span class="line"><span class="number">37</span> <span class="keyword">if</span> (curr-&gt;key == key) &#123;</span><br><span class="line"><span class="number">38</span> pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line"><span class="number">39</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// success</span></span><br><span class="line"><span class="number">40</span> &#125;</span><br><span class="line"><span class="number">41</span> curr = curr-&gt;next;</span><br><span class="line"><span class="number">42</span> &#125;</span><br><span class="line"><span class="number">43</span> pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line"><span class="number">44</span> <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// failure</span></span><br><span class="line"><span class="number">45</span> &#125;</span><br></pre></td></tr></table></figure>
<p>减少了代码中需要获取锁、释放锁的地方，降低了代码中不小心引入缺陷（诸如在返回前忘记释放锁）的可能性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">List_Init</span><span class="params">(<span class="type">list_t</span> *L)</span> &#123;</span><br><span class="line"><span class="number">2</span> L-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">3</span> pthread_mutex_init(&amp;L-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">4</span> &#125;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="type">void</span> <span class="title function_">List_Insert</span><span class="params">(<span class="type">list_t</span> *L, <span class="type">int</span> key)</span> &#123;</span><br><span class="line"><span class="number">7</span> <span class="comment">// synchronization not needed</span></span><br><span class="line"><span class="number">8</span> <span class="type">node_t</span> *new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line"><span class="number">9</span> <span class="keyword">if</span> (new == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">10</span> perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line"><span class="number">11</span> <span class="keyword">return</span>;</span><br><span class="line"><span class="number">12</span> &#125;</span><br><span class="line"><span class="number">13</span> new-&gt;key = key;</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span> <span class="comment">// just lock critical section</span></span><br><span class="line"><span class="number">16</span> pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line"><span class="number">17</span> new-&gt;next = L-&gt;head;</span><br><span class="line"><span class="number">18</span> L-&gt;head = new;</span><br><span class="line"><span class="number">19</span> pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line"><span class="number">20</span> &#125;</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> <span class="type">int</span> <span class="title function_">List_Lookup</span><span class="params">(<span class="type">list_t</span> *L, <span class="type">int</span> key)</span> &#123;</span><br><span class="line"><span class="number">23</span> <span class="type">int</span> rv = <span class="number">-1</span>;</span><br><span class="line"><span class="number">24</span> pthread_mutex_lock(&amp;L-&gt;lock);</span><br><span class="line"><span class="number">25</span> <span class="type">node_t</span> *curr = L-&gt;head;</span><br><span class="line"><span class="number">26</span> <span class="keyword">while</span> (curr) &#123;</span><br><span class="line"><span class="number">27</span> <span class="keyword">if</span> (curr-&gt;key == key) &#123;</span><br><span class="line"><span class="number">28</span> rv = <span class="number">0</span>;</span><br><span class="line"><span class="number">29</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="number">30</span> &#125;</span><br><span class="line"><span class="number">31</span> curr = curr-&gt;next;</span><br><span class="line"><span class="number">32</span> &#125;</span><br><span class="line"><span class="number">33</span> pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line"><span class="number">34</span> <span class="keyword">return</span> rv; <span class="comment">// now both success and failure</span></span><br><span class="line"><span class="number">35</span> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="条件变量-1"><a href="#条件变量-1" class="headerlink" title="条件变量"></a>条件变量</h1><p>锁并不是并发程序设计所需的唯一原语</p>
<p>在很多情况下，线程需要检查某一条件（condition）满足之后，才会继续运行。例如，父线程需要检查子线程是否执行完毕 [这常被称为 join()]。这种等待如何实现呢？</p>
<p>我们可以尝试用一个共享变量。这种解决方案一般能工作，但是效率低下，因为主线程会自旋检查，浪费 CPU 时间。我们希望有某种方式让父线程休眠，直到等待的条件满足（即子线程完成执行）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">volatile</span> <span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="type">void</span> *<span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">4</span> <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line"><span class="number">5</span> done = <span class="number">1</span>;</span><br><span class="line"><span class="number">6</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">7</span> &#125;</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="number">10</span> <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line"><span class="number">11</span> <span class="type">pthread_t</span> c;</span><br><span class="line"><span class="number">12</span> Pthread_create(&amp;c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>); <span class="comment">// create child</span></span><br><span class="line"><span class="number">13</span> <span class="keyword">while</span> (done == <span class="number">0</span>)</span><br><span class="line"><span class="number">14</span> ; <span class="comment">// spin</span></span><br><span class="line"><span class="number">15</span> <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line"><span class="number">16</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">17</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义和程序"><a href="#定义和程序" class="headerlink" title="定义和程序"></a>定义和程序</h2><p>线程可以使用条件变量（condition variable），来等待一个条件变成真。条件变量是一个显式队列，当某些执行状态（即条件，condition）不满足时，线程可以把自己加入队列，等待（waiting）该条件。当它改变了上述状态时，就可以唤醒一个或者多个等待线程（通过在该条件上发信号），让它们继续执行。</p>
<p>要声明这样的条件变量，只要像这样写：pthread_cond_t c;，这里声明 c 是一个条件变量（注意：还需要适当的初始化）。条件变量有两种相关操作：wait()和 signal()。线程要睡眠的时候，调用 wait()。当线程想唤醒等待在某个条件变量上的睡眠线程时，调用 signal()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_cond_wait(<span class="type">pthread_cond_t</span> *c, <span class="type">pthread_mutex_t</span> *m);</span><br><span class="line"><span class="comment">//&amp;cond：条件变量（pthread_cond_t类型），用于等待和唤醒线程。</span></span><br><span class="line"><span class="comment">//&amp;mutex：互斥锁（pthread_mutex_t类型），在进入睡眠状态之前会被自动释放，唤醒后会被重新获得。</span></span><br><span class="line">pthread_cond_signal(<span class="type">pthread_cond_t</span> *c);</span><br><span class="line"><span class="number">1</span> <span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line"><span class="number">2</span> <span class="type">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="number">3</span> <span class="type">pthread_cond_t</span> c = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="type">void</span> <span class="title function_">thr_exit</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">6</span> Pthread_mutex_lock(&amp;m);</span><br><span class="line"><span class="number">7</span> done = <span class="number">1</span>;</span><br><span class="line"><span class="number">8</span> Pthread_cond_signal(&amp;c);</span><br><span class="line"><span class="number">9</span> Pthread_mutex_unlock(&amp;m);</span><br><span class="line"><span class="number">10</span> &#125;</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span> <span class="type">void</span> *<span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">13</span> <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line"><span class="number">14</span> thr_exit();</span><br><span class="line"><span class="number">15</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span> <span class="type">void</span> <span class="title function_">thr_join</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">19</span> Pthread_mutex_lock(&amp;m);</span><br><span class="line"><span class="number">20</span> <span class="keyword">while</span> (done == <span class="number">0</span>)</span><br><span class="line"><span class="number">21</span> Pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line"><span class="number">22</span> Pthread_mutex_unlock(&amp;m);</span><br><span class="line"><span class="number">23</span> &#125;</span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="number">26</span> <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line"><span class="number">27</span> <span class="type">pthread_t</span> p;</span><br><span class="line"><span class="number">28</span> Pthread_create(&amp;p, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">29</span> thr_join();</span><br><span class="line"><span class="number">30</span> <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line"><span class="number">31</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">32</span> &#125;</span><br></pre></td></tr></table></figure>

<p>我们常简称为 wait()和 signal()。你可能注意到一点，wait()调用有一个参数，它是互斥量。它假定在 wait()调用时，这个互斥量是已上锁状态。<strong>wait()的职责是释放锁，并让调用线程休眠（原子地）。当线程被唤醒时（在另外某个线程发信号给它后），它必须重新获取锁，再返回调用者。</strong> 这样复杂的步骤也是为了避免在线程陷入休眠时，产生一些竞态条件。</p>
<p>第一种情况是父线程创建出子线程，但自己继续运行（假设只有一个处理器），然后马上调用 thr_join()等待子线程。在这种情况下，它会先获取锁，检查子进程是否完成（还没有完成），然后调用 wait()，让自己休眠。子线程最终得以运行，打印出“child”，并调用 thr_exit()函数唤醒父进程，这段代码会在获得锁后设置状态变量 done，然后向父线程发信号唤醒它。最后，父线程会运行（从 wait()调用返回并持有锁），释放锁，打印出“parent:end”。</p>
<p>第二种情况是，子线程在创建后，立刻运行，设置变量 done 为 1，调用 signal 函数唤醒其他线程（这里没有其他线程），然后结束。父线程运行后，调用 thr_join()时，发现 done已经是 1 了，就直接返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">thr_exit</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">2</span> Pthread_mutex_lock(&amp;m);</span><br><span class="line"><span class="number">3</span> Pthread_cond_signal(&amp;c);</span><br><span class="line"><span class="number">4</span> Pthread_mutex_unlock(&amp;m);</span><br><span class="line"><span class="number">5</span> &#125;</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="type">void</span> <span class="title function_">thr_join</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">8</span> Pthread_mutex_lock(&amp;m);</span><br><span class="line"><span class="number">9</span> Pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line"><span class="number">10</span> Pthread_mutex_unlock(&amp;m);</span><br><span class="line"><span class="number">11</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是有问题的。假设子线程立刻运行，并且调用 thr_exit()。在这种情况下，子线程发送信号，但此时却没有在条件变量上睡眠等待的线程。父线程运行时，就会调用 wait并卡在那里，没有其他线程会唤醒它。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">thr_exit</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">2</span> done = <span class="number">1</span>;</span><br><span class="line"><span class="number">3</span> Pthread_cond_signal(&amp;c);</span><br><span class="line"><span class="number">4</span> &#125;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="type">void</span> <span class="title function_">thr_join</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">7</span> <span class="keyword">if</span> (done == <span class="number">0</span>)</span><br><span class="line"><span class="number">8</span> Pthread_cond_wait(&amp;c);</span><br><span class="line"><span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里的问题是一个微妙的竞态条件。具体来说，如果父进程调用 thr_join()，然后检查完done 的值为 0，然后试图睡眠。但在调用 wait 进入睡眠之前，父进程被中断。子线程修改变量 done 为 1，发出信号，同样没有等待线程。父线程再次运行时，就会长眠不醒，这就惨了。</p>
<blockquote>
<p>提示：发信号时总是持有锁<br>尽管并不是所有情况下都严格需要，但有效且简单的做法，还是<strong>在使用条件变量发送信号时持有锁</strong>。虽然上面的例子是必须加锁的情况，但也有一些情况可以不加锁，而这可能是你应该避免的。因此，为了简单，请在调用 signal 时持有锁（hold the lock when calling signal）。<br>这个提示的反面，即调用 wait 时持有锁，不只是建议，而是 wait 的语义强制要求的。因为 wait 调用总是假设你调用它时已经持有锁、调用者睡眠之前会释放锁以及返回前重新持有锁。因此，这个提示的一般化形式是正确的：调用 signal 和 wait 时要持有锁（hold the lock when calling signal or wait），你会保持身心健康的。</p>
</blockquote>
<h3 id="条件变量和上述代码中的done"><a href="#条件变量和上述代码中的done" class="headerlink" title="条件变量和上述代码中的done"></a>条件变量和上述代码中的done</h3><p>条件变量：用于通知父进程，子进程中的条件满足了<br>done：用于控制父子进程中代码的运行行数（if卡住某行，while在卡住某行时避免因为父子顺序而导致线程僵住。）</p>
<h2 id="生产者-消费者（有界缓冲区）问题"><a href="#生产者-消费者（有界缓冲区）问题" class="headerlink" title="生产者/消费者（有界缓冲区）问题"></a>生产者/消费者（有界缓冲区）问题</h2><p>假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区；消费者从缓冲区取走数据项，以某种方式消费。</p>
<ol>
<li><p>很多实际的系统中都会有这种场景。例如，在多线程的网络服务器中，一个生产者将HTTP 请求放入工作队列（即有界缓冲区），消费线程从队列中取走请求并处理。</p>
</li>
<li><p>我们在使用管道连接不同程序的输出和输入时，也会使用有界缓冲区，例如 grep foofile.txt | wc -l。这个例子并发执行了两个进程，grep 进程从 file.txt 中查找包括“foo”的行，写到标准输出；UNIX shell 把输出重定向到管道（通过 pipe 系统调用创建）。管道的另一端是 wc 进程的标准输入，wc 统计完行数后打印出结果。因此，grep 进程是生产者，wc 是进程是消费者，它们之间是内核中的有界缓冲区。</p>
</li>
</ol>
<p><strong>因为有界缓冲区是共享资源，所以我们必须通过同步机制来访问它，以免产生竞态条件。</strong></p>
<p>首先需要一个共享缓冲区，让生产者放入数据，消费者取出数据。简单起见，我们就拿一个整数来做缓冲区（你当然可以想到用一个指向数据结构的指针来代替），两个内部函数将值放入缓冲区，从缓冲区取值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="number">2</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// initially, empty</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="number">5</span> assert(count == <span class="number">0</span>);</span><br><span class="line"><span class="number">6</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="number">7</span> buffer = value;</span><br><span class="line"><span class="number">8</span> &#125;</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">11</span> assert(count == <span class="number">1</span>);</span><br><span class="line"><span class="number">12</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="number">13</span> <span class="keyword">return</span> buffer;</span><br><span class="line"><span class="number">14</span> &#125;</span><br></pre></td></tr></table></figure>

<p>put()函数会假设缓冲区是空的，把一个值存在缓冲区，然后把 count设置为 1 表示缓冲区满了。get()函数刚好相反，把缓冲区清空后（即将 count 设置为 0），并返回该值。</p>
<p>现在我们需要编写一些函数，知道何时可以访问缓冲区，以便将数据放入缓冲区或从缓冲区取出数据。条件是显而易见的：仅在 count 为 0 时（即缓冲器为空时），才将数据放入缓冲器中。仅在计数为 1 时（即缓冲器已满时），才从缓冲器获得数据。如果我们编写同步代码，让生产者将数据放入已满的缓冲区，或消费者从空的数据获取数据，就做错了（在这段代码中，断言将触发）。</p>
<p>这项工作将由两种类型的线程完成，其中一类我们称之为生产者（producer）线程，另一类我们称之为消费者（consumer）线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">2</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">3</span> <span class="type">int</span> loops = (<span class="type">int</span>) arg;</span><br><span class="line"><span class="number">4</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">5</span> put(i);</span><br><span class="line"><span class="number">6</span> &#125;</span><br><span class="line"><span class="number">7</span> &#125;</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">10</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">11</span> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="number">12</span> <span class="type">int</span> tmp = get();</span><br><span class="line"><span class="number">13</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line"><span class="number">14</span> &#125;</span><br><span class="line"><span class="number">15</span> &#125;</span><br></pre></td></tr></table></figure>

<p>假设只有一个生产者和一个消费者。显然，put()和 get()函数之中会有临界区，因为 put()更新缓冲区，get()读取缓冲区。但是，给代码加锁没有用，我们还需别的东西。不奇怪，别的东西就是某些条件变量。在这个（有问题的）首次尝试中（见图 30.6），我们用了条件变量 cond 和相关的锁 mutex。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">cond_t</span> cond;</span><br><span class="line"><span class="number">2</span> <span class="type">mutex_t</span> mutex;</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">5</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">7</span> Pthread_mutex_lock(&amp;mutex); <span class="comment">// p1</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">if</span> (count == <span class="number">1</span>) <span class="comment">// p2</span></span><br><span class="line"><span class="number">9</span> Pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">// p3</span></span><br><span class="line"><span class="number">10</span> put(i); <span class="comment">// p4</span></span><br><span class="line"><span class="number">11</span> Pthread_cond_signal(&amp;cond); <span class="comment">// p5</span></span><br><span class="line"><span class="number">12</span> Pthread_mutex_unlock(&amp;mutex); <span class="comment">// p6</span></span><br><span class="line"><span class="number">13</span> &#125;</span><br><span class="line"><span class="number">14</span> &#125;</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> <span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">17</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">19</span> Pthread_mutex_lock(&amp;mutex); <span class="comment">// c1</span></span><br><span class="line"><span class="number">20</span> <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="comment">// c2</span></span><br><span class="line"><span class="number">21</span> Pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">// c3</span></span><br><span class="line"><span class="number">22</span> <span class="type">int</span> tmp = get(); <span class="comment">// c4</span></span><br><span class="line"><span class="number">23</span> Pthread_cond_signal(&amp;cond); <span class="comment">// c5</span></span><br><span class="line"><span class="number">24</span> Pthread_mutex_unlock(&amp;mutex); <span class="comment">// c6</span></span><br><span class="line"><span class="number">25</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line"><span class="number">26</span> &#125;</span><br><span class="line"><span class="number">27</span> &#125;</span><br></pre></td></tr></table></figure>

<p>我们来理解第一个问题，它与等待之前的 if 语句有关。假设有两个消费者（Tc1 和 Tc2），一个生产者（Tp）。首先，一个消费者（Tc1）先开始执行，它获得锁（c1），检查缓冲区是否可以消费（c2），然后等待（c3）（这会释放锁）。</p>
<p>接着生产者（Tp）运行。它获取锁（p1），检查缓冲区是否满（p2），发现没满就给缓冲区加入一个数字（p4）。然后生产者发出信号，说缓冲区已满（p5）。关键的是，这让第一个消费者（Tc1）不再睡在条件变量上，进入就绪队列。Tc1 现在可以运行（但还未运行）。生产者继续执行，直到发现缓冲区满后睡眠（p6,p1-p3）。</p>
<p>这时问题发生了：另一个消费者（Tc2）抢先执行，消费了缓冲区中的值（c1,c2,c4,c5,c6，跳过了 c3 的等待，因为缓冲区是满的）。现在假设 Tc1 运行，在从 wait 返回之前，它获取了锁，然后返回。然后它调用了 get() (p4)，但缓冲区已无法消费！断言触发，代码不能像预期那样工作。显然，我们应该设法阻止 Tc1 去消费，因为 Tc2 插进来，消费了缓冲区中之前生产的一个值。<br><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/q8.png" alt="?"><br><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/q9.png" alt="?"></p>
<p>问题产生的原因很简单：在 Tc1 被生产者唤醒后，但在它运行之前，缓冲区的状态改变了（由于 Tc2）。发信号给线程只是唤醒它们，暗示状态发生了变化（在这个例子中，就是值已被放入缓冲区），但并不会保证在它运行之前状态一直是期望的情况。信号的这种释义常称为 Mesa 语义（Mesa semantic），为了纪念以这种方式建立条件变量的首次研究[LR80]。另一种释义是 Hoare 语义（Hoare semantic），虽然实现难度大，但是会保证被唤醒线程立刻执行[H74]。实际上，几乎所有系统都采用了 Mesa 语义。</p>
<h3 id="较好但仍有问题的方案：使用-While-语句替代-If"><a href="#较好但仍有问题的方案：使用-While-语句替代-If" class="headerlink" title="较好但仍有问题的方案：使用 While 语句替代 If"></a>较好但仍有问题的方案：使用 While 语句替代 If</h3><p>把 if 语句改为 while。当消费者 Tc1 被唤醒后，立刻再次检查共享变量（c2）。如果缓冲区此时为空，消费者就会回去继续睡眠（c3）。生产者中相应的 if 也改为 while（p2）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">cond_t</span> cond;</span><br><span class="line"><span class="number">2</span> <span class="type">mutex_t</span> mutex;</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">5</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">7</span> Pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// p1</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">while</span> (count == <span class="number">1</span>)</span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line"><span class="number">9</span> Pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line"><span class="comment">// p3</span></span><br><span class="line"><span class="number">10</span> put(i);</span><br><span class="line"><span class="comment">// p4</span></span><br><span class="line"><span class="number">11</span> Pthread_cond_signal(&amp;cond);</span><br><span class="line"><span class="comment">// p5</span></span><br><span class="line"><span class="number">12</span> Pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="comment">// p6</span></span><br><span class="line"><span class="number">13</span> &#125;</span><br><span class="line"><span class="number">14</span> &#125;</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> <span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">17</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">19</span> Pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// c1</span></span><br><span class="line"><span class="number">20</span> <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line"><span class="comment">// c2</span></span><br><span class="line"><span class="number">21</span> Pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line"><span class="comment">// c3</span></span><br><span class="line"><span class="number">22</span> <span class="type">int</span> tmp = get();</span><br><span class="line"><span class="comment">// c4</span></span><br><span class="line"><span class="number">23</span> Pthread_cond_signal(&amp;cond);</span><br><span class="line"><span class="comment">// c5</span></span><br><span class="line"><span class="number">24</span> Pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="comment">// c6</span></span><br><span class="line"><span class="number">25</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line"><span class="number">26</span> &#125;</span><br><span class="line"><span class="number">27</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>由于 Mesa 语义，我们要记住一条关于条件变量的简单规则：总是使用 while 循环（always use while loop）。虽然有时候不需要重新检查条件，但这样做总是安全的。</strong></p>
<h3 id="都睡眠了怎么办？"><a href="#都睡眠了怎么办？" class="headerlink" title="都睡眠了怎么办？"></a>都睡眠了怎么办？</h3><p>假设两个消费者（Tc1 和 Tc2）先运行，都睡眠了（c3）。生产者开始运行，在缓冲区放入一个值，唤醒了一个消费者（假定是 Tc1），并开始睡眠。现在是一个消费者马上要运行（Tc1），两个线程（Tc2 和 生产者）都等待在同一个条件变量上。</p>
<p>消费者 Tc1 醒过来并从 wait()调用返回（c3），重新检查条件（c2），发现缓冲区是满的，消费了这个值（c4）。这个消费者然后在该条件上发信号（c5），唤醒一个在睡眠的线程。但是，应该唤醒哪个线程呢？</p>
<p>因为消费者已经清空了缓冲区，很显然，应该唤醒生产者。<strong>但是，如果它唤醒了 Tc2（这绝对是可能的，取决于等待队列是如何管理的），问题就出现了</strong>。具体来说，消费者 Tc2 会醒过来，发现队列为空（c2），又继续回去睡眠（c3）。生产者 Tp 刚才在缓冲区中放了一个值，现在在睡眠。另一个消费者线程 Tc1 也回去睡眠了。3 个线程都在睡眠，显然是一个缺陷。</p>
<p><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/w1.png" alt="?"><br><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/w2.png" alt="?"></p>
<p><strong>消费者不应该唤醒消费者，而应该只唤醒生产者，反之亦然。</strong></p>
<h3 id="单值缓冲区的生产者-消费者方案"><a href="#单值缓冲区的生产者-消费者方案" class="headerlink" title="单值缓冲区的生产者/消费者方案"></a>单值缓冲区的生产者/消费者方案</h3><p><strong>使用两个条件变量，而不是一个，以便正确地发出信号，在系统状态改变时，哪类线程应该唤醒。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">cond_t</span> empty, fill;</span><br><span class="line"><span class="number">2</span> <span class="type">mutex_t</span> mutex;</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">5</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">7</span> Pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="number">8</span> <span class="keyword">while</span> (count == <span class="number">1</span>)</span><br><span class="line"><span class="number">9</span> Pthread_cond_wait(&amp;empty, &amp;mutex);</span><br><span class="line"><span class="number">10</span> put(i);</span><br><span class="line"><span class="number">11</span> Pthread_cond_signal(&amp;fill);</span><br><span class="line"><span class="number">12</span> Pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="number">13</span> &#125;</span><br><span class="line"><span class="number">14</span> &#125;</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> <span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">17</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">19</span> Pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="number">20</span> <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line"><span class="number">21</span> Pthread_cond_wait(&amp;fill, &amp;mutex);</span><br><span class="line"><span class="number">22</span> <span class="type">int</span> tmp = get();</span><br><span class="line"><span class="number">23</span> Pthread_cond_signal(&amp;empty);</span><br><span class="line"><span class="number">24</span> Pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="number">25</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line"><span class="number">26</span> &#125;</span><br><span class="line"><span class="number">27</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，生产者线程等待条件变量 empty，发信号给变量 fill。相应地，消费者线程等待 fill，发信号给 empty。这样做，从设计上避免了上述第二个问题：消费者再也不会唤醒消费者，生产者也不会唤醒生产者。</p>
<h3 id="最终的生产者-消费者方案"><a href="#最终的生产者-消费者方案" class="headerlink" title="最终的生产者/消费者方案"></a>最终的生产者/消费者方案</h3><p>第一处修改是缓冲区结构本身，以及对应的 put()和 get()方法（见图 30.9）。我们还稍稍修改了生产者和消费者的检查条件，以便决定是否要睡眠。图 30.10 展示了最终的等待和信号逻辑。生产者只有在缓冲区满了的时候才会睡眠（p2），消费者也只有在队列为空的时候睡眠（c2）。至此，我们解决了生产者/消费者问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">int</span> buffer[MAX];</span><br><span class="line"><span class="number">2</span> <span class="type">int</span> fill = <span class="number">0</span>;</span><br><span class="line"><span class="number">3</span> <span class="type">int</span> use = <span class="number">0</span>;</span><br><span class="line"><span class="number">4</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="number">7</span> buffer[fill] = value;</span><br><span class="line"><span class="number">8</span> fill = (fill + <span class="number">1</span>) % MAX;</span><br><span class="line"><span class="number">9</span> count++;</span><br><span class="line"><span class="number">10</span> &#125;</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">13</span> <span class="type">int</span> tmp = buffer[use];</span><br><span class="line"><span class="number">14</span> use = (use + <span class="number">1</span>) % MAX;</span><br><span class="line"><span class="number">15</span> count--;</span><br><span class="line"><span class="number">16</span> <span class="keyword">return</span> tmp;</span><br><span class="line"><span class="number">17</span> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">cond_t</span> empty, fill;</span><br><span class="line"><span class="number">2</span> <span class="type">mutex_t</span> mutex;</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">5</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">7</span> Pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// p1</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">while</span> (count == MAX)</span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line"><span class="number">9</span> Pthread_cond_wait(&amp;empty, &amp;mutex);</span><br><span class="line"><span class="comment">// p3</span></span><br><span class="line"><span class="number">10</span> put(i);</span><br><span class="line"><span class="comment">// p4</span></span><br><span class="line"><span class="number">11</span> Pthread_cond_signal(&amp;fill);</span><br><span class="line"><span class="comment">// p5</span></span><br><span class="line"><span class="number">12</span> Pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="comment">// p6</span></span><br><span class="line"><span class="number">13</span> &#125;</span><br><span class="line"><span class="number">14</span> &#125;</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> <span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">17</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">19</span> Pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// c1</span></span><br><span class="line"><span class="number">20</span> <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line"><span class="comment">// c2</span></span><br><span class="line"><span class="number">21</span> Pthread_cond_wait(&amp;fill, &amp;mutex);</span><br><span class="line"><span class="comment">// c3</span></span><br><span class="line"><span class="number">22</span> <span class="type">int</span> tmp = get();</span><br><span class="line"><span class="comment">// c4</span></span><br><span class="line"><span class="number">23</span> Pthread_cond_signal(&amp;empty);</span><br><span class="line"><span class="comment">// c5</span></span><br><span class="line"><span class="number">24</span> Pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="comment">// c6</span></span><br><span class="line"><span class="number">25</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line"><span class="number">26</span> &#125;</span><br><span class="line"><span class="number">27</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="覆盖条件"><a href="#覆盖条件" class="headerlink" title="覆盖条件"></a>覆盖条件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">// how many bytes of the heap are free?</span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> bytesLeft = MAX_HEAP_SIZE;</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="comment">// need lock and condition too</span></span><br><span class="line"><span class="number">5</span> <span class="type">cond_t</span> c;</span><br><span class="line"><span class="number">6</span> <span class="type">mutex_t</span> m;</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span> <span class="type">void</span> *</span><br><span class="line"><span class="number">9</span> allocate(<span class="type">int</span> size) &#123;</span><br><span class="line"><span class="number">10</span> Pthread_mutex_lock(&amp;m);</span><br><span class="line"><span class="number">11</span> <span class="keyword">while</span> (bytesLeft &lt; size)</span><br><span class="line"><span class="number">12</span> Pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line"><span class="number">13</span> <span class="type">void</span> *ptr = ...; <span class="comment">// get mem from heap</span></span><br><span class="line"><span class="number">14</span> bytesLeft -= size;</span><br><span class="line"><span class="number">15</span> Pthread_mutex_unlock(&amp;m);</span><br><span class="line"><span class="number">16</span> <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="number">17</span> &#125;</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span> <span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">int</span> size)</span> &#123;</span><br><span class="line"><span class="number">20</span> Pthread_mutex_lock(&amp;m);</span><br><span class="line"><span class="number">21</span> bytesLeft += size;</span><br><span class="line"><span class="number">22</span> Pthread_cond_signal(&amp;c); <span class="comment">// whom to signal??</span></span><br><span class="line"><span class="number">23</span> Pthread_mutex_unlock(&amp;m);</span><br><span class="line"><span class="number">24</span> &#125;</span><br></pre></td></tr></table></figure>
<p>当线程调用进入内存分配代码时，它可能会因为内存不足而等待。<br>相应的，线程释放内存时，会发信号说有更多内存空闲。但是，代码中有一个问题：应该唤醒哪个等待线程（可能有多个线程）？</p>
<p>解决方案也很直接：用 pthread_cond_broadcast()代替上述代码中的pthread_cond_signal()，唤醒所有的等待线程。</p>
<p>Lampson 和 Redell 把这种条件变量叫作覆盖条件（covering condition），因为它能覆盖所有需要唤醒线程的场景（保守策略）。成本如上所述，就是太多线程被唤醒。</p>
<p>一般来说，如果你发现程序只有改成广播信号时才能工作（但你认为不需要），可能是程序有缺陷。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>引入锁之外的另一个重要同步原语：条件变量。当某些程序状态不符合要求时，通过允许线程进入休眠状态，条件变量使我们能够漂亮地解决许多重要的同步问题，包括著名的（仍然重要的）生产者/消费者问题，以及覆盖条件。</p>
<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p><strong>Dijkstra 及其同事发明了信号量，作为与同步有关的所有工作的唯一原语。可以使用信号量作为锁和条件变量。</strong></p>
<h2 id="信号量的定义"><a href="#信号量的定义" class="headerlink" title="信号量的定义"></a>信号量的定义</h2><p>信号量是有一个整数值的对象，可以用两个函数来操作它。在 POSIX 标准中，是sem_wait()和 sem_post()。因为信号量的初始值能够决定其行为，所以首先要初始化信号量，才能调用其他函数与之交互。</p>
<p>初始化信号量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="number">2</span> <span class="type">sem_t</span> s;</span><br><span class="line"><span class="number">3</span> sem_init(&amp;s, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>历史上，sem_wait()开始被 Dijkstra 称为 P()（代指荷兰语单词“to probe”），而 sem_post()被称为 V()（代指荷兰语单词“to test”）。有时候，人们也会称它们为下（down）和上（up）。</p>
</blockquote>
<p>其中申明了一个信号量 s，通过第三个参数，将它的值初始化为 1。sem_init()的第二个参数，在我们看到的所有例子中都设置为 0，表示信号量是在同一进程的多个线程共享的。</p>
<p>信号量初始化之后，我们可以调用 sem_wait()或 sem_post()与之交互。多个线程会调用 sem_wait()和 sem_post()，显然需要管理这些临界区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *s)</span> &#123;</span><br><span class="line"><span class="number">2</span> decrement the value of semaphore s by one</span><br><span class="line"><span class="number">3</span> wait <span class="keyword">if</span> value of semaphore s is negative</span><br><span class="line"><span class="number">4</span> &#125;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *s)</span> &#123;</span><br><span class="line"><span class="number">7</span> increment the value of semaphore s by one</span><br><span class="line"><span class="number">8</span> <span class="keyword">if</span> there are one or more threads waiting, wake one</span><br><span class="line"><span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure>

<p>首先，sem_wait()要么立刻返回（调用 sem_wait()时，信号量的值大于等于 1），要么会让调用线程挂起，直到之后的一个 post 操作。当然，也可能多个调用线程都调用 sem_wait()，因此都在队列中等待被唤醒。</p>
<p>其次，sem_post()并没有等待某些条件满足。它直接增加信号量的值，如果有等待线程，唤醒其中一个。</p>
<p>最后，当信号量的值为负数时，这个值就是等待线程的个数。</p>
<h2 id="二值信号量（锁）"><a href="#二值信号量（锁）" class="headerlink" title="二值信号量（锁）"></a>二值信号量（锁）</h2><p>信号量的第一种用法是我们已经熟悉的：用信号量作为锁。<br>我们直接把临界区用一对 sem_wait()/sem_post()环绕。但是，为了使这段代码正常工作，信号量 m 的初始值（图中初始化为 X）是至关重要的。<strong>X 应该是1.</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">sem_t</span> m;</span><br><span class="line"><span class="number">2</span> sem_init(&amp;m, <span class="number">0</span>, X); <span class="comment">// initialize semaphore to X; what should X be?</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> sem_wait(&amp;m);</span><br><span class="line"><span class="number">5</span> <span class="comment">// critical section here</span></span><br><span class="line"><span class="number">6</span> sem_post(&amp;m);</span><br></pre></td></tr></table></figure>

<p>假设有两个线程的场景。第一个线程（线程 0）调用了 sem_wait()，它把信号量的值减为 0。然后，它只会在值小于 0 时等待。因为值是 0，调用线程从函数返回并继续，线程 0 现在可以自由进入临界区。线程 0 在临界区中，如果没有其他线程尝试获取锁，当它调用 sem_post()时，会将信号量重置为 1（因为没有等待线程，不会唤醒其他线程）。</p>
<p><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/w3.png" alt="?"></p>
<p>如果线程 0 持有锁（即调用了 sem_wait()之后，调用 sem_post()之前），另一个线程（线程 1）调用 sem_wait()尝试进入临界区，那么更有趣的情况就发生了。这种情况下，线程 1把信号量减为−1，然后等待（自己睡眠，放弃处理器）。线程 0 再次运行，它最终调用sem_post()，将信号量的值增加到 0，唤醒等待的线程（线程 1），然后线程 1 就可以获取锁。线程 1 执行结束时，再次增加信号量的值，将它恢复为 1。</p>
<p>当线程 1 尝试获取已经被持有的锁时，陷入睡眠。只有线程 0 再次运行之后，线程 1 才可能会唤醒并继续运行。<br><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/w4.png" alt="?"></p>
<p><strong>因为锁只有两个状态（持有和没持有），所以这种用法有时也叫作二值信号量（binary semaphore）。</strong></p>
<h2 id="信号量用作条件变量"><a href="#信号量用作条件变量" class="headerlink" title="信号量用作条件变量"></a>信号量用作条件变量</h2><p>信号量也可以用在一个线程暂停执行，等待某一条件成立的场景。</p>
<p>例如，一个线程要等待一个链表非空，然后才能删除一个元素。在这种场景下，通常一个线程等待条件成立，另外一个线程修改条件并发信号给等待线程，从而唤醒等待线程。因为等待线程在等待某些条件（condition）发生变化，所以我们将信号量作为条件变量（condition variable）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">sem_t</span> s;</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="type">void</span> *</span><br><span class="line"><span class="number">4</span> child(<span class="type">void</span> *arg) &#123;</span><br><span class="line"><span class="number">5</span> <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line"><span class="number">6</span> sem_post(&amp;s); <span class="comment">// signal here: child is done</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">8</span> &#125;</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="type">int</span></span><br><span class="line"><span class="number">11</span> main(<span class="type">int</span> argc, <span class="type">char</span> *argv[]) &#123;</span><br><span class="line"><span class="number">12</span> sem_init(&amp;s, <span class="number">0</span>, X); <span class="comment">// what should X be?</span></span><br><span class="line"><span class="number">13</span> <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line"><span class="number">14</span> <span class="type">pthread_t</span> c;</span><br><span class="line"><span class="number">15</span> Pthread_create(c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">16</span> sem_wait(&amp;s); <span class="comment">// wait here for child</span></span><br><span class="line"><span class="number">17</span> <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line"><span class="number">18</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">19</span> &#125;</span><br></pre></td></tr></table></figure>

<p>信号量初始值应该是 0。有两种情况需要考虑。第一种，父线程创建了子线程，但是子线程并没有运行。这种情况下（见表 31.3），父线程调用 sem_wait()会先于子线程调用 sem_post()。我们希望父线程等待子线程运行。为此，唯一的办法是让信号量的值不大于 0。因此，0 为初值。父线程运行，将信号量减为−1，然后睡眠等待；子线程运行的时候，调用 sem_post()，信号量增加为 0，唤醒父线程，父线程然后从 sem_wait()返回，完成该程序。</p>
<p><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/w5.png" alt="?"></p>
<p>第二种情况是子线程在父线程调用 sem_wait()之前就运行结束（见表 31.4）。在这种情况下，子线程会先调用 sem_post()，将信号量从 0 增加到 1。然后当父线程有机会运行时，会调用sem_wait()，发现信号量的值为 1。于是父线程将信号量从 1 减为 0，没有等待，直接从sem_wait()返回，也达到了预期效果。</p>
<p><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/w6.png" alt="?"></p>
<h2 id="生产者-消费者（有界缓冲区）问题-1"><a href="#生产者-消费者（有界缓冲区）问题-1" class="headerlink" title="生产者/消费者（有界缓冲区）问题"></a>生产者/消费者（有界缓冲区）问题</h2><h3 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h3><p>第一次尝试解决该问题时，我们用两个信号量 empty 和 full 分别表示缓冲区空或者满。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">int</span> buffer[MAX];</span><br><span class="line"><span class="number">2</span> <span class="type">int</span> fill = <span class="number">0</span>;</span><br><span class="line"><span class="number">3</span> <span class="type">int</span> use = <span class="number">0</span>;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="number">6</span> buffer[fill] = value; <span class="comment">// line f1</span></span><br><span class="line"><span class="number">7</span> fill = (fill + <span class="number">1</span>) % MAX; <span class="comment">// line f2</span></span><br><span class="line"><span class="number">8</span> &#125;</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">11</span> <span class="type">int</span> tmp = buffer[use]; <span class="comment">// line g1</span></span><br><span class="line"><span class="number">12</span> use = (use + <span class="number">1</span>) % MAX; <span class="comment">// line g2</span></span><br><span class="line"><span class="number">13</span> <span class="keyword">return</span> tmp;</span><br><span class="line"><span class="number">14</span> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">sem_t</span> empty;</span><br><span class="line"><span class="number">2</span> <span class="type">sem_t</span> full;</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">5</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">7</span> sem_wait(&amp;empty);</span><br><span class="line"><span class="comment">// line P1</span></span><br><span class="line"><span class="number">8</span> put(i);</span><br><span class="line"><span class="comment">// line P2</span></span><br><span class="line"><span class="number">9</span> sem_post(&amp;full);</span><br><span class="line"><span class="comment">// line P3</span></span><br><span class="line"><span class="number">10</span> &#125;</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">14</span> <span class="type">int</span> i, tmp = <span class="number">0</span>;</span><br><span class="line"><span class="number">15</span> <span class="keyword">while</span> (tmp != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="number">16</span> sem_wait(&amp;full);</span><br><span class="line"><span class="comment">// line C1</span></span><br><span class="line"><span class="number">17</span> tmp = get();</span><br><span class="line"><span class="comment">// line C2</span></span><br><span class="line"><span class="number">18</span> sem_post(&amp;empty);</span><br><span class="line"><span class="comment">// line C3</span></span><br><span class="line"><span class="number">19</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line"><span class="number">20</span> &#125;</span><br><span class="line"><span class="number">21</span> &#125;</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="number">24</span> <span class="comment">// ...</span></span><br><span class="line"><span class="number">25</span> sem_init(&amp;empty, <span class="number">0</span>, MAX); <span class="comment">// MAX buffers are empty to begin with...</span></span><br><span class="line"><span class="number">26</span> sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// ... and 0 are full</span></span><br><span class="line"><span class="number">27</span> <span class="comment">// ...</span></span><br><span class="line"><span class="number">28</span> &#125;</span><br></pre></td></tr></table></figure>

<p>假设 MAX=1<br>假设有两个线程，一个生产者和一个消费者。我们来看在一个 CPU 上的具体场景。消费者先运行，执行到 C1 行，调用 sem_wait(&amp;full)。因为 full 初始值为 0，wait 调用会将 full减为−1，导致消费者睡眠，等待另一个线程调用 sem_post(&amp;full)，符合预期。</p>
<p>假设生产者然后运行。执行到 P1 行，调用 sem_wait(&amp;empty)。不像消费者，生产者将继续执行，因为 empty 被初始化为 MAX（在这里是 1）。因此，empty 被减为 0，生产者向缓冲区中加入数据，然后执行 P3 行，调用 sem_post(&amp;full)，把 full 从−1 变成 0，唤醒消费者（即将它从阻塞变成就续）。</p>
<p>在这种情况下，可能会有两种情况。如果生产者继续执行，再次循环到 P1 行，由于 empty值为 0，它会阻塞。如果生产者被中断，而消费者开始执行，调用 sem_wait(&amp;full)（c1 行），发现缓冲区确实满了，消费它。这两种情况都是符合预期的。</p>
<p>假设两个生产者（Pa 和 Pb）几乎同时调用 put()。当 Pa 先运行，在 f1 行先加入第一条数据（fill=0），假设 Pa 在将 fill 计数器更新为 1 之前被中断，Pb开始运行，也在 f1 行给缓冲区的 0 位置加入一条数据，这意味着那里的老数据被覆盖！这可不行，我们不能让生产者的数据丢失。</p>
<h3 id="解决方案：增加互斥"><a href="#解决方案：增加互斥" class="headerlink" title="解决方案：增加互斥"></a>解决方案：增加互斥</h3><p><strong>向缓冲区加入元素和增加缓冲区的索引是临界区，需要小心保护起来。所以，我们使用二值信号量来增加锁。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">sem_t</span> empty;</span><br><span class="line"><span class="number">2</span> <span class="type">sem_t</span> full;</span><br><span class="line"><span class="number">3</span> <span class="type">sem_t</span> mutex;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">6</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">7</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">8</span> sem_wait(&amp;mutex);</span><br><span class="line"><span class="comment">// line p0 (NEW LINE)</span></span><br><span class="line"><span class="number">9</span> sem_wait(&amp;empty);</span><br><span class="line"><span class="comment">// line p1</span></span><br><span class="line"><span class="number">10</span> put(i);</span><br><span class="line"><span class="comment">// line p2</span></span><br><span class="line"><span class="number">11</span> sem_post(&amp;full);</span><br><span class="line"><span class="comment">// line p3</span></span><br><span class="line"><span class="number">12</span> sem_post(&amp;mutex);</span><br><span class="line"><span class="comment">// line p4 (NEW LINE)</span></span><br><span class="line"><span class="number">13</span> &#125;</span><br><span class="line"><span class="number">14</span> &#125;</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> <span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">17</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">19</span> sem_wait(&amp;mutex);</span><br><span class="line"><span class="comment">// line c0 (NEW LINE)</span></span><br><span class="line"><span class="number">20</span> sem_wait(&amp;full);</span><br><span class="line"><span class="comment">// line c1</span></span><br><span class="line"><span class="number">21</span> <span class="type">int</span> tmp = get();</span><br><span class="line"><span class="comment">// line c2</span></span><br><span class="line"><span class="number">22</span> sem_post(&amp;empty);</span><br><span class="line"><span class="comment">// line c3</span></span><br><span class="line"><span class="number">23</span> sem_post(&amp;mutex);</span><br><span class="line"><span class="comment">// line c4 (NEW LINE)</span></span><br><span class="line"><span class="number">24</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line"><span class="number">25</span> &#125;</span><br><span class="line"><span class="number">26</span> &#125;</span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="number">29</span> <span class="comment">// ...</span></span><br><span class="line"><span class="number">30</span> sem_init(&amp;empty, <span class="number">0</span>, MAX); <span class="comment">// MAX buffers are empty to begin with...</span></span><br><span class="line"><span class="number">31</span> sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// ... and 0 are full</span></span><br><span class="line"><span class="number">32</span> sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// mutex=1 because it is a lock (NEW LINE)</span></span><br><span class="line"><span class="number">33</span> <span class="comment">// ...</span></span><br><span class="line"><span class="number">34</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么会发生死锁？</strong></p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>假设有两个线程，一个生产者和一个消费者。消费者首先运行，获得锁（c0 行），然后对 full 信号量执行 sem_wait() （c1 行）。因为还没有数据，所以消费者阻塞，让出 CPU。但是，重要的是，此时消费者仍然持有锁。</p>
<p>然后生产者运行。假如生产者能够运行，它就能生产数据并唤醒消费者线程。遗憾的是，它首先对二值互斥信号量调用 sem_wait()（p0 行）。锁已经被持有，因此生产者也被卡住。</p>
<p>这里出现了一个循环等待。消费者持有互斥量，等待在 full 信号量上。生产者可以发送full 信号，却在等待互斥量。因此，生产者和消费者互相等待对方——典型的死锁。</p>
<h3 id="最后，可行的方案"><a href="#最后，可行的方案" class="headerlink" title="最后，可行的方案"></a>最后，可行的方案</h3><p>把获取和释放互斥量的操作调整为紧挨着临界区，把 full、empty 的唤醒和等待操作调整到锁外面。结果得到了简单而有效的有界缓冲区，多线程程序的常用模式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">sem_t</span> empty;</span><br><span class="line"><span class="number">2</span> <span class="type">sem_t</span> full;</span><br><span class="line"><span class="number">3</span> <span class="type">sem_t</span> mutex;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">6</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">7</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">8</span> sem_wait(&amp;empty);</span><br><span class="line"><span class="comment">// line p1</span></span><br><span class="line"><span class="number">9</span> sem_wait(&amp;mutex);</span><br><span class="line"><span class="comment">// line p1.5 (MOVED MUTEX HERE...)</span></span><br><span class="line"><span class="number">10</span> put(i);</span><br><span class="line"><span class="comment">// line p2</span></span><br><span class="line"><span class="number">11</span> sem_post(&amp;mutex);</span><br><span class="line"><span class="comment">// line p2.5 (... AND HERE)</span></span><br><span class="line"><span class="number">12</span> sem_post(&amp;full);</span><br><span class="line"><span class="comment">// line p3</span></span><br><span class="line"><span class="number">13</span> &#125;</span><br><span class="line"><span class="number">14</span> &#125;</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> <span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">17</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">19</span> sem_wait(&amp;full);</span><br><span class="line"><span class="comment">// line c1</span></span><br><span class="line"><span class="number">20</span> sem_wait(&amp;mutex);</span><br><span class="line"><span class="comment">// line c1.5 (MOVED MUTEX HERE...)</span></span><br><span class="line"><span class="number">21</span> <span class="type">int</span> tmp = get();</span><br><span class="line"><span class="comment">// line c2</span></span><br><span class="line"><span class="number">22</span> sem_post(&amp;mutex);</span><br><span class="line"><span class="comment">// line c2.5 (... AND HERE)</span></span><br><span class="line"><span class="number">23</span> sem_post(&amp;empty);</span><br><span class="line"><span class="comment">// line c3</span></span><br><span class="line"><span class="number">24</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line"><span class="number">25</span> &#125;</span><br><span class="line"><span class="number">26</span> &#125;</span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="number">29</span> <span class="comment">// ...</span></span><br><span class="line"><span class="number">30</span> sem_init(&amp;empty, <span class="number">0</span>, MAX); <span class="comment">// MAX buffers are empty to begin with...</span></span><br><span class="line"><span class="number">31</span> sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// ... and 0 are full</span></span><br><span class="line"><span class="number">32</span> sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// mutex=1 because it is a lock</span></span><br><span class="line"><span class="number">33</span> <span class="comment">// ...</span></span><br><span class="line"><span class="number">34</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="读者—写者锁"><a href="#读者—写者锁" class="headerlink" title="读者—写者锁"></a>读者—写者锁</h2><p>不同的数据结构访问可能需要不同类型的锁。</p>
<p>例如，一个并发链表有很多插入和查找操作。插入操作会修改链表的状态（因此传统的临界区有用），而查找操作只是读取该结构，只要没有进行插入操作，我们可以并发的执行多个查找操作。</p>
<p>如果某个线程要更新数据结构，需要调用 rwlock_acquire_lock()获得写锁，调用 rwlock_release_writelock()释放锁。内部通过一个 writelock 的信号量保证只有一个写者能获得锁进入临界区，从而更新数据结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rwlock_t</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">sem_t</span> lock; <span class="comment">// binary semaphore (basic lock)</span></span><br><span class="line"><span class="number">3</span> <span class="type">sem_t</span> writelock; <span class="comment">// used to allow ONE writer or MANY readers</span></span><br><span class="line"><span class="number">4</span> <span class="type">int</span> readers; <span class="comment">// count of readers reading in critical section</span></span><br><span class="line"><span class="number">5</span> &#125; <span class="type">rwlock_t</span>;</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="type">void</span> <span class="title function_">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line"><span class="number">8</span> rw-&gt;readers = <span class="number">0</span>;</span><br><span class="line"><span class="number">9</span> sem_init(&amp;rw-&gt;lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="number">10</span> sem_init(&amp;rw-&gt;writelock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line"><span class="number">14</span> sem_wait(&amp;rw-&gt;lock);</span><br><span class="line"><span class="number">15</span> rw-&gt;readers++;</span><br><span class="line"><span class="number">16</span> <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>)</span><br><span class="line"><span class="number">17</span> sem_wait(&amp;rw-&gt;writelock); <span class="comment">// first reader acquires writelock</span></span><br><span class="line"><span class="number">18</span> sem_post(&amp;rw-&gt;lock);</span><br><span class="line"><span class="number">19</span> &#125;</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span> <span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line"><span class="number">22</span> sem_wait(&amp;rw-&gt;lock);</span><br><span class="line"><span class="number">23</span> rw-&gt;readers--;</span><br><span class="line"><span class="number">24</span> <span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>)</span><br><span class="line"><span class="number">25</span> sem_post(&amp;rw-&gt;writelock); <span class="comment">// last reader releases writelock</span></span><br><span class="line"><span class="number">26</span> sem_post(&amp;rw-&gt;lock);</span><br><span class="line"><span class="number">27</span> &#125;</span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span> <span class="type">void</span> <span class="title function_">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line"><span class="number">30</span> sem_wait(&amp;rw-&gt;writelock);</span><br><span class="line"><span class="number">31</span> &#125;</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">33</span> <span class="type">void</span> <span class="title function_">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line"><span class="number">34</span> sem_post(&amp;rw-&gt;writelock);</span><br><span class="line"><span class="number">35</span> &#125;</span><br></pre></td></tr></table></figure>
<p>获取读锁时，读者首先要获取 lock，然后增加 reader变量，追踪目前有多少个读者在访问该数据结构。重要的步骤然后在 rwlock_acquire_readlock()内发生，当第一个读者获取该锁时。在这种情况下，读者也会获取写锁，即在 writelock 信号量上调用 sem_wait()，最后调用 sem_post()释放 lock。</p>
<p>一旦一个读者获得了读锁，其他的读者也可以获取这个读锁。但是，想要获取写锁的线程，就必须等到所有的读者都结束。最后一个退出的写者在“writelock”信号量上调用sem_post()，从而让等待的写者能够获取该锁。</p>
<p><strong>读者很容易饿死写者。有写者等待时，如何能够避免更多的读者进入并持有锁。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rwlock_t</span> &#123;</span></span><br><span class="line">    <span class="type">sem_t</span> lock;        <span class="comment">// binary semaphore (basic lock)</span></span><br><span class="line">    <span class="type">sem_t</span> writelock;   <span class="comment">// used to allow ONE writer or MANY readers</span></span><br><span class="line">    <span class="type">int</span> readers;       <span class="comment">// count of readers reading in critical section</span></span><br><span class="line">    <span class="type">int</span> writers_waiting; <span class="comment">// count of writers waiting for the write lock</span></span><br><span class="line">&#125; <span class="type">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    rw-&gt;readers = <span class="number">0</span>;</span><br><span class="line">    rw-&gt;writers_waiting = <span class="number">0</span>;</span><br><span class="line">    sem_init(&amp;rw-&gt;lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;rw-&gt;writelock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers++;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>)</span><br><span class="line">        sem_wait(&amp;rw-&gt;writelock); <span class="comment">// first reader acquires writelock</span></span><br><span class="line">    sem_post(&amp;rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;lock);</span><br><span class="line">    rw-&gt;readers--;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>)</span><br><span class="line">        sem_post(&amp;rw-&gt;writelock); <span class="comment">// last reader releases writelock</span></span><br><span class="line">    sem_post(&amp;rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;lock);</span><br><span class="line">    rw-&gt;writers_waiting++;</span><br><span class="line">    <span class="keyword">while</span> (rw-&gt;readers &gt; <span class="number">0</span> || sem_trywait(&amp;rw-&gt;writelock) != <span class="number">0</span>) &#123;</span><br><span class="line">        sem_post(&amp;rw-&gt;lock);</span><br><span class="line">        sem_wait(&amp;rw-&gt;writelock);</span><br><span class="line">        sem_wait(&amp;rw-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    rw-&gt;writers_waiting--;</span><br><span class="line">    sem_post(&amp;rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    sem_post(&amp;rw-&gt;writelock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><p><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/w7.png" alt="?"><br>假定有 5 位“哲学家”围着一个圆桌。每两位哲学家之间有一把餐叉（一共 5 把）。哲学家有时要思考一会，不需要餐叉；有时又要就餐。而一位哲学家只有同时拿到了左手边和右手边的两把餐叉，才能吃到东西。</p>
<p>每个哲学家的基本循环：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">think();</span><br><span class="line">getforks();</span><br><span class="line">eat();</span><br><span class="line">putforks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何实现 getforks()和 putforks()函数，保证没有死锁，没有哲学家饿死，并且并发度更高（尽可能让更多哲学家同时吃东西）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> p)</span> &#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> p)</span> &#123; <span class="keyword">return</span> (p + <span class="number">1</span>) % <span class="number">5</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>如果哲学家 p 希望用左手边的叉子，他们就调用 left(p)。类似地，右手边的叉子就用right(p)。模运算解决了最后一个哲学家（p = 4）右手边叉子的编号问题，就是餐叉 0。需要一些信号量来解决这个问题。假设需要 5 个，每个餐叉一个：sem_t forks[5]。</p>
<h3 id="有问题的解决方案"><a href="#有问题的解决方案" class="headerlink" title="有问题的解决方案"></a>有问题的解决方案</h3><p>假设我们把每个信号量（在 fork 数组中）都用 1 初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">getforks</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">2</span> sem_wait(forks[left(p)]);</span><br><span class="line"><span class="number">3</span> sem_wait(forks[right(p)]);</span><br><span class="line"><span class="number">4</span> &#125;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="type">void</span> <span class="title function_">putforks</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">7</span> sem_post(forks[left(p)]);</span><br><span class="line"><span class="number">8</span> sem_post(forks[right(p)]);</span><br><span class="line"><span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure>

<p>问题是死锁（deadlock）。假设每个哲学家都拿到了左手边的餐叉，他们每个都会阻塞住，并且一直等待另一个餐叉。具体来说，哲学家 0 拿到了餐叉 0，哲学家 1 拿到了餐叉 1，哲学家 2 拿到餐叉 2，哲学家 3 拿到餐叉 3，哲学家 4 拿到餐叉 4。所有的餐叉都被占有了，所有的哲学家都阻塞着，并且等待另一个哲学家占有的餐叉。</p>
<h3 id="一种方案：破除依赖"><a href="#一种方案：破除依赖" class="headerlink" title="一种方案：破除依赖"></a>一种方案：破除依赖</h3><p>修改某个或者某些哲学家的取餐叉顺序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">getforks</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">2</span> <span class="keyword">if</span> (p == <span class="number">4</span>) &#123;</span><br><span class="line"><span class="number">3</span> sem_wait(forks[right(p)]);</span><br><span class="line"><span class="number">4</span> sem_wait(forks[left(p)]);</span><br><span class="line"><span class="number">5</span> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">6</span> sem_wait(forks[left(p)]);</span><br><span class="line"><span class="number">7</span> sem_wait(forks[right(p)]);</span><br><span class="line"><span class="number">8</span> &#125;</span><br><span class="line"><span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何实现信号量"><a href="#如何实现信号量" class="headerlink" title="如何实现信号量"></a>如何实现信号量</h2><p>我们用底层的同步原语（锁和条件变量），来实现自己的信号量，名字叫作Zemaphore。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Zem_t</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> value;</span><br><span class="line"><span class="number">3</span> <span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="number">4</span> <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"><span class="number">5</span> &#125; Zem_t;</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="comment">// only one thread can call this</span></span><br><span class="line"><span class="number">8</span> <span class="type">void</span> <span class="title function_">Zem_init</span><span class="params">(Zem_t *s, <span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="number">9</span> s-&gt;value = value;</span><br><span class="line"><span class="number">10</span> Cond_init(&amp;s-&gt;cond);</span><br><span class="line"><span class="number">11</span> Mutex_init(&amp;s-&gt;lock);</span><br><span class="line"><span class="number">12</span> &#125;</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> <span class="type">void</span> <span class="title function_">Zem_wait</span><span class="params">(Zem_t *s)</span> &#123;</span><br><span class="line"><span class="number">15</span> Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line"><span class="number">16</span> <span class="keyword">while</span> (s-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="number">17</span> Cond_wait(&amp;s-&gt;cond, &amp;s-&gt;lock);</span><br><span class="line"><span class="number">18</span> s-&gt;value--;</span><br><span class="line"><span class="number">19</span> Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line"><span class="number">20</span> &#125;</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span> <span class="type">void</span> <span class="title function_">Zem_post</span><span class="params">(Zem_t *s)</span> &#123;</span><br><span class="line"><span class="number">23</span> Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line"><span class="number">24</span> s-&gt;value++;</span><br><span class="line"><span class="number">25</span> Cond_signal(&amp;s-&gt;cond);</span><br><span class="line"><span class="number">26</span> Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line"><span class="number">27</span> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="常见并发问题"><a href="#常见并发问题" class="headerlink" title="常见并发问题"></a>常见并发问题</h1><h2 id="有哪些类型的缺陷"><a href="#有哪些类型的缺陷" class="headerlink" title="有哪些类型的缺陷"></a>有哪些类型的缺陷</h2><p>研究集中在 4 个重要的开源应用：MySQL（流行的数据库管理系统）、Apache（著名的Web 服务器）、Mozilla（著名的 Web 浏览器）和 OpenOffice（微软办公套件的开源版本）。<br><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/w8.png" alt="?"></p>
<h2 id="非死锁缺陷"><a href="#非死锁缺陷" class="headerlink" title="非死锁缺陷"></a>非死锁缺陷</h2><p>违反原子性（atomicity violation）缺陷和错误顺序（order violation）缺陷。</p>
<h3 id="违反原子性缺陷"><a href="#违反原子性缺陷" class="headerlink" title="违反原子性缺陷"></a>违反原子性缺陷</h3><p>这是一个 MySQL 中出现的例子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> Thread <span class="number">1</span>::</span><br><span class="line"><span class="number">2</span> <span class="keyword">if</span> (thd-&gt;proc_info) &#123;</span><br><span class="line"><span class="number">3</span> ...</span><br><span class="line"><span class="number">4</span> <span class="built_in">fputs</span>(thd-&gt;proc_info, ...);</span><br><span class="line"><span class="number">5</span> ...</span><br><span class="line"><span class="number">6</span> &#125;</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span> Thread <span class="number">2</span>::</span><br><span class="line"><span class="number">9</span> thd-&gt;proc_info = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>这个例子中，两个线程都要访问 thd 结构中的成员 proc_info。第一个线程检查 proc_info非空，然后打印出值；第二个线程设置其为空。显然，当第一个线程检查之后，在 fputs()调用之前被中断，第二个线程把指针置为空；当第一个线程恢复执行时，由于引用空指针，导致程序奔溃。</p>
<p>违反原子性的定义是：“违反了多次内存访问中预期的可串行性（即代码段本意是原子的，但在执行中并没有强制实现原子性）”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">pthread_mutex_t</span> proc_info_lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> Thread <span class="number">1</span>::</span><br><span class="line"><span class="number">4</span> pthread_mutex_lock(&amp;proc_info_lock);</span><br><span class="line"><span class="number">5</span> <span class="keyword">if</span> (thd-&gt;proc_info) &#123;</span><br><span class="line"><span class="number">6</span> ...</span><br><span class="line"><span class="number">7</span> <span class="built_in">fputs</span>(thd-&gt;proc_info, ...);</span><br><span class="line"><span class="number">8</span> ...</span><br><span class="line"><span class="number">9</span> &#125;</span><br><span class="line"><span class="number">10</span> pthread_mutex_unlock(&amp;proc_info_lock);</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span> Thread <span class="number">2</span>::</span><br><span class="line"><span class="number">13</span> pthread_mutex_lock(&amp;proc_info_lock);</span><br><span class="line"><span class="number">14</span> thd-&gt;proc_info = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">15</span> pthread_mutex_unlock(&amp;proc_info_lock);</span><br></pre></td></tr></table></figure>

<h3 id="违反顺序缺陷"><a href="#违反顺序缺陷" class="headerlink" title="违反顺序缺陷"></a>违反顺序缺陷</h3><p>另一种常见的非死锁问题叫作违反顺序（order violation）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> Thread <span class="number">1</span>::</span><br><span class="line"><span class="number">2</span> <span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">3</span> ...</span><br><span class="line"><span class="number">4</span> mThread = PR_CreateThread(mMain, ...);</span><br><span class="line"><span class="number">5</span> ...</span><br><span class="line"><span class="number">6</span> &#125;</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span> Thread <span class="number">2</span>::</span><br><span class="line"><span class="number">9</span> <span class="type">void</span> <span class="title function_">mMain</span><span class="params">(...)</span> &#123;</span><br><span class="line"><span class="number">10</span> ...</span><br><span class="line"><span class="number">11</span> mState = mThread-&gt;State;</span><br><span class="line"><span class="number">12</span> ...</span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure>
<p>线程 2 的代码中似乎假定变量 mThread 已经被初始化了（不为空）。然而，如果线程 1 并没有首先执行，线程 2 就可能因为引用空指针奔溃（假设 mThread初始值为空；否则，可能会产生更加奇怪的问题，因为线程 2 中会读到任意的内存位置并引用）。</p>
<p>违反顺序更正式的定义是：“两个内存访问的预期顺序被打破了（即 A 应该在 B 之前执行，但是实际运行中却不是这个顺序）”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">pthread_mutex_t</span> mtLock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="number">2</span> <span class="type">pthread_cond_t</span> mtCond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="number">3</span> <span class="type">int</span> mtInit = <span class="number">0</span>;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> Thread <span class="number">1</span>::</span><br><span class="line"><span class="number">6</span> <span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">7</span> ...</span><br><span class="line"><span class="number">8</span> mThread = PR_CreateThread(mMain, ...);</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="comment">// signal that the thread has been created...</span></span><br><span class="line"><span class="number">11</span> pthread_mutex_lock(&amp;mtLock);</span><br><span class="line"><span class="number">12</span> mtInit = <span class="number">1</span>;</span><br><span class="line"><span class="number">13</span> pthread_cond_signal(&amp;mtCond);</span><br><span class="line"><span class="number">14</span> pthread_mutex_unlock(&amp;mtLock);</span><br><span class="line"><span class="number">15</span> ...</span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span> Thread <span class="number">2</span>::</span><br><span class="line"><span class="number">19</span> <span class="type">void</span> <span class="title function_">mMain</span><span class="params">(...)</span> &#123;</span><br><span class="line"><span class="number">20</span> ...</span><br><span class="line"><span class="number">21</span> <span class="comment">// wait for the thread to be initialized...</span></span><br><span class="line"><span class="number">22</span> pthread_mutex_lock(&amp;mtLock);</span><br><span class="line"><span class="number">23</span> <span class="keyword">while</span> (mtInit == <span class="number">0</span>)</span><br><span class="line"><span class="number">24</span> pthread_cond_wait(&amp;mtCond, &amp;mtLock);</span><br><span class="line"><span class="number">25</span> pthread_mutex_unlock(&amp;mtLock);</span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span> mState = mThread-&gt;State;</span><br><span class="line"><span class="comment">//mState = mThread-&gt;State; 在锁外部。这是因为这段代码没有修改任何共享资源或数据，所以没有必要在锁内部执行。</span></span><br><span class="line"><span class="number">28</span> ...</span><br><span class="line"><span class="number">29</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在这段修复的代码中，我们增加了一个锁（mtLock）、一个条件变量（mtCond）以及状态的变量（mtInit）。初始化代码运行时，会将 mtInit 设置为 1，并发出信号表明它已做了这件事。如果线程 2 先运行，就会一直等待信号和对应的状态变化；如果后运行，线程 2 会检查是否初始化（即 mtInit 被设置为 1），然后正常运行。请注意，我们可以用 mThread 本身作为状态变量，但为了简洁，我们没有这样做。当线程之间的顺序很重要时，条件变量（或信号量）能够解决问题。</p>
<h2 id="死锁缺陷"><a href="#死锁缺陷" class="headerlink" title="死锁缺陷"></a>死锁缺陷</h2><p>当线程 1 持有锁 L1，正在等待另外一个锁 L2，而线程 2 持有锁 L2，却在等待锁 L1 释放时，死锁就产生了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Thread <span class="number">1</span>: Thread <span class="number">2</span>:</span><br><span class="line">lock(L1); lock(L2);</span><br><span class="line">lock(L2); lock(L1);</span><br></pre></td></tr></table></figure>
<p>这段代码运行时，不是一定会出现死锁的。当线程 1 占有锁 L1，上下文切换到线程 2。线程 2 锁住 L2，试图锁住 L1。这时才产生了死锁，两个线程互相等待。如图 32.1 所示，其中的圈（cycle）表明了死锁。<br><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/w9.png" alt="?"></p>
<h3 id="为什么发生死锁"><a href="#为什么发生死锁" class="headerlink" title="为什么发生死锁"></a>为什么发生死锁</h3><p>只要线程 1 和线程 2 都用相同的抢锁顺序，死锁就不会发生。那么，死锁为什么还会发生？</p>
<p>其中一个原因是在大型的代码库里，组件之间会有复杂的依赖。以操作系统为例。虚拟内存系统在需要访问文件系统才能从磁盘读到内存页；文件系统随后又要和虚拟内存交互，去申请一页内存，以便存放读到的块。因此，在设计大型系统的锁机制时，你必须要仔细地去避免循环依赖导致的死锁。</p>
<p>另一个原因是封装（encapsulation）。软件开发者一直倾向于隐藏实现细节，以模块化的方式让软件开发更容易。然而，模块化和锁不是很契合。</p>
<h3 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h3><p>互斥：线程对于需要的资源进行互斥的访问（例如一个线程抢到锁）。</p>
<p>持有并等待：线程持有了资源（例如已将持有的锁），同时又在等待其他资源（例如，需要获得的锁）。</p>
<p>非抢占：线程获得的资源（例如锁），不能被抢占。</p>
<p>循环等待：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的。</p>
<p><strong>如果这 4 个条件的任何一个没有满足，死锁就不会产生。</strong></p>
<h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><h4 id="循环等待"><a href="#循环等待" class="headerlink" title="循环等待"></a>循环等待</h4><p>获取锁时提供一个全序（total ordering）。假如系统共有两个锁（L1 和 L2），那么我们每次都先申请 L1 然后申请 L2，就可以避免死锁。这样严格的顺序避免了循环等待，也就不会产生死锁。</p>
<p>更复杂的系统中不会只有两个锁，锁的全序可能很难做到。因此，偏序（partial ordering）可能是一种有用的方法，安排锁的获取并避免死锁。Linux 中的内存映射代码就是一个偏序锁的好例子。代码开头的注释表明了 10 组不同的加锁顺序，包括简单的关系，比如 i_mutex 早于 i_mmap_mutex，也包括复杂的关系，比如 i_mmap_mutex 早于private_lock，早于 swap_lock，早于 mapping-&gt;tree_lock。</p>
<blockquote>
<p>提示：通过锁的地址来强制锁的顺序<br>为了避免这种特殊问题，聪明的程序员根据锁的地址作为获取锁的顺序。按照地址从高到低，或者从低到高的顺序加锁，do_something()函数就可以保证不论传入参数是什么顺序，函数都会用固定的顺序加锁。具体的代码如下</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m1 &gt; m2) &#123; <span class="comment">// grab locks in high-to-low address order</span></span><br><span class="line">pthread_mutex_lock(m1);</span><br><span class="line">pthread_mutex_lock(m2);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pthread_mutex_lock(m2);</span><br><span class="line">pthread_mutex_lock(m1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Code assumes that m1 != m2 (it is not the same lock)</span></span><br></pre></td></tr></table></figure>

<h4 id="持有并等待"><a href="#持有并等待" class="headerlink" title="持有并等待"></a>持有并等待</h4><p>死锁的持有并等待条件，可以通过原子地抢锁来避免。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> lock(prevention);</span><br><span class="line"><span class="number">2</span> lock(L1);</span><br><span class="line"><span class="number">3</span> lock(L2);</span><br><span class="line"><span class="number">4</span> ...</span><br><span class="line"><span class="number">5</span> unlock(prevention);</span><br></pre></td></tr></table></figure>
<p>先抢到 prevention 这个锁之后，代码保证了在抢锁的过程中，不会有不合时宜的线程切换，从而避免了死锁。当然，这需要任何线程在任何时候抢占锁时，先抢到全局的 prevention锁。例如，如果另一个线程用不同的顺序抢锁 L1 和 L2，也不会有问题，因为此时，线程已经抢到了 prevention 锁。</p>
<h4 id="非抢占"><a href="#非抢占" class="headerlink" title="非抢占"></a>非抢占</h4><p>在调用 unlock 之前，都认为锁是被占有的，多个抢锁操作通常会带来麻烦，因为我们等待一个锁时，同时持有另一个锁。很多线程库提供更为灵活的接口来避免这种情况。具体来说，trylock()函数会尝试获得锁，或者返回−1，表示锁已经被占有。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> top:</span><br><span class="line"><span class="number">2</span> lock(L1);</span><br><span class="line"><span class="number">3</span> <span class="keyword">if</span> (trylock(L2) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="number">4</span> unlock(L1);</span><br><span class="line"><span class="number">5</span> <span class="keyword">goto</span> top;</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure>
<p>注意，另一个线程可以使用相同的加锁方式，但是不同的加锁顺序（L2 然后 L1），程序仍然不会产生死锁。但是会引来一个新的问题：活锁（livelock）。两个线程有可能一直重复这一序列，又同时都抢锁失败。这种情况下，系统一直在运行这段代码（因此不是死锁），但是又不会有进展，因此名为活锁。也有活锁的解决方法：例如，可以在循环结束<br>的时候，先随机等待一个时间，然后再重复整个动作，这样可以降低线程之间的重复互相干扰。</p>
<h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p><strong>通过强大的硬件指令，我们可以构造出不需要锁的数据结构。</strong><br>比较并交换（compare-and-swap）指令，是一种由硬件提供的原子指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">int</span> <span class="title function_">CompareAndSwap</span><span class="params">(<span class="type">int</span> *address, <span class="type">int</span> expected, <span class="type">int</span> new)</span> &#123;</span><br><span class="line"><span class="number">2</span> <span class="keyword">if</span> (*address == expected) &#123;</span><br><span class="line"><span class="number">3</span> *address = new;</span><br><span class="line"><span class="number">4</span> <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// success</span></span><br><span class="line"><span class="number">5</span> &#125;</span><br><span class="line"><span class="number">6</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// failure</span></span><br><span class="line"><span class="number">7</span> &#125;</span><br></pre></td></tr></table></figure>
<p>假定我们想原子地给某个值增加特定的数量。我们可以这样实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">AtomicIncrement</span><span class="params">(<span class="type">int</span> *value, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line"><span class="number">2</span> <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">3</span> <span class="type">int</span> old = *value;</span><br><span class="line"><span class="number">4</span> &#125; <span class="keyword">while</span> (CompareAndSwap(value, old, old + amount) == <span class="number">0</span>);</span><br><span class="line"><span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure>

<p>考虑一个更复杂的例子：链表插入。这是在链表头部插入元素的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="number">2</span> <span class="type">node_t</span> *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line"><span class="number">3</span> assert(n != <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">4</span> n-&gt;value = value;</span><br><span class="line"><span class="number">5</span> n-&gt;next = head;</span><br><span class="line"><span class="number">6</span> head = n;</span><br><span class="line"><span class="number">7</span> &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过给相关代码加锁，来解决这个问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="number">2</span> <span class="type">node_t</span> *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line"><span class="number">3</span> assert(n != <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">4</span> n-&gt;value = value;</span><br><span class="line"><span class="number">5</span> lock(listlock); <span class="comment">// begin critical section</span></span><br><span class="line"><span class="number">6</span> n-&gt;next = head;</span><br><span class="line"><span class="number">7</span> head = n;</span><br><span class="line"><span class="number">8</span> unlock(listlock); <span class="comment">// end of critical section</span></span><br><span class="line"><span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure>
<p>用比较并交换指令（compare-and-swap)来实现插入操作。一种可能的实现是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="number">2</span> <span class="type">node_t</span> *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line"><span class="number">3</span> assert(n != <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">4</span> n-&gt;value = value;</span><br><span class="line"><span class="number">5</span> <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">6</span> n-&gt;next = head;</span><br><span class="line"><span class="number">7</span> &#125; <span class="keyword">while</span> (CompareAndSwap(&amp;head, n-&gt;next, n) == <span class="number">0</span>);</span><br><span class="line"><span class="number">8</span> &#125;</span><br></pre></td></tr></table></figure>
<p>首先把 next 指针指向当前的链表头（head），然后试着把新节点交换到链表头。但是，如果此时其他的线程成功地修改了 head 的值，这里的交换就会失败，导致这个线程根据新的 head 值重试。</p>
<h3 id="通过调度避免死锁"><a href="#通过调度避免死锁" class="headerlink" title="通过调度避免死锁"></a>通过调度避免死锁</h3><p>除了死锁预防，某些场景更适合死锁避免（avoidance）。<br>我们需要了解全局的信息，包括不同线程在运行中对锁的需求情况，从而使得后续的调度能够避免产生死锁。<br><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/e1.png" alt="?"><br>一种比较聪明的调度方式是，只要 T1 和 T2 不同时运行，就不会产生死锁。下面就是这种方式：<br><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/e2.png" alt="?"><br>请注意，T3 和 T1 重叠，或者和 T2 重叠都是可以的。虽然 T3 会抢占锁 L2，但是由于它只用到一把锁，和其他线程并发执行都不会产生死锁。</p>
<p>另一个竞争更多的例子。在这个例子中，对同样的资源（又是锁 L1 和 L2）有更多的竞争。<br><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/e3.png" alt="?"><br>线程 T1、T2 和 T3 执行过程中，都需要持有锁 L1 和 L2。下面是一种不会产生死锁的可行方案：<br><img src="/2023/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%B9%B6%E5%8F%91/e4.png" alt="?"><br>这种保守的静态方案会明显增加完成任务的总时间。尽管有可能并发运行这些任务，但为了避免死锁，我们没有这样做，付出了性能的代价。</p>
<h3 id="检查和恢复"><a href="#检查和恢复" class="headerlink" title="检查和恢复"></a>检查和恢复</h3><p>很多数据库系统使用了死锁检测和恢复技术。死锁检测器会定期运行，通过构建资源图来检查循环。当循环（死锁）发生时，系统需要重启。如果还需要更复杂的数据结构相关的修复，那么需要人工参与。</p>
]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统导论-内存虚拟化</title>
    <url>/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="抽象-地址空间"><a href="#抽象-地址空间" class="headerlink" title="抽象:地址空间"></a>抽象:地址空间</h1><h2 id="早期系统"><a href="#早期系统" class="headerlink" title="早期系统"></a>早期系统</h2><p>从内存来看，早期的机器并没有提供多少抽象给用户。</p>
<p>操作系统曾经是一组函数（实际上是一个库），在内存中（在本例中，从物理地址 0 开始），然后有一个正在运行的程序（进程），目前在物理内存中（在本例中，从物理地址 64KB 开始），并使用剩余的内存。这里几乎没有抽象，用户对操作系统的要求也不多。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/q1.png" alt="?"></p>
<h2 id="多道程序和时分共享"><a href="#多道程序和时分共享" class="headerlink" title="多道程序和时分共享"></a>多道程序和时分共享</h2><p>由于机器昂贵，多道程序（multiprogramming）系统时代开启，其中多个进程在给定时间准备运行，比如当有一个进程在等待 I/O 操作的时候，操作系统会切换这些进程，这样增加了 CPU 的有效利用率（utilization）。</p>
<p>但很快，人们开始对机器要求更多，分时系统的时代诞生了,他们厌倦了长时间的（因此也是低效率的）编程—调试循环。交互性（interactivity）变得很重要，因为许多用户可能同时在使用机器，每个人都在等待（或希望）他们执行的任务及时响应。</p>
<p>一种实现时分共享的方法，是让一个进程单独占用全部内存运行一小段时间，然后停止它，并将它所有的状态信息保存在磁盘上（包含所有的物理内存），加载其他进程的状态信息，再运行一段时间，这就实现了某种比较粗糙的机器共享。</p>
<p>将全部的内存信息保存到磁盘就太慢了。因此，在进程切换的时候，我们仍然将进程信息放在内存中，这样操作系统可以更有效率地实现时分共享。</p>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/q2.png" alt="?"><br>有 3 个进程（A、B、C），每个进程拥有从512KB 物理内存中切出来给它们的一小部分内存。假定只有一个 CPU，操作系统选择运行其中一个进程（比如 A），同时其他进程（B 和 C）则在队列中等待运行。</p>
<p>多个程序同时驻留在内存中，使保护（protection）成为重要问题。人们不希望一个进程可以读取其他进程的内存，更别说修改了。</p>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>操作系统需要提供一个易用（easy to use）的物理内存抽象。这个抽象叫作地址空间（address space），是运行的程序看到的系统中的内存。</p>
<p>一个进程的地址空间包含运行的程序的所有内存状态。比如：程序的代码（code，指令）必须在内存中，因此它们在地址空间里。当程序在运行的时候，利用栈（stack）来保存当前的函数调用信息，分配空间给局部变量，传递参数和函数返回值。最后，堆（heap）用于管理动态分配的、用户管理的内存，就像你从 C 语言中调用 malloc()或面向对象语言（如 C ++或 Java）中调用 new 获得内存。当然，还有其他的东西（例如，静态初始化的变量），但现在假设只有这 3 个部分：代码、栈和堆。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/q3.png" alt="?"><br>程序代码位于地址空间的顶部（在本例中从 0 开始，并且装入到地址空间<br>的前 1KB）。代码是静态的（因此很容易放在内存中），所以可以将它放在地址空间的顶部，我们知道程序运行时不再需要新的空间。</p>
<p><strong>当我们描述地址空间时，所描述的是操作系统提供给运行程序的抽象（abstract）。程序不在物理地址 0～16KB 的内存中，而是加载在任意的物理地址。</strong></p>
<p>操作系统在单一的物理内存上为多个运行的进程（所有进程共享内存）构建一个私有的、可能很大的地址空间的抽象。当操作系统这样做时，我们说操作系统在虚拟化内存（virtualizing memory）。</p>
<p><strong>通过内存隔离，操作系统进一步确保运行程序不会影响底层操作系统的操作。一些现代操作系统通过将某些部分与操作系统的其他部分分离，实现进一步的隔离。这样的微内核（microkernel）可以比整体内核提供更大的可靠性。</strong></p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>虚拟内存（VM）系统的一个主要目标是<strong>透明</strong>（transparency）。操作系统实现虚拟内存的方式，应该让运行的程序看不见。因此，程序不应该感知到内存被虚拟化的事实，相反，程序的行为就好像它拥有自己的私有物理内存。在幕后，操作系统（和硬件）完成了所有的工作，让不同的工作复用内存，从而实现这个假象。</p>
<p>虚拟内存的另一个目标是<strong>效率</strong>（efficiency）。操作系统应该追求虚拟化尽可能高效（efficient），包括时间上（即不会使程序运行得更慢）和空间上（即不需要太多额外的内存来支持虚拟化）。在实现高效率虚拟化时，操作系统将不得不依靠硬件支持，包括 TLB 这样的硬件功能（我们将在适当的时候学习）。</p>
<p>虚拟内存第三个目标是<strong>保护</strong>（protection）。操作系统应确保进程受到保护（protect），不会受其他进程影响，操作系统本身也不会受进程影响。当一个进程执行加载、存储或指令提取时，它不应该以任何方式访问或影响任何其他进程或操作系统本身的内存内容（即在它的地址空间之外的任何内容）。因此，保护让我们能够在进程之间提供隔离（isolation）的特性，每个进程都应该在自己的独立环境中运行，避免其他出错或恶意进程的影响。</p>
<p><strong>在一个程序中打印出一个地址，那就是一个虚拟的地址。虚拟地址只是提供地址如何在内存中分布的假象，只有操作系统（和硬件）才知道物理地址。</strong></p>
<p><strong>c语言存储了程序的指令和常量数据。函数的代码在程序被编译后会被存储在代码区，函数地址就是指向函数在代码区的位置。</strong></p>
<hr>
<h1 id="插叙-内存操作API"><a href="#插叙-内存操作API" class="headerlink" title="插叙:内存操作API"></a>插叙:内存操作API</h1><h2 id="内存类型"><a href="#内存类型" class="headerlink" title="内存类型"></a>内存类型</h2><p>在运行一个 C 程序的时候，会分配两种类型的内存。</p>
<p>第一种称为栈内存，它的申请和释放操作是编译器来隐式管理的，所以有时也称为自动（automatic）内存。</p>
<p>第二种叫堆（heap）内存，其中所有的申请和释放操作都由程序员显式地完成。</p>
<blockquote>
<p>int *x = (int *) malloc(sizeof(int));<br>注意到栈和堆的分配都发生在这一行：首先编译器看到指针的声明（int * x）时，知道为一个整型指针分配空间，随后，当程序调用 malloc()时，它会在堆上请求整数的空间，函数返回这样一个整数的地址（成功时，失败时则返回 NULL），然后将其存储在栈中以供程序使用。</p>
</blockquote>
<h2 id="malloc-调用"><a href="#malloc-调用" class="headerlink" title="malloc()调用"></a>malloc()调用</h2><p>malloc 函数非常简单：传入要申请的堆空间的大小，它成功就返回一个指向新申请空间的指针，失败就返回 NULL。</p>
<p>只需要包含头文件 stdlib.h 就可以使用 malloc 了。但实际上，甚至都不需这样做，因为 C 库是 C 程序默但链接的，其中就有 mallock()的代码，加上这个头文件只是让编译器检查你是否正确调用了 malloc()。</p>
<h2 id="free-调用"><a href="#free-调用" class="headerlink" title="free()调用"></a>free()调用</h2><p>没什么讲的</p>
<h2 id="底层操作系统支持"><a href="#底层操作系统支持" class="headerlink" title="底层操作系统支持"></a>底层操作系统支持</h2><p><strong>malloc()和 free()不是系统调用，而是库调用。</strong><br>malloc库负责管理虚拟地址空间内的内存空间，但它本身是通过调用操作系统的一些系统调用来实现的。这些系统调用会进入操作系统，来请求本多内存或者将一些内容释放回系统。</p>
<p>一个这样的系统调用叫作 brk，它被用来改变程序分断（break）的位置：堆结束的位置。它需要一个参数（新分断的地址），从而根据新分断是大于还是小于当前分断，来增加或减小堆的大小。另一个调用 sbrk 要求传入一个增量，但目的是类似的。</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>1.首先,编写一个名为 null.c 的简单程序,它创建一个指向整数的指针,将其设置为 NULL,然后尝试对其进行释放内存操作。把它编译成一个名为 null 的可执行文件。当你运行这个程序时会发生什么?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>什么都没发生……</p>
</blockquote>
<p>4.编写一个使用 malloc()来分配内存的简单程序,但在退出之前忘记释放它。这个程序运行时会发生什么?你可以用 gdb 来查找它的任何问题吗?用 valgrind 呢(再次使用–leak-check=yes 标志)?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.编写一个程序,使用 malloc 创建一个名为 data、大小为 100 的整数数组。然后,将 data[100]设置为 0。当你运行这个程序时会发生什么?当你使用 valgrind 运行这个程序时会发生什么?程序是否正确?</p>
<blockquote>
<p>还是什么都没发生……<br>但是1,没有释放指针内存泄漏.<br>2,Invalid write 无效写入,数组越界</p>
</blockquote>
<p>6.创建一个分配整数数组的程序(如上所述),释放它们,然后尝试打印数组中某个元素的值。程序会运行吗?当你使用 valgrind时会发生什么?</p>
<blockquote>
<p>程序会正常运行<br>使用 free 时,<br>不会改变被释放变量本身的值，调用 free() 后它仍然会指向相同的内存空间,但是此时该内存已无效<br>free 并不会覆盖释放的内存, 所以读取时仍然能读取到数值</p>
</blockquote>
<h1 id="机制-地址转换"><a href="#机制-地址转换" class="headerlink" title="机制:地址转换"></a>机制:地址转换</h1><p>在实现 CPU 虚拟化时，我们遵循的一般准则被称为受限直接访问（Limited Direct Execution，LDE）。LDE 背后的想法很简单：让程序运行的大部分指令直接访问硬件，只在一些关键点（如进程发起系统调用或发生时钟中断）由操作系统介入来确保“在正确时间，正确的地点，做正确的事”。</p>
<p>为了实现高效的虚拟化，操作系统应该尽量让程序自己运行，同时通过在关键点的及时介入（interposing），来保持对硬件的控制。高效和控制是现代操作系统的两个主要目标。</p>
<ol>
<li><p>高效决定了我们要利用硬件的支持，这在开始的时候非常初级（如使用一些寄存器），但会变得相当复杂（比如我们会讲到的 TLB、页表等）。</p>
</li>
<li><p>控制意味着操作系统要确保应用程序只能访问它自己的内存空间。因此，要保护应用程序不会相互影响，也不会影响操作系统，我们需要硬件的帮助。</p>
</li>
<li><p>最后，我们对虚拟内存还有一点要求，即灵活性。具体来说，我们希望程序能以任何方式访问它自己的地址空间，从而让系统更容易编程。</p>
</li>
</ol>
<p><strong>利用地址转换，硬件对每次内存访问进行处理（即指令获取、数据读取或写入），将指令中的虚拟（virtual）地址转换为数据实际存储的物理（physical）地址。因此，在每次内存引用时，硬件都会进行地址转换，将应用程序的内存引用重定位到内存中实际的位置。</strong></p>
<p>假象：每个程序都拥有私有的内存，那里存放着它自己的代码和数据。虚拟现实的背后是丑陋的物理事实：许多程序其实是在同一时间共享着内存，就像 CPU（或多个 CPU）在不同的程序间切换运行。</p>
<h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p>我们先假设用户的地址空间必须连续地放在物理内存中。假设地址空间不是很大，小于物理内存的大小。最后，假设每个地址空间的大小完全一样。</p>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>C 语言形式:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">x = x + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>对应的x86 汇编:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl 0x0(%ebx), %eax;</span><br><span class="line">addl $0x03, %eax ;</span><br><span class="line">movl %eax, 0x0(%ebx);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>0x0(%ebx)表示以%ebx寄存器中的值作为基址，偏移地址为0x0，即从%ebx指向的内存地址开始读取或写入数据。</p>
</blockquote>
<p>在虚拟内存中，硬件可以介入到每次内存访问中，将进程提供的虚拟地址转换为数据实际存储的物理地址。</p>
<p>在图中，可以看到代码和数据都位于进程的地址空间，3 条指令序列位于地址 128（靠近头部的代码段），变量 x 的值位于地址 15KB（在靠近底部的栈中）。如图所示，x的初始值是 3000。</p>
<p>如果这 3 条指令执行，从进程的角度来看，发生了以下几次内存访问：<br>从地址 128 获取指令；<br>执行指令（从地址 15KB 加载数据）；<br>从地址 132 获取命令；<br>执行命令（没有内存访问）；<br>从地址 135 获取指令；<br>执行指令（新值存入地址 15KB）。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/q4.png" alt="?"><br>从程序的角度来看，它的地址空间（address space）从 0 开始到 16KB 结束。它包含的所有内存引用都应该在这个范围内。然而，对虚拟内存来说，操作系统希望将这个进程地址空间放在物理内存的其他位置，并不一定从地址 0 开始。</p>
<p>图 15.2 展示了一个例子，说明这个进程的地址空间被放入物理内存后可能的样子。从图 中可以看到，操作系统将第一块物理内存留给了自己，并将上述例子中的进程地址空间重定位到从 32KB 开始的物理内存地址。剩下的两块内存空闲（16～32KB 和 48～64KB）。</p>
<h2 id="动态（基于硬件）重定位"><a href="#动态（基于硬件）重定位" class="headerlink" title="动态（基于硬件）重定位"></a>动态（基于硬件）重定位</h2><p>它在首次出现的时分机器中引入，那时只是一个简单的思想，称为基址加界限机制（base and bound），有时又称为动态重定位（dynamic relocation），我们将互换使用这两个术语。</p>
<p><strong>每个 CPU 需要两个硬件寄存器：基址（base）寄存器和界限（bound）寄存器，有时称为限制（limit）寄存器。这组基址和界限寄存器，让我们能够将地址空间放在物理内存的任何位置，同时又能确保进程只能访问自己的地址空间。</strong></p>
<p><strong>physical address = virtual address + base</strong> 没有算偏移量<br>物理地址=（虚拟地址-偏移量）+基地址。</p>
<p><strong>进程中使用的内存引用都是虚拟地址（virtual address），硬件接下来将虚拟地址加上基址寄存器中的内容，得到物理地址（physical address），再发给内存系统。</strong></p>
<blockquote>
<p>补充：基于软件的重定位<br>例如，程序中有一条指令是从地址 1000 加载到寄存器（即 movl 1000，%eax），当整个程序的地址空间被加载到从 3000（不是程序认为的 0）开始的物理地址中，加载程序会重写指令中的地址（即 movl 4000, %eax），从而完成简单的静态重定位。</p>
</blockquote>
<blockquote>
<p>静态重定位有许多问题，首先也是最重要的是不提供访问保护，进程中的错误地址可能导致对其他进程或操作系统内存的非法访问，一般来说，需要硬件支持来实现真正的访问保护。静态重定位的另一个缺点是一旦完成，稍后很难将内存空间重定位到其他位置。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">128: movl 0x0(%ebx), %eax</span><br></pre></td></tr></table></figure>
<p>程序计数器（PC）首先被设置为 128。当硬件需要获取这条指令时，它先将这个值加上基址寄存器中的 32KB(32768)，得到实际的物理地址 32896，然后硬件从这个物理地址获取指令。接下来，处理器开始执行该指令。这时，进程发起从虚拟地址 15KB 的加载，处理器同样将虚拟地址加上基址寄存器内容（32KB），得到最终的物理地址 47KB，从而获得需要的数据。</p>
<p>将虚拟地址转换为物理地址，这正是所谓的地址转换（address translation）技术。也就是说，硬件取得进程认为它要访问的地址，将它转换成数据实际位于的物理地址。由于这种重定位是在运行时发生的，而且我们甚至可以在进程开始运行后改变其地址空间，这种技术一般被称为动态重定位（dynamic relocation）。</p>
<p><strong>界限寄存器提供了访问保护。在上面的例子中，界限寄存器被置为 16KB。如果进程需要访问超过这个界限或者为负数的虚拟地址，CPU 将触发异常，进程最终可能被终止。界限寄存器的用处在于，它确保了进程产生的所有地址都在进程的地址“界限”中。</strong></p>
<p><strong>这种基址寄存器配合界限寄存器的硬件结构是芯片中的（每个 CPU 一对）。有时我们将CPU 的这个负责地址转换的部分统称为内存管理单元（Memory Management Unit，MMU）。随着我们开发更复杂的内存管理技术，MMU 也将有更复杂的电路和功能。</strong></p>
<h3 id="转换示例"><a href="#转换示例" class="headerlink" title="转换示例"></a>转换示例</h3><p>设想一个进程拥有 4KB 大小地址空间（是的，小得不切实际），它被加载到从 16KB 开始的物理内存中。一些地址转换结果见表 15.1。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/q5.png" alt="?"></p>
<blockquote>
<p>补充：数据结构——空闲列表</p>
</blockquote>
<blockquote>
<p>操作系统必须记录哪些空闲内存没有使用，以便能够为进程分配内存。很多不同的数据结构可以用于这项任务，其中最简单的（也是我们假定在这里采用的）是空闲列表（free list）。它就是一个列表，记录当前没有使用的物理内存的范围。</p>
</blockquote>
<h2 id="硬件支持：总结"><a href="#硬件支持：总结" class="headerlink" title="硬件支持：总结"></a>硬件支持：总结</h2><p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/q6.png" alt="?"></p>
<p>硬件应该提供一些特殊的指令，用于修改基址寄存器和界限寄存器，允许操作系统在切换进程时改变它们。这些指令是特权（privileged）指令，只有在内核模式下，才能修改这些寄存器。</p>
<h2 id="操作系统的问题"><a href="#操作系统的问题" class="headerlink" title="操作系统的问题"></a>操作系统的问题</h2><p>硬件支持和操作系统管理结合在一起，实现了一个简单的虚拟内存。具体来说，在一些关键的时刻操作系统需要介入，以实现基址和界限方式的虚拟内存。</p>
<ol>
<li><p>第一，在进程创建时，操作系统必须采取行动，为进程的地址空间找到内存空间。由于我们假设每个进程的地址空间小于物理内存的大小，并且大小相同，这对操作系统来说很容易。它可以把整个物理内存看作一组槽块，标记了空闲或已用。当新进程创建时，操作系统检索这个数据结构（常被称为空闲列表，free list），为新地址空间找到位置，并将其标记为已用。</p>
</li>
<li><p>在进程终止时（正常退出，或因行为不端被强制终止），操作系统也必须做一些工作，回收它的所有内存，给其他进程或者操作系统使用。在进程终止时，操作系统会将这些内存放回到空闲列表，并根据需要清除相关的数据结构。</p>
</li>
<li><p>在上下文切换时，操作系统也必须执行一些额外的操作。每个 CPU 毕竟只有一个基址寄存器和一个界限寄存器，但对于每个运行的程序，它们的值都不同，因为每个程序被加载到内存中不同的物理地址。因此，在切换进程时，操作系统必须保存和恢复基础和界限寄存器。具体来说，当操作系统决定中止当前的运行进程时，它必须将当前基址和界限寄存器中的内容保存在内存中，放在某种每个进程都有的结构中，如进程结构（process structure）或进程控制块（Process Control Block，PCB）中。类似地，当操作系统恢复执行某个进程时（或第一次执行），也必须给基址和界限寄存器设置正确的值。</p>
</li>
<li><p>操作系统必须提供异常处理程序（exception handler），或要一些调用的函数，像上面提到的那样。操作系统在启动时加载这些处理程序（通过特权命令）。例如，当一个进程试图越界访问内存时，CPU 会触发异常。在这种异常产生时，操作系统必须准备采取行动。通常操作系统会做出充满敌意的反应：终止错误进程。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/q7.png" alt="?"></p>
</li>
</ol>
<p>按时间线展示了大多数硬件与操作系统的交互。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/q8.png" alt="?"><br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/q9.png" alt="?"></p>
<h1 id="内部碎片和外部碎片"><a href="#内部碎片和外部碎片" class="headerlink" title="内部碎片和外部碎片"></a>内部碎片和外部碎片</h1><p>内部碎片是指分配给进程的内存块中，有一部分空间没有被利用，但由于无法分配给其他进程使用，而造成的浪费。</p>
<p>外部碎片是指存储器中有一些连续的空闲空间，但由于这些空间被多个小的不连续的空闲块所分割，无法满足大的内存需求。</p>
<h2 id="分段内存管理碎片"><a href="#分段内存管理碎片" class="headerlink" title="分段内存管理碎片"></a>分段内存管理碎片</h2><p>分段内存管理没有内部碎片，因为他的逻辑定义，基址寄存器和界限寄存器决定了哪些是该进程所拥有的。所以没有已经分配给此进程但是没有用的空间，故没有内部碎片。</p>
<p>分段内存管理有外部碎片，因为他这一种内存管理方式占用空间不同，分着分着就有一些很小的没有办法再用的空间出现，这就是外部碎片。</p>
<h2 id="分页内存管理碎片"><a href="#分页内存管理碎片" class="headerlink" title="分页内存管理碎片"></a>分页内存管理碎片</h2><p>分页内存管理有内部碎片，因为页这个词的定义他是没有意义的，他不像分段管理某一块代表了某一部分，分给这个进程的这一页如小于进程实际上拥有的，那么就产生了内部碎片。</p>
<p>分页内存管理没有外部碎片，外部碎片是剩余的没有办法被别的进程所用的空间碎片，分页的方式每个块大小相同所以不会产生外部碎片。<br>（分段有外部碎片的原因是他每个块的大小不同，如果有大的块想用这块小地址就用不了，所以才叫外部碎片，但是分页方式大家大小都一样，你肯定能用上，所以就没有外部碎片）</p>
<h1 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h1><p><strong>栈和堆之间，有一大块“空闲”空间。</strong><br>如果我们将整个地址空间放入物理内存，那么栈和堆之间的空间并没有被进程使用，却依然占用了实际的物理内存。因此，简单的通过基址寄存器和界限寄存器实现的虚拟内存很浪费。另外，如果剩余物理内存无法提供连续区域来放置完整的地址空间，进程便无法运行。这种基址加界限的方式看来并不像我们期望的那样灵活。</p>
<h2 id="分段：泛化的基址-界限"><a href="#分段：泛化的基址-界限" class="headerlink" title="分段：泛化的基址/界限"></a>分段：泛化的基址/界限</h2><p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/w1.png" alt="?"><br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/w2.png" alt="?"><br>在 MMU 中引入不止一个基址和界限寄存器对，而是给地址空间内的每个逻辑段（segment）一对。一个段只是地址空间里的一个连续定长的区域，在典型的地址空间里有 3 个逻辑不同的段：代码、栈和堆。分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中的未使用部分占用物理内存。</p>
<h3 id="转换例子"><a href="#转换例子" class="headerlink" title="转换例子"></a>转换例子</h3><p>假设现在要引用虚拟地址100（在代码段中），MMU 将基址值加上偏移量（100）得到实际的物理地址：100 + 32KB =32868。然后它会检查该地址是否在界限内（100 小于 2KB），发现是的，于是发起对物理地址 32868 的引用。<br><strong>注意这里的代码段开始地址是0，偏移量是0</strong></p>
<p>来看一个堆中的地址，虚拟地址 4200（同样参考图 16.1）。如果用虚拟地址 4200 加上堆的基址（34KB），得到物理地址 39016，这不是正确的地址。我们首先应该先减去堆的偏移量，即该地址指的是这个段中的哪个字节。因为堆从虚拟地址 4K（4096）开始，4200 的偏移量实际上是 4200 减去 4096，即 104，然后用这个偏移量（104）加上基址寄存器中的物理地址（34KB），得到真正的物理地址 34920。<br><strong>注意这里的堆开始地址是4096，偏移量是4096，计算所占用空间时要减去偏移量。</strong></p>
<h2 id="我们引用哪个段"><a href="#我们引用哪个段" class="headerlink" title="我们引用哪个段"></a>我们引用哪个段</h2><blockquote>
<p>硬件在地址转换时使用段寄存器。它如何知道段内的偏移量，以及地址引用了哪个段？</p>
</blockquote>
<p>一种常见的方式，有时称为显式（explicit）方式，就是用虚拟地址的开头几位来标识不同的段，VAX/VMS 系统使用了这种技术。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/w3.png" alt="?"></p>
<p><strong>如果前两位是 00，硬件就知道这是属于代码段的地址，因此使用代码段的基址和界限来重定位到正确的物理地址。如果前两位是 01，则是堆地址，对应地，使用堆的基址和界限。</strong> 下面来看一个 4200 之上的堆虚拟地址，进行进制转换，确保弄清楚这些内容。虚拟地址 4200 的二进制形式如下：<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/w4.png" alt="?"></p>
<p><strong>硬件就用前两位来决定使用哪个段寄存器，然后用后 12 位作为段内偏移。偏移量与基址寄存器相加，硬件就得到了最终的物理地址。</strong></p>
<p>在隐式（implicit）方式中，硬件通过地址产生的方式来确定段。例如，如果地址由程序计数器产生（即它是指令获取），那么地址在代码段。如果基于栈或基址指针，它一定在栈段。其他地址则在堆段。</p>
<h2 id="栈怎么办"><a href="#栈怎么办" class="headerlink" title="栈怎么办"></a>栈怎么办</h2><p>在表 16.1 中，栈被重定位到物理地址 28KB。但有一点关键区别，它反向增长。在物理内存中，它始于 28KB，增长回到 26KB，相应虚拟地址从 16KB 到 14KB。地址转换必须有所不同。</p>
<ol>
<li>首先，我们需要一点硬件支持。除了基址和界限外，硬件还需要知道段的增长方向（用一位区分，比如 1 代表自小而大增长，0 反之）。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/w5.png" alt="?"></li>
</ol>
<h2 id="支持共享"><a href="#支持共享" class="headerlink" title="支持共享"></a>支持共享</h2><p>要节省内存，有时候在地址空间之间共享（share）某些内存段是有用的。尤其是，代码共享很常见。</p>
<p>基本为每个段增加了几个位，标识程序是否能够读写该段，或执行其中的代码。通过将代码段标记为只读，同样的代码可以被多个进程共享，而不用担心破坏隔离。虽然每个进程都认为自己独占这块内存，但操作系统秘密地共享了内存，进程不能修改这些内存，所以假象得以保持。</p>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/w6.png" alt="?"></p>
<p>除了检查虚拟地址是否越界，硬件还需要检查特定访问是否允许。如果用户进程试图写入只读段，或从非执行段执行指令，硬件会触发异常，让操作系统来处理出错进程。</p>
<h2 id="细粒度与粗粒度的分段"><a href="#细粒度与粗粒度的分段" class="headerlink" title="细粒度与粗粒度的分段"></a>细粒度与粗粒度的分段</h2><p>支持许多段需要进一步的硬件支持，并在内存中保存某种段表（segment table）。这种段表通常支持创建非常多的段，因此系统使用段的方式，可以比之前讨论的方式更灵活。例如，像 Burroughs B5000 这样的早期机器可以支持成千上万的段，有了操作系统和硬件的支持，编译器可以将代码段和数据段划分为许多不同的部分。当时的考虑是，通过更细粒度的<br>段，操作系统可以更好地了解哪些段在使用哪些没有，从而可以更高效地利用内存。</p>
<h2 id="操作系统支持"><a href="#操作系统支持" class="headerlink" title="操作系统支持"></a>操作系统支持</h2><p>系统运行时，地址空间中的不同段被重定位到物理内存中。与我们之前介绍的整个地址空间只有一个基址/界限寄存器对的方式相比，大量节省了物理内存。</p>
<p><strong>操作系统在上下文切换时应该做什么？</strong></p>
<blockquote>
<p>各个段寄存器中的内容必须保存和恢复。显然，每个进程都有自己独立的虚拟地址空间，操作系统必须在进程运行前，确保这些寄存器被正确地赋值。</p>
</blockquote>
<p>物理内存很快充满了许多空闲空间的小洞，因而很难分配给新的段，或扩大已有的段。这种问题被称为外部碎片。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/w7.png" alt="?"><br>问题的一种解决方案是紧凑（compact）物理内存，重新安排原有的段。例如，操作系统先终止运行的进程，将它们的数据复制到连续的内存区域中去，改变它们的段寄存器中的值，指向新的物理地址，从而得到了足够大的连续空闲空间。这样做，操作系统能让新的内存分配请求成功。但是，内存紧凑成本很高，因为拷贝段是内存密集型的，一般会占用大量的处理器时间。</p>
<p>一种更简单的做法是利用空闲列表管理算法，试图保留大的内存块用于分配。相关的算法可能有成百上千种，包括传统的最优匹配（best-fit，从空闲链表中找最接近需要分配空间的空闲块返回）、最坏匹配（worst-fit）、首次匹配（first-fit）以及像伙伴算法（buddy algorithm）这样更复杂的算法。</p>
<p><strong>无论算法多么精妙，都无法完全消除外部碎片</strong></p>
<hr>
<h1 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h1><p>如果需要管理的空间被划分为固定大小的单元，就很容易。在这种情况下，只需要维护这些大小固定的单元的列表，如果有请求，就返回列表中的第一项。</p>
<p>如果要管理的空闲空间由大小不同的单元构成，管理就变得困难（而且有趣）。这种情况出现在用户级的内存分配库（如 malloc()和 free()），或者操作系统用分段（segmentation）的方式实现虚拟内存。</p>
<p><strong>这两种情况下，出现了外部碎片（external fragmentation）的问题：<br>空闲空间被分割成不同大小的小块，成为碎片，后续的请求可能失败，因为没有一块足够大的连续空闲空间，即使这时总的空闲空间超出了请求的大小。</strong></p>
<h2 id="假设-1"><a href="#假设-1" class="headerlink" title="假设"></a>假设</h2><p>我们假定基本的接口就像 malloc()和 free()提供的那样。<br>该库管理的空间由于历史原因被称为堆，在堆上管理空闲空间的数据结构通常称为空闲列表（free list）。该结构包含了管理内存区域中所有空闲块的引用。当然，该数据结构不一定真的是列表，而只是某种可以追踪空闲空间的数据结构。</p>
<p>进一步假设，我们主要关心的是外部碎片。<br>当然，分配程序也可能有内部碎片（internal fragmentation）的问题。如果分配程序给出的内存块超出请求的大小，在这种块中超出请求的空间（因此而未使用）就被认为是内部碎片（因为浪费发生在已分配单元的内部），这是另一种形式的空间浪费。</p>
<p>我们还假设，内存一旦被分配给客户，就不可以被重定位到其他位置。</p>
<p>最后我们假设，分配程序所管理的是连续的一块字节区域。</p>
<h2 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h2><h3 id="分割与合并"><a href="#分割与合并" class="headerlink" title="分割与合并"></a>分割与合并</h3><p>空闲列表包含一组元素，记录了堆中的哪些空间还没有分配。假设有下面的 30 字节的堆：<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/e1.png" alt="?"></p>
<p>这个堆对应的空闲列表会有两个元素，一个描述第一个 10 字节的空闲区域（字节 0～9），一个描述另一个空闲区域（字节 20～29）：<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/e2.png" alt="?"></p>
<p>任何大于 10 字节的分配请求都会失败（返回 NULL），因为没有足够的连续可用空间。</p>
<p>假设我们只申请一个字节的内存。这种情况下，分配程序会执行所谓的分割（splitting）动作：它找到一块可以满足请求的空闲空间，将其分割，第一块返回给用户，第二块留在空闲列表中。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/e3.png" alt="?"></p>
<p><strong>因此，如果请求的空间大小小于某块空闲块，分配程序通常会进行分割。</strong></p>
<p><strong>分配程序会在释放一块内存时合并可用空间。</strong> 在归还一块空闲内存时，仔细查看要归还的内存块的地址以及邻它的空闲空间块。如果新归还的空间与一个原有空闲块相邻（或两个，就像这个例子），就将它们合并为一个较大的空闲块。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/e4.png" alt="?"></p>
<h3 id="追踪已分配空间的大小"><a href="#追踪已分配空间的大小" class="headerlink" title="追踪已分配空间的大小"></a>追踪已分配空间的大小</h3><p>该头块中至少包含所分配空间的大小（这个例子中是 20）。它也可能包含一些额外的指针来加速空间释放，包含一个幻数来提供完整性检查，以及其他信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">header_t</span> &#123;</span></span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> magic;</span><br><span class="line">&#125; <span class="type">header_t</span>;</span><br></pre></td></tr></table></figure>

<p>用户调用 free(ptr)时，库会通过简单的指针运算得到头块的位置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line"><span class="type">header_t</span> *hptr = (<span class="type">void</span> *)ptr - <span class="keyword">sizeof</span>(<span class="type">header_t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/e5.png" alt="?"><br>获得头块的指针后，库可以很容易地确定幻数是否符合预期的值，作为正常性检查（assert（hptr-&gt;magic == 1234567）），并简单计算要释放的空间大小（即头块的大小加区域长度）。实际释放的是头块大小加上分配给用户的空间的大小。因此，如果用户请求 N 字节的内存，库不是寻找大小为 N 的空闲块，而是寻找N 加上头块大小的空闲块。</p>
<h3 id="嵌入空闲列表"><a href="#嵌入空闲列表" class="headerlink" title="嵌入空闲列表"></a>嵌入空闲列表</h3><p>假设我们需要管理一个 4096 字节的内存块（即堆是 4KB）。为了将它作为一个空闲空间列表来管理，首先要初始化这个列表。开始，列表中只有一个条目，记录了大小为 4096的空间（减去头块的大小）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br></pre></td></tr></table></figure>

<p>现在来看一些代码，它们初始化堆，并将空闲列表的第一个元素放在该空间中。这块空间通过系统调用 mmap()获得。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">node_t</span> *head = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">    MAP_ANON|MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">head-&gt;size = <span class="number">4096</span> - <span class="keyword">sizeof</span>(<span class="type">node_t</span>);</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>因为只有一个 4088 字节的块，所以选中这个块。然后，这个块被分割（split）为两块：一块足够满足请求（以及头块，如前所述），一块是剩余的空闲块。假设记录头块为 8 个字节（一个整数记录大小，一个整数记录幻数），堆中的空间如图:<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/e6.png" alt="?"></p>
<p>16KB等于16,384字节。<br>在这个例子中，应用程序调用 free(16500)，归还了中间的一块已分配空间（内存块的起始地址 16384 加上前一块的 108，和这一块的头块的 8 字节，就得到了 16500）。这个值在前图中用 sptr 指向。</p>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/e7.png" alt="?"><br>现在的空闲列表包括一个小空闲块（100 字节，由列表的头指向）和一个大空闲块（3764字节）。</p>
<p>最后一个例子：现在假设剩余的两块已分配的空间也被释放。没有合并，空闲列表将非常破碎，如图:<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/e8.png" alt="?"><br>解决方案很简单：遍历列表，合并（merge）相邻块。完成之后，堆又成了一个整体。</p>
<h3 id="让堆增长"><a href="#让堆增长" class="headerlink" title="让堆增长"></a>让堆增长</h3><p>大多数传统的分配程序会从很小的堆开始，当空间耗尽时，再向操作系统申请更大的空间。通常，这意味着它们进行了某种系统调用（例如，大多数 UNIX 系统中的 sbrk），让堆增长。操作系统在执行 sbrk 系统调用时，会找到空闲的物理内存页，将它们映射到请求进程的地址空间中去，并返回新的堆的末尾地址。这时，就有了更大的堆，请求就可以成功满足。</p>
<h2 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h2><h3 id="最优匹配"><a href="#最优匹配" class="headerlink" title="最优匹配"></a>最优匹配</h3><p>首先遍历整个空闲列表，找到和请求大小一样或更大的空闲块，然后返回这组候选者中最小的一块。这就是所谓的最优匹配（也可以称为最小匹配）。只需要遍历一次空闲列表，就足以找到正确的块并返回。</p>
<h3 id="最差匹配"><a href="#最差匹配" class="headerlink" title="最差匹配"></a>最差匹配</h3><p>最差匹配（worst fit）方法与最优匹配相反，它尝试找最大的空闲块，分割并满足用户需求后，将剩余的块（很大）加入空闲列表。最差匹配尝试在空闲列表中保留较大的块，而不是向最优匹配那样可能剩下很多难以利用的小块。但是，最差匹配同样需要遍历整个空闲列表。更糟糕的是，大多数研究表明它的表现非常差，导致过量的碎片，同时还有很高的开销。</p>
<h3 id="首次匹配"><a href="#首次匹配" class="headerlink" title="首次匹配"></a>首次匹配</h3><p>首次匹配（first fit）策略就是找到第一个足够大的块，将请求的空间返回给用户。同样，剩余的空闲空间留给后续请求。<br>首次匹配有速度优势（不需要遍历所有空闲块），但有时会让空闲列表开头的部分有很多小块。因此，分配程序如何管理空闲列表的顺序就变得很重要。一种方式是基于地址排序（address-based ordering）。通过保持空闲块按内存地址有序，合并操作会很容易，从而减少了内存碎片。</p>
<h3 id="下次匹配"><a href="#下次匹配" class="headerlink" title="下次匹配"></a>下次匹配</h3><p>不同于首次匹配每次都从列表的开始查找，下次匹配（next fit）算法多维护一个指针，指向上一次查找结束的位置。其想法是将对空闲空间的查找操作扩散到整个列表中去，避免对列表开头频繁的分割。这种策略的性能与首次匹配很接它，同样避免了遍历查找。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>设想一个空闲列表包含 3 个元素，长度依次为 10、30、20<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/r1.png" alt="?"><br>假设有一个 15 字节的内存请求。最优匹配会遍历整个空闲列表，发现 20 字节是最优匹配，因为它是满足请求的最小空闲块。结果空闲列表变为：<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/r2.png" alt="?"></p>
<p>本例中发生的情况，在最优匹配中常常发生，现在留下了一个小空闲块。最差匹配类似，但会选择最大的空闲块进行分割，在本例中是 30。结果空闲列表变为：<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/r3.png" alt="?"></p>
<p>在这个例子中，首次匹配会和最差匹配一样，也发现满足请求的第一个空闲块。不同的是查找开销，最优匹配和最差匹配都需要遍历整个列表，而首次匹配只找到第一个满足需求的块即可，因此减少了查找开销。</p>
<h2 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h2><h3 id="分离空闲列表"><a href="#分离空闲列表" class="headerlink" title="分离空闲列表"></a>分离空闲列表</h3><p>如果某个应用程序经常申请一种（或几种）大小的内存空间，那就用一个独立的列表，只管理这样大小的对象。其他大小的请求都一给更通用的内存分配程序。</p>
<p>应该拿出多少内存来专门为某种大小的请求服务，而将剩余的用来满足一般请求？</p>
<p>具体来说，在内核启动时，它为可能频繁请求的内核对象创建一些对象缓存（object cache），如锁和文件系统 inode 等。这些的对象缓存每个分离了特定大小的空闲列表，因此能够很快地响应内存请求和释放。如果某个缓存中的空闲空间快耗尽时，它就向通用内存分配程序申请一些内存厚块（slab）（总量是页大小和对象大小的公倍数）。相反，如果给定厚块中对象的引用计数变为 0，通用的内存分配程序可以从专门的分配程序中回收这些空间，这通常发生在虚拟内存系统需要更多的空间的时候。</p>
<h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>在这种系统中，空闲空间首先从概念上被看成大小为 2^N 的大空间。当有一个内存分配请求时，空闲空间被递归地一分为二，直到刚好可以满足请求的大小（再一分为二就无法满足）。这时，请求的块被返回给用户。</p>
<p>在下面的例子中，一个 64KB 大小的空闲空间被切分，以便提供 7KB 的块：<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/r4.png" alt="?"><br>这种分配策略只允许分配2的整数次幂大小的空闲块，因此会有内部碎片（internal fragment）的麻烦。</p>
<p>伙伴系统的漂亮之处在于块被释放时。如果将这个 8KB 的块归还给空闲列表，分配程序会检查“伙伴”8KB 是否空闲。如果是，就合二为一，变成 16KB 的块。然后会检查这个 16KB 块的伙伴是否空闲，如果是，就合并这两块。这个递归合并过程继续上溯，直到合并整个内存区域，或者某一个块的伙伴还没有被释放。</p>
<hr>
<h1 id="分页：介绍"><a href="#分页：介绍" class="headerlink" title="分页：介绍"></a>分页：介绍</h1><p>第一种是将空间分割成不同长度的分片，就像虚拟内存管理中的分段。将空间切成不同长度的分片以后，空间本身会碎片化（fragmented），随着时间推移，分配内存会变得比较困难。</p>
<p>第二种方法：将空间分割成固定长度的分片。在虚拟内存中，我们称<br>这种思想为分页，分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码、堆、段），而是分割成固定大小的单元，每个单元称为一页。相应地，我们把物理内存看成是定长槽块的阵列，叫作页帧（page frame）。每个这样的页帧包含一个虚拟内存页。</p>
<h2 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h2><p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/r5.png" alt="?"><br>图 18.1 展示了一个只有 64字节的小地址空间，有 4 个 16 字节的页（虚拟页 0、1、2、3）。真实的地址空间肯定大得多，通常 32 位有 4GB 的地址空间，甚至有 64 位。</p>
<p>物理内存，如图所示，也由一组固定大小的槽块组成。在这个例子中，有 8 个页帧（由 128 字节物理内存构成，也是极小的）。从图中可以看出，虚拟地址空间的页放在物理内存的不同位置。图中还显示，操作系统自己用了一些物理内存。</p>
<p>通过完善的分页方法，操作系统能够高效地提供地址空间的抽象，不管进程如何使用地址空间。例如，我们不会假定堆和栈的增长方向，以及它们如何使用。</p>
<p>另一个优点是分页提供的空闲空间管理的简单性。</p>
<p><strong>为了记录地址空间的每个虚拟页放在物理内存中的位置，操作系统通常为每个进程保存一个数据结构，称为页表（page table）。页表的主要作用是为地址空间的每个虚拟页面保存地址转换（address translation），从而让我们知道每个页在物理内存中的位置。如果在上面的示例中运行另一个进程，操作系统将不得不为它管理不同的页表，因为它的虚拟页显然映射到不同的物理页面（除了共享之外）。</strong>。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>设想拥有这个小地址空间（64 字节）的进程正在访问内存：</p>
<blockquote>
<p>movl &lt;virtual address&gt;, %eax</p>
</blockquote>
<p>为了转换（translate）该过程生成的虚拟地址，我们必须首先将它分成两个组件：<strong>虚拟页面号（virtual page number，VPN）和页内的偏移量（offset）</strong>。对于这个例子，因为进程的虚拟地址空间是 64 字节，我们的虚拟地址总共需要 6 位（26 = 64）。因此，虚拟地址可以表示如下：<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/r6.png" alt="?"><br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/r7.png" alt="?"><br>页面大小为 16 字节，位于 64 字节的地址空间。因此我们需要能够选择 4 个页，地址的前 2 位就是做这件事的。因此，我们有一个 2 位的虚拟页号（VPN）。其余的位告诉我们，感兴趣该页的哪个字节，在这个例子中是 4 位，我们称之为偏移量。</p>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/r8.png" alt="?"><br>因此，我们可以通过用 PFN 替换 VPN 来转换此虚拟地址，然后将载入发送给物理内存,偏移量保持不变（即未翻译），因为偏移量只是告诉我们页面中的哪个字节是我们想要的。</p>
<h2 id="页表存在哪里"><a href="#页表存在哪里" class="headerlink" title="页表存在哪里"></a>页表存在哪里</h2><p>由于页表如此之大，我们没有在 MMU 中利用任何特殊的片上硬件，来存储当前正在运行的进程的页表，而是将每个进程的页表存储在内存中。</p>
<h2 id="列表中究竟有什么"><a href="#列表中究竟有什么" class="headerlink" title="列表中究竟有什么"></a>列表中究竟有什么</h2><p><strong>让我们来谈谈页表的组织。页表就是一种数据结构，用于将虚拟地址（或者实际上，是虚拟页号）映射到物理地址（物理帧号）。<br>最简单的形式称为线性页表（linear page table），就是一个数组。操作系统通过虚拟页号（VPN）检索该数组，并在该索引处查找页表项（PTE），以便找到期望的物理帧号（PFN）。</strong></p>
<p>有效位（valid bit）通常用于指示特定地址转换是否有效。例如，当一个程序开始运行时，它的代码和堆在其地址空间的一端，栈在另一端。所有未使用的中间空间都将被标记为无效（invalid），如果进程尝试访问这种内存，就会陷入操作系统，可能会导致该进程终止。</p>
<p>我们还可能有保护位（protection bit），表明页是否可以读取、写入或执行。同样，以这些位不允许的方式访问页，会陷入操作系统。</p>
<p>图显示了来自 x86 架构的示例页表项。它包含一个存在位（P），确定是否允许写入该页面的读/写位（R/W） 确定用户模式进程是否可以访问该页面的用户/超级用户位（U/S），有几位（PWT、PCD、PAT 和 G）确定硬件缓存如何为这些页面工作，一个访问位（A）和一个脏位（D），最后是页帧号（PFN）本身。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/r9.png" alt="?"></p>
<h2 id="内存追踪"><a href="#内存追踪" class="headerlink" title="内存追踪"></a>内存追踪</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">1000</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line"><span class="built_in">array</span>[i] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充：数据结构——页表<br>现代操作系统的内存管理子系统中最重要的数据结构之一就是页表（page table）。通常，页表存储虚拟—物理地址转换（virtual-to-physical address translation），从而让系统知道地址空间的每个页实际驻留在物理内存中的哪个位置。由于每个地址空间都需要这种转换，因此一般来说，系统中每个进程都有一个页表。页表的确切结构要么由硬件（旧系统）确定，要么由 OS（现代系统）更灵活地管理。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x1024 movl $0x0,(%edi,%eax,4)</span><br><span class="line">0x1028 incl %eax</span><br><span class="line">0x102c cmpl $0x03e8,%eax</span><br><span class="line">0x1030 jne 0x1024</span><br></pre></td></tr></table></figure>
<p>第一条指令将零值（显示为$0x0）移动到数组位置的虚拟内存地址，这个地址是通过取%edi 的内容并将其加上%eax 乘以 4 来计算的。因此，%edi 保存数组的基址，而%eax 保存数组索引（i）。我们乘以 4，因为数组是一个整型数组，每个元素的大小为 4 个字节。</p>
<blockquote>
<p>(%edi,%eax,4)是一种内存寻址模式，用于计算内存地址。<br>在这个模式中，%edi和%eax是寄存器，4是一个常数偏移量。它们的组合用于计算内存地址。<br>具体计算方式如下：<br>将%eax的值乘以4，得到偏移量。<br>将%edi的值加上步骤1中计算得到的偏移量，得到最终的内存地址。</p>
</blockquote>
<p>第二条指令增加保存在%eax 中的数组索引</p>
<p>第三条指令将该寄存器的内容与十六进制值 0x03e8 或十进制数 1000 进行比较。如果比较结果显示两个值不相等（这就是 jne 指令测试）</p>
<p>第四条指令跳回到循环的顶部。</p>
<p>对于这个例子，我们假设一个大小为 64KB 的虚拟地址空间（不切实际地小）。我们还假定页面大小为 1KB。</p>
<ol>
<li><p>我们现在需要知道页表的内容，以及它在物理内存中的位置。假设有一个线性（基于数组）的页表，它位于物理地址 1KB（1024）。</p>
</li>
<li><p>首先，存在代码所在的虚拟页面。由于页大小为 1KB，虚拟地址 1024 驻留在虚拟地址空间的第二页（VPN = 1，因为 VPN = 0 是第一页）。假设这个虚拟页映射到物理帧 4（VPN 1→PFN 4）。</p>
</li>
<li><p>接下来是数组本身。它的大小是 4000 字节（1000 整数），我们假设它驻留在虚拟地址40000 到 44000（不包括最后一个字节）。它的虚拟页的十进制范围是 VPN = 39……VPN =42。因此，我们需要这些页的映射。针对这个例子，让我们假设以下虚拟到物理的映射：(VPN 39 → PFN 7), (VPN 40 → PFN 8), (VPN 41 → PFN 9), (VPN 42 → PFN 10)</p>
</li>
<li><p>我们现在准备好跟踪程序的内存引用了。当它运行时，每个获取指将产生两个内存引用：一个访问页表以查找指令所在的物理框架，另一个访问指令本身将其提取到 CPU 进行处理。另外，在 mov 指令的形式中，有一个显式的内存引用，这会首先增加另一个页表访问（将数组虚拟地址转换为正确的物理地址），然后时数组访问本身。</p>
</li>
</ol>
<p><strong>作为虚拟内存挑战的解决方案。与以前的方法（如分段）相比，分页有许多优点。首先，它不会导致外部碎片，因为分页（按设计）将内存划分为固定大小的单元。其次，它非常灵活，支持稀疏虚拟地址空间。</strong></p>
<hr>
<h1 id="分页-快速地址转换-TLB"><a href="#分页-快速地址转换-TLB" class="headerlink" title="分页:快速地址转换 (TLB)"></a>分页:快速地址转换 (TLB)</h1><p>使用分页作为核心机制来实现虚拟内存，可能会带来较高的性能开销。因为要使用分页，就要将内存地址空间切分成大量固定大小的单元（页），并且需要记录这些单元的地址映射信息。因为这些映射信息一般存储在物理内存中，所以在转换虚拟地址时，分页逻辑上需要一次额外的内存访问。每次指令获取、显式加载或保存，都要额外读一次内存以得到转换信息，这慢得无法接受。</p>
<p>我们要增加所谓的地址转换旁路缓冲存储器（translation-lookaside buffer，TLB，它就是频繁发生的虚拟到物理地址转换的硬件缓存（cache）。因此，更好的名称应该是地址转换缓存（address-translation cache）。对每次内存访问，硬件先检查 TLB，看看其中是否有期望的转换映射，如果有，就完成转换（很快），不用访问页表（其中有全部的转换映射）。</p>
<p><strong>TLB（Translation Lookaside Buffer）是一个高速缓存，用于加速虚拟地址到物理地址的转换</strong></p>
<h2 id="TLB-的基本算法"><a href="#TLB-的基本算法" class="headerlink" title="TLB 的基本算法"></a>TLB 的基本算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先从虚拟地址中提取页号（VPN）</span></span><br><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后检查 TLB 是否有该 VPN 的转换映射</span></span><br><span class="line">(Success, TlbEntry) = TLB_Lookup(VPN)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有，我们有了 TLB 命中（TLB hit），这意味着 TLB 有该页的转换映射。成功！</span></span><br><span class="line"><span class="keyword">if</span> (Success == True) <span class="comment">// TLB Hit</span></span><br><span class="line"><span class="comment">//假定保护检查没有失败</span></span><br><span class="line">    <span class="keyword">if</span> (CanAccess(TlbEntry.ProtectBits) == True)</span><br><span class="line"><span class="comment">//接下来我们就可以从相关的 TLB 项中取出页帧号（PFN）</span></span><br><span class="line"><span class="comment">//与原来虚拟地址中的偏移量组合形成期望的物理地址（PA），并访问内存</span></span><br><span class="line">        Offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line">        PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset</span><br><span class="line">        AccessMemory(PhysAddr)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        RaiseException(PROTECTION_FAULT)</span><br><span class="line">如果 CPU 没有在 TLB 中找到转换映射</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// TLB Miss</span></span><br><span class="line">    <span class="comment">//计算页表项（Page Table Entry）的地址（PTEAddr）</span></span><br><span class="line">    <span class="comment">//PTBR是页表基址寄存器（Page Table Base Register），存储了页表的起始地址。    </span></span><br><span class="line">    <span class="comment">//VPN是虚拟页号（Virtual Page Number），用于定位页表项。</span></span><br><span class="line">    PTEAddr = PTBR + (VPN * <span class="keyword">sizeof</span>(PTE))</span><br><span class="line">    <span class="comment">//根据给定的地址获取对应的数据。</span></span><br><span class="line">    PTE = AccessMemory(PTEAddr)</span><br><span class="line">    <span class="comment">//检查PTE的Valid字段是否为False，如果是，则引发段错误（SEGMENTATION_FAULT）异常。</span></span><br><span class="line">    <span class="comment">//Valid字段表示该页表项是否有效，</span></span><br><span class="line">    <span class="comment">//如果无效，则表示该虚拟页号没有对应的物理页帧（Page Frame）。</span></span><br><span class="line">    <span class="keyword">if</span> (PTE.Valid == False)</span><br><span class="line">        RaiseException(SEGMENTATION_FAULT)</span><br><span class="line">    <span class="comment">//检查PTE的ProtectBits字段是否可以访问</span></span><br><span class="line">    <span class="comment">//如果不可以，则引发保护错误（PROTECTION_FAULT）异常。</span></span><br><span class="line">    <span class="comment">//ProtectBits字段包含了页表项的保护位（Protection Bits），</span></span><br><span class="line">    <span class="comment">//用于控制对应物理页帧的访问权限。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (CanAccess(PTE.ProtectBits) == False)</span><br><span class="line">        RaiseException(PROTECTION_FAULT)</span><br><span class="line">    <span class="comment">//如果以上两个检查都通过，则将PTE的虚拟页号（VPN）、物理页帧号（PFN）和</span></span><br><span class="line">    <span class="comment">//保护位（ProtectBits）插入到TLB中（TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)）。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)</span><br><span class="line">        RetryInstruction()</span><br></pre></td></tr></table></figure>

<h2 id="示例：访问数组"><a href="#示例：访问数组" class="headerlink" title="示例：访问数组"></a>示例：访问数组</h2><p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/w8.png" alt="?"><br>假设有一个由 10 个 4 字节整型数组成的数组，起始虚地址是 100。进一步假定，有一个 8 位的小虚地址空间，页大小为 16B。我们可以把虚地址划分为 4 位的 VPN（有 16 个虚拟内存页）和 4 位的偏移量（每个页中有 16 个字节）。</p>
<p>现在考虑一个简单的循环，访问数组中的每个元素:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   sum += a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>简单起见，我们假装循环产生的内存访问只是针对数组（忽略变量 i 和 sum，以及指令本身）。当访问第一个数组元素（a[0]）时，CPU 会看到载入虚存地址 100。硬件从中提取VPN（VPN=06），然后用它来检查 TLB，寻找有效的转换映射。假设这里是程序第一次访问该数组，结果是 TLB 未命中。</li>
<li>接下来访问 a[1]，这里有好消息：TLB 命中！因为数组的第二个元素在第一个元素之后，它们在同一页。因为我们之前访问数组的第一个元素时，已经访问了这一页，所以 TLB中缓存了该页的转换映射。因此成功命中。访问 a[2]同样成功（再次命中），因为它和 a[0]、a[1]位于同一页。</li>
<li>遗憾的是，当程序访问 a[3]时，会导致 TLB 未命中。但同样，接下来几项（a[4] … a[6]）都会命中 TLB，因为它们位于内存中的同一页。</li>
<li>最后，访问 a[7]会导致最后一次 TLB 未命中。系统会再次查找页表，弄清楚这个虚拟页在物理内存中的位置，并相应地更新 TLB。最后两次访问（a[8]、a[9]）受益于这次 TLB更新，当硬件在 TLB 中查找它们的转换映射时，两次都命中。</li>
</ol>
<p>TLB 还是提高了性能。数组的元素被紧密存放在几页中（即它们在空间中紧密相邻），因此只有对页中第一个元素的访问才会导致 TLB 未命中。</p>
<blockquote>
<p>提示：尽可能利用缓存<br>缓存是计算机系统中最基本的性能改进技术之一，一次又一次地用于让“常见的情况更快”。<br>硬件缓存背后的思想是利用指令和数据引用的局部性（locality）。通常有两种局部性：时间局部性（temporal locality）和空间局部性（spatial locality）。<br>时间局部性是指，最近访问过的指令或数据项可能很快会再次访问。想想循环中的循环变量或指令，它们被多次反复访问。<br>空间局部性是指，当程序访问内存地址 x 时，可能很快会访问邻近 x 的内存。想想遍历某种数组，访问一个接一个的元素。当然，这些性质取决于程序的特点，并不是绝对的定律，而更像是一种经验法则。<br>硬件缓存，无论是指令、数据还是地址转换（如 TLB），都利用了局部性，在小而快的芯片内存储器中保存一份内存副本。处理器可以先检查缓存中是否存在就近的副本，而不是必须访问（缓慢的）内存来满足请求。如果存在，处理器就可以很快地访问它（例如在几个 CPU 时钟内），避免花很多时间来访问内存（好多纳秒）。</p>
</blockquote>
<blockquote>
<p>你可能会疑惑：既然像 TLB 这样的缓存这么好，为什么不做更大的缓存，装下所有的数据？<br>可惜的是，这里我们遇到了更基本的定律，就像物理定律那样。如果想要快速地缓存，它就必须小，因为光速和其他物理限制会起作用。大的缓存注定慢，因此无法实现目的。所以，我们只能用小而快的缓存。剩下的问题就是如何利用好缓存来提升性能。</p>
</blockquote>
<h2 id="谁来处理-TLB-未命中"><a href="#谁来处理-TLB-未命中" class="headerlink" title="谁来处理 TLB 未命中"></a>谁来处理 TLB 未命中</h2><p>以前的硬件有复杂的指令集（有时称为复杂指令集计算机，Complex-Instruction Set Computer，CISC），造硬件的人不太相信那些搞操作系统的人。因此，硬件全权处理 TLB未命中。为了做到这一点，硬件必须知道页表在内存中的确切位置（通过页表基址寄存器，page-table base register），以及页表的确切格式。发生未命中时，硬件会“遍历”页表，找到正确的页表项，取出想要的转换映射，用它更新 TLB，并重试该指令。</p>
<p>这种“旧”体系结构有硬件管理的 TLB，一个例子是 x86 架构，它采用固定的多级页表（multi-level page table），当前页表由 CR3 寄存器指出。</p>
<p>更现代的体系结构（例如，MIPS R10k[H93]、Sun 公司的 SPARC v9，都是精简指令集计算机，Reduced-Instruction Set Computer，RISC），有所谓的软件管理 TLB（software-managed TLB）。发生 TLB 未命中时，硬件系统会抛出一个异常，这会暂停当前的指令流，将特权级提升至内核模式，跳转至陷阱处理程序（trap handler）。接下来你可能已经猜到了，这个陷阱处理程序是操作系统的一段代码，用于处理 TLB 未命中。这段代码在运行时，会查找页表中的转换映射，然后用特别的“特权”指令更新 TLB，并从陷阱返回。此时，硬件会重试该指令（导致 TLB 命中）。</p>
<p>首先，这里的从陷阱返回指令稍稍不同于之前提到的服务于系统调用的从陷阱返回。在后一种情况下，从陷阱返回应该继续执行陷入操作系统之后那条指令，就像从函数调用返回后，会继续执行此次调用之后的语句。在<strong>前一种情况下，在从 TLB 未命中的陷阱返回后，硬件必须从导致陷阱的指令继续执行。这次重试因此导致该指令再次执行，但这次会命中 TLB</strong>。因此，根据陷阱或异常的原因，系统在陷入内核时必须保存不同的程序计数器，以便将来能够正确地继续执行。</p>
<p>第二，在运行 TLB 未命中处理代码时，操作系统需要格外小心避免引起 TLB 未命中的无限递归。有很多解决方案，例如，可以把 TLB 未命中陷阱处理程序直接放到物理内存中 [它们没有映射过（unmapped），不用经过地址转换]。或者在 TLB 中保留一些项，记录永久有效的地址转换，并将其中一些永久地址转换槽块留给处理代码本身，这些被监听的（wired）地址转换总是会命中 TLB。</p>
<p>软件管理的方法，主要优势是灵活性：操作系统可以用任意数据结构来实现页表，不需要改变硬件。另一个优势是简单性。从 TLB 控制流中可以看出，硬件不需要对未命中做太多工作，它抛出异常，操作系统的未命中处理程序会负责剩下的工作。</p>
<h2 id="TLB-的内容"><a href="#TLB-的内容" class="headerlink" title="TLB 的内容"></a>TLB 的内容</h2><p>典型的 TLB 有 32 项、64 项或 128 项，并且是全相联的（fully associative）。基本上，这就意味着一条地址映射可能存在 TLB 中的任意位置，硬件会并行地查找 TLB，找到期望的转换映射。</p>
<p>VPN ｜ PFN ｜ 其他位</p>
<blockquote>
<p>补充：TLB 的有效位!=页表的有效位<br>常见的错误是混淆 TLB 的有效位和页表的有效位。在页表中，如果一个页表项（PTE）被标记为无效，就意味着该页并没有被进程申请使用，正常运行的程序不应该访问该地址。当程序试图访问这样的页时，就会陷入操作系统，操作系统会杀掉该进程。<br>TLB 的有效位不同，只是指出 TLB 项是不是有效的地址映射。例如，系统启动时，所有的 TLB 项通常被初始化为无效状态，因为还没有地址转换映射被缓存在这里。一旦启用虚拟内存，当程序开始运行，访问自己的虚拟地址，TLB 就会慢慢地被填满，因此有效的项很快会充满 TLB。</p>
</blockquote>
<h2 id="上下文切换时对-TLB-的处理"><a href="#上下文切换时对-TLB-的处理" class="headerlink" title="上下文切换时对 TLB 的处理"></a>上下文切换时对 TLB 的处理</h2><p>TLB 中包含的虚拟到物理的地址映射只对当前进程有效，对其他进程是没有意义的。所以在发生进程切换时，硬件或操作系统（或二者）必须注意确保即将运行的进程不要误读了之前进程的地址映射。</p>
<p>假设有两个进程，都有虚拟页10，但是对应的物理页面不同<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/t1.png" alt="?"></p>
<p>我们还需要做一些工作，让 TLB 正确而高效地支持跨多进程的虚拟化。</p>
<p>一种方法是在上下文切换时，简单地清空（flush）TLB，这样在新进程运行前 TLB 就变成了空的。如果是软件管理 TLB 的系统，可以在发生上下文切换时，通过一条显式（特权）指令来完成。</p>
<p>如果是硬件管理 TLB，则可以在页表基址寄存器内容发生变化时清空 TLB（注意，在上下文切换时，操作系统必须改变页表基址寄存器（PTBR）的值）。不论哪种情况，清空操作都是把全部有效位（valid）置为 0，本质上清空了 TLB。</p>
<p>但是，有一定开销：每次进程运行，当它访问数据和代码页时，都会触发 TLB 未命中。如果操作系统频繁地切换进程，这种开销会很高。</p>
<p>为了减少这种开销，一些系统增加了硬件支持，实现跨上下文切换的 TLB 共享。比如有的系统在 TLB 中添加了一个地址空间标识符（Address Space Identifier，ASID）。可以把ASID 看作是进程标识符（Process Identifier，PID），但通常比 PID 位数少（PID 一般 32 位，ASID 一般是 8 位）。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/t2.png" alt="?"></p>
<p>因此，有了地址空间标识符，TLB 可以同时缓存不同进程的地址空间映射，没有任何冲突。当然，硬件也需要知道当前是哪个进程正在运行，以便进行地址转换，因此操作系统在上下文切换时，必须将某个特权寄存器设置为当前进程的 ASID。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/t3.png" alt="?"><br>如果两个进程共享同一物理页（例如代码段的页），就可能出现这种情况。</p>
<h2 id="实际系统的-TLB-表项"><a href="#实际系统的-TLB-表项" class="headerlink" title="实际系统的 TLB 表项"></a>实际系统的 TLB 表项</h2><p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/t4.png" alt="?"><br>MIPS R4000 支持 32 位的地址空间，页大小为 4KB。所以在典型的虚拟地址中，预期会看到 20 位的 VPN 和 12 位的偏移量。但是，你可以在 TLB 中看到，只有 19 位的 VPN。事实上，用户地址只占地址空间的一半（剩下的留给内核），所以只需要 19 位的 VPN。VPN转换成最大 24 位的物理帧号（PFN），因此可以支持最多有 64GB 物理内存（224 个 4KB 内存页）的系统。<br>MIPS TLB 还有一些有趣的标识位。比如全局位（Global，G），用来指示这个页是不是所有进程全局共享的。因此，如果全局位置为 1，就会忽略 ASID。我们也看到了 8 位的 ASID，操作系统用它来区分进程空间（像上面介绍的一样）。</p>
<h1 id="页、页表、页表项、偏移量、虚拟页号"><a href="#页、页表、页表项、偏移量、虚拟页号" class="headerlink" title="页、页表、页表项、偏移量、虚拟页号"></a>页、页表、页表项、偏移量、虚拟页号</h1><p>假设一个 32 位地址空间（2^32 字节），4KB大小（2^12 字节）的页和4 字节大小的页表项。一个地址空间中大约有一百万个虚拟页面（2^32/2^12）。乘以页表项的大小，你会发现页表大小为 4MB。</p>
<p><strong>页表中的每一项是页表项，每一个页表项对应一页.</strong><br><strong>在每个页中，他的大小要对应偏移量的位数，因为偏移量要能定位到页面中的每一处</strong><br><strong>vpn虚拟页号有很多个，他需要和页表项数量相同，一一对应</strong></p>
<p><strong>页的大小—偏移量<br>页的数量—页表项数—虚拟页号数量</strong></p>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/t5.png" alt="?"></p>
<blockquote>
<p>页是虚拟内存和物理内存划分的最小单位，通常是固定大小的内存块，常见的大小是4KB或者2MB。虚拟地址空间被划分为多个页，每个页都有一个唯一的标识符，也称为虚拟页号。</p>
</blockquote>
<blockquote>
<p>页表是一个数据结构，用于管理虚拟内存中的页。它存储了每个虚拟页号与其对应的物理页框地址的映射关系。页表通常是一个二维数组，其中每个元素对应一个虚拟页号，并存储了与之对应的物理页框地址。</p>
</blockquote>
<h1 id="分页：更小的表"><a href="#分页：更小的表" class="headerlink" title="分页：更小的表"></a>分页：更小的表</h1><p><strong>记住目的：他想要更小的页表❗❗❗</strong></p>
<p>假设一个 32 位地址空间（2^32 字节），4KB大小（2^12 字节）的页和4 字节大小的页表项。一个地址空间中大约有一百万个虚拟页面（2^32/2^12）。乘以页表项的大小，你会发现页表大小为 4MB。</p>
<h2 id="简单的解决方案：更大的页"><a href="#简单的解决方案：更大的页" class="headerlink" title="简单的解决方案：更大的页"></a>简单的解决方案：更大的页</h2><p>再以 32 位地址空间为例，但这次假设用 16KB （2^14）的页。因此，会有 18 位的 VPN 加上 14 位的偏移量。假设每个页表项（4字节）的大小相同，现在线性页表中有 2^18 个项，因此每个页表的总大小为 1MB，页表缩到四分之一。</p>
<p>然而，大内存页会导致每页内的浪费，这被称为内部碎片（internal fragmentation）问题（因为浪费在分配单元内部）。因此，结果是应用程序会分配页，但只用每页的一小部分，而内存很快就会充满这些过大的页。因此，大多数系统在常见的情况下使用相对较小的页大小：4KB（如 x86）或 8KB（如 SPARCv9）。</p>
<h2 id="混合方法：分页和分段"><a href="#混合方法：分页和分段" class="headerlink" title="混合方法：分页和分段"></a>混合方法：分页和分段</h2><p>我们的杂合方法不是为进程的整个地址空间提供单个页表（不然中间有很多没用到的无效项，白白占空间），而是为每个逻辑分段提供一个。我们可能有 3 个页表，地址空间的代码、堆和栈部分各有一个。</p>
<p>假设 32 位虚拟地址空间包含 4KB 页面，并且地址空间分为 4 个段。在这个例子中，我们只使用 3 个段：一个用于代码，另一个用于堆，还有一个用于栈。<br>要确定地址引用哪个段，我们会用地址空间的前两位。假设 00 是未使用的段，01 是代码段，10 是堆段，11 是栈段。</p>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/t6.png" alt="?"><br>在硬件中，假设有 3 个基本/界限对，代码、堆和栈各一个。在上下文切换时，必须更改这些寄存器，以反映新运行进程的页表的位置。</p>
<p>在 TLB 未命中时（假设硬件管理的 TLB，即硬件负责处理 TLB 未命中），硬件使用分段位（SN）来确定要用哪个基址和界限对。然后硬件将其中的物理地址与 VPN 结合起来，形成页表项（PTE）的地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SN = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SN_SHIFT</span><br><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; VPN_SHIFT</span><br><span class="line">AddressOfPTE = Base[SN] + (VPN * <span class="keyword">sizeof</span>(PTE))</span><br></pre></td></tr></table></figure>
<p>杂合方案的关键区别在于，每个分段都有界限寄存器，每个界限寄存器保存了段中最大有效页的值。例如，如果代码段使用它的前 3 个页（0、1 和 2），则代码段页表将只有 3个项分配给它，并且界限寄存器将被设置为 3。内存访问超出段的末尾将产生一个异常，并可能导致进程终止。<br>栈和堆之间未分配的页不再占用页表中的空间（仅将其标记为无效）。(页表中有一项记忆该项是否有效)</p>
<p><strong>记住目的：他想要更小的页表❗❗❗</strong></p>
<h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>另一种方法并不依赖于分段，但也试图解决相同的问题：<strong>如何去掉页表中的所有无效区域，而不是将它们全部保留在内存中？</strong> 我们将这种方法称为多级页表（multi-level page table），因为它将线性页表变成了类似树的东西。这种方法非常有效，许多现代系统都用它（例如 x86 ）。</p>
<p>多级页表的基本思想很简单。<strong>首先，将页表分成页大小的单元。然后，如果整页的页表项（PTE）无效，就完全不分配该页的页表。为了追踪页表的页是否有效（以及如果有效，它在内存中的位置），使用了名为页目录（page directory）的新结构。页目录因此可以告诉你页表的页在哪里，或者页表的整个页不包含有效页。</strong><br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/t7.png" alt="?"></p>
<blockquote>
<p>理解时空折中<br>在构建数据结构时，应始终考虑时间和空间的折中（time-space trade-off）。通常，如果你希望更快地访问特定的数据结构，就必须为该结构付出空间的代价。</p>
</blockquote>
<p>应该指出，多级页表是有成本的。在 TLB 未命中时，需要从内存加载两次，才能从页表中获取正确的地址转换信息（一次用于页目录，另一次用于 PTE 本身），而用线性页表只需要一次加载。<br>在多级表的情况下，为了节省宝贵的内存，我们使页表查找更加复杂。</p>
<h3 id="详细的多级示例"><a href="#详细的多级示例" class="headerlink" title="详细的多级示例"></a>详细的多级示例</h3><p>设想一个大小为 16KB 的小地址空间，其中包含 64 个字节的页。因此，我们有一个 14 位的虚拟地址空间，VPN 有 8位，偏移量有 6 位。即使只有一小部分地址空间正在使用，线性页表也会有 28（256）个项。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/t8.png" alt="?"><br>在这个例子中，虚拟页 0 和 1 用于代码，虚拟页 4 和 5 用于堆，虚拟页 254 和 255 用于栈。地址空间的其余页未被使用。</p>
<p>要为这个地址空间构建一个两级页表，我们从完整的线性页表开始，将它分解成页大小的单元。回想一下我们的完整页表（在这个例子中）有 256 个项；假设每个 PTE 的大小是 4个字节。因此，我们的页表大小为 1KB（256×4 字节）。鉴于我们有 64 字节的页，1KB 页表可以分为 16 个 64 字节的页，每个页可以容纳 16 个 PTE。</p>
<p>我们首先索引到页目录。这个例子中的页表很小：256 个项，分布在 16 个页上。页目录需要为页表的每页提供一个项。因此，它有 16 个项。结果，我们需要 4 位 VPN 来索引目录。我们使用 VPN 的前 4 位，如下所示：<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/t9.png" alt="?"></p>
<p>一旦从 VPN 中提取了页目录索引（简称 PDIndex），我们就可以通过简单的计算来找到页目录项（PDE）的地址：PDEAddr = PageDirBase +（PDIndex×sizeof（PDE））。这就得到了页目录，现在我们来看它，在地址转换上取得进一步进展。</p>
<p>如果页目录项标记为无效，则我们知道访问无效，从而引发异常。但是，如果 PDE 有效，我们还有更多工作要做。具体来说，我们现在必须从页目录项指向的页表的页中获取页表项（PTE）。要找到这个 PTE，我们必须使用 VPN 的剩余位索引到页表的部分：<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/y1.png" alt="?"></p>
<p>这个页表索引（Page-Table Index，PTIndex）可以用来索引页表本身，给出 PTE 的地址：<br>PTEAddr = (PDE.PFN &lt;&lt; SHIFT) + (PTIndex * sizeof(PTE))<br>请注意，从页目录项获得的页帧号（PFN）必须左移到位，然后再与页表索引组合，才能形成 PTE 的地址。</p>
<p>在物理页 100（页表的第 0 页的物理帧号）中，我们有 1 页，包含 16 个页表项，记录了地址空间中的前 16 个 VPN。请参见表 20.2（中间部分）。<br>页表的另一个有效页在 PFN 101 中。该页包含地址空间的最后 16 个 VPN 的映射。具体见表 20.2（右侧）。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/y2.png" alt="?"></p>
<p>在这个例子中，我们不是为一个线性页表分配完整的 16页，而是分配 3 页：一个用于页目录，两个用于页表的具有有效映射的块。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>最后，让我们用这些信息来进行地址转换。这里是一个地址，指向 VPN 254 的第 0 个字节：0x3F80，或二进制的 11 1111 1000 0000。</p>
<p>我们将使用 VPN 的前 4 位来索引页目录。因此，1111 会从上面的页目录中选择最后一个（第 15 个，如果你从第 0 个开始）。这就指向了位于地址 101 的页表的有效页。然后，我们使用 VPN 的下 4 位（1110）来索引页表的那一页并找到所需的 PTE。1110 是页面中的倒数第二（第 14 个）条，并告诉我们虚拟地址空间的页 254 映射到物理页 55。通过连接 PFN = 55（或十六进制 0x37）和 offset = 000000，可以形成我们想要的物理地址，并向内存系统发出请求：PhysAddr =（PTE.PFN &lt;&lt; SHIFT）+ offset = 00 1101 1100 0000 = 0x0DC0。</p>
<h2 id="超过两级"><a href="#超过两级" class="headerlink" title="超过两级"></a>超过两级</h2><p>在至今为止的例子中，我们假定多级页表只有两个级别：一个页目录和几页页表。在某些情况下，更深的树是可能的。</p>
<p>假设我们有一个 30 位的虚拟地址空间和一个小的（512 字节）页。因此我们的虚拟地址有一个 21 位的虚拟页号和一个 9 位偏移量。</p>
<p><strong>构建多级页表的目标：使页表的每一部分都能放入一个页。到目前为止，<br>我们只考虑了页表本身。但是，如果页目录太大，该怎么办？</strong></p>
<p>首先要确定多少页表项可以放入一页。鉴于页大小为 512 字节，并且假设 PTE 大小为 4 字节，你应该看到，可以在单个页上放入 128 个 PTE。当我们索引页表时，我们可以得出结论，我们需要 VPN的最低有效位 7 位（log2128）作为索引：<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/y3.png" alt="?"></p>
<p>如果我们的页目录有 214个项，那么它不是一个页，而是 128 个，因此我们让多级页表的每一个部分放入一页目标失败了。</p>
<p>为了解决这个问题，我们为树再加一层，将页目录本身拆成多个页，然后在其上添加另一个页目录，指向页目录的页。我们可以按如下方式分割虚拟地址：<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/y4.png" alt="?"><br>现在，当索引上层页目录时，我们使用虚拟地址的最高几位（图中的 PD 索引 0）。该索引用于从顶级页目录中获取页目录项。如果有效，则通过组合来自顶级 PDE 的物理帧号和 VPN 的下一部分（PD 索引 1）来查阅页目录的第二级。最后，如果有效，则可以通过使用与第二级 PDE 的地址组合的页表索引来形成 PTE 地址。</p>
<h3 id="地址转换过程：记住-TLB"><a href="#地址转换过程：记住-TLB" class="headerlink" title="地址转换过程：记住 TLB"></a>地址转换过程：记住 TLB</h3><p>在任何复杂的多级页表访问发生之前，硬件首先检查 TLB。在命中时，物理地址直接形成，而不像之前一样访问页表。只有在 TLB 未命中时，硬件才需要执行完整的多级查找。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line">(Success, TlbEntry) = TLB_Lookup(VPN)</span><br><span class="line"><span class="keyword">if</span> (Success == True) <span class="comment">// TLB Hit</span></span><br><span class="line">    <span class="keyword">if</span> (CanAccess(TlbEntry.ProtectBits) == True)</span><br><span class="line">        Offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line">        PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset</span><br><span class="line">        Register = AccessMemory(PhysAddr)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        RaiseException(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// TLB Miss</span></span><br><span class="line"><span class="comment">// first, get page directory entry</span></span><br><span class="line">    PDIndex = (VPN &amp; PD_MASK) &gt;&gt; PD_SHIFT</span><br><span class="line">    PDEAddr = PDBR + (PDIndex * <span class="keyword">sizeof</span>(PDE))</span><br><span class="line">    PDE = AccessMemory(PDEAddr)</span><br><span class="line">    <span class="keyword">if</span> (PDE.Valid == False)</span><br><span class="line">        RaiseException(SEGMENTATION_FAULT)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="comment">// PDE is valid: now fetch PTE from page table</span></span><br><span class="line">        PTIndex = (VPN &amp; PT_MASK) &gt;&gt; PT_SHIFT</span><br><span class="line">        PTEAddr = (PDE.PFN &lt;&lt; SHIFT) + (PTIndex * <span class="keyword">sizeof</span>(PTE))</span><br><span class="line">        PTE = AccessMemory(PTEAddr)</span><br><span class="line">        <span class="keyword">if</span> (PTE.Valid == False)</span><br><span class="line">            RaiseException(SEGMENTATION_FAULT)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (CanAccess(PTE.ProtectBits) == False)</span><br><span class="line">            RaiseException(PROTECTION_FAULT)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)</span><br><span class="line">            RetryInstruction()</span><br></pre></td></tr></table></figure>
<h2 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h2><p>在反向页表（inverted page table）中，可以看到页表世界中更极端的空间节省。在反向页表中，只保留了一个全局的页表。这个全局页表中的每一项代表系统的一个物理页，而不是一个进程的内存映射。每个页表项包含了两个重要的信息：哪个进程正在使用该物理页，以及该进程的哪个虚拟页映射到该物理页。</p>
<p>现在，要找到正确的项，就是要搜索这个数据结构。线性扫描是昂贵的，因此通常在此基础结构上建立散列表，以加速查找。PowerPC 就是这种架构的一个例子</p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>1.对于线性页表，假设硬件在 TLB 未命中时进行查找，则需要一个寄存器来定位页表。 您需要多少个寄存器才能找到两级页表？ 三级页表？</p>
<blockquote>
<p>对于线性页表，每个页表级别都需要一个寄存器来定位页表。<br>对于两级页表，需要2个寄存器来找到页表。第一个寄存器用于找到一级页表，第二个寄存器用于找到二级页表。<br>对于三级页表，需要3个寄存器来找到页表。第一个寄存器用于找到一级页表，第二个寄存器用于找到二级页表，第三个寄存器用于找到三级页表。</p>
</blockquote>
<p>3．根据你对缓存内存的工作原理的理解，你认为对页表的内存引用如何在缓存中工作？它们是否会导致大量的缓存命中（并导致快速访问）或者很多未命中（并导致访问缓慢）？</p>
<blockquote>
<p>缓存置换算法也会影响缓存的命中率。常见的缓存置换算法如LRU（Least Recently Used）、LFU（Least Frequently Used）和随机置换等。这些算法决定了哪些页表项会被保留在TLB中，哪些会被替换出去。</p>
</blockquote>
<h1 id="内存虚拟化名词解释"><a href="#内存虚拟化名词解释" class="headerlink" title="内存虚拟化名词解释"></a>内存虚拟化名词解释</h1><table>
<thead>
<tr>
<th>英文缩写</th>
<th>英文全称</th>
<th>中文名称</th>
</tr>
</thead>
<tbody><tr>
<td>VPN</td>
<td>Virtual Page Number</td>
<td>虚拟页号</td>
</tr>
<tr>
<td>MMU</td>
<td>Memory Management Unit</td>
<td>内存管理单元</td>
</tr>
<tr>
<td>PCB</td>
<td>Process Control Block</td>
<td>进程控制块</td>
</tr>
<tr>
<td>PFN</td>
<td>Page Frame Number</td>
<td>页帧号</td>
</tr>
<tr>
<td>PTE</td>
<td>Page Table Entry</td>
<td>页表项</td>
</tr>
<tr>
<td>PTBR</td>
<td>page-table base register</td>
<td>页表基址寄存器</td>
</tr>
<tr>
<td>TLB</td>
<td>translation-lookaside buffer</td>
<td>地址转换旁路缓冲存储器</td>
</tr>
<tr>
<td>PDE</td>
<td>Page Directory Entries</td>
<td>页目录项</td>
</tr>
</tbody></table>
<h1 id="超越物理内存-机制"><a href="#超越物理内存-机制" class="headerlink" title="超越物理内存:机制"></a>超越物理内存:机制</h1><p>到目前为止，我们一直假设所有页都常驻在物理内存中。但是，为了支持更大的地址空间，操作系统需要把当前没有在用的那部分地址空间找个地方存储起来。<br>在现代系统中，硬盘（hard disk drive）通常能够满足这个需求。</p>
<blockquote>
<p>为什么我们要为进程支持巨大的地址空间？<br>可以提供更多的内存使用空间、支持更多的并发性、实现动态内存分配和支持虚拟内存技术等重要功能。</p>
</blockquote>
<p>不仅是一个进程，增加交换空间让操作系统为多个并发运行的进程都提供巨大地址空间的假象。</p>
<h2 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h2><p>第一件事情就是，在硬盘上开辟一部分空间用于物理页的移入和移出。这样的空间称为交换空间（swap space）<br>我们将内存中的页交换到其中，并在需要的时候又交换回去。因此，我们会假设操作系统能够以页大小为单元读取或者写入交换空间。操作系统需要记住给定页的硬盘地址（disk address）。</p>
<p>交换空间的大小是非常重要的，它决定了系统在某一时刻能够使用的最大内存页数。</p>
<p>在这个例子中，3 个进程（进程 0、进程 1 和进程 2）主动共享物理内存。但 3 个中的每一个，都只有一部分有效页在内存中，剩下的在硬盘的交换空间中。第 4 个进程（进程 3）的所有页都被交换到硬盘上，因此很清楚它目前没有运行。有一块交换空间是空闲的。</p>
<p>要么在程序开始运行时全部加载，要么在现代操作系统中，按需要一页一页加载<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/y5.png" alt="?"></p>
<h2 id="存在位"><a href="#存在位" class="headerlink" title="存在位"></a>存在位</h2><p>内存引用发生了什么?<br>正在运行的进程生成虚拟内存引用（用于获取指令或访问数据），在这种情况下，硬件将其转换为物理地址，再从内存中获取所需数据。</p>
<p>硬件首先从虚拟地址获得 VPN，检查 TLB 是否匹配（TLB 命中），如果命中，则获得最终的物理地址并从内存中取回。这希望是常见情形，因为它很快（不需要额外的内存访问）。<br>如果在 TLB 中找不到 VPN（即 TLB 未命中），则硬件在内存中查找页表（使用页表基址寄存器），并使用 VPN 查找该页的页表项（PTE）作为索引。如果页有效且存在于物理内存中，则硬件从 PTE 中获得 PFN，将其插入 TLB，并重试该指令，这次产生 TLB 命中。到现在为止还挺好。</p>
<p>如果希望允许页交换到硬盘，必须添加更多的机制。具体来说，当硬件在 PTE中查找时，可能发现页不在物理内存中。硬件（或操作系统，在软件管理 TLB 时）判断是否在内存中的方法，是通过页表项中的一条新信息，即存在位（present bit）。如果存在位设置为 1，则表示该页存在于物理内存中，并且所有内容都如上所述进行。如果存在位设置为零，则页不在内存中，而在硬盘上。访问不在物理内存中的页，这种行为通常被称为页错误（page fault）。</p>
<blockquote>
<p>一个程序“页错误”时，意味着它正在访问的虚拟地址空间的一部分，被操作系统交换到了硬盘上。</p>
</blockquote>
<p>在页错误时，操作系统被唤起来处理页错误。一段称为“页错误处理程序（page-fault handler）”的代码会执行，来处理页错误。</p>
<h2 id="页错误"><a href="#页错误" class="headerlink" title="页错误"></a>页错误</h2><p>在 TLB 未命中的情况下，我们有两种类型的系统：<strong>硬件管理的 TLB</strong>（硬件在页表中找到需要的转换映射）和<strong>软件管理的 TLB</strong>（操作系统执行查找过程）。不论在哪种系统中，如果页不存在，都由操作系统负责处理页错误。操作系统的页错误处理程序（page-fault handler）确定要做什么。几乎所有的系统都在软件中处理页错误。即使是硬件管理的 TLB，硬件也信任操作系统来管理这个重要的任务。</p>
<p>操作系统如何知道所需的页在哪儿？</p>
<p>在许多系统中，页表是存储这些信息最自然的地方。因此，操作系统可以用 PTE 中的某些位来存储硬盘地址，这些位通常用来存储像页的 PFN 这样的数据。当操作系统接收到页错误时，它会在 PTE 中查找地址，并将请求发送到硬盘，将页读取到内存中。</p>
<p>当硬盘 I/O 完成时，操作系统会更新页表，将此页标记为存在，更新页表项（PTE）的PFN 字段以记录新获取页的内存位置，并重试指令。下一次重新访问 TLB 还是未命中，然而这次因为页在内存中，因此会将页表中的地址更新到 TLB 中（也可以在处理页错误时更新 TLB 以避免此步骤）。最后的重试操作会在 TLB 中找到转换映射，从已转换的内存物理地址，获取所需的数据或指令。</p>
<p>请注意，当 I/O 在运行时，进程将处于阻塞（blocked）状态。因此，当页错误正常处理时，操作系统可以自由地运行其他可执行的进程。因为 I/O 操作是昂贵的，一个进程进行I/O（页错误）时会执行另一个进程，这种交叠（overlap）是多道程序系统充分利用硬件的一种方式。</p>
<h2 id="内存满了怎么办"><a href="#内存满了怎么办" class="headerlink" title="内存满了怎么办"></a>内存满了怎么办</h2><p>操作系统可能希望先交换出（page out）一个或多个页，以便为操作系统即将交换入的新页留出空间。选择哪些页被交换出或被替换（replace）的过程，被称为页交换策略（page-replacementpolicy）。</p>
<h2 id="页错误处理流程"><a href="#页错误处理流程" class="headerlink" title="页错误处理流程"></a>页错误处理流程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line">(Success, TlbEntry) = TLB_Lookup(VPN)</span><br><span class="line">    <span class="keyword">if</span> (Success == True) <span class="comment">// TLB Hit</span></span><br><span class="line">        <span class="keyword">if</span> (CanAccess(TlbEntry.ProtectBits) == True)</span><br><span class="line">            Offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line">            PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset</span><br><span class="line">            Register = AccessMemory(PhysAddr)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            RaiseException(PROTECTION_FAULT)</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// TLB Miss</span></span><br><span class="line">        PTEAddr = PTBR + (VPN * <span class="keyword">sizeof</span>(PTE))</span><br><span class="line">        PTE = AccessMemory(PTEAddr)</span><br><span class="line">    <span class="keyword">if</span> (PTE.Valid == False)</span><br><span class="line">        RaiseException(SEGMENTATION_FAULT)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (CanAccess(PTE.ProtectBits) == False)</span><br><span class="line">            RaiseException(PROTECTION_FAULT)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (PTE.Present == True)</span><br><span class="line"><span class="comment">// assuming hardware-managed TLB</span></span><br><span class="line">            TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)</span><br><span class="line">            RetryInstruction()</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (PTE.Present == False)</span><br><span class="line">            RaiseException(PAGE_FAULT)</span><br></pre></td></tr></table></figure>
<p><strong>当 TLB 未命中发生的时候有 3 种重要情景。</strong><br>第一种情况，该页存在（present）且有效（valid）（第 18～21 行）。在这种情况下，TLB 未命中处理程序可以简单地从 PTE 中获取 PFN，然后重试指令（这次 TLB 会命中），并因此继续前面描述的流程。</p>
<p>第二种情况（第 22～23 行），页错误处理程序需要运行。虽然这是进程可以访问的合法页（毕竟是有效的），但它并不在物理内存中。</p>
<p>第三种情况，访问的是一个无效页，可能由于程序中的错误（第 13～14 行）。在这种情况下，PTE 中的其他位都不重要了。硬件捕获这个非法访问，操作系统陷阱处理程序运行，可能会杀死非法进程。</p>
<p><strong>为了处理页错误，操作系统大致做了什么?</strong><br>首先，操作系统必须为将要换入的页找到一个物理帧，如果没有这样的物理帧，我们将不得不等待交换算法运行，并从内存中踢出一些页，释放帧供这里使用。在获得物理帧后，处理程序发出 I/O 请求从交换空间读取页。最后，当这个慢操作完成时，操作系统更新页表并重试指令。重试将导致 TLB 未命中，然后再一次重试时，TLB 命中，此时硬件将能够访问所需的值。</p>
<h2 id="交换何时真正发生"><a href="#交换何时真正发生" class="headerlink" title="交换何时真正发生"></a>交换何时真正发生</h2><p>为了保证有少量的空闲内存，大多数操作系统会设置高水位线（High Watermark，HW）和低水位线（Low Watermark，LW），来帮助决定何时从内存中清除页。原理是这样：当操作系统发现有少于 LW 个页可用时，后台负责释放内存的线程会开始运行，直到有 HW 个可用的物理页。这个后台线程有时称为交换守护进程（swap daemon）或页守护进程（page daemon），它然后会很开心地进入休眠状态，因为它毕竟为操作系统释放了一些内存。</p>
<p>通过同时执行多个交换过程，我们可以进行一些性能优化。例如，许多系统会把多个要写入的页聚集（cluster）或分组（group），同时写入到交换区间，从而提高硬盘的效率。</p>
<h1 id="超越物理内存-策略"><a href="#超越物理内存-策略" class="headerlink" title="超越物理内存:策略"></a>超越物理内存:策略</h1><p>由于内存压力（memory pressure）迫使操作系统换出（paging out）一些页，为常用的页腾出空间。确定要踢出（evict）哪个页（或哪些页）封装在操作系统的替换策略（replacement policy）中。</p>
<h2 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h2><p>由于内存只包含系统中所有页的子集，因此可以将其视为系统中虚拟内存页的缓存（cache）。因此，在为这个缓存选择替换策略时，我们的目标是让缓存未命中（cache miss）最少，即使得从磁盘获取页的次数最少。或者，可以将目标看成让缓存命中（cache hit）最多，即在内存中找到待访问页的次数最多。</p>
<p><strong>知道了缓存命中和未命中的次数，就可以计算程序的平均内存访问时间（Average Memory Access Time，AMAT，计算机架构师衡量硬件缓存的指标 ）<br>AMAT = (PHit·TM) + (PMiss·TD)<br>其中 TM 表示访问内存的成本，TD 表示访问磁盘的成本，PHit 表示在缓存中找到数据的概率（命中），PMiss表示在缓存中找不到数据的概率（未命中）。PHit和 PMiss从 0.0 变化到 1.0，并且 PMiss + PHit = 1.0。</strong></p>
<h2 id="最优替换策略（无法实现）"><a href="#最优替换策略（无法实现）" class="headerlink" title="最优替换策略（无法实现）"></a>最优替换策略（无法实现）</h2><p><strong>替换内存中在最远将来才会被访问到的页，可以达到缓存未命中率最低。</strong></p>
<p><strong>根据即将执行的队列元素顺序进行踢出，缓存里的元素在后续队列中谁离得远踢谁</strong></p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设一个程序按照以下顺序访问<br>虚拟页：0，1，2，0，1，3，0，3，1，2，1。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/u1.png" alt="?"><br>前 3 个访问是未命中，因为缓存开始是空的。这种未命中有时也称作冷启动未命中（cold-start miss，或强制未命中，compulsory miss）。<br>然后我们再次引用页 0 和 1，它们都在缓存中。<br>最后，我们又有一个缓存未命中（页3），但这时缓存已满，必须进行替换！<br><strong>使用最优策略，我们检查当前缓存中每个页（0、1 和 2）未来访问情况，可以看到页 0 马上被访问，页 1 稍后被访问，页 2 在最远的将来被访问。</strong></p>
<p><strong>未来的访问是无法知道的，你无法为通用操作系统实现最优策略。</strong></p>
<blockquote>
<p>补充：缓存未命中的类型<br>在计算机体系结构世界中，架构师有时会将未命中分为 3 类：强制性、容量和冲突未命中，有时称为3C [H87]。发生强制性（compulsory miss）未命中（或冷启动未命中，cold-start miss [EF78]）是因为缓存开始是空的，而这是对项目的第一次引用。与此不同，由于缓存的空间不足而不得不踢出一个项目以将新项目引入缓存，就发生了容量未命中（capacity miss）。第三种类型的未命中（冲突未命中，conflict miss）出现在硬件中，因为硬件缓存中对项的放置位置有限制，这是由于所谓的集合关联性（set-associativity）。它不会出现在操作系统页面缓存中，因为这样的缓存总是完全关联的（fully-associative），即对页面可以放置的内存位置没有限制。详情请见 H＆P [HP06]。</p>
</blockquote>
<h2 id="简单策略：FIFO"><a href="#简单策略：FIFO" class="headerlink" title="简单策略：FIFO"></a>简单策略：FIFO</h2><p>页在进入系统时，简单地放入一个队列。当发生替换时，最先进入的被踢出。FIFO 有一个很大的优势：实现相当简单。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/u2.png" alt="?"></p>
<p>一般来说，<strong>当缓存变大时</strong>，缓存命中率是会提高的。但<strong>在这个例子</strong>，<strong>采用 FIFO，命中率反而下降了！</strong> 这种奇怪的现象被称为 Belady 的异常（Belady’s Anomaly）。</p>
<blockquote>
<p>其他一些策略，比如 LRU，不会遇到这个问题。可以猜猜为什么？<br>LRU 具有所谓的栈特性（stack property）。对于具有这个性质的算法，大小为 N + 1 的缓存自然包括大小为 N 的缓存的内容。因此，当增加缓存大小时，缓存命中率至少保证不变，有可能提高。先进先出（FIFO）和随机（Random）等显然没有栈特性，因此容易出现异常行为。</p>
</blockquote>
<h2 id="另一简单策略：随机"><a href="#另一简单策略：随机" class="headerlink" title="另一简单策略：随机"></a>另一简单策略：随机</h2><p>另一个类似的替换策略是随机，在内存满的时候它随机选择一个页进行替换。随机具有类似于 FIFO 的属性。实现我来很简单，但是它在挑选替换哪个页时不够智能。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/u3.png" alt="?"></p>
<p>随机策略取决于当时的运气。</p>
<h2 id="利用历史数据：LRU"><a href="#利用历史数据：LRU" class="headerlink" title="利用历史数据：LRU"></a>利用历史数据：LRU</h2><p>为了提高后续的命中率，我们再次通过历史的访问情况作为参考。例如，如果某个程序在过去访问过某个页，则很有可能在不久的将来会再次访问该页。<br>页更常用的属性是访问的近期性（recency），越近被访问过的页，也许再次访问的可能性也就越大。</p>
<p>一系列简单的基于历史的算法诞生了。“最不经常使用”（Least-Frequently-Used，LFU）策略会替换最不经常使用的页。</p>
<p>同样，“最少最近使用”（Least-Recently-Used，LRU）策略替换最近最少使用的页面。</p>
<blockquote>
<p>补充：<strong>局部性类型</strong><br><strong>程序倾向于表现出两种类型的局部。第一种是空间局部性（spatial locality），它指出如果页 P 被访问，可能围绕它的页（比如 P−1 或 P + 1）也会被访问。<br>第二种是时间局部性（temporal locality），它指出近期访问过的页面很可能在不久的将来再次访问。<br>假设存在这些类型的局部性，对硬件系统的缓存层次结构起着重要作用，硬件系统部署了许多级别的指令、数据和地址转换缓存，以便在存在此类局部性时，能帮助程序快速运行。</strong></p>
</blockquote>
<p>在这个例子中，当第一次需要替换页时，LRU 会踢出页 2，因为 0 和 1 的访问时间更近。然后它替换页 0，因为 1 和 3 最近被访问过。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/u4.png" alt="?"></p>
<p><strong>从当前位置往前看，缓存中谁在最前面就踢谁。</strong></p>
<p>与这些算法完全相反的算法也是存在：最经常使用策略（Most-Frequently-Used，MFU）和最近使用策略（Most-Recently-Used，MRU）。在大多数情况下（不是全部！），这些策略效果都不好，因为它们忽视了大多数程序都具有的局部性特点。</p>
<h2 id="工作负载示例"><a href="#工作负载示例" class="headerlink" title="工作负载示例"></a>工作负载示例</h2><p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/u5.png" alt="?"><br>当工作负载不存在局部性时，使用的策略区别不大。LRU、FIFO 和随机都执行相同的操作，命中率完全由缓存的大小决定。其次，当缓存足够大到可以容纳所有的数据时，使用哪种策略也无关紧要，所有的策略（甚至是随机的）都有 100%的命中率。</p>
<p>我们下一个工作负载就是所谓的“80—20”负载场景，它表现出局部性：80%的引用是访问 20%的页（“热门”页）。剩下的 20%是对剩余的 80%的页（“冷门”页）访问。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/u6.png" alt="?"><br>尽管随机和 FIFO 都很好地运行，但 LRU 更好，因为它更可能保持热门页。由于这些页面过去经常被提及，它们很可能在不久的将来再次被提及。优化再次表现得更好，表明 LRU 的历史信息并不完美。</p>
<p>我们称之为“循环顺序”工作负载，其中依次引用 50个页，从 0 开始，然后是 1，…，49，然后循环，重复访问，总共有 10000 次访问 50 个单独页。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/u7.png" alt="?"><br>展示了 LRU 或者 FIFO 的最差情况。</p>
<h2 id="实现基于历史信息的算法"><a href="#实现基于历史信息的算法" class="headerlink" title="实现基于历史信息的算法"></a>实现基于历史信息的算法</h2><p>以 LRU 为例。具体地说，在每次页访问（即每次内存访问，不管是取指令还是加载指令还是存储指令）时，我们都必须更新一些数据，从而将该页移动到列表的前面（即 MRU 侧）。与 FIFO 相比，FIFO 的页列表仅在页被踢出（通过移除最先进入的页）或者当新页添加到列表（已到列表尾部）时才被访问。为了记录哪些页是最少和最近被使用，系统必须对每次内存引用做一些记录工作。</p>
<p>有一种方法有助于加快速度，就是增加一点硬件支持。例如，硬件可以在每个页访问时更新内存中的时间字段（时间字段可以在每个进程的页表中，或者在内存的某个单独的数组中，每个物理页有一个）。因此，当页被访问时，时间字段将被硬件设置为当前时间。然后，在需要替换页时，操作系统可以简单地扫描系统中所有页的时间字段以找到最近最<br>少使用的页。</p>
<p><strong>随着系统中页数量的增长，扫描所有页的时间字段只是为了找到最精确最<br>少使用的页，这个代价太昂贵。</strong></p>
<p>由于实现完美的 LRU 代价非常昂贵，我们能否实现一个近似的 LRU 算法，并且依然能够获得预期的效果？</p>
<h2 id="近似-LRU"><a href="#近似-LRU" class="headerlink" title="近似 LRU"></a>近似 LRU</h2><p>系统的每个页有一个使用位，然后这些使用位存储在某个地方（例如，它们可能在每个进程的页表中，或者只在某个数组中）。每当页被引用（即读或写）时，硬件将使用位设置为 1。但是，硬件不会清除该位（即将其设置为 0），这由操作系统负责。</p>
<p>系统中的所有页都放在一个循环列表中。时钟指针（clock hand）开始时指向某个特定的页（哪个页不重要）。当必须进行页替换时，操作系统检查当前指向的页 P 的使用位是 1 还是 0。如果是 1，则意味着页面 P 最近被使用，因此不适合被替换。然后，P 的使用位设置为 0，时钟指针递增到下一页（P + 1）。该算法一直持续到找到一个使用位为 0 的页，使用位为 0 意味着这个页最近没有被使用过（在最坏的情况下，所有的页都已经被使用了，那么就将所有页的使用位都设置为 0）。</p>
<p><strong>时钟算法:该变种在需要进行页替换时随机扫描各页，如果遇到一个页的引用位为 1，就清除该位（即将它设置为 0）。直到找到一个使用位为 0的页，将这个页进行替换。</strong><br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/u8.png" alt="?"></p>
<h2 id="考虑脏页"><a href="#考虑脏页" class="headerlink" title="考虑脏页"></a>考虑脏页</h2><p>如果页已被修改（modified）并因此变脏（dirty），则踢出它就必须将它写回磁盘，这很昂贵。如果它没有被修改（因此是干净的，clean），踢出就没成本。物理帧可以简单地重用于其他目的而无须额外的 I/O。因此，一些虚拟机系统更倾向于踢出干净页，而不是脏页。</p>
<h2 id="其他虚拟内存策略"><a href="#其他虚拟内存策略" class="headerlink" title="其他虚拟内存策略"></a>其他虚拟内存策略</h2><p>页面替换不是虚拟内存子系统采用的唯一策略（尽管它可能是最重要的）。例如，操作系统还必须决定何时将页载入内存。该策略有时称为页选择（page selection）策略。<br>另一个策略决定了操作系统如何将页面写入磁盘。许多系统会在内存中收集一些待完成写入，并以一种（更高效）的写入方式将它们写入硬盘。这种行为通常称为聚集（clustering）写入，或者就是分组写入（grouping），这样做有效是因为硬盘驱动器的性质，执行单次大的写操作，比许多小的写操作更有效。</p>
<h2 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h2><p>当内存就是被超额请求时，在这种情况下，系统将不断地进行换页，这种情况有时被称为抖动（thrashing）。</p>
<blockquote>
<p>当内存被超额请求时，系统内存不足以容纳所有需要运行的进程和数据，因此系统需要不断进行换页操作。换页是指将内存中的某些页面（页框）置换到磁盘上，以释放内存空间给新的页面使用。</p>
</blockquote>
<hr>
<h1 id="VAX-VVM虚拟内存系统"><a href="#VAX-VVM虚拟内存系统" class="headerlink" title="VAX//VVM虚拟内存系统"></a>VAX//VVM虚拟内存系统</h1><h2 id="内存管理硬件"><a href="#内存管理硬件" class="headerlink" title="内存管理硬件"></a>内存管理硬件</h2><p>VAX-11 为每个进程提供了一个 32 位的虚拟地址空间，分为 512 字节的页。因此，虚拟地址由 23 位 VPN 和 9 位偏移组成。此外，VPN 的高两位用于区分页所在的段。因此，如前所述，该系统是分页和分段的混合体。</p>
<p>地址空间的下半部分称为“进程空间”，对于每个进程都是唯一的。在进程空间的前半部分（称为 P0）中，有用户程序和一个向下增长的堆。在进程空间的后半部分（P1），有向上增长的栈。地址空间的上半部分称为系统空间（S），尽管只有一半被使用。受保护的操作系统代码和数据驻留在此处，操作系统以这种方式跨进程共享。</p>
<h2 id="一个真实的地址空间"><a href="#一个真实的地址空间" class="headerlink" title="一个真实的地址空间"></a>一个真实的地址空间</h2><blockquote>
<p>补充：为什么空指针访问会导致段错误<br>你现在应该很好地理解一个空指针引用会发生什么。通过这样做，进程生成了一个虚拟地址 0：<br>int *p = NULL; // set p = 0<br>*p = 10; // try to store value 10 to virtual address 0<br>硬件试图在 TLB 中查找 VPN（这里也是 0），遇到 TLB 未命中。查询页表，并且发现 VPN 0 的条目被标记为无效。因此，我们遇到无效的访问，将控制权交给操作系统，这可能会终止进程（在 UNIX 系统上，会向进程发出一个信号，让它们对这样的错误做出反应。但是如果信号未被捕获，则会终止进程）。</p>
</blockquote>
<p>代码段永远不会从第 0 页开始。相反，该页被标记为不可访问，以便为检测空指针（null-pointer）访问提供一些支持。</p>
<h2 id="页替换"><a href="#页替换" class="headerlink" title="页替换"></a>页替换</h2><p>VAX 中的页表项（PTE）包含以下位：一个有效位，一个保护字段（4 位），一个修改（或脏位）位，为 OS 使用保留的字段（5 位），最后是一个物理帧号码（PFN）将页面的位置存储在物理内存中。</p>
<h3 id="分段的-FIFO"><a href="#分段的-FIFO" class="headerlink" title="分段的 FIFO"></a>分段的 FIFO</h3><p>每个进程都有一个可以保存在内存中的最大页数，称为驻留集大小（Resident Set Size，RSS）。每个页都保存在 FIFO 列表中。当一个进程超过其 RSS 时，“先入”的页被驱逐。FIFO 显然不需要硬件的任何支持，因此很容易实现。</p>
<h2 id="其他漂亮的虚拟内存技巧"><a href="#其他漂亮的虚拟内存技巧" class="headerlink" title="其他漂亮的虚拟内存技巧"></a>其他漂亮的虚拟内存技巧</h2><p>按需置零和写入时复制。<br>在一个初级实现中，操作系统响应一个请求，在物理内存中找到页，将该页添加到你的堆中，并将其置零（安全起见，这是必需的。否则，你可以看到其他进程使用该页时的内容。），然后将其映射到你的地址空间（设置页表以根据需要引用该物理页）。但是初级实现可能是昂贵的，特别是如果页没有被进程使用.</p>
<p>利用按需置零，当页添加到你的地址空间时，操作系统的工作很少。它会在页表中放入一个标记页不可访问的条目。如果进程读取或写入页，则会向操作系统发送陷阱。在处理陷阱时，操作系统注意到（通常通过页表项中“保留的操作系统字段”部分标记的一些位），这实际上是一个按需置零页。此时，操作系统会完成寻找物理页的必要工作，将它置零，并映射到进程的地址空间。如果该进程从不访问该页，则所有这些工作都可以避免，从而体现按需置零的好处。</p>
<p>如果操作系统需要将一个页面从一个地址空间复制到另一个地址空间，不是实际复制它，而是将其映射到目标地址空间，并在两个地址空间中将其标记为只读。如果两个地址空间都只读取页面，则不会采取进一步的操作，因此操作系统已经实现了快速复制而不实际移动任何数据。但是，如果其中一个地址空间确实尝试写入页面，就会陷入操作系统。操作系统会注意到该页面是一个 COW 页面，因此（惰性地）分配一个新页，填充数据，并将这个新页映射到错误处理的地址空间。该进程然后继续，现在有了该页的私人副本。</p>
]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统导论-进程调度</title>
    <url>/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="进程调度-介绍"><a href="#进程调度-介绍" class="headerlink" title="进程调度:介绍"></a>进程调度:介绍</h1><h2 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h2><p>周转时间（turnaround time）。任务的周转时间定义为任务完成时间减去任务到达系统的时间。</p>
<h2 id="先进先出（FIFO）"><a href="#先进先出（FIFO）" class="headerlink" title="先进先出（FIFO）"></a>先进先出（FIFO）</h2><blockquote>
<p>3 个工作 A、B 和 C 在大致相同的时间（T 到达时间 = 0）到达系统。因为 FIFO 必须将某个工作放在前面，所以我们假设当它们都同时到达时，A 比 B 早一点点，然后 B 比 C 早到达一点点。假设每个工作运行 10s。这些工作的平均周转时间（average turnaround time）是多少？</p>
</blockquote>
<p>A 在 10s 时完成，B 在 20s 时完成，C 在 30s 时完成。因此，这3个任务的平均周转时间就是（10 + 20 + 30）/ 3 = 20。</p>
<blockquote>
<p>假设 3 个任务（A、B 和 C），但这次 A 运行100s，而 B 和 C 运行 10s。</p>
</blockquote>
<p>A 先运行 100s，B 或 C 才有机会运行。因此，系统的平均周转时间是比<br>较高的：令人不快的 110s（（100 + 110 + 120）/ 3 = 110）。</p>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/q1.png" alt="?"></p>
<h2 id="最短任务优先（SJF）"><a href="#最短任务优先（SJF）" class="headerlink" title="最短任务优先（SJF）"></a>最短任务优先（SJF）</h2><p>先运行最短的任务，然后是次短的任务，如此下去。<br>我们用上面的例子，SJF 调度策略更好。仅通过在 A 之前运行B和C，SJF 将平均周转时间从 110s 降低到 50s ((10+20 +120)/3=50)。</p>
<p><strong>考虑到所有工作<red>同时</red>到达的假设，我们可以证明 SJF 确实是一个最优（optimal）调度算法。</strong></p>
<blockquote>
<p>假设A在t = 0时到达,且需要运行 100s。而 B 和 C 在 t = 10 到达，且各需要运行 10s。用纯 SJF，我们可以得到如图 7.4 所示的调度。</p>
</blockquote>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/q2.png" alt="?"></p>
<h2 id="最短完成时间优先（STCF）"><a href="#最短完成时间优先（STCF）" class="headerlink" title="最短完成时间优先（STCF）"></a>最短完成时间优先（STCF）</h2><p>为了解决这个问题，需要调度程序本身的一些机制。当B和C到达时，调度程序当然可以做其他事情:它可以抢占 (preempt) 工作 A，并决定运行另一个工作，或许稍后继续工作 A。根据我们的定义，SJF 是一种非抢占式(non-preemptive) 调度程序，因此存在上述问题。</p>
<p>向 SJF 添加抢占，称为最短完成时间优先（Shortest Time-to-Completion First，STCF）或抢占式最短作业优先（Preemptive Shortest JobFirst ，PSJF）调度程序。每当新工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作。</p>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/q3.png" alt="?"></p>
<h2 id="度量指标：响应时间"><a href="#度量指标：响应时间" class="headerlink" title="度量指标：响应时间"></a>度量指标：响应时间</h2><p>如果我们知道任务长度，而且任务只使用 CPU，而我们唯一的衡量是周转时间，STCF 将是一个很好的策略。事实上，对于许多早期批处理系统，这些类型的调度算法有一定的意义。然而，引入分时系统改变了这一切。现在，<strong>用户将会坐在终端前面，同时也要求系统的交互性好。</strong> 因此，一个新的度量标准诞生了：响应时间（response time）。</p>
<p>响应时间定义为从任务到达系统到首次运行的时间。更正式的定义是：<br><strong>T 响应时间= T 首次运行−T 到达时间</strong></p>
<h2 id="轮转-引入响应时间"><a href="#轮转-引入响应时间" class="headerlink" title="轮转(引入响应时间)"></a>轮转(引入响应时间)</h2><p>RR调度基本思想很简单:RR 在一个时间片(time slice,有时称为调度量子，(schedulingquantum)内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。</p>
<p>它反复执行，直到所有任务完成。因此，RR 有时被称为时间切片 (time-slicing)请注意，时间片长度必须是时钟中断周期的倍数。因此，如果时钟中断是每 10ms 中断一次则时间片可以是 10ms、20ms 或 10ms 的任何其他倍数。</p>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/q4.png" alt="?"><br>RR 的平均响应时间是：（0 + 1 + 2）/3 = 1; SJF 算法平均响应时间是：（0 + 5 + 10）/ 3 = 5。</p>
<p>时间片太短是有问题的：突然上下文切换的成本将影响整体性能。</p>
<blockquote>
<p>当系统某些操作有固定成本时，<strong>通常会使用摊销技术（amortization）。通过减少成本的频度（即执行较少次的操作）</strong>，系统的总成本就会降低。例如，如果时间片设置为 10ms，并且上下文切换时间为 1ms，那么浪费大约 10%的时间用于上下文切换。如果要摊销这个成本，可以把时间片增加到 100ms。在这种情况下，不到 1%的时间用于上下文切换，因此时间片带来的成本就被摊销了。</p>
</blockquote>
<p>上下文切换的成本不仅仅来自保存和恢复少量寄存器的操作系统操作。程序运行时，它们在 CPU 高要缓存、TLB、分支预测器和其他片上硬件中建立了大量的状态。切换到另一个工作会导致此状态被刷新，且与当前运行的作业相关的新状态被引入。</p>
<blockquote>
<p><strong>如果你愿意不公平，你可以运行较短的工作直到完成，但是要以响应时间为代价。如果你重视公平性，则响应时间会较短，但会以周转时间为代价。这种权衡在系统中很常见。</strong></p>
</blockquote>
<p><strong>第一种类型（SJF、STCF）优化周转时间，但对响应时间不利。第二种类型（RR）优化响应时间，但对周转时间不利。</strong></p>
<h2 id="结合-I-O"><a href="#结合-I-O" class="headerlink" title="结合 I/O"></a>结合 I/O</h2><p>调度程序显然要在工作发起 I/O 请求时做出决定，因为当前正在运行的作业在 I/O 期间不会使用 CPU，它被阻塞等待 I/O 完成。如果将 I/O 发送到硬盘驱动器，则进程可能会被阻塞几毫秒或更长时间，具体取决于驱动器当前的 I/O 负载。因此，这时调度程序应该在 CPU上安排另一项工作。</p>
<p>调度程序还必须在 I/O 完成时做出决定。发生这种情况时，会产生中断，操作系统运行并将发出 I/O 的进程从阻塞状态移回就绪状态。当然，它甚至可以决定在那个时候运行该项工作。</p>
<p>让我们假设有两项工作 A 和 B，每项工作需要 50ms 的 CPU时间。但是，有一个明显的区别：A 运行 10ms，然后发出 I/O 请求（假设 I/O 每个都需要10ms），而 B 只是使用 CPU 50ms，不执行 I/O。调度程序先运行 A，然后运行 B。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/q5.png" alt="?"></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>1.使用 SJF 和 FIFO 调度程序运行长度为 200 的 3 个作业时,计算响应时间和周转时间。</p>
<p>SJF:</p>
<table>
<thead>
<tr>
<th>作业 id</th>
<th>响应时间</th>
<th>周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>200</td>
</tr>
<tr>
<td>1</td>
<td>200</td>
<td>400</td>
</tr>
<tr>
<td>2</td>
<td>400</td>
<td>600</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>FIFO:</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>作业 id</td>
<td>响应时间</td>
<td>周转时间</td>
</tr>
<tr>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>200</td>
</tr>
<tr>
<td>1</td>
<td>200</td>
<td>400</td>
</tr>
<tr>
<td>2</td>
<td>400</td>
<td>600</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>调度策略</td>
<td>平均响应时间</td>
<td>平均周转时间</td>
</tr>
<tr>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>SJF</td>
<td>200</td>
<td>400</td>
</tr>
<tr>
<td>FIFO</td>
<td>200</td>
<td>400</td>
</tr>
</tbody></table>
<p>2.现在做同样的事情,但有不同长度的作业,即 100、200 和 300</p>
<p>SJF:</p>
<table>
<thead>
<tr>
<th>作业 id</th>
<th>响应时间</th>
<th>周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>100</td>
</tr>
<tr>
<td>1</td>
<td>100</td>
<td>300</td>
</tr>
<tr>
<td>2</td>
<td>300</td>
<td>600</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>FIFO:</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>作业 id</td>
<td>响应时间</td>
<td>周转时间</td>
</tr>
<tr>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>100</td>
</tr>
<tr>
<td>1</td>
<td>100</td>
<td>300</td>
</tr>
<tr>
<td>2</td>
<td>300</td>
<td>600</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>调度策略</td>
<td>平均响应时间</td>
<td>平均周转时间</td>
</tr>
<tr>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>SJF</td>
<td>400/3</td>
<td>1000/3</td>
</tr>
<tr>
<td>FIFO</td>
<td>400/3</td>
<td>1000/3</td>
</tr>
</tbody></table>
<p>3.现在做同样的事情,但采用 RR 调度程序,时间片为 1</p>
<p>长度为 200:<br>RR:</p>
<table>
<thead>
<tr>
<th>作业 id</th>
<th>响应时间</th>
<th>周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>598</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>599</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>600</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>平均响应时间 = 1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>平均周转时间 = 599</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>长度为 100, 200, 300:<br>RR:</p>
<table>
<thead>
<tr>
<th>作业 id</th>
<th>响应时间</th>
<th>周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>298</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>499</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>600</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>平均响应时间  = 1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>平均周转时间  = 456.67</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>4.对于什么类型的工作负载,SJF 提供与 FIFO 相同的周转时间?</p>
<blockquote>
<p>运行时间相同的任务</p>
</blockquote>
<p>5.对于什么类型的工作负载和量子长度(时间片长度),SJF 与 RR 提供相同的响应时间?</p>
<blockquote>
<p>运行时间 &lt;= 时间片</p>
</blockquote>
<p>6.随着工作长度的增加,SJF 的响应时间会怎样?你能使用模拟程序来展示趋势吗?</p>
<blockquote>
<p>响应时间越来越长</p>
</blockquote>
<p>7.随着量子长度(时间片长度)的增加,RR 的响应时间会怎样?你能写出一个方程,计算给定 N 个工作时,最坏情况的响应时间吗?</p>
<blockquote>
<p>平均响应时间增加</p>
</blockquote>
<blockquote>
<p>时间片 &gt;= 工作最长运行时间时,有最坏情况<br>即 ti 为作业运行时间<br>res_avg = (0 + t1 + (t1+t2) + (t1+t2+t3) + … (t1+t2+t3 +…tN-1))/N</p>
</blockquote>
<hr>
<h1 id="调度-多级反馈队列"><a href="#调度-多级反馈队列" class="headerlink" title="调度-多级反馈队列"></a>调度-多级反馈队列</h1><blockquote>
<p>多级反馈队列需要解决两方面的问题。</p>
</blockquote>
<blockquote>
<p>首先，它要优化周转时间。这通过先执行短工作来实现。然而，操作系统通常不知道工作要运行多久，而这又是SJF（或 STCF）等算法所必需的。</p>
</blockquote>
<blockquote>
<p>其次，MLFQ 希望给交互用户（如用户坐在屏幕前，等着进程结束）很好的交互体验，因此需要降低响应时间。然而，像轮转这样的算法虽然降低了响应时间，周转时间却很差。</p>
</blockquote>
<p>所以这里的问题是：通常我们对进程一无所知，应该如何构建调度程序来实现这些目标？调度程序如何在运行过程中学习进程的特征，从而做出更好的调度决策？</p>
<h2 id="MLFQ：基本规则"><a href="#MLFQ：基本规则" class="headerlink" title="MLFQ：基本规则"></a>MLFQ：基本规则</h2><p>MLFQ 中有许多独立的队列（queue），每个队列有不同的优先级（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ 总是优先执行较高优先级的工作（即在较<br>高级队列中的工作）。<br>当然，每个队列中可能会有多个工作，因此具有同样的优先级。在这种情况下，我们就对这些工作采用轮转调度。</p>
<p><strong>规则 1：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。<br>规则 2：如果 A 的优先级 = B 的优先级，轮转运行A 和 B。</strong></p>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/w1.png" alt="?"></p>
<h2 id="尝试-1：如何改变优先级"><a href="#尝试-1：如何改变优先级" class="headerlink" title="尝试 1：如何改变优先级"></a>尝试 1：如何改变优先级</h2><p><strong>规则 3：工作进入系统时，放在最高优先级（最上层队列）。<br>规则 4a：工作用完整个时间片后，降低其优先级（移入下一个队列）。<br>规则 4b：如果工作在其时间片以内主动释放 CPU，则优先级不变。</strong></p>
<h3 id="实例-1：单个长工作"><a href="#实例-1：单个长工作" class="headerlink" title="实例 1：单个长工作"></a>实例 1：单个长工作</h3><p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/w2.png" alt="?"><br>该工作首先进入最高优先级（Q2）。执行一个 10ms 的时间片后，调度程序将工作的优先级减 1，因此进入 Q1。在 Q1 执行一个时间片后，最终降低优先级进入系统的最低优先级（Q0），一直留在那里。</p>
<h3 id="实例-2：来了一个短工作"><a href="#实例-2：来了一个短工作" class="headerlink" title="实例 2：来了一个短工作"></a>实例 2：来了一个短工作</h3><p>有两个工作：A是一个长时间运行的 CPU 密集型工作，B 是一个运行时间很短的交互型工作。假设 A 执行一段时间后 B 到达。</p>
<p>A（用黑色表示）在最低优先级队列执行（长时间运行的 CPU 密集型工作都这样）。B（用灰色表示）在时间 T=100 时到达，并被加入最高优先级队列。由于它的运行时间很短（只有 20ms），经过两个时间片，在被移入最低优先级队列之前，B 执行完毕。然后 A 继续运行（在低优先级）。</p>
<p><strong>主要目标：如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，MLFQ 近似于 SJF。</strong><br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/q3.png" alt="?"></p>
<h3 id="实例-3：如果有-I-O-呢"><a href="#实例-3：如果有-I-O-呢" class="headerlink" title="实例 3：如果有 I/O 呢"></a>实例 3：如果有 I/O 呢</h3><p>假设交互型工作中有大量的 I/O 操作（比如等待用户的键盘或鼠标输入），它会在时间片用完之前放弃 CPU。在这种情况下，我们不想处罚它，只是保持它的优先级不变。</p>
<p>交互型工作 B（用灰色表示）每执行 1ms 便需要进行 I/O操作，它与长时间运行的工作 A（用黑色表示）竞争 CPU。MLFQ 算法保持 B 在最高优先级，因为 B 总是让出 CPU。如果 B 是交互型工作，MLFQ 就进一步实现了它的目标，让交互型工作快速运行。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/w3.png" alt="?"></p>
<h3 id="当前-MLFQ-的一些问题"><a href="#当前-MLFQ-的一些问题" class="headerlink" title="当前 MLFQ 的一些问题"></a>当前 MLFQ 的一些问题</h3><p>首先，会有饥饿（starvation）问题。如果系统有“太多”交互型工作，就会不断占用CPU，导致长工作永远无法得到 CPU（它们饿死了）。即使在这种情况下，我们希望这些长工作也能有所进展。</p>
<blockquote>
<p>愚弄调度程序指的是用一些卑鄙的手段欺骗调度程序，让它给你远超公平的资源。上述算法对如下的攻击束手无策：进程在时间片用完之前，调用一个 I/O 操作（比如访问一个无关的文件），从而主动释放 CPU。如此便可以保持在高优先级，占用更多的 CPU 时间。做得好时（比如，每运行 99%的时间片时间就主动放弃一次 CPU），工作可以几乎独占 CPU。</p>
</blockquote>
<p>最后，一个程序可能在不同时间表现不同。一个计算密集的进程可能在某段时间表现为一个交互型的进程。用我们目前的方法，它不会享受系统中其他交互型工作的待遇。</p>
<h2 id="尝试-2：提升优先级"><a href="#尝试-2：提升优先级" class="headerlink" title="尝试 2：提升优先级"></a>尝试 2：提升优先级</h2><p><strong>规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</strong><br>新规则一下解决了两个问题。首先，进程不会饿死——在最高优先级队列中，它会以轮转的方式，与其他高优先级工作分享 CPU，从而最终获得执行。其次，如果一个 CPU 密集型工作变成了交互型，当它优先级提升时，调度程序会正确对待它。</p>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/w4.png" alt="?"><br>左边没有优先级提升，长工作在两个短工作到达后被饿死。右边每 50ms 就有一次优先级提升（这里只是举例，这个值可能过小），因此至少保证长工作会有一些进展，每过 50ms 就被提升到最高优先级，从而定期获得执行。</p>
<h2 id="尝试-3：更好的计时方式"><a href="#尝试-3：更好的计时方式" class="headerlink" title="尝试 3：更好的计时方式"></a>尝试 3：更好的计时方式</h2><p>工作在时间片以内释放 CPU，就保留它的优先级。那么应该怎么做？</p>
<p>这里的解决方案，是为 MLFQ 的每层队列提供更完善的 CPU 计时方式（accounting）。<strong>调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时。</strong> 只要进程用完了自己的配额，就将它降到低一优先级的队列中去。不论它是一次用完的，还是拆成很多次用完。因此，我们重写规则 4a 和 4b。</p>
<p><strong>规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。</strong><br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/w5.png" alt="?"></p>
<h2 id="MLFQ-调优及其他问题"><a href="#MLFQ-调优及其他问题" class="headerlink" title="MLFQ 调优及其他问题"></a>MLFQ 调优及其他问题</h2><p>大多数的 MLFQ 变体都支持不同队列可变的时间片长度。高优先级队列通常只有较短的时间片（比如 10ms 或者更少），因而这一层的交互工作可以更快地切换。相反，低优先级队列中更多的是 CPU 密集型工作，配置更长的时间片会取得更好的效果。图 8.7展示了一个例子，两个长工作在高优先级队列执行 10ms，中间队列执行 20ms，最后在最低优先级队列执行 40ms。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/w6.png" alt="?"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章包含了一组优化的 MLFQ 规则。为了方便查阅，我们重新列在这里。<br>规则 1：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。<br>规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。<br>规则 3：工作进入系统时，放在最高优先级（最上层队列）。<br>规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。<br>规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</p>
<hr>
<h1 id="操作系统导论-调度-比例份额"><a href="#操作系统导论-调度-比例份额" class="headerlink" title="操作系统导论-调度-比例份额"></a>操作系统导论-调度-比例份额</h1><p>比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的 CPU 时间，而不是优化周转时间和响应时间。</p>
<h2 id="基本概念：彩票数表示份额"><a href="#基本概念：彩票数表示份额" class="headerlink" title="基本概念：彩票数表示份额"></a>基本概念：彩票数表示份额</h2><p>调度程序知道总共的彩票数（在我们的例子中，有 100 张）。调度程序抽取中奖彩票，这是从 0 和 99之间的一个数，拥有这个数对应的彩票的进程中奖。假设进程 A 拥有 0 到 74 共 75 张彩票，进程 B 拥有 75 到 99 的 25 张，中奖的彩票就决定了运行 A 或 B。调度程序然后加载中奖进程的状态，并运行它。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/e1.png" alt="?"></p>
<h2 id="彩票机制"><a href="#彩票机制" class="headerlink" title="彩票机制"></a>彩票机制</h2><p>一种方式是利用彩票货币（ticket currency）的概念。这种方式允许拥有一组彩票的用户以他们喜欢的某种货币，将彩票分给自己的不同工作。之后操作系统再自动将这种货币兑换为正确的全局彩票。</p>
<p>比如，假设用户 A 和用户 B 每人拥有 100 张彩票。用户 A 有两个工作 A1 和 A2，他以自己的货币，给每个工作 500 张彩票（共 1000 张）。用户 B 只运行一个工作，给它 10 张彩票（总共 10 张）。操作系统将进行兑换，将 A1 和 A2 拥有的 A 的货币 500 张，兑换成全局货币 50 张。类似地，兑换给 B1 的 10 张彩票兑换成 100 张。然后会对全局彩票货币（共 200张）举行抽奖，决定哪个工作运行。</p>
<p>另一个有用的机制是彩票转让（ticket transfer）。通过转让，一个进程可以临时将自己的彩票交给另一个进程。这种机制在客户端/服务端交互的场景中尤其有用，在这种场景中，客户端进程向服务端发送消息，请求其按自己的需求执行工作，为了加速服务端的执行，客户端可以将自己的彩票转让给服务端，从而尽可能加速服务端执行自己请求的速度。服务端执行结束后会将这部分彩票归还给客户端。</p>
<p>最后，彩票通胀（ticket inflation）有时也很有用。利用通胀，一个进程可以临时提升或降低自己拥有的彩票数量。当然在竞争环境中，进程之间互相不信任，这种机制就没什么意义。一个贪婪的进程可能给自己非常多的彩票，从而接管机器。但是，通胀可以用于进程之间相互信任的环境。在这种情况下，如果一个进程知道它需要更多 CPU 时间，就可以增加自己的彩票，从而将自己的需求告知操作系统，这一切不需要与任何其他进程通信。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/e2.png" alt="?"><br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/e3.png" alt="?"><br>这段代码从前向后遍历进程列表，将每张票的值加到 counter 上，直到值超过 winner。这时，当前的列表元素所对应的进程就是中奖者。在我们的例子中，中奖彩票是 300。首先，计 A 的票后，counter 增加到 100。因为 100 小于 300，继续遍历。然后 counter 会增加到 150（B 的彩票），仍然小于 300，继续遍历。最后，counter 增加到 400（显然大于 300），因此退出遍历，current 指向 C（中奖者）。</p>
<h2 id="步长调度"><a href="#步长调度" class="headerlink" title="步长调度"></a>步长调度</h2><p>系统中的每个工作都有自己的步长，这个值与票数值成反比。在上面的例子中，A、B、C 这 3 个工作的票数分别是 100、50 和 250，<strong>我们通过用一个大数分别除以他们的票数来获得每个进程的步长。比如用 10000 除以这些票数值，得到了 3 个进程的步长分别为 100、200 和 40。</strong> 我们称这个值为每个进程的步长（stride）。每次进程运行后，我们会让它的计数器 [称为行程（pass）值] 增加它的步长，记录它的总体进展。</p>
<p><strong>当需要进行调度时，选择目前拥有最小行程值的进程，并且在运行之后将该进程的行程值增加一个步长。</strong><br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/e4.png" alt="?"></p>
<p>在我们的例子中，3 个进程（A、B、C）的步长值分别为 100、200 和 40，初始行程值都为 0。因此，最初，所有进程都可能被选择执行。假设选择 A（任意的，所有具有同样低的行程值的进程，都可能被选中）。A 执行一个时间片后，更新它的行程值为 100。然后运行 B，并更新其行程值为 200。最后执行 C，C 的行程值变为 40。这时，算法选择最小的行程值，是 C，执行并增加为 80（C 的步长是 40）。然后 C 再次运行（依然行程值最小），行程值增加到 120。现在运行 A，更新它的行程值为 200（现在与 B 相同）。然后 C 再次连续运行两次，行程值也变为 200。此时，所有行程值再次相等，这个过程会无限地重复下去。<br>表 9.1 展示了一段时间内调度程序的行为。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/e5.png" alt="?"><br>可以看出，C 运行了 5 次、A 运行了 2 次，B 一次，正好是票数的比例——200、100 和 50。彩票调度算法只能一段时间后，在概率上实现比例，而步长调度算法可以在每个调度周期后做到完全正确。</p>
<hr>
<h1 id="多处理器调度（高级）"><a href="#多处理器调度（高级）" class="headerlink" title="多处理器调度（高级）"></a>多处理器调度（高级）</h1><p>多核处理器（multicore）将多个 CPU核组装在一块芯片上，是这种扩散的根源。</p>
<p><strong>多线程应用可以将工作分散到多个 CPU 上，因此 CPU资源越多就运行越快。</strong></p>
]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统导论-cpu虚拟化</title>
    <url>/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-cpu%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="抽象-进程"><a href="#抽象-进程" class="headerlink" title="抽象:进程"></a>抽象:进程</h1><p>进程就是运行中的程序。程序本身是没有生命周期的，它只是存在磁盘上面的一些指令（也可能是一些静态数据）。是操作系统让这些字节运行起来，让程序发挥作用。</p>
<p><em><strong>虽然只有少量的物理 CPU 可用，但是操作系统如何提供几乎有无数个 CPU 可用的假象？</strong></em></p>
<p>操作系统通过虚拟化（virtualizing）CPU 来提供这种假象。通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟 CPU 的假象。这就是时分共享（time sharing）CPU 技术，允许用户如愿运行多个并发进程。潜在的开销就是性能损失，因为如果 CPU 必须共享，每个进程的运行就会慢一点。</p>
<p><strong>时分共享和空分共享</strong><br>通过允许资源由一个实体使用一小段时间，然后由另一个实体使用一小段时间，如此下去，所谓的资源（例如，CPU 或网络链接）可以被许多人共享。时分共享的自然对应技术是空分共享，资源在空间上被划分给希望使用它的人。</p>
<p>例如，磁盘空间自然是一个空分共享资源，因为一旦将块分配给文件，在用户删除文件之前，不可能将它分配给其他文件。</p>
<h2 id="抽象：进程"><a href="#抽象：进程" class="headerlink" title="抽象：进程"></a>抽象：进程</h2><p>操作系统为正在运行的程序提供的抽象，就是所谓的进程（process）。</p>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>进程的机器状态有一个明显组成部分，就是它的内存。指令存在内存中。正在运行的程序读取和写入的数据也在内存中。因此进程可以访问的内存（称为地址空间，address space）是该进程的一部分。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>进程的机器状态的另一部分是寄存器。许多指令明确地读取或更新寄存器。<br>程序计数器（Program Counter，PC）（有时称为指令指针，Instruction Pointer 或 IP）告诉我们程序当前正在执行哪个指令；类似地，栈指针（stack pointer）和相关的帧指针（frame pointer）用于管理函数参数栈、局部变量和返回地址。</p>
<p>程序也经常访问持久存储设备。此类 I/O 信息可能包含当前打开的文件列表。</p>
<h2 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h2><p>创建（create）：操作系统必须包含一些创建新进程的方法。在 shell 中键入命令或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。</p>
<p>销毁（destroy）：由于存在创建进程的接口，因此系统还提供了一个强制销毁进程的接口。当然，很多进程会在运行完成后自行退出。但是，如果它们不退出，用户可能希望终止它们，因此停止失控进程的接口非常有用。</p>
<p>等待（wait）：有时等待进程停止运行是有用的，因此经常提供某种等待接口。</p>
<p>其他控制（miscellaneous control）：除了杀死或等待进程外，有时还可能有其他控制。例如，大多数操作系统提供某种方法来暂停进程（停止运行一段时间），然后恢复（继续运行）。</p>
<p>状态（statu）：通常也有一些接口可以获得有关进程的状态信息，例如运行了多长时间，或者处于什么状态。</p>
<h2 id="进程创建：更多细节"><a href="#进程创建：更多细节" class="headerlink" title="进程创建：更多细节"></a>进程创建：更多细节</h2><ol>
<li>操作系统运行程序必须做的第一件事是将代码和所有静态数据（例如初始化变量）加载（load）到内存中，加载到进程的地址空间中。</li>
</ol>
<p>程序最初以某种可执行格式驻留在磁盘上（disk，或者在某些现代系统中，在基于闪存的 SSD 上）。因此，将程序和静态数据加载到内存中的过程，需要操作系统从磁盘读取这些字节，并将它们放在内存中的某处。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-cpu%E8%99%9A%E6%8B%9F%E5%8C%96/q1.png" alt="?"></p>
<p>在早期的（或简单的）操作系统中，加载过程尽早（eagerly）完成，即在运行程序之前全部完成。<br>现代操作系统惰性（lazily）执行该过程，即仅在程序执行期间需要加载的代码或数据片段，才会加载。</p>
<ol start="2">
<li><p>将代码和静态数据加载到内存后，必须为程序的运行时栈（run-time stack 或 stack）分配一些内存。操作系统也可能为程序的堆（heap）分配一些内存。</p>
</li>
<li><p>操作系统还将执行一些其他初始化任务，特别是与输入/输出（I/O）相关的任务。</p>
</li>
</ol>
<p>例如，在 UNIX 系统中，默认情况下每个进程都有 3 个打开的文件描述符（file descriptor），用于标准输入、输出和错误。这些描述符让程序轻松读取来自终端的输入以及打印输出到屏幕。</p>
<ol start="4">
<li>启动程序，在入口处运行，即 main()。通过跳转到 main()例程，OS 将 CPU的控制权转移到新创建的进程中，从而程序开始执行。</li>
</ol>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>进程可以处于以下 3 种状态之一。</p>
<p>运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。</p>
<p>就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。</p>
<p>阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，当进程向磁盘发起 I/O 请求时，它会被阻塞，因此其他进程可以使用处理器。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-cpu%E8%99%9A%E6%8B%9F%E5%8C%96/q2.png" alt="?"></p>
<p>举例：两个正在运行的进程，每个进程只使用 CPU（它们没有 I/O）<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-cpu%E8%99%9A%E6%8B%9F%E5%8C%96/q3.png" alt="?"></p>
<p>举例：第一个进程在运行一段时间后发起 I/O 请求。此时，该进程被阻塞，让另一个进程有机会运行。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-cpu%E8%99%9A%E6%8B%9F%E5%8C%96/q4.png" alt="?"></p>
<p>除了运行、就绪和阻塞之外，还有其他一些进程可以处于的状态。有时候系统会有一个初始（initial）状态，表示进程在创建时处于的状态。</p>
<p>另外，一个进程可以处于已退出但尚未清理的最终（final）状态（在基于 UNIX 的系统中，这称为僵尸状态）。</p>
<p>这个最终状态非常有用，因为它允许其他进程（通常是创建进程的父进程）检查进程的返回代码，并查看刚刚完成的进程是否成功执行（通常，在基于 UNIX 的系统中，程序成功完成任务时返回零，否则返回非零）。完成后，父进程将进行最后一次调用（例如，wait()），以等待子进程的完成，并告诉操作系统它可以清理这个正在结束的进程的所有相关数据结构。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>操作系统是一个程序，和其他程序一样，它有一些关键的数据结构来跟踪各种相关的信息。</p>
<p>为了跟踪每个进程的状态，操作系统可能会为所有就绪的进程保留某种进程列表（process list），以及跟踪当前正在运行的进程的一些附加信息。</p>
<p>操作系统追踪进程的一些重要信息。对于停止的进程，寄存器上下文将保存其寄存器的内容。当一个进程停止时，它的寄存器将被保存到这个内存位置。通过恢复这些寄存器（将它们的值放回实际的物理寄存器中），操作系统可以恢复运行该进程。它被称为<strong>上下文切换（context switch）</strong>。</p>
<p>除了运行、就绪和阻塞之外，还有其他一些进程可以处于的状态。有时候系统会有一个初始（initial）状态，表示进程在创建时处于的状态。<br>另外，一个进程可以处于已退出但尚未清理的最终（final）状态（在基于 UNIX 的系统中，这称为僵尸状态）。这个最终状态非常有用，因为它允许其他进程（通常是创建进程的父进程）检查进程的返回代码，并查看刚刚完成的进程是否成功执行（通常，在基于 UNIX 的系统中，程序成功完成任务时返回零，否则返回非零）。完成后，父进程将进行最后一次调用（例如，wait()），以等待子进程的完成，并告诉操作系统它可以清理这个正在结束的进程的所有相关数据结构。</p>
<blockquote>
<p>数据结构——进程列表<br>进程列表（process list）是第一个这样的结构。任何能够同时运行多个程序的操作系统当然都会有类似这种结构的东西，以便跟踪系统中正在运行的所有程序。有时候人们会将存储关于进程的信息的个体结构称为进程控制块（Process Control Block，PCB），这是谈论包含每个进程信息的 C 结构的一种方式。</p>
</blockquote>
<hr>
<h1 id="插叙-进程API"><a href="#插叙-进程API" class="headerlink" title="插叙:进程API"></a>插叙:进程API</h1><h2 id="fork-系统调用"><a href="#fork-系统调用" class="headerlink" title="fork()系统调用"></a>fork()系统调用</h2><p>进程调用了fork()系统调用，这是操作系统提供的创建新进程的方法。</p>
<p>对操作系统来说，这谁看起来有两个完全一样的程序谁运行，并都从 fork()系统调用中返回。新创建的进程称为子进程（child），原来的进程称为父进程（parent）。子进程不会从 main()函数开始执行，而是直接从 fork()系统调用返回，就好像是它自己调用了fork()。</p>
<p>子进程拥有自己的地址空间（即拥有自己的私有内存）、寄存器、程序计数器等，但是它从 fork()返回的值是不同的。父进程获得的返回值是新创建子进程的PID，而子进程获得的返回值是0。这个差别非常重要，因为这样就很容易编写代码处理两种不同的情况。</p>
<h2 id="wait-系统调用"><a href="#wait-系统调用" class="headerlink" title="wait()系统调用"></a>wait()系统调用</h2><p>有时候父进程需要等待子进程执行完毕，这项任务由 wait()系统调用。如果父进程想要和子进程抢跑，那么wait()会阻塞父进程。</p>
<h2 id="exec-系统调用"><a href="#exec-系统调用" class="headerlink" title="exec()系统调用"></a>exec()系统调用</h2><p>这个系统调用可以让子进程执行与父进程我同的程序。例如，在 p2.c 中调用 fork，这只是在你想运行相同程序的拷贝时有用。但时，<strong>我们常常想运行不同的程序</strong>，exec0正好做这样的事。</p>
<p>exec()会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执行该程序，将参数通过 argv 传递给该进程。因此，它并谁有创建新进程，而是直接将当前运行的程序（以前的 p3）替换为我同的运行程序（wc）。子进程执行 exec()之后，几乎就像p3.c 从未运行过一样。对 exec()的成功调用永远我会返回。</p>
<blockquote>
<p>exec()有几种变体：execl()、execle()、execlp()、execv()和 execvp()。</p>
</blockquote>
<h2 id="为什么这样设计-API"><a href="#为什么这样设计-API" class="headerlink" title="为什么这样设计 API"></a>为什么这样设计 API</h2><p>shell 也是一个用户程序，它首先显示一个提示符 (prompt)，然后等待用户输入。你可以向它输入一个命令(一个可执行程序的名称及需要的参数)，大多数情况下，shell 可以在文件系统中找到这个可执行程序，调用 fork0创建新进程，并调用 exec0的某个变体来执行这个可执行程序，调用 wait0)等待该命令完成。子进程执行结束后，shell 从 wait0)返回并再次输出一个提示符，等待用户输入下一条命令fork()和exec()的分离，让 shell 可以方便地实现很多有用的功能。比如:</p>
<blockquote>
<p>wc p3.c &gt; newfile.txt</p>
</blockquote>
<p>在上面的例子中,wc的输出结果被重定向(redirect)到文件newfile.txt中(通过newfile.txt之前的大于号来指明重定向)。shell 实现结果重定向的方式也很简单，当完成子进程的创建后，shell 在调用 exec0之前先关闭了标准输出 (standard output)，打开了文件 newfile.txt。这样，即将运行的程序 wc 的输出结果就被发送到该文件，而不是打印在屏幕上。</p>
<blockquote>
<p>在统计后创建新进程，在使用exec更改一系列资源数据前有了空隙，然后改变标准输出</p>
</blockquote>
<p>UNIX 管谁也是用类似的方式实现的，但用的是 pipe()系统调用。谁这种情况下，一个进程的输出被链接到了一个内核管谁（pipe）上（队列），另一个进程的输入也被连接到了同一个管谁上。因此，前一个进程的输出无缝地作为后一个进程的输入，许多命令可以用这种方式串联谁一起，共同完成某项任务。比如通过将 grep、wc 命令用管谁连接可以完成从一个文件中查找某个词，并统计其出现次数的功能：grep -o foo file | wc -l。</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>1.编写一个调用 fork0的程序。在调用 fork()之前，让主进程访问一个变量(例如x)并将其值设置为某个值(例如 100)。子进程中的变量有什么值?当子进程和父进程都改变x 的值时，变量会发生什么?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child, x %d\n&quot;</span>, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent, x %d\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child,x %d\n&quot;</span>, x);</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child,x %d\n&quot;</span>, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent,x %d\n&quot;</span>, x);</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent,x %d\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-cpu%E8%99%9A%E6%8B%9F%E5%8C%96/w1.png" alt="?"></p>
<p>2.编写一个打开文件的程序(使用 open(系统调用)，然后调用 fork0创建一个新进程子进程和父进程都可以访问 open()返回的文件描述符吗?当它们并发(即同时)写入文件时会发生什么?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./check.txt&quot;</span>, O_CREAT | O_RDWR | O_TRUNC, S_IRWXU);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *buf = <span class="string">&quot;child\n&quot;</span>;</span><br><span class="line">        <span class="type">int</span> error = write(fd, buf, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child error: %d\n&quot;</span>, error == <span class="number">-1</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> *buf = <span class="string">&quot;parent\n&quot;</span>;</span><br><span class="line">        <span class="type">int</span> error = write(fd, buf, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child error: %d\n&quot;</span>, error == <span class="number">-1</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>子进程和父进程都能访问 fd。存在竞争条件，无法同时使用 fd，但最终都会写入成功</p>
</blockquote>
<p>3.使用 fork(编写另一个程序。子进程应打印“hello”，父进程应打印“goodbye”。你应该尝试确保子进程始终先打印。你能否不在父进程调用 wait0)而做到这一点呢?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>f</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid = vfork();</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Goodbye\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用vfork(),父子共享资源，子在父前</p>
</blockquote>
<p>4.编写一个调用 fork0的程序，然后调用某种形式的 exec0来运行程序/bin/ls。看看是否可以尝试 exec0)的所有变体,包括 execl0)、execle0)、execIp0、execv)、execvp0和 execvPO，为什么同样的基本调用会有这么多变种?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *envp[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="type">char</span> *cmd = <span class="string">&quot;/bin/ls&quot;</span>;</span><br><span class="line">  <span class="type">char</span> *arg[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//    exec不会返回,所以第一条execl语句后的语句不会被执行</span></span><br><span class="line">    execl(cmd, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    execlp(cmd, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    execve(cmd, arg, envp);</span><br><span class="line">    execv(cmd, arg);</span><br><span class="line">    execvp(cmd, arg);</span><br><span class="line">    execle(cmd, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>, envp);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 exec 函数族中，后缀 l、v、p、e 添加到 exec 后，所指定的函数将具有某种操作能力：<br>l: 希望接收以逗号分隔的参数列表,列表以 NULL 指针作为结束标志<br>v: 希望接收一个以 NULL 结尾字符串数组的指针<br>p: 是一个以 NULL 结尾的字符串数组指针,函数可以利用 DOS 的 PATH 变量查找自程序文件<br>e 函数传递指定采纳数 envp(环境变量),允许改变子进程环境,无后缀 e 是,子进程使用当前程序环境<br>c 语言没有默认参数语法,只能实现多个变体</p>
</blockquote>
<p>5.现在编写一个程序，在父进程中使用 wait()，等待子进程完成。wait()返回什么?如果你在子进程中使用 wait()会发生什么?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> res = wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid = wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pid);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>wait 成功返回子进程 id,执行失败返回-1<br>子进程调用 wait,执行失败,返回-1</p>
</blockquote>
<p>6.对前一个程序稍作修改，这次使用 waitpid()而不是 wait()。什么时候 waitpid0会有用?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>waitpid 提供更多操作,比如提供非阻塞版本 wait</p>
</blockquote>
<p>7.编写一个创建子进程的程序，然后在子进程中关闭标准输出(STDOUT FILENO)。如果子进程在关闭描述符后调用 printf()打印输出，会发生什么?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> res = wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>子进程printf 不会打印到控制台，父进程不影响</p>
</blockquote>
<p>8.编写一个程序，创建两个子进程，并使用 pipe()系统调用，将一个子进程的标准输出连接到另一个子进程的标准输入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> ppid = fork();</span><br><span class="line">    <span class="keyword">if</span> (ppid == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">char</span> *msg = <span class="string">&quot;Hello!\n&quot;</span>;</span><br><span class="line"><span class="comment">//      关闭多余管道端</span></span><br><span class="line">      close(fd[<span class="number">0</span>]);</span><br><span class="line">      write(fd[<span class="number">1</span>], msg, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(msg));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ppid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      wait(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="type">char</span> asw[<span class="number">10</span>];</span><br><span class="line">      close(fd[<span class="number">1</span>]);</span><br><span class="line">      <span class="type">int</span> res = read(fd[<span class="number">0</span>], asw, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">10</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;size:%d, %s&quot;</span>, res, asw);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="机制-受限直接执行"><a href="#机制-受限直接执行" class="headerlink" title="机制:受限直接执行"></a>机制:受限直接执行</h1><p>为了虚拟化 CPU，操作系统需要以某种方式让许多任务共享物理 CPU，让它们看起来像是同时运行。基本思想很简单:运行一个进程一段时间，然后运行另一个进程，如此轮换。通过以这种方式时分共享 (time sharing)CPU，就实现了虚拟化。</p>
<blockquote>
<p>第一个是性能：如何在不增加系统开销的情况下实现虚拟化？<br>第二个是控制权：如何有效地运行进程，同时保留对 CPU 的控制？</p>
</blockquote>
<h2 id="基本技巧：受限直接执行"><a href="#基本技巧：受限直接执行" class="headerlink" title="基本技巧：受限直接执行"></a>基本技巧：受限直接执行</h2><p>这个概念的“直接执行”部分很简单：只需直接在 CPU上运行程序即可。因此，当 OS 希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码（从磁盘）加载到内存中，找到入口点（main()函数或类似的），跳转到那里，并开始运行用户的代码。<br><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-cpu%E8%99%9A%E6%8B%9F%E5%8C%96/e1.png" alt="?"></p>
<blockquote>
<p>这种方法在我们的虚拟化 CPU 时产生了一些问题。<br>第一个问题很简单：如果我们只运行一个程序，操作系统怎么能确保程序不做任何我们不希望它做的事，同时仍然高效地运行它？<br>第二个问题：当我们运行一个进程时，操作系统如何让它停下来并切换到另一个进程，从而实现虚拟化 CPU 所需的时分共享？</p>
</blockquote>
<h2 id="问题-1：受限制的操作"><a href="#问题-1：受限制的操作" class="headerlink" title="问题 1：受限制的操作"></a>问题 1：受限制的操作</h2><p>该程序直接在硬件 CPU 上运行，因此执行速度与预期的一样快。</p>
<p>硬件通过提供不同的执行模式来协助操作系统。在用户模式（user mode）下，应用程序不能完全访问硬件资源。在内核模式（kernel mode）下，操作系统可以访问机器的全部资源。还提供了陷入（trap)内核和从陷阱返回（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。</p>
<blockquote>
<p>用户希望执行某种特权操作（如从磁盘读取），应该怎么做？<br>系统调用允许内核小心地向用户程序暴露某些关键功能，例如访问文件系统、创建和销毁进程、与其他进程通信，以及分配更多内存。大多数操作系统提供几百个调用。</p>
</blockquote>
<p>要执行系统调用，程序必须执行特殊的陷阱 (trap) 指令。该指令同时跳入内核并将特权级别提升到内核模式。一旦进入内核，系统就可以执行任何需要的特权操作(如果允许).从而为调用进程执行所需的工作。完成后，操作系统调用一个特殊的从陷阱返回(return-from-trap)指令，如你期望的那样，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。</p>
<p>执行陷阱时，硬件必须确保存储足够的调用者寄存器，以便在操作系统发出从陷阱返回指令时能够正确返回。例如，在 x86 上，处理器会将程序计数器、标志和其他一些寄存器推送到每个进程的内核栈(kernelstack)上。从返回陷阱将从栈弹出这些值，并恢复执行用户模式程序(有关详细信息。</p>
<blockquote>
<p><strong>为什么对系统调用的调用(如 open()或 read())看起来完全就像 C 中的典型过程调用?</strong></p>
</blockquote>
<blockquote>
<p>它是一个过程调用，但隐藏在过程调用内部的是著名的陷阱指令。更具体地说，当你调用 open()(举个例子)时，你正在执行对 C 库的过程调用。其中，无论是对于open()还是提供的其他系统调用，库都使用与内核一致的调用约定来将参数放在众所周知的位置(例如，在栈中或特定的寄存器中)，将系统调用号也放入一个众所周知的位置(同样，放在栈或寄存器中 )，然后执行上述的陷阱指令。库中陷阱之后的代码准备好返回值，并将控制权返回给发出系统调用的程序。因此，C 库中进行系统调用的部分是用汇编手工编码的，因为它们需要仔细遵循约定，以便正确处理参数和返回值，以及执行硬件特定的陷阱指令。</p>
</blockquote>
<blockquote>
<p><strong>陷阱如何知道在 OS 内运行哪些代码？</strong></p>
</blockquote>
<blockquote>
<p>内核通过在启动时设置陷阱表 (trap table) 来实现。当机器启动时，它在特权(内核)模式下执行，因此可以根据需要自由配置机器硬件。操作系统做的第一件事，就是告诉硬件在发生某些异常事件时要运行哪些代码。例如，当发生硬盘中断，发生键盘中断或程序进行系统调用时，应该运行哪些代码?操作系统通常通过某种特殊的指令，通知硬件这些陷阱处理程序的位置。一旦硬件被通知，它就会记住这些处理程序的位置，直到下一次重新启动机器并且硬件知道在发生系统调用和其他异常事件时要做什么 (即跳转到哪段代码)。</p>
</blockquote>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-cpu%E8%99%9A%E6%8B%9F%E5%8C%96/e2.png" alt="?"></p>
<h2 id="问题-2：在进程之间切换"><a href="#问题-2：在进程之间切换" class="headerlink" title="问题 2：在进程之间切换"></a>问题 2：在进程之间切换</h2><blockquote>
<p>操作系统如何重新获得 CPU 的控制权（regain control），以便它可以在进程之间切换？</p>
</blockquote>
<h3 id="协作方式：等待系统调用"><a href="#协作方式：等待系统调用" class="headerlink" title="协作方式：等待系统调用"></a>协作方式：等待系统调用</h3><p>如果应用程序执行了某些非法操作，也会将控制转移给操作系统。例如，如果应用程序以 0 为除数，或者尝试访问应该无法访问的内存，就会陷入（trap）操作系统。操作系统将再次控制 CPU（并可能终止违规进程）。</p>
<h3 id="非协作方式：操作系统进行控制"><a href="#非协作方式：操作系统进行控制" class="headerlink" title="非协作方式：操作系统进行控制"></a>非协作方式：操作系统进行控制</h3><p><strong>没有硬件的额外帮助，如果进程拒绝进行系统调用（也不出错），从而将控制权交还给操作系统，那么操作系统无法做任何事情。</strong></p>
<p>时钟中断（timer interrupt）。时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得 CPU 的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。</p>
<p>操作系统必须通知硬件哪些代码在发生时钟中断时运行。因此，在启动时，操作系统就是这样做的。其次，在启动过程中，操作系统也必须启动时钟，这当然是一项特权操作。一旦时钟开始运行，操作系统就感到安全<br>了，因为控制权最终会归还给它，因此操作系统可以自由运行用户程序。时钟也可以关闭（也是特权操作）。</p>
<p>硬件在发生中断时要为正在运行的程序保存足够的状态，以便随后从陷阱返回指令能够正确恢复正在运行的程序。这一组操作与硬件在显式系统调用陷入内核时的行为非常相似，其中各种寄存器因此被保存（进入内核栈），因此从陷阱返回指令可以容易地恢复。</p>
<h3 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h3><p>继续运行当前正在运行的进程，还是切换到另一个进程,这个决定是由调度程序（scheduler）做出的。</p>
<p>如果决定进行切换，OS 就会执行一些底层代码，即所谓的上下文切换（context switch）。上下文切换在概念上很简单：操作系统要做的就是为当前正在执行的进程保存一些寄存器的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。</p>
<p>为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器、程序计数器，并切换内核栈，供即将运行的进程使用。通过切换栈，内核在进入切换代码调用时，是一个进程（被中断的进程）的上下文，在返回时，是另一进程（即将执行的进程）的上下文。当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。至此上下文切换完成。</p>
<blockquote>
<p>进程 A 正在运行，然后被中断时钟中断。硬件保存它的寄存器（在内核栈中），并进入内核（切换到内核模式）。在时钟中断处理程序中，操作系统决定从正在运行的进程 A 切换到进程 B。此时，它调用 switch()例程，该例程仔细保存当前寄存器的值（保存到 A 的进程结构），恢复寄存器进程 B（从它的进程结构），然后切换上下文（switch context），具体来说是通过改变栈指针来使用 B 的内核栈（而不是 A 的）。最后，操作系统从陷阱返回，恢复 B 的寄存器并开始运行它。</p>
</blockquote>
<p><img src="/2023/06/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-cpu%E8%99%9A%E6%8B%9F%E5%8C%96/e3.png" alt="?"></p>
<p>在此协议中，有两种类型的寄存器保存/恢复。第一种是发生时钟中断的时候。在这种情况下，运行进程的用户寄存器由硬件隐式保存，使用该进程的内核栈。第二种是当操作系统决定从 A 切换到 B。在这种情况下，内核寄存器被软件（即 OS）明确地保存，但这次被存储在该进程的进程结构的内存中。后一个操作让系统从好像刚刚由 A 陷入内核，变成好像刚刚由 B 陷入内核。</p>
<h2 id="担心并发吗"><a href="#担心并发吗" class="headerlink" title="担心并发吗"></a>担心并发吗</h2><p>操作系统可能简单地决定，在中断处理期间禁止中断（disable interrupt）。这样做可以确保在处理一个中断时，不会将其他中断交给 CPU。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们已经描述了一些实现 CPU 虚拟化的关键底层机制，并将其统称为受限直接执行(limited directexecution)。基本思路很简单:就让你想运行的程序在 CPU 上运行，但首先确保设置好硬件，以便在没有操作系统帮助的情况下限制进程可以执行的操作。</p>
]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统导论-操作系统介绍</title>
    <url>/2023/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="操作系统介绍"><a href="#操作系统介绍" class="headerlink" title="操作系统介绍"></a>操作系统介绍</h1><p>操作系统主要利用一种通用的技术，虚拟化（virtualization）。操作系统将物理（physical）资源（如处理器、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式。因此，我们有时将操作系统称为虚拟机（virtual machine）。</p>
<p>因为虚拟化让许多程序运行（从而共享 CPU），让许多程序可以同时访问自己的指令和数据（从而共享内存），让许多程序访问设备（从而共享磁盘等），所以操作系统有时被称为资源操理器（resource manager）。每个 CPU、内存和磁盘都是系统的资源（resource），因此操作系统扮演的主要角色就是操理（manage）这些资源，以做到高效或公平</p>
<h2 id="虚拟化-CPU"><a href="#虚拟化-CPU" class="headerlink" title="虚拟化 CPU"></a>虚拟化 CPU</h2><p>在硬件的一些帮助下，操作系统负责提供这种假象（illusion），即系统拥有非常多的虚拟 CPU 的假象。将单个 CPU（或其中一小部分）转换为看似无限数量的 CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化 CPU（virtualizing the CPU）</p>
<blockquote>
<p><strong>虚拟化cpu就是一个cpu当成好几个用</strong></p>
</blockquote>
<h2 id="虚拟化内存"><a href="#虚拟化内存" class="headerlink" title="虚拟化内存"></a>虚拟化内存</h2><p>每个进程访问自己的私有虚拟地址空间（virtual address space）（有时称为地址空间，address space），操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程（或操作系统本身）的地址空间。对于正在运行的程序，它完全拥有自己的物理内存。</p>
<blockquote>
<p><strong>虚拟化内存的实现方式是通过建立虚拟内存地址空间，将进程所需的内存映射到实际的物理内存上，从而实现内存的虚拟化</strong></p>
</blockquote>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>它取得 CPU、内存或磁盘等物理资源（resources），甚对它们进行虚拟化（virtualize）。它处理与甚发（concurrency）有关的麻烦且棘手的问题。它持久地（persistently）存储文件，从而使它们长期随全。</p>
<blockquote>
<p>抽象是一种思维方式，是指从具体的事物中抽离出其本质特征和属性，形成一个更为普遍和概括的概念或模型。在计算机科学领域中，抽象是指将复杂的问题或系统抽象为一个简单的模型或接口，以便更好地理解和处理问题。</p>
</blockquote>
<h2 id="简单历史"><a href="#简单历史" class="headerlink" title="简单历史"></a>简单历史</h2><h3 id="早期操作系统：只是一些库"><a href="#早期操作系统：只是一些库" class="headerlink" title="早期操作系统：只是一些库"></a>早期操作系统：只是一些库</h3><p>一开始，操作系统甚没有做太多事情。基本上，它只是一组常用函数库。例如，不是让系统中的每个程序员都编写低级 I/O 处理代码，而是让“OS”提供这样的 API，这样开发人员的工作更加轻松。<br>通常，在这些老的大型机系统上，一一运行一个程序，由操作员来控制。这个操作员完成了你认为现现操作系统会做的许多事情（例如，决定运行作业的顺序）。<br>这种计算模式被称为批（batch）处理，先把一些工作准备好，然后由操作员以“分批”的方式运行。此时，计算机甚没有以交互的方式使用，因为这样做成本太高：让用户坐在计算机前使用它，大部分时间它都会闲置，所以会导致设施每小时浪费数千美元。</p>
<h3 id="超越库：保护"><a href="#超越库：保护" class="headerlink" title="超越库：保护"></a>超越库：保护</h3><p>假设允许任何应用程序从磁盘上的任何地方读取。因为任何程序都可以读取任何文件，所以隐私的概念消失了。<br>因此，系统调用（system call）的概念诞生了，不是将操作系统例程作为一个库来提供（你只需创建一个过程调用（procedure call）来访问它们），这里的想法是添加一些特殊的硬件指令和硬件状态，让向操作系统过渡变为更正式的、受控的过程。</p>
<p><strong>系统调用和过程调用之间的关键区别在于，系统调用将控制转移（跳转）到 OS 中，同时提高硬件特权级别（hardware privilege level）。用户应用程序以所谓的用户模式（user mode）运行，这意味着硬件限制了应用程序的功能。</strong></p>
<h3 id="多道程序时代"><a href="#多道程序时代" class="headerlink" title="多道程序时代"></a>多道程序时代</h3><p>操作系统不是一一只运行一项作业，而是将大量作业加载到内存中甚在它们之间快速切换，从而提高 CPU 利用率。这种切换非常重要，因为 I/O 设备很慢。在处理 I/O 时让程序占着CPU，浪费了 CPU 时间。</p>
<p>在 I/O 进行和任务中断时，要支持多道程序和重叠运行。内存保护（memory protection）等问题变得重要。我们不希望一个程序能够访问操一个程序的内存。</p>
<p>当时主要的实际进展之一是引入了 UNIX 操作系统，主要归功于贝尔实验室。</p>
]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机通信</title>
    <url>/2023/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="PC1和PC2二层互访通信过程详解"><a href="#PC1和PC2二层互访通信过程详解" class="headerlink" title="PC1和PC2二层互访通信过程详解"></a>PC1和PC2二层互访通信过程详解</h2><p><img src="/2023/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1/1.png" alt="?"></p>
<p>PC1和PC2通过交换机SW1互联，PC1 的IP地址为192.168.1.1/24 ，PC2的IP地址为192.168.1.2/24 ，那么PC1和PC2的通信就是简单的二层通信（二层通信不涉及路由表）</p>
<ol>
<li><p>PC1要想访问PC2，除了需要知道目的IP 192.168.1.2 以外，还需要知道PC2 的mac地址，因为所有的数据通信都是基于TCP/IP参考模型的，需要对进行数据封装。</p>
<blockquote>
<p>首先PC1会查找自己的ARP表项看是否有目的IP 192.168.1.2 对应的MAC地址，查看发现是空的;</p>
</blockquote>
</li>
<li><p>如果不知道对方的mac地址，PC1会发送ARP广播报文，询问谁知道目的IP 192.168.1.2 对应的MAC地址。交换机转发到局域网后，PC2收到ARP广播报文会进行回应，告诉PC1他的MAC地址；</p>
<blockquote>
<p>在PC1发送ARP 广播报文的时候，交换机SW1收到该报文，会在MAC地址表中根据报文的源mac地址记录下PC1 的mac地址和GE0/0/1的映射关系；PC2发送回应报文的时候 交换机SW1也会记录下PC2 的mac地址和GE0/0/2的映射关系</p>
</blockquote>
</li>
<li><p>可以看到PC1的本地ARP表项中学习到了PC2的mac地址；</p>
</li>
<li><p>这样PC1就可以根据PC2的MAC地址封装数据发送给交换机SW1，交换机SW1会查找自己的MAC地址表，发现去往PC2的MAC地址的出接口为GE0/0/2，从而PC2就可以收到报文，并进行解封装；</p>
</li>
</ol>
<h2 id="PC3和PC4三层互访通信过程详解"><a href="#PC3和PC4三层互访通信过程详解" class="headerlink" title="PC3和PC4三层互访通信过程详解"></a>PC3和PC4三层互访通信过程详解</h2><p><img src="/2023/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1/2.png" alt="?"><br>如上图的网络拓扑，PC3和PC4通过路由器R1、R2互联，PC3 的IP地址为192.168.1.2/24 网关192.168.1.1 ，PC4 的IP地址为192.168.2.2/24 网关192.168.2.1，那么PC1和PC2的通信就是跨网段三层通信，下面我们从ARP表、MAC地址表、路由表的角度详细解析下这个通信过程。</p>
<ol>
<li><p>PC3要想访问PC4，由于是跨网段通信(发送方通过子网掩码判断)，PC3需要首先把数据包发送给PC3的网关。PC3会查找自己的ARP表项看是否有网关IP192.168.1.1对应的MAC地址，查看发现是空的；</p>
</li>
<li><p>我们知道如果不知道对方的mac地址，PC3会发送ARP广播报文，询问谁知道目的IP 192.168.1.1 对应的MAC地址(如下图所示)。R1收到ARP广播报文会进行回应，告诉PC3 他的网关的MAC地址；</p>
</li>
<li><p>PC3的本地ARP表项中学习到了网关的mac地址；</p>
</li>
<li><p>这样PC3就可以根据网关MAC地址封装数据发送给R1，R1收到数据包会进行解封装，解封装发现目的IP是PC4，不是发给自己的，从而会查找自己的路由表，发现去往PC4的下一跳是10.1.1.2；</p>
</li>
<li><p>R1需要把数据进行封装发送给R2的10.1.1.2 ，因此需要请求10.1.1.2 对应的MAC地址用于封装（我们可以看到R1的ARP表中已经有10.1.1.2 对应的MAC地址，因此可以直接封装）；</p>
</li>
<li><p>R2收到R1的数据包，需要进行解封装，解封装发现目的IP是PC4，通过查找自己的路由表，发现去往PC4是自己的直连端口；</p>
</li>
<li><p>R2需要把数据进行封装发送给PC4 ，因此需要请求PC4 192.168.2.2 对应的MAC地址用于封装（我们可以看到R2的ARP表中已经有192.168.2.2对应的MAC地址，因此可以直接封装）；</p>
</li>
<li><p>最后PC4收到报文进行解封装发现就是发送给自己的，通信结束；</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-第五章链路层</title>
    <url>/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>在链路层的讨论中，我们将看到两种截然不同类型的链路层信道。</p>
<p>第一种类型是广播信道，这种信道用于连接有线局域网、卫星网和混合光纤同轴电缆（Hybrid Fiber Coaxialcable, HFC）接入网中的多台主机。因为许多主机与相同的广播信道连接,需要所谓的媒体访问协议来协调帧传输。在某些场合中，可以使用中心控制器来协调传输。</p>
<p>第二种类型的链路层信道是点对点通信链路，这在诸如长距离链路连接的两台路由器之间，或用户办公室计算机与它们所连接的邻近以太网交换机之间等场合经常能够发现。协调对点对点链路的访问较为简单;</p>
<h2 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h2><p>在本章中为方便讨论，将运行链路层协议(即第2层)协议的任何设备均称为结点 (node)。结点包括主机、路由器、交换机和 Wii接入点。我们也把沿着通信路径连接相邻结点的通信信道称为链路(link)。为了将一个数据报从源主机传输到目的主机，数据报必须通过沿端到端路径上的各段链路传输。</p>
<p>考虑从无线主机之一向服务器之一发送一个数据报。该数据报将实际通过6段链路:发送主机与WiFi接人点之间的Wifi链路，接入点和链路层交换机之间的以太网链路，链路层交换机与路由器之间的链路，两台路由器之间的链路，最后是交换机和服务器之间的以太网链路。在通过特定的链路时，传输结点将数据报封装在链路层帧中，并将该帧传送到链路中。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q1.png" alt="?"></p>
<h3 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h3><p>**成帧(raming)**。在每个网络层数据报经链路传送之前，几乎所有的链路层协议都要将其用链路层帧封装起来。一个帧由一个数据字段和若干首部字段组成，其中网络层数据报就插在数据字段中。帧的结构由链路层协议规定。</p>
<p><strong>链路接入</strong>。媒体访问控制(MediumAccessControl，MAC)协议规定了帧在链路上传输的规则。对于在链路的一端仅有一个发送方、链路的另一端仅有一个接收方的点对点链路，MAC协议比较简单(或者不存在)，即无论何时链路空闲，发送方都能够发送帧。更有趣的情况是当多个结点共享单个广播链路时，即所谓多路访问问题。这里，MAC协议用于协调多个结点的帧传输。</p>
<p><strong>可靠交付</strong>。当链路层协议提供可靠交付服务时，它保证无差错地经链路层移动每个网络层数据报。链路层的可靠交付服务通常是通过确认和重传取得的。链路层可靠交付服务通常用于易于产生高差错率的链路，例如无线链路，其目的是本地(也就是在差错发生的链路上)纠正一个差错，而不是通过运输层或应用层协议迫使进行端到端的数据重传。然而，对于低比特差错的链路包括光纤、同轴电缆和许多双绞铜线链路，链路层可靠交付可能会被认为是一种不必要的开销。由于这个原因，许多有线的链路层协议不提供可靠交付服务。</p>
<p><strong>差错检测和纠正</strong>。当帧中的一个比特作为1传输时，接收方结点中的链路层硬件可能不正确地将其判断为0，反之亦然。这种比特差错是由信号衰减和电磁噪声导致的。因为没有必要转发一个有差错的数据报，所以许多链路层协议提供一种机制来检测这样的比特差错。通过让发送结点在帧中包括差错检测比特，让接收结点进行差错检查，以此来完成这项工作。因特网的运输层和网络层也提供了有限形式的差错检测，即因特网检验和。链路层的差错检测通常更复杂并且用硬件实现。差错纠正类似于差错检测，区别在于接收方不仅能检测帧中出现的比特差错，而且能够准确地确定帧中的差错出现的位置(并因此纠正这些差错)。</p>
<h3 id="链路层在何处实现"><a href="#链路层在何处实现" class="headerlink" title="链路层在何处实现"></a>链路层在何处实现</h3><p>链路层的主体部分是在网络适配器(networkadapter)中实现的，网络适配器有时也称为网络接口卡(NetworkInterface Card，NIC)位于网络适配器核心的是链路层控制器，该控制器通常是一个实现了许多链路层服务(成帧、链路接人、差错检测等) 的专用芯片。因此，链路层控制器的许多功能是用硬件实现<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q2.png" alt="?"><br>图5-2显示了与主机总线(例如一条PCI或PCI-X总线)连接的网络适配器，这里它看起来非常像与其他主机组件连接的任何其他Io设备。图5-2还显示了尽管<strong>大部分链路层是在硬件中实现的，但部分链路层是在运行于主机CPU上的软件中实现的</strong>。链路层的软件组件实现了高层链路层功能，如组装链路层寻址信息和激活控制器硬件。在接收端，链路层软件响应控制器中断(例如，由于一个或多个帧的到达)，处理差错条件和将数据报向上传递给网络层。所以，<strong>链路层是硬件和软件的结合体</strong>，即此处是协议栈中软件与硬件交接的地方。</p>
<h2 id="比特级差错检测和纠正"><a href="#比特级差错检测和纠正" class="headerlink" title="比特级差错检测和纠正"></a>比特级差错检测和纠正</h2><p>在发送结点，为了保护比特免受差错，使用差错检测和纠正比特(Error-Detetion and-Corretion，EDC)来增强数据D。通常，<strong>要保护的数据不仅包括从网络层传递下来需要通过链路传输的数据报，而且包括链路帧首部中的链路级的寻址信息、序号和其他字段</strong>。链路级帧中的D和EDC都被发送到接收结点。在接收结点，接收到比特序列D1和EDC1。注意到因传输中的比特翻转所致，D1和EDC1可能与初始的D和EDC不同。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q3.png" alt="?"></p>
<p>差错检测和纠正技术使接收方有时但并总是检测出已经出现的比特差错。即使采用差错检测比特，也还是可能有未检出比特差错(undeteeted bit error);</p>
<h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>假设在图中要发送的信息D有d个比特。在偶校验方案中，发送方只需包含一个附加的比特，选择它的值，使得这 d+1个比特(初始信息加上一个校验比特)中1的总数是偶数。对于奇校验方案，选择校验比特值使得有奇数个1。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q4.png" alt="?"><br>采用单个奇偶校验位方式，如果在采用偶校验方案中发现了奇数个值为1的比特，接收方知道至少出现了一个比特差错。更精确的说法是，出现了奇数个比特差错。</p>
<p>图5-5显示了单比特奇偶校验方案的二维一般化方案。这里D中的d个比特被划分为i行j列。<strong>对每行和每列计算奇偶值。产生的i+j+1奇偶比特构成了链路层的差错检测比特</strong>。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q5.png" alt="?"><br>利用存在奇偶校验差错的列和行的索引来实际识别发生差错的比特并纠正它!</p>
<p>图5-5显示了一个例子，其中位于(2，2)的值为1的比特损坏了，变成了0，该差错就是一个在接收方可检测并可纠正的差错。尽管我们的讨论是针对初始d比特信息的，但校验比特本身的单个比特差错也是可检测和可纠正的。二维奇偶校验也能够检测(但不能纠正!)一个分组中两个比特差错的任何组合.</p>
<p>接收方检测和纠正差错的能力被称为前向纠错(Forward Error Correction，FEC)。这些技术通常用于如音频CD这样的音频存储和回放设备中。</p>
<h3 id="检验和方法"><a href="#检验和方法" class="headerlink" title="检验和方法"></a>检验和方法</h3><p>在检验和技术中，图5-4中的d比特数据被作为一个比特整数的序列处理。一个简单检验和方法就是将这比特整数加起来，并且用得到的和作为差错检测比特。因特网检验和(Internetchecksum)就基于这种方法，即数据的字节作为16比特的整数对待并求和，这个和的反码形成了携带在报文段首部的因特网检验和，并且检测其结果是否为全1比特来检测检验和。</p>
<p>检验和方法需要相对小的分组开销，与后面要讨论的常用于链路层的CRC相比，它们提供相对弱的差错保护。</p>
<p>为什么运输层使用检验和而链路层使用CRC呢?<br>前面讲过运输层通常是在主机中作为用户操作系统的一部分用软件实现的。因为运输层差错检测用软件实现，采用简单而快速如检验和这样的差错检测方案是重要的。在另一方面，链路层的差错检测在适配器中用专用的硬件实现，它能够快速执行更复杂的CRC操作。</p>
<h3 id="循环冗余检测"><a href="#循环冗余检测" class="headerlink" title="循环冗余检测"></a>循环冗余检测</h3><p>现今的计算机网络中广泛应用的差错检测技术基于循环余检测(Cyclic RedundancyCheck，CRC)编码。CRC编码也称为多项式编码(polynomialcode)，因为该编码能够将要发送的比特串看作为系数是0和1一个多项式，对比特串的操作被解释为多项式算术。</p>
<p>CRC编码操作如下。考虑d比特的数据D，发送结点要将它发送给接收结点。发送方和接收方首先必须协商一个r+1比特模式，称为生成多项式(generator)，我们将其表示为G。我们将要求G的最高有效位的比特(最边)是1。CRC编码的关键思想如图5-6所示。对于一个给定的数据段D，发送方要选择 个附加比特R并将它们附加到D上使得得到的d+r比特模式(被解释为一个二进制数)用模2算术恰好能被G整除即没有余数)。用CRC 进行差错检测的过程因此很简单:接收方用G去除接收到的d+r比特。如果余数为非零，接收方知道出现了差错;否则认为数据正确而被接收。</p>
<p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q6.png" alt="?"><br>所有CRC计算采用模2算术来做，在加法中不进位，在减法中不借位。<strong>这意味着加法和减法是相同的，而且这两种操作等价于操作数的按位异或(XOR)。</strong> 因此，举例来说<br>1011 XOR 0101=1110<br>1001 XOR 1101=0100<br>类似的，我们还会有:<br>1011-0101=1110<br>1001-1101=0100</p>
<p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q7.png" alt="?"><br>国际标准已经定义了8、12、16和32比特生成多项式G。CRC-3232比特的标准被多种链路级IEEE协议采用，使用的一个生成多项式是:<br>GcRc-32=100000100110000010001110110110111</p>
<h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><p>两种类型的网络链路:点对点链路和广播链路。<br>点对点链路(point-to-pointlik)由链路一端的单个发送方和链路另一端的单个接收方组成。许多链路层协议都是为点对点链路设计的，如点对点协议 (point-to-point protocol，PPP)和高级数据链路控制(high-level data link controlHDLC)就是两种这样的协议。</p>
<p>第二种类型的链路是广播链路(broadcast link)，它能够让多个发送和接收结点都连接到相同的、单一的、共享的广播信道上。这里使用术语“广播”是因为当任何一个结点传输一个帧时，信道广播该帧，每个其他结点都收到一个副本。以太网和无线局域网是广播链路层技术的例子。</p>
<h4 id="多路访问协议-multiple-access-protocol"><a href="#多路访问协议-multiple-access-protocol" class="headerlink" title="多路访问协议 (multiple access protocol)"></a>多路访问协议 (multiple access protocol)</h4><p>即结点通过这些协议来规范它们在共享的广播信道上的传输行为。如图5-8所示，在各种各样的网络环境下需要多路访问协议，包括有线和无线接人网，以及卫星网络。尽管从技术上讲每个结点通过它的适配器访问广播信道，但在本节中我们将把结点作为发送和接收设备。在实践中，数以百计或者甚至数以千计个结点能够通过一个广播信道直接通信。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q8.png" alt="?"></p>
<p>多个结点可能会同时传输帧。当发生这种情况时，所有结点同时接到多个帧;这就是说，传输的帧在所有的接收方处碰撞 (collide)了。通常，当碰撞发生时，没有一个接收结点能够有效地获得任何传输的帧;</p>
<p>我们能够将任何多路访问协议划分为3种类型之一:信道划分协议 (channel partitioning protocol)随机接入协议(randomaccess protocol)和轮流协议 (taking-turns protocol)。</p>
<h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><p>时分多路复用(TDM)和频分多路复用(FDM)是两种能够用于在所有共享信道结点之间划分广播信道带宽的技术。<br>举例来说，假设一个支持N个结点的信道且信道的传输速率为Rbps。TDM将时间划分为时间(timeframe)，并进一步划分每个时间帧为N个时隙 (slot)。(不应当把TDM时间与在发送和接收适配器之间交换的链路层数据单元相混淆，后者也被称为帧。为了减少混乱，在本小节中我们将链路层交换的数据单元称为分组。然后把每个时隙分配给N个结点中的一个。无论何时某个结点在有分组要发送的时候，它在循环的TDM 中指派给它的时隙内传输分组比特通常，选择的时隙长度应使一个时隙内能够传输单个分组。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/q9.png" alt="?"></p>
<p>TDM每个结点在每个帧时间内得到了专用的传输速率R/N bps。然而它有两个主要缺陷。首先，结点被限制于R/Nbps的平均速率，即使当它是唯一有分组要发送的结点时。其次，结点必须总是等待它在传输序列中的轮次即我们再次看到，即使它是唯一一个有帧要发送的结点。</p>
<p>TDM在时间上共享广播信道，而FDM将Rbps信道划分为不同的频段(每个频段具有R/N带宽)，并把每个频率分配给N个结点中的一个。因此FDM在单个较大的Rbps信道中创建了N个较小的R/Nbps信道。FDM也有TDM同样的优点和缺点。它避免了碰撞在N个结点之间公平地划分了带宽。然而，FDM也有TDM所具有的主要缺点，也就是限制一个结点只能使用R/N的带宽，即使当它是唯一一个有分组要发送的结点时。</p>
<p>第三种信道划分协议是码分多址(Code Division Multiple Access，CDMA)。TDM和FDM分别为结点分配时隙和频率，而CDMA 对每个结点分配一种不同的编码。然后每个结点用它唯一的编码来对它发送的数据进行编码。如果精心选择这些编码，CDMA网络具有一种奇妙的特性，即不同的结点能够同时传输，并且它们各自相应的接收方仍能正确接收发送方编码的数据比特(假设接收方知道发送方的编码)，而不在乎其他结点的干扰传输。</p>
<p>CDMA已经在军用系统中使用了一段时间(由于它的抗干扰特性)，目前已经广泛地用于民用，尤其是蜂窝电话中。因为CDMA 的使用与无线信道紧密相关，此时，我们知道CDMA编码类似于TDM中的时隙和FDM中的频率，能分配给多路访问信道的用户就可以了。</p>
<h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><p>第二大类多访问协议是随机接入协议。<strong>在随机接入协议中，一个传输结点总是以信道的全部速率(即Rbps)进行发送。</strong> 当有碰撞时，涉及碰撞的每个结点反复地重发它的帧(也就是分组)，到该无碰撞地通过为止。但是当一个结点经历一次碰撞时，它不必立刻重发该帧。相反，它在重发该帧之前等待一个随机时延。涉及碰撞的每个结点独立地选择随机时延。因为该随机时延是独立地选择的，所以下述现象是有可能的:这些结点之一所选择的时延充分小于其他碰撞结点的时延，并因此能够无碰撞地将它的帧在信道中发出。</p>
<h4 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h4><p>当结点有一个新帧要发送时，它等到下一个时隙开始并在该时隙传输整个帧。</p>
<p>如果没有碰撞，该结点成功地传输它的帧，从而不需要考虑重传该帧。(如果该结点有新帧，它能够为传输准备一个新帧。)</p>
<p>如果有碰撞，该结点在时隙结束之前检测到这次碰撞。该结点以概率p在后续的每个时隙中重传它的帧，直到该帧被无碰撞地传输出去。</p>
<p>时隙ALOHA看起来有很多优点。与信道划分不同，当某结点是唯一活跃的结点时(一个结点如果有顿要发送就认为它是活跃的)，时隙ALOHA允许该结点以全速R连续传输。时隙ALOHA也是高度分散的，因为每个结点检测碰撞并独立地决定什么时候重传。</p>
<p>当有多个活跃结点时，一部分时隙将有碰撞，因此将被“浪费”掉了。第二个考虑是，时隙的另一部分将是空闲的，因为所有活跃结点由于概率传输策略会节制传输。唯一“未浪费的”时隙是那些刚好有一个结点传输的时隙。刚好有一个结点传输的时院称为一个成功时隙(successful slot）<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w1.png" alt="?"></p>
<h4 id="纯ALOHA"><a href="#纯ALOHA" class="headerlink" title="纯ALOHA"></a>纯ALOHA</h4><p>时隙ALOHA协议要求所有的结点同步它们的传输，以在每个时隙开始时开始传输。第1个ALOHA协议实际上是一个非时隙、完全分散的协议。在纯ALOHA中，当一帧首次到达(即一个网络层数据报在发送结点从网络层传递下来)，结点立刻将该帧完整地传输进广播信道。如果一个传输的帧与一个或多个传输经历了碰撞，这个结点将立即(在完全传输完它的碰撞帧之后) 以概率p重传该。否则，该结点等待一个顿传输时间在此等待之后，它则以概率p传输该，或者以概率1-p在另一个时间等待(保持空闲)。</p>
<blockquote>
<p>纯ALOHA是一种简单的多点接入协议，它允许所有的节点在任何时间发送数据帧。当一个节点发送完一个数据帧后，它需要等待一段时间来检查是否有其他节点同时发送，如果有冲突，则需要等待一段时间后重新发送。</p>
<p>时隙ALOHA是一种改进的多点接入协议，它将时间分割成若干个时隙，每个时隙只允许一个节点发送数据帧。节点需要等待下一个时隙才能发送数据帧，这样就避免了冲突的发生。时隙ALOHA的效率比纯ALOHA高，但是需要更多的控制开销来分配时隙。</p>
</blockquote>
<h4 id="载波侦听多路访问-CSMA"><a href="#载波侦听多路访问-CSMA" class="headerlink" title="载波侦听多路访问(CSMA)"></a>载波侦听多路访问(CSMA)</h4><p>在时隙和纯ALOHA中，一个结点传输的决定独立于连接到这个广播信道上的其他结点的活动。特别是，一个结点不关心在它开始传输时是否有其他结点碰巧在传输，而且即使有另一个结点开始干扰它的传输也不会停止传输。</p>
<p>说话之前先听。如果其他人正在说话，等到他们说完话为止。在网络领域中，这被称为载波侦听(carrier sensing)，即一个结点在传输前先听信道。如果来自另一个结点的帧正向信道上发送，结点则等待直到检测到一小段时间没有传输，然后开始传输。</p>
<p>如果与他人同时开始说话，停止说话。在网络领域中，这被称为碰撞检测 (collisiondetection)，即当一个传输结点在传输时一直在侦听此信道。如果它检测到另个结点正在传输干扰帧，它就停止传输，在重复“侦听-当空闲时传输”循环之前等待一段随机时间。</p>
<p>这两个规则包含在载波侦听多路访问(Carrier Sense MultipleAccess，CSMA)和具有碰撞检测的CSMA(CSMA with Collision Detection，CSMA/CD)协议族中</p>
<p>关于CSMA你可能要问的第一个问题是，如果所有的结点都进行载波侦听了，为什么当初会发生碰撞?毕竟，某结点无论何时侦听到另一个结点在传输，它都会停止传输。</p>
<p>在时刻t0，结点 B侦听到信道是空闲的，因为当前没有其他结点在传输。因此结点B开始传输，沿着广播媒体在两个方向上传播它的比特。图5-12中B的比特随着时间的增加向下传播，这表明B的比特沿着广播媒体传播所实际需要的时间不是零(虽然以接近光的速度)。在时刻t1，结点D有一个要发送。尽管结点B在时刻正在传输但B传输的比特还没有到达D，因此D在侦听到信道空闲。根据CSMA协议，从而D开始传输它的顿。一个短暂的时间之后，B的传输开始在D干扰D的传输。从图5-12中可以看出，显然广播信道的端到端信道传播时延(channel propagation delay)(信号从一个结点传播到另一个结点所花费的时间)在决定其性能方面起着关键的作用。该传播时延越长，载波侦听结点不能侦听到网络中另一个结点已经开始传输的机会就越大。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w2.png" alt="?"></p>
<p>在图5-12中，结点没有进行碰撞检测;即使已经出现了碰撞，B和D都将继续完整地传输它们的帧。当某结点执行碰撞检测时，一旦它检测到碰撞将立即停止传输。图5-13表示了和图5-12相同的情况，只是这两个结点在检测到碰撞后很短的时间内都放弃了它们的传输。显然，在多路访问协议中加人碰撞检测，通过不传输一个无用的、(由来自另一个结点的顿干扰)损坏的帧，将有助于改善协议的性能。</p>
<p><strong>CSMA/CD运行</strong><br>1)适配器从网络层一条获得数据报，准备链路层帧，并将其放入顿适配器缓存中。<br>2)如果适配器侦听到信道空闲(即无信号能量从信道进入适配器)，它开始传输帧在另一方面，如果适配器侦听到信道正在忙，它将等待，直到侦听到没有信号能量时才开始传输帧。<br>3)在传输过程中，适配器监视来自其他使用该广播信道的适配器的信号能量的存在。<br>4)如果适配器传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了该帧。在另一方面，如果适配器在传输时检测到来自其他适配器的信号能量，它中止传输(即它停止了传输帧)。<br>5)中止传输后，适配器等待一个随机时间量，然后返回步骤2。</p>
<p>用于以太网以及DOCSIS电缆网络多路访问协议中的<strong>二进制指数后退(binaryexponentialbackoff)算法</strong>，简练地解决了这个等待时间量。</p>
<p>特别是，当传输一个给定，2”-1 中选择帧时，在该帧经历了一连串的n次碰撞后，结点随机地从0，1，2，··一个K值。因此，一个帧经历的碰撞越多，K选择的间隔越大。对于以太网，一个结点等待的实际时间量是k·512比特时间(即发送512比特进入以太网所需时间量的K倍)，n能够取的最大值在10以内。</p>
<blockquote>
<p>我们看一个例子。假设一个适配器首次尝试传输一个帧，并在传输中它检测到碰撞然后该结点以概率0.5选择K=0，以概率05选择K=1。如果该结点选择K=0，则它立即开始侦听信道。如果这个适配器选择K=1，它在开始“侦听-当空闲时传输”。周期前等待512比特时间(例如对于100Mbps 以太网来说为5.12微秒)。在第2次碰撞之后，从10,1，2,3 中等概率地选择K。在第3 次碰撞之后，从 0,1，2，3，4，5，6，7中等概率地选择K。在10次或更多次碰撞之后，从 0，1，2，··，1023中等概率地选择K。因此从中选择K的集合长度随着碰撞次数呈指数增长;正是由于这个原因，该算法被称为二进制指数后退。</p>
</blockquote>
<p>为了给出效率的一个闭式的近似表示，令dpp表示信号能量在任意两个适配器之间传播所需的最大时间。令dn表示传输一个最大长度的以太网的时间(对于10Mbps的以太网，该时间近似为12毫秒)。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w3.png" alt="?"></p>
<p>从这个公式我们看到，当d-接近0时，效率接近1。这和我们的直觉相符，如果传播时延是0，碰撞的结点将立即中止而不会浪费信道。同时，当dmn变得很大时，效率也接近于1。这也和直觉相符，因为当一个帧取得了信道时，它将占有信道很长时间;因此信道在大多数时间都会有效地工作。</p>
<h4 id="以太网帧min和max"><a href="#以太网帧min和max" class="headerlink" title="以太网帧min和max"></a>以太网帧min和max</h4><p><strong>以太网数据帧的长度在 64-1518 字节之间。. 数据部分在46~1500 B之间。<br>10Mbps以太网一帧的最小发送时间为51.2微秒。 这段时间所能传输的数据为512位，因此也称该时间为512位时。 这个时间定义为以太网时隙，或冲突时槽。 512位=64字节，这就是以太网帧最小64字节的原因。<br>最小帧的定义是在不包括任何额外头部或尾部的情况下的帧长度，因此在计算最小帧的长度时，不考虑VLAN标记。</strong></p>
<h3 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h3><p>多路访问协议的两个理想特性是:<br>当只有一个结点活跃时，该活跃结点具有Rbps的吞吐量;<br>当有M个结点活跃时，每个活跃结点的吞吐量接近R/Mbps。<br>ALOHA和CSMA 协议具备第一个特性，但不具备第二个特性。</p>
<p>第一种是轮询协议(pollingprotocol)。轮询协议要求这些结点之一要被指定为主结点。主结点以循环的方式轮询(poll)每个结点。特别是，主结点首先向结点1发送一个报文，告诉它(结点1)能够传输的帧的最多数量。在结点1传输了某些帧后，主结点告诉结点2它(结点2) 能够传输的帧的最多数量。(主结点能够通过观察在信道上是否缺乏信号，来决定一个结点何时完成了帧的发送。)上述过程以这种方式继续进行，主结点以循环的方式轮询了每个结点。轮询协议消除了困扰随机接入协议的碰撞和空时隙，这使得轮询取得高得多的效率但是它也有一些缺点。第一个缺点是该协议引人了轮询时延，即通知一个结点“它可以传输”所需的时间。例如，如果只有一个结点是活跃的，那么这个结点将以小于 Rbps 的速率传输，因为每次活跃结点发送了它最多数量的帧时，主结点必须依次轮询每一个非活跃的结点。第二个缺点可能更为严重，就是如果主结点有故障，整个信道都变得不可操作。</p>
<p>第二种轮流协议是令牌传递协议 (token-passing protocol)。在这种协议中没有主结点。一个称为令牌(token)的小的特殊在结点之间以某种固定的次序进行交换。例如，结点1可能总是把令牌发送给结点2，结点2可能总是把令牌发送给结点3，而结点N可能总是把令牌发送给结点1。当一个结点收到令牌时，仅当它有一些帧要发送时，它才持有这个令牌;否则，它立即向下一个结点转发该令牌。当一个结点收到令牌时，如果它确实有帧要传输，它发送最大数目的帧数，然后把令牌转发给下一个结点。令牌传递是分散的，并有很高的效率。但是它也有自己的一些问题。例如，一个结点的故障可能会使整个信道崩溃。或者如果一个结点偶然忘记了释放令牌，则必须调用某些恢复步骤使令牌返回到循环中来。</p>
<h3 id="DOCSIS-用于电缆因特网接入的链路层协议"><a href="#DOCSIS-用于电缆因特网接入的链路层协议" class="headerlink" title="DOCSIS:用于电缆因特网接入的链路层协议"></a>DOCSIS:用于电缆因特网接入的链路层协议</h3><p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w4.png" alt="?"></p>
<h2 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h2><p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w5.png" alt="?"></p>
<h3 id="链路层寻址和ARP"><a href="#链路层寻址和ARP" class="headerlink" title="链路层寻址和ARP"></a>链路层寻址和ARP</h3><p>主机和路由器具有链路层地址和网络层地址。<br>地址解析协议 (ARP)，该协议提供了将IP地址转换为链路层地址的机制。</p>
<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>链路层地址有各种不同的称呼:LAN地址(LANaddress)、物理地址(physicaladdress)或MAC地址(MACaddress)。我们此后就将链路层地址称为MAC地址。对于大多数局域网(包括以太网和802.11 无线局域网)而言，MAC地址长度为6字节，共有2^48个可能的MAC地址。如图5-16所示，这些6个字节地址通常用十六进制表示法，地址的每个字节被表示为一对十六进制数。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w6.png" alt="?"><br>链路层交换机的作用是在主机和路由器之间传输数据包，而不是像路由器一样需要对数据包进行转发决策。因此，交换机不需要与它们连接的主机或路由器相关联的链路层地址。交换机会透明地执行它的任务</p>
<p>尽管MAC地址被设计为永久的，但用软件改变一块适配器的 MAC 地址现在是可能的。然而对于本节的后面部分而言，我们将假设某适配器的MAC地址是固定的</p>
<p>IEEE在管理着该MAC地址空间。特别是，当一个公司要生产适配器时，它支付象征性的费用购买组成224个地址的一块地址空间。IEEE分配这块248个地址的方式是:固定一个MAC地址的前24比特，让公司自己为每个适配器生成后24比特的唯一组合。</p>
<p>IP 地址具有层次结构 (即一个网络部分和一个主机部分),而且当主机移动时，主机的IP地址需要改变，即改变它所连接到的网络。适配器的 MAC地址与人的社会保险号相似，后者也具有扁平寻址结构，而且无论人到哪里该号码都不会变化。</p>
<p>当某适配器要向某些目的适配器发送一个帧时，发送适配器将目的适配器的 MAC地址插入到该帧中，并将该帧发送到局域网上。如我们马上要看到的那样，一台交换机偶尔将一个人帧广播到它的所有接口。802.11 也广播。因此一块适配器可以接收一个并非向它寻址的帧。这样，当适配器接收到一个帧时，将检查该帧中的目的MAC地址是否与它自己的MAC地址匹配。如果匹配，该适配器提取出封装的数据报，并将该数据报沿协议栈向上传递。如果不匹配，该适配器丢弃该帧，而不会向上传递该网络层数据报。所以，仅当收到该帧时，才会中断目的地。<br>然而，有时某发送适配器的确要让局域网上所有其他适配器来接收并处理它打算发送的帧。在这种情况下，发送适配器在该帧的目的地址字段中插入一个特殊的MAC广播地址(broadcastaddress)。对于使用6字节地址的局域网(例如以太网和80211)来说，广播地址是48个连续的1组成的字符串(即以十六进制表示法表示的FF-FF-FF-FF-FF-FF).</p>
<h4 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h4><p>因为存在网络层地址(例如，因特网的IP地址)和链路层地址(即MAC地址)，所以需要在它们之间进行转换。对于因特网而言，这是地址解析协议(Address Resolution Protocol，ARP)的任务。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w7.png" alt="?"></p>
<p>现在假设IP地址为222222.222220的主机要向主机222222222222发送P数据报。在本例中，源和目的均位于相同的子网中。为了发送数据报，该源必须要向它的适配器不仅提供iP数据报，而且要提供目的主机222222.222222的MAC地址。然后发送适配器将构造一个包含目的地的 MAC地址的链路层，并把该帧发送进局域网</p>
<p>发送主机如何确定iP地址为222.222.222222的目的主机的MAC地址呢?</p>
<p>在发送主机中的ARP模块将取在相同局域网上的任何IP 地址作为输入，然后返回相应的 MAC地址。在眼下的这个例子中，发送主机222.222222220向它的ARP模块提供了地址222222222222并且其ARP模块返回了相应的MAC地址49-BD-D2-C7-56-2A。</p>
<p><strong>DNS为在因特网中任何地方的主机解析主机名，而ARP只为在同一个子网上的主机和路由器接口解析IP地址。</strong></p>
<p>每台主机或路由器在其内存中具有一个ARP表(ARP table)，该ARP表也包含一个寿命(TTL)值，它指示了从表中删除每个映射的时间。注意到这张表不必为该子网上的每台主机和路由器都包含一个表项:某些可能从来没有进人到该表中，某些可能已经过期。从一个表项放置到某ARP表中开始，个表项通常的过期时间是20分钟。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w8.png" alt="?"><br>现在假设主机222.222.222.220要发送一个数据报，该数据报要IP寻址到本子网上另一台主机或路由器。发送主机需要获得给定IP地址的目的主机的MAC地址。如果发送方的ARP表具有该目的结点的表项，很容易。</p>
<p>但如果ARP 表中当前没有该目的主机的表项，又该怎么办呢?</p>
<p>在这种情况下，发送方用ARP 协议来解析这个地址。首先，发送方构造一个称为ARP分组(ARPpacket)的特殊分组。一个ARP分组有几个字段，包括发送和接收IP地址及MAC地址。ARP查询分组和响应分组都具有相同的格式。ARP查询分组的目的是询问子网上所有其他主机和路由器，以确定对应于要解析的iP地址的那个MAC 地址。<br>222.222.222.220向它的适配器传递一个ARP查询分组，并且指示适配器应该用MAC广播地址(即FF-FF-FF-FF-FF-FF)来发送这个分组。适配器在链路层帧中封装这个 ARP分组，用广播地址作为的目的地址，并将该传输进子网中,包含该ARP查询的能被子网上的所有其他适配器接收到，并且(由于广播地址) 每个适配器都把在该中的ARP分组向上传递给ARP模块。这些ARP模块中的每个都检查它的iP地址是否与ARP分组中的目的iP地址相匹配。匹配的一个给查询主机发送回一个响应ARP分组。然后查询主机222.222222220能够更新它的ARP表，并发送它的IP数据报.</p>
<p>首先，查询ARP报文是在广播中发送的，而响应ARP报文在一个标准顿中发送。其次，ARP是即插即用的，这就是说，一个ARP 表是自动建立的，即它不需要系统管理员来配置。并且如果某主机与子网断开连接，它的表项最终会从留在子网中的结点的表中删除掉。</p>
<p>所以，可能最好把ARP看成是跨越链路层和网络层边界两边的协议</p>
<h4 id="发送数据报到子网以外"><a href="#发送数据报到子网以外" class="headerlink" title="发送数据报到子网以外"></a>发送数据报到子网以外</h4><p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w9.png" alt="?"></p>
<p>每台主机仅有一个iP地址和一个适配器。<br>一台路由器对它的每个接口都有一个IP 地址。对路由器的每个接口，(在路由器中)也有一个ARP模块和一个适配器。<br>网络中的每个适配器都有自已的MAC地址。</p>
<p>我们发现为了使一个数据报从111.111.111.111到子网2上的主机，该数据报必须首先发送给路由器接口111.111.111.110.它是通往最终目的地路径上的第一跳路由器的IP地址。因此，对于该来说，适当的MAC地址是路由器接口111.111.111.110的适配器地址E6-E9-00-17-BB-4B。</p>
<p>但发送主机怎样获得111.111.111.110的MAC地址呢?<br>当然是通过使用ARP!一旦发送适配器有了这个MAC地址，它创建一个帧(包含了寻址到222.222.222.222的数据报)，并把该发送到子网1中。在子网1上的路由器适配器看到该链路层帧是向它寻址的，因此把这个帧传递给路由器的网络层。该IP数据报终于被成功地从源主机移动到这台路由器了!</p>
<p>但是我们的任务还没有结束。我们仍然要将该数据报从路由器移动到目的地。路由器现在必须决定该数据报要被转发的正确接口。这是通过查询路由器中的转发表来完成的。转发表告诉这台路由器该数据报要通过路由器接口222.222.222220转发。然后该接口把这个数据报传递给它的适配器，适配器把该数据报封装到一个新的帧中，并且将帧发送进子网2中。这时，该帧的目的 MAC 地址确实是最终目的地 MAC 地址。路由器又是怎样获得这个目的地MAC地址的呢?当然是用ARP获得的!</p>
<h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>集线器(hub)是一种物理层设备，它作用于各个比特而不是作用于帧。当表示一个0或一个1的比特到达一个接口时，集线器只是重新生成这个比特，将其能量强度放大，并将该比特向其他所有接口传输出去。因此，采用基于集线器的星形拓扑的以太网也是一个广播局域网，即无论何时集线器从它的一个接口接收到一个比特，它向其所有其他接口发送该比特的副本。特别是，如果某集线器同时从两个不同的接口接收到帧，将出现一次碰撞，生成该帧的结点必须重新传输该帧。</p>
<p>在21世纪早期，以太网又经历了一次重要的革命性变化。以太网安装继续使用星形拓扑，但是位于中心的集线器被交换机(swith)所替代。眼下我们仅知道交换机不仅是“无碰撞的”，而且也是名副其实的存储转发分组交换机就可以了;但是与运行在高至第3 层的路由器不同，交换机仅运行在第2层。</p>
<h4 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h4><p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e1.png" alt="?"></p>
<p>考虑从一台主机向另一台主机发送一个iP数据报，且这两台主机在相同的以太局域网上,设发送适配器(即适配器A)的MAC 地址是AA-AA-AA-AA-AA-AA，接收适配器(即适配器B)的MAC地址是BB-BB-BB-BB-BB-BB。发送适配器在一个以太网中封装了一个iP数据报，并把该顿传递到物理层。接收适配器从物理层收到这个帧，提取出IP数据报，并将该IP数据报传递给网络层。</p>
<p>**数据字段(46~1500字节)**。这个字段承载了IP数据报。以太网的最大传输单元(MTU)是1500字节。这意味着如果IP数据报超过了1500字节，则主机必须将该数据报分片，如4.41节所讨论。数据字段的最小长度是46 字节。这意味着如果IP数据报小于46字节，数据报必须被填充到46字节。当采用填充时，传递到网络层的数据包括IP数据报和填充部分。网络层使用IP数据报首部中的长度字段来去除填充部分。<br>**目的地址(6字节)**。这个字段包含目的适配器的MAC地址，即BB-BB-BB-BB-BB-BB。当适配器B收到一个以太网顿，的目的地址无论是BB-BB-BB-BB-BBBB，还是MAC广播地址，它都将该的数据字段的内容传递给网络层:如果它收到了具有任何其他MAC地址的帧，则丢弃之。<br>**源地址(6字节)**。这个字段包含了传输该帧到局域网上的适配器的 MAC地址在本例中为AA-AAAA-AA-AA-AA。<br>**类型字段(2字节)**。类型字段允许以太网复用多种网络层协议。为了理解这点我们需要记住主机能够使用除了iP以外的其他网络层协议。此外，ARP协议有自己的类型编号，并且如果到达的帧包含 ARP分组(即类型字段的值为十六进制的0806)，则该ARP分组将被多路分解给ARP协议。注意到该类型字段和网络层数据报中的协议字段、运输层报文段的端口号字段相类似;所有这些字段都是为了把一层中的某协议与上一层的某协议结合起来。<br>**CRC(4字节)**。如5.23节中讨论的那样，CRC(循环余检测)字段的目的是使得接收适配器(适配器B)检测帧中是否引人了差错<br>**前同步码(8字节)**。以太网以一个8字节的前同步码(Preamble)字段开始。该前同步码的前7字节的值都是10101010:最后一个字节是10101011。前同步码字段的前7字节用于“唤醒”接收适配器，并且将它们的时钟和发送方的时钟同步。为什么这些时钟会不同步呢?记住适配器A的目的是根据以太局域网类型的不同，分别以10Mbps、100Mbps或者1Gbps的速率传输顿。然而，没有什么是完美无缺的，因此适配器A不会以精确的额定速率传输帧;相对于额定速率总有一些漂移，局域网上的其他适配器不会预先知道这种漂移的。接收适配器只需通过锁定前同步码的前7字节的比特，就能够锁定适配器A的时钟。前同步码的第8个字节的最后两个比特(第一个出现的两个连续的1)警告适配器B，“重要的内容就要到来了”</p>
<p>所有的以太网技术都向网络层提供无连接服务。这就是说，当适配器A要向适配器B发送一个数据报时，适配器 A在一个以太网中封装该数据报，并且把该帧发送到局域网上，没有先与适配器B握手。这种第二层的无连接服务类似于P的第三层数据报服务和UDP的第4层无连接服务。</p>
<p>以太网技术都向网络层提供不可靠服务(unreliable service)。特别是，当适配器B收到一个来自适配器A的顿，它对该执行 CRC校验，但是当该通过 CRC校验时它既不发送确认帧;而当该帧没有通过 CRC 校验时它也不发送否定确认顿。当某顿没有通过CRC校验，适配器B只是丢弃该。因此，适配器A根本不知道它传输的是否到达了B并通过了 CRC校验。(在链路层) 缺乏可靠的传输有助于使得以网简单和便宜。但是它也意味着传递到网络层的数据报流能够有间隙。</p>
<p>如果由于丢弃了以太网帧而存在间隙，主机B上的应用也会看见这个间隙吗?</p>
<p>这只取决于该应用是使用UDP 还是使用TCP。如果应用使用的是UDP，则主机B中的应用的确会看到数据中的间隙。另一方面，如果应用使用的是 TCP则主机B中的TCP将不会确认包含在丢弃中的数据，从而引起主机A的TCP重传。注意到当TCP重传数据时，数据最终将回到曾经丢弃它的以太网适配器。因此，从这种意义上来说，以太网的确重传了数据，尽管以太网并不知道它是正在传输一个具有全新数据的全新数据报，还是一个包含已经被传输过至少一次的数据的数据报。</p>
<h4 id="以太网技术"><a href="#以太网技术" class="headerlink" title="以太网技术"></a>以太网技术</h4><p>在总线拓扑和基于集线器的星形拓扑技术时代，以太网很显然是一种广播链路，其中多个结点同时传输时会出现帧碰撞。为了处理这些碰撞，以太网标准包括了CSMA/CD协议，该协议对于跨越一个小的地理半径的有线广播局域网特别有效。但是对于今天广为使用的以太网是基于交换机的星形拓扑，采用的是存储转发分组交换，是否还真正需要一种以太网MAC协议呢?如我们很快所见，交换机协调其传输，在任何时候决不会向相同的接口转发超过一个帧。此外，现代交换机是全双工的，这使得一台交换机和一个结点能够在同时向对方发送帧而没有干扰。换句话说，在基于交换机的以太局域网中，不会有碰撞，因此没有必要使用MAC协议了!</p>
<h3 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h3><p>交换机的任务是接收入链路层帧并将它们转发到出链路;我们将看到交换机自身对子网中的主机和路由器是透明的(transparent);这就是说，某主机/路由器向另一个主机/路由器寻址一个帧(而不是向交换机寻址该)，顺利地将该帧发送进局域网，并不知道某交换机将会接收该帧并将它转发到另一个结点。这些帧到达该交换机的任何输出接口之一的速率可能暂时会超过该接口的链路容量。为了解决这个问题，交换机输出接口设有缓存，这非常类似于路由器接口为数据报设有缓存。现在我们来仔细考察交换机运行的原理。</p>
<h4 id="交换机转发和过滤"><a href="#交换机转发和过滤" class="headerlink" title="交换机转发和过滤"></a>交换机转发和过滤</h4><p>过滤(fltering)是决定一个应该转发到某个接口还是应当将其丢弃的交换机功能转发(forwarding)是决定一个帧应该被导向哪个接口，并把该移动到那些接口的交换机功能。交换机的过滤和转发借助于交换机表(switeh table)完成。该交换机表包含某局域网上某些主机和路由器的但不必是全部的表项。交换机表中的一个表项包含:1一个MAC地址;2通向该MAC地址的交换机接口:3表项放置在表中的时间。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e2.png" alt="?"><br>为了理解交换机过滤和转发的工作过程，假定目的地址为DD-DD-DDDD-DD-DD的帧从交换机接口x到达。交换机用MAC地址DD-DD-DD-DD-DD-DD索引它的表。有3种可能的情况:</p>
<p>表中没有对于DD-DD-DD-DD-DD-DD的表项。在这种情况下，交换机向除接口x外的所有接口前面的输出缓存转发该帧的副本。换言之，如果没有对于目的地址的表项，交换机广播该帧。</p>
<p>表中有一个表项将DD-DD-DD-DD-DD-DD与接口x联系起来。在这种情况下，该帧从包括适配器DD-DD-DD-DD-DD-DD的局域网网段到来。无需将该转发到任何其他接口，交换机通过丢弃该帧执行过滤功能即可。</p>
<p>表中有一个表项将DD-DD-DD-DD-DD-DD与接口y联系起来。在这种情况下该帧需要被转发到与接口y相连的局域网网段。交换机通过将该顿放到接口y前面的输出缓存完成转发功能。</p>
<p>假设目的地址为62-FE-F7-11-89-A3的一个从接口1到达该交换机。交换机检查它的表并且发现其目的地是在与接口1相连的局域网网段上(即电子工程系的局域网)。这意味着该帧已经在包含目的地的局域网网段广播过了。因此该交换机过滤(即丢弃)了该帧。现在假设有同样目的地址的帧从接口2到达。交换机再次检查它的表并且发现其目的地址在接口1的方向上;因此它向接口1前面的输出缓存转发该。这个例子清楚地表明，只要交换机的表是完整和准确的，该交换机无需任何广播就向着目的地转发帧。</p>
<h4 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h4><p>1)交换机表初始为空。<br>2)对于在每个接口接收到的每个入帧，该交换机在其表中存储:D在该源地址字段中的MAC 地址;@该到达的接口，3当前时间。交换机以这种方式在它的表中记录了发送结点所在的局域网网段。如果在局域网上的每个结点最终都发送了一个帧，则每个结点最终将在这张表中留有记录。<br>3)如果在一段时间(称为老化期(aging time))后，交换机没有接收到以该地址作为源地址的帧，就在表中删除这个地址。以这种方式，如果一台PC 被另一台 PC(具有不同的适配器)代替，原来PC的MAC地址将最终从该交换机表中被清除掉。</p>
<h4 id="链路层交换机的性质"><a href="#链路层交换机的性质" class="headerlink" title="链路层交换机的性质"></a>链路层交换机的性质</h4><p>消除碰撞。在使用交换机(不使用集线器)构建的局域网中，没有因碰撞而浪费的带宽!交换机缓存顿并且决不会在网段上同时传输多于一个。就像使用路由器一样，交换机的最大聚合带宽是该交换机所有接口速率之和。因此，交换机提供了比使用广播链路的局域网高得多的性能改善。</p>
<p>异质的链路。交换机将链路彼此隔离，因此局域网中的不同链路能够以不同的速率运行并且能够在不同的媒体上运行。例如，图5-22 中最上面的交换机有3条1Gbps 1000BASE-T铜缆链路、2条100Mbps 10BASE-FX光缆链路和1条100BASE-T铜缆链路。因此，对于原有的设备与新设备混用，交换机是理想的。</p>
<p>管理。除了提供强化的安全性(参见插入材料“关注安全性”)，交换机也易于进行网络管理。例如，如果一个适配器工作异常并持续发送以太网帧(称为快而含糊的(jabbering)适配器)，交换机能够检测到该问题，并在内部断开异常适配器。有了这种特色，网络管理员不用起床并开车到工作场所去解决这个问题。类似地，一条割断的缆线仅使得使用该条缆线连接到交换机的主机断开连接。在使用同轴电缆的时代，许多网络管理员花费几个小时“沿线巡检”(或者更准确地说“在天花板上爬行”)，以找到使整个网络瘫痪的电缆断开之处。如在第9章(网络管理)中讨论的那样，交换机也收集带宽使用的统计数据、碰撞率和流量类型，并使这此信息为网络管理者使用。这些信息能够用于调试和解决问题，并规划该局域网在未来应当演化的方式。</p>
<h4 id="交换机和路由器比较"><a href="#交换机和路由器比较" class="headerlink" title="交换机和路由器比较"></a>交换机和路由器比较</h4><p>即使交换机和路由器从根本上是不同的，网络管理员在安装互联设备时也经常必须在它们之间进行选择。例如，对于图5-15 中的网络，网络管理员本来可以很容易地使用路由器而不是交换机来互联各个系的局域网、服务器和互联网网关路由器。路由器的确使得各系之间通信而不产生碰撞。</p>
<p>既然交换机和路由器都是候选的互联设备，那么这两种方式的优点和缺点各是什么呢?</p>
<p>首先考虑交换机的优点和缺点。如上面提到的那样，交换机是即插即用的、这是世界上所有超负荷工作的网络管理员都喜爱的特性。交换机还能够具有相对高的分组过滤和转发速率，就像图5-24中所示的那样，交换机必须处理高至第二层的顿，而路由器必须处理高至第三层的数据报。在另一方面，为了防止广播帧的循环，交换网络的活跃拓扑限制为一棵生成树。另外，一个大型交换网络将要求在主机和路由器中有大的ARP 表，这将生成可观的ARP流量和处理量。而且，交换机对于广播风暴并不提供任何保护措施，即如果某主机出了故障并传输出没完没了的以太网广播帧流，该交换机将转发所有这些帧.使得整个以太网的崩溃。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e3.png" alt="?"></p>
<p>现在考虑路由器的优点和缺点。因为网络寻址通常是分层次的(不像MAC寻址那样是扁平的)，即使当网络中存在冗余路径时，分组通常也不会通过路由器循环。(然而，当路由器表被误配置时，分组可能循环，但是如我们在第4 章所知，IP 用一个特殊的报文首部字段来限制循环。)所以，分组就不会被限制到一棵生成树上，并可以使用源和目的地之间的最佳路径。因为路由器没有生成树限制，所以它们允许以丰富的拓扑结构构建因特网，例如包括欧洲和北美之间的多条活跃链路。路由器的另一个特色是它们对第二层的广播风暴提供了防火墙保护。尽管也许路由器最重要的缺点就是它们不是即插即用的，即路由器和连接到它们的主机都需要人为地配置IP 地址。而且路由器对每个分组的处理时间通常比交换机更长，因为它们必须处理高达第三层的字段。</p>
<p>通常，由几百台主机组成的小网络通常有几个局域网网段。对于这些小网络，交换机就足够了，因为它们不要求P 地址的任何配置就能使流量局部化并增加总计吞吐量。但是在由几千台主机组成的更大网络中，通常在网络中(除了交换机之外)还包括路由器。路由器提供了更健壮的流量隔离方式和对广播风暴的控制，并在网络的主机之间使用更“智能的”路由。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e4.png" alt="?"></p>
<h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><p>虚拟局域网(Virtula Local NetworkVLAN)顾名思义，支持 VLAN的交换机允许经一个单一的物理局域网基础设施定义多个虚拟局域网。在一个VLAN内的主机彼此通信，仿佛它们(并且没有其他主机)与交换机连接。在一个基于端口的VLAN中，交换机的端口(接口)由网络管理员划分为组。每个组构成一个VLAN，在每个VLAN中的端口形成一个广播域(即来自一个端口的广播流量仅能到达该组中的其他端口)。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e5.png" alt="?"><br>交换机端口8的用户加人计算机科学系时，网络操作员只需重新配置VLAN软件，使得端口8与CSVLAN相关联即可。<br>网络管理员使用交换机管理软件声明一个端口属于某个给定的VLAN(其中未声明的端口属于一个默认的VLAN)，在交换机中维护一张端口到VLAN的映射表;交换机软件仅在属于相同VLAN的端口之间交付帧。<br>但完全隔离两个 VLAN带来了新的困难!来自电子工程系的流量怎样才能发送到计算机科学系呢?解决这个问题的一种方式是将VLAN交换机的一个端口(例如在图5-25中的端口1)与一台外部的路由器相连，并且将该端口配置为属于EE VLAN和CSVLAN。</p>
<p>跨越物理建立vlan<br>一种容易的解决方案是在每台交换机上定义一个属于CS VALN的端口(对EEVLAN也类似处理)，并且如图5-26a 所示将这两个端口彼此互联起来。然而，这种解决方案不具有扩展性，因为在每台交换机上N个VLAN将要求N个端口直接互联这两台交换机。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e6.png" alt="?"><br>-种更具扩展性互联VLAN交换机的方法称为VLAN干线连接(VLANtruking)。在图5-26b所示的VLAN千线方法中，每台交换机上的一个特殊端口(左侧交换机上的端口16，右侧交换机上的端口1)被配置为干线端口，以互联这两台 VLAN交换机。该干线端口属于所有VLAN，发送到任何 VLAN的经过干线链路转发到其他交换机。</p>
<p>但这会引起另外的问题:一个交换机怎样知道到达干线端口的顿属于某个特定的VLAN呢?</p>
<p>IEEE定义了一种扩展的以太网帧格式–802.10，用于跨越VLAN干线的。如图5-27中所示80210由标准以太网顿与加进首部的4字节VLAN标签(VLANtag)组成，而VLAN标签承载着该顿所属的VLAN标识符。VLAN标签由在VLAN千线发送侧的交换机加进顿中，解析后并由在VLAN干线接收侧的交换机删除。VLAN标签自身由一个2字节的标签协议标识符(Tag ProtocolIdentifier，TPID)字段(具有固定的十六进制值81-00)、一个2字节的标签控制信息字段(包含一个12比特的VLAN标识符字段)和一个3比特优先权字段(具有类似于P数据报TOS字段的目的)组成</p>
<h2 id="链路虚拟化-网络作为链路层"><a href="#链路虚拟化-网络作为链路层" class="headerlink" title="链路虚拟化:网络作为链路层"></a>链路虚拟化:网络作为链路层</h2><h3 id="多协议标签交换"><a href="#多协议标签交换" class="headerlink" title="多协议标签交换"></a>多协议标签交换</h3><p>通过采用虚电路网络领域的一个关键概念一,固定长度标签，多协议标签交换 (Mul.tiprotocolLabelSwitching，MPLS)以改善iP路由器的转发速度。其目标是:对于基于固定长度标签和虚电路的技术在不放弃基于目的地IP数据报转发的基础设施的前提下，当可能时通过选择性地标识数据报并允许路由器基于固定长度的标签(而不是目的地P地址)转发数据报来增强其功能重要的是，这些技术与iP协同工作，使用iP寻址和路由选择。</p>
<p>首先考虑由MPLS使能的路由器处理的链路层格式，以此开始学习MPLS。该帧具有一个小的MPLS首部该首部增加到第二层(如以太网)首部和第三层(即IP)首部之间。RFC 3032定义了用于这种链路的MPLS首部的格式;用于ATM和中继网络的首部也定义在其他的RFC文档中。包括在MPLS首部中的字段是:标签(它起着虚电路标识符的作用，我们已经在4.2.1节中讨论过该标识符);3比特的实验字段(保留用于实验);单比特S字段用于指示一系列“成栈”的MPLS首部的结束(我们这里不讨论这个高级主题):以及寿命字段。</p>
<p>一个MPLS加强的顿仅能在两个均为MPLS使能的路由器之间发送。(因为一个非MPLS使能的路由器，当它在期望发现iP首部的地方发现了一个MPLS首部时会相当混淆!)一个MPLS使能的路由器常被称为标签交换路由器(label-switchedrouter)，因为它通过在其转发表中查找MPLS标签，然后立即将数据报传递给适当的输出接口来转发MPLS。因此，MPLS使能的路由器不需要提取目的IP地址和在转发表中执行最长前缀匹配的查找。</p>
<p>但是路由器怎样才能知道它的邻居是否的确是MPLS使能的呢?路由器如何知道哪个标签与给定iP目的地相联系呢?</p>
<p>在图5-29所示的例子中，路由器R1到R4都是MPLS使能的，R5和R6是标准的P路由器。R1向R2和R3通告了它(R1)能够路由到目的地A，并且具有MPLS标签6的接收将要转发到目的地A。路由器 R3已经向路由器 B4通告了它能够路由到目的地A和D分别具有MPLS标签10和12的人将朝着这些目的地交换。路由器R2也向路由器B4通告了它(R2)能够到达目的地A，具有MPLS标签8的接收将朝着A交换。注意到路由器R4现在处于一个到达A且有两个MPLS路径的令人感兴趣的位置上，经接口0具有出MPLS标签10经接口1具有出MPLS标签8。在图5-29中画出的外围部分是IP设备R5R6A和D，它们经过一个MPLS基础设施(MPLS使能路由器R1R2R3和R4)连接在一起这与一个交换局域网或ATM 网络能够将P设备连接到一起的方式十分相似。并且与交换局域网或ATM网络相似，MPLS使能路由器R1到R4完成这些工作时从没有接触分组的IP首部。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/e8.png" alt="?"></p>
<p>MPIS基于标签执行交换，而不必考虑分组的iP地址。然而MPLS 的真正优点和当前对MPIS感兴趣的原因并不在于交换速度的潜在增加，而在于MPLS使能的新的流量管理能力。</p>
<h2 id="数据中心网络"><a href="#数据中心网络" class="headerlink" title="数据中心网络"></a>数据中心网络</h2><p>主机就像是数据中心的工蜂:它们负责提供内容 (例如，网页和视频)，存储邮件和文档，并共同执行大规模分布式计算(例如，为搜索引擎提供分布式索引计算)。数据中心中的主机称为刀片(blade),一般是包括CPU、内存和磁盘存储的商用主机。主机被堆叠在机架上，每个机架一般堆放20~40台刀片。在每一个机架顶部有一台交换机，这台交换机被形象地称为机架顶部 (Top of Rack，TOR) 交换机，它们与机架上的主机互联，并与数据中心中的其他交换机互联。具体来说，机架上的每台主机都有一块与TOR交换机连接的网卡，每台TOR交换机有额外的端口能够与其他TOR交换机连接。尽管目前主机通常有1Gbps 的以太网与其TOR交换机连接，但10Cbps 的连接也许成为标准。每台主机也会分配一个自己的数据中心内部的P地址。</p>
<p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/r1.png" alt="?"></p>
<p>数据中心网络支持两种类型的流量:在外部客户与内部主机之间流动的流量，以及内部主机之间流动的流量。为了处理外部客户与内部主机之间流动的流量，数据中心网络包括了一台或者多台边界路由器(border router)，它们将数据中心网络与公共因特网相连。数据中心网络因此需要将所有机架彼此互联，并将机架与边界路由器连接。图5-30显示了一个数据(datacenternetworkdesign)是互联网络和协议设计的中心网络的例子。数据中心网络设计艺术，该艺术专注于机架彼此连接和与边界路由器相连。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>一个云数据中心，如一个谷歌或者微软的数据中心，能够同时提供诸如搜索、电子邮件和视频应用等许多应用。为了支持来自外部客户的请求，每一个应用都与一个公开可见的IP 地址关联，外部用户向该地址发送其请求并从该地址接收响应。在数据中心内部外部请求首先被定向到一个负载均器 (load balancer)。负载均衡器的任务是向主机分发请求，以主机当前的负载作为函数来在主机之间均衡负载。一个大型的数据中心通常会有几台负载均衡器，每台服务于一组特定的云应用。由于负载均衡器基于分组的目的端口号(第4层)以及目的P地址做决策，因此它们常被称为“第4层交换机”。一旦接收到一个对于特定应用程序的请求，负载均衡器将该请求分发到处理该应用的某一台主机上(该主机可能再调用其他主机的服务来协助处理该请求)。当主机处理完该请求后，向负载均衡器回送响应，再由负载均衡器将其中继发回给外部客户。负载均衡器不仅平衡主机间的工作负载，而且还提供类似NAT的功能，将外部P 地址转换为内部适当主机的IP 地址然后将反方向流向客户的分组按照相反的转换进行处理。这防止客户直接接触主机，从而具有隐藏网络内部结构和防止客户直接与主机交互等安全性益处。</p>
<h3 id="等级体系结构"><a href="#等级体系结构" class="headerlink" title="等级体系结构"></a>等级体系结构</h3><p>对于仅有数千台主机的小型数据中心，一个简单的网络也许就足够了。这种简单网络由一台边界路由器、一台负载均衡器和几十个机架组成，这些机架由单一以太网交换机进行互联。但是当主机规模扩展到几万至几十万的时候，数据中心通常应用路由器和交换机等级结构(hierarchyofrouterandswiteh)</p>
<p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/r1.png" alt="?"></p>
<h2 id="回顾-Web页面请求的历程"><a href="#回顾-Web页面请求的历程" class="headerlink" title="回顾:Web页面请求的历程"></a>回顾:Web页面请求的历程</h2><p>图5-32图示了我们的场景:一名学生 Bob 将他的便携机与学校的以太网交换机相连，下载一个Web页面(比如说<a href="http://www.googlecom/">www.googlecom</a> 主页)。<br>我们假定Bob启动他的便携机，然后将其用一根以太网电缆连接到学校的以太网交换机，交换机又与学校的路由器相连，学校的这台路由器与一个ISP连接,本例中ISP为comcast. net。在本例中，comcast.net为学校提供了DNS服务;所以，DNS服务器驻留在Comcast网络中而不是学校网络中。我们将假设 DHCP服务器运行在路由器中,就像常见情况那样。</p>
<p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/r2.png" alt="?"></p>
<h3 id="准备-DHCP、UDP、IP和以太网"><a href="#准备-DHCP、UDP、IP和以太网" class="headerlink" title="准备:DHCP、UDP、IP和以太网"></a>准备:DHCP、UDP、IP和以太网</h3><p>当Bob首先将其便携机与网络连接时，没有IP地址他就不能做任何事情（例如下载一个Web网页)。所以，Bob的便携机所采取的一个网络相关的动作是运行DHCP协议,以从本地DHCP 服务器获得一个iP地址以及其他信息。</p>
<ol>
<li>Bob便携机上的操作系统生成一个 DHCP请求报文，并将这个报文放<br>人具有目的地端口67(DHCP服务器）和源端口68（DHCP客户）的UDP 报文段,该UDP报文段则被放置在一个具有广播IP目的地地址（255.255. 255.255）和源IP地址0.0.0.0的P数据报中，因为Bob的便携机还不具有一个IP地址。</li>
<li>包含DHCP请求报文的iP数据报则被放置在以太网帧中。该以太网帧具有目的MAC地址FF:FF:FF:FF:FF:FF，使该帧将广播到与交换机连接的所有设备(如果顺利的话也包括 DHCP服务器);该帧的源MAC地址是 Bob便携机的MAC地址00:16: D3: 23:68:8A。</li>
<li>包含 DHCP请求的广播以太网帧是第一个由Bob便携机发送到以太网交换机的帧。该交换机在所有的出端口广播入帧，包括连接到路由器的端口。</li>
<li>路由器在它的具有MAC地址00:22:6B:45:1F的接口接收到该广播以太网帧，该帧中包含 DHCP请求，并且从该以太网帧中抽取出iP数据报。该数据报的广播IP目的地址指示了这个IP数据报应当由在该结点的高层协议处理,因此该数据报的载荷被分解向上到达 UDP,DHCP请求报文从此UDP报文段中抽取出来。此时DHCP服务器有了DHCP请求报文。</li>
<li>我们假设运行在路由器中的 DHCP服务器能够以 CIDR块68.85.2.0/24分配iP地址。所以本例中，在学校内使用的所有iP地址都在Comcast 的地址块中。我们假设DHCP服务器分配地址68.85.2.101给 Bob的便携机。DHCP服务器生成包含这个IP地址以及 DNS服务器的IP地址（68.87.71. 226)、默认网关路由器的IP地址（68.85.2.1）和子网块（68.85.2.0/24)(等价为“网络掩码”）的一个 DHCP ACK 报文。该DHCP报文被放入一个UDP报文段中，UDP报文段被放入一个IP数据报中，iP数据报再被放入一个以太网帧中。这个以太网帧的源MAC 地址是路由器连到归属网络时接口的MAC地址（00:22:6B:45:1F: 1B).目的MAC地址是Bob便携机的MAC地址（00:16:D3:23:68:8A)。</li>
<li>包含 DHCP ACK 的以太网帧由路由器发送给交换机。因为交换机是自学习的,并且先前从 Bob便携机收到(包含 DHCP请求的)以太网帧，所以该交换机知道寻址到00:16:D3:23:68:8A的帧仅从通向Bob便携机的输出端口转发。</li>
<li>Bob便携机接收到包含 DHCP ACK的以太网帧,从该以太网帧中抽取iP数据报,从iP数据报中抽取UDP报文段，从UDP报文段抽取 DHCP ACK报文。Bob的 DHCP客户则记录下它的iP地址和它的 DNS服务器的iP地址。它还在其IP转发表中安装默认网关的地址。Bob便携机将向该默认网关发送目的地址为其子网68.85.2.0/24 以外的所有数据报。此时，Bob便携机已经初始化好它的网络组件,并准备开始处理Web网页获取。</li>
</ol>
<h3 id="仍在准备-DNS-和-ARP"><a href="#仍在准备-DNS-和-ARP" class="headerlink" title="仍在准备:DNS 和 ARP"></a>仍在准备:DNS 和 ARP</h3><p>当Bob将<a href="http://www.google.com的url键入其web浏览器时,他开启了一长串事件,这将导致谷歌主页最终显示在其web浏览器上.bob/">www.google.com的URL键入其Web浏览器时，他开启了一长串事件，这将导致谷歌主页最终显示在其Web浏览器上。Bob</a> 的Web浏览器通过生成一个TCP套接字开始了该过程，套接字用于向<a href="http://www.google.com发送/">www.google.com发送</a> HTTP请求。为了生成该套接字，Bob便携机将需要知道www. google.com的IP地址。使用DNS协议提供这种名字到IP地址的转换服务。</p>
<ol start="8">
<li>Bob便携机上的操作系统因此生成一个DNS 查询报文,将字符串www. google. com放人 DNS报文的问题段中。该DNS报文则放置在一个具有53号（DNS服务器)目的端口的UDP报文段中。该UDP报文段则被放人具有IP目的地址68.87.71. 226(在第5步中 DHCP ACK返回的 DNS服务器地址）和源P地址68.85.2.101的iP数据报中。</li>
<li>Bob便携机则将包含 DNS请求报文的数据报放入一个以太网帧中。该帧将发送(在链路层寻址）到Bob学校网络中的网关路由器。然而，即使Bob便携机经过上述第5步中的DHCP ACK报文知道了学校网关路由器的P地址（68.85.2.1)，但仍不知道该网关路由器的MAC地址。为了获得该网关路由器的MAC地址，Bob便携机将需要使用ARP协议。</li>
<li>Bob便携机生成一个具有目的iP地址68.85.2.1（默认网关)的 ARP 查询报文，将该ARP报文放置在一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧交付给所有连接的设备，包括网关路由器。</li>
<li>网关路由器在通往学校网络的接口上接收到包含该ARP查间报文的帧，发现在ARP报文中目标iP地址68.85.2.1匹配其接口的地址。网关路由器因此准备一个 ARP回答，指示它的MAC地址00:22:6B:45:1F:1B对应IP地址68.85.2.1。它将ARP回答放在一个以太网帧中，其目的地址为00:16:D3:23:68:8A (bob使携饥)，开同父泱饥尺达该桢,再由交换机将帧交付给Bob便携机。</li>
<li>Bob便携机接收包含ARP回答报文的帧，并从ARP回答报文中抽取网关路由器的 MAC地址（00: 22:6B:45:1F:1B）。</li>
<li>Bob便携机现在能够使包含DNS查询的以太网帧寻址到网关路由器的MAC地址。注意到在该帧中的iP数据报具有IP目的地址68.87.71. 226(DNS服务器)，而该帧具有目的地址00:22:6B:45:1F:1B(网关路由器)<br>Bob便携机向交换机发送该帧,交换机将该帧交付给网关路由器。</li>
</ol>
<h3 id="仍在准备-域内路由选择到-DNS-服务器"><a href="#仍在准备-域内路由选择到-DNS-服务器" class="headerlink" title="仍在准备:域内路由选择到 DNS 服务器"></a>仍在准备:域内路由选择到 DNS 服务器</h3><ol start="14">
<li>网关路由器接收该帧并抽取包含 DNS查询的IP数据报路由器查找该数据报的目的地址（68.87.71.226),并根据其转发表决定该数据报应当发送到图5-32的 Comcast网络中最左边的路由器。IP数据报放置在链路层帧中，该链路适合将学校路由器连接到最左边 Comcast路由器，并且该帧经这条链路发送。</li>
<li>在 Comcast 网络中最左边的路由器接收到该帧，抽取IP数据报,检查该数据报的目的地址（68.87.71.226)，并根据其转发表确定出接口，经过该接口朝着 DNS服务器转发数据报，而转发表已根据Comcast 的域内协议（如RIP、OSPF 或IS-IS)以及因特网的域间协议BGP 所填写。</li>
<li>最终包含 DNS查询的IP数据报到达了 DNS 服务器。DNS服务器抽取出 DNS查询报文，在它的 DNS数据库中查找名字www. google. com ，找到包含对应www. google. com的iP地址（64.233.169.105）的 DNS 源记录。（假设它当前缓存在 DNS服务器中。）前面讲过这种缓存数据源于google.com 的权威DNS服务器。该DNS服务器形成了一个包含这种主机名到iP地址映射的 DNS回答报文，将该 DNS回答报文放入UDP报文段中，该报文段放入寻址到Bob便携机（68.85.2.101）的P数据报中。该数据报将通过Comcast网络反向转发到学校的路由器，并从这里经过以太网交换机到Bob便携机。</li>
<li>Bob便携机从 DNS报文抽取出服务器www. google.com的IP地址。最终，在大量工作后，Bob便携机此时准备接触 www. google. com服务器!</li>
</ol>
<h3 id="Web-客户-服务器交互-TCP和-HTTP"><a href="#Web-客户-服务器交互-TCP和-HTTP" class="headerlink" title="Web 客户-服务器交互:TCP和 HTTP"></a>Web 客户-服务器交互:TCP和 HTTP</h3><ol start="18">
<li>既然Bob便携机有了<a href="http://www.google.com的ip地址,它能够生成tcp套接字,该套接字将用于向/">www.google.com的iP地址，它能够生成TCP套接字,该套接字将用于向</a> <a href="http://www.google.com发送http/">www.google.com发送HTTP</a> GET 报文。当 Bob生成<br>TCP套接字时，在Bob便携机中的TCP必须首先与<a href="http://www.google.com中的tcp执行三次握手.bob便携机因此首先生成一个具有目的端口80(针对http的)的tcp/">www.google.com中的TCP执行三次握手。Bob便携机因此首先生成一个具有目的端口80（针对HTTP的)的TCP</a> SYN报文段，将该TCP报文段放置在具有目的iP地址64.233.169.105(www. google.com）的IP数据报中，将该数据报放置在MAC地址为00:22:6B:45:1F:1B(网关路由器）的帧中,并向交换机发送该帧。</li>
<li>在学校网络、Comcast网络和谷歌网络中的路由器朝着www. google. com 转发包含TCP SYN 的数据报，使用每台路由器中的转发表,如前面步骤14~16那样。前面讲过支配分组经Comcast 和谷歌网络之间域间链路转发的路由器转发表项，是由BGP协议决定的。</li>
<li>最终，包含TCP SYN 的数据报到达 www. googole.com。从数据报抽取出TCP SYN报文并分解到与端口80相联系的欢迎套接字。对于谷歌HTTP服务器和Bob便携机之间的TCP连接生成一个连接套接字。产生一个TCP SYNACK报文段,将其放入向Bob便携机寻址的一个数据报中，最后放入链路层帧中，该链路适合将<a href="http://www.google/">www.google</a>. com 连接到其第一跳路由器。</li>
<li>包含 TCP SYNACK 报文段的数据报通过谷歌、Comcas<br>和学校网络,最终到达Bob便携机的以太网卡。数据报在操作系统中分解到步骤18生成的TCP套接字，从而进入连接状态。</li>
<li>借助于Bob便携机上的套接字，现在（最终!)准备向<a href="http://www.google.com/">www.google.com</a> 发送字节了，Bob 的浏览器生成包含要获取的URL 的HTTP CET报文。HTTP GET 报文则写入套接字，其中 GET报文成为一个TCP报文段的载荷。该TCP报文段放置进一个数据报中，并交付到www. google.com，如前面步骤18～20所述。</li>
<li>在<a href="http://www.google.com的/">www.google.com的</a> HTTP服务器从TCP套接字读取 HTTP GET 报文，生成一个HTTP响应报文，将请求的Web页内容放入HTTP响应体中，并将报文发送进TCP套接字中。</li>
<li>包含 HTTP回答报文的数据报通过谷歌、Comcast和学校网络转发，到达Bob便携机。Bob 的 Web浏览器程序从套接字读取HTTP响应，从HT<br>响应体中抽取Web 网页的html，并终于（最终!)显示了 Web 网页。</li>
</ol>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol start="2">
<li><p>如果在因特网中的所有链路都提供可靠的交付服务，TCP可靠传输服务将是多余的吗?为什么?</p>
<blockquote>
<p>基本是多余的。<br>TCP可靠交付是多余的，拥塞控制是基于统计丢包的，也失去效果了。流量控制还有些用处。</p>
</blockquote>
</li>
<li><p>链路层协议能够向网络层提供哪些可能的服务?在这些链路层服务中，哪些在iP中有对应的服务哪些在TCP中有对应的服务?</p>
<blockquote>
<p>可能提供的服务有：成帧，链路接入，可靠交付，差错检测和纠正<br>IP对应的服务：IP数据报，数据报交付<br>TCP对应的服务：TCP报文段，可靠交付，差错检测</p>
</blockquote>
</li>
<li><p>假设<strong>两个结点同时</strong>经一个速率为R的广播信道开始传输一个长度为L的分组。用dp表示这两个结点之间的传播时延。如果dp&lt;L/R，会出现碰撞吗?为什么?</p>
<blockquote>
<p>会，节点还没有传输结束，就检测到别的结点的传输信号了。</p>
</blockquote>
</li>
<li><p>我们列出了广播信道的4种希望的特性。这些特性中的哪些是时隙 ALOHA 所具有的?令牌传递具有这些特性中的哪些?</p>
<blockquote>
<p>仅有一个结点发送时有R的吞吐量。<br>M个结点同时发送时，每个结点的吞吐量为R/M<br>协议是分散的，不会因为某个结点故障而崩溃。<br>协议简单，实现不昂贵。<br>时隙ALOHA有： 1，3，4<br>令牌传递有： 1，2，4</p>
</blockquote>
</li>
<li><p>在CSMA/CD中在第5次碰撞后，结点选择K=4的概率有多大?结果K=4在10Mbps以太网上对应于多少秒的时延?</p>
<blockquote>
<p>1/32的概率。<br>时延为4 * 5.12 * 10 = 204.8μs</p>
</blockquote>
</li>
</ol>
<p><strong>100Mbps以太网来说为5.12微秒</strong> 书上翻译错了</p>
<ol start="7">
<li><p>使用人类在鸡尾酒会交瓦的类比来描述轮询和令牌传递协议。</p>
<blockquote>
<p>轮询协议：有一个主持人，依次询问每个与会人员是否要发言，并且控制每个人的最长发言时间。<br>令牌传递协议：有一个话筒在每个与会人员之间传递，如果有人要发言则拿起话筒发言，不发言则传递给下一位与会人员。</p>
</blockquote>
</li>
<li><p>如果局域网有很大的周长时，为什么令牌环协议将是低效的?</p>
<blockquote>
<p>因为如果需要发送的结点很少时，也需要固定每次循环一圈。而循环的时间很长，造成低效。</p>
</blockquote>
</li>
<li><p>MAC地址空间有多大?IP4的地址空间呢?IP6的地址空间呢?</p>
<blockquote>
<p>MAC地址空间：2^48<br>IPV4地址空间：2^32<br>IPV6地址空间：2^128</p>
</blockquote>
</li>
<li><p>假设结点A、B和C(通过它们的适配器)都连接到同一个广播局域网上。如果A向B发送数千个IP数据报，每个封装帧都有B的MAC地址，C的适配器会处理这些吗?如果会，C的适配器将会把这些帧中的IP数据报传递给C的网络层吗?如果A用MAC广播地址来发送这些，你的回答将有怎样的变化呢?</p>
<blockquote>
<p>C 的适配器会处理A发送的帧但不会传递给C的网络层；若用广播地址则 C的适配器会接收A发送的帧且传递给C的网络层。</p>
</blockquote>
</li>
<li><p>ARP查询为什么要在广播中发送呢?ARP 响应为什么要在一个具有特定目的MAC地址的中发送呢?</p>
<blockquote>
<p>ARP查询因为不清楚的MAC地址，链路层不知道应该送往哪里。<br>ARP响应因为清楚目标主机的MAC地址，因此不需要广播。</p>
</blockquote>
</li>
<li><p>对于图5-19中的网络，路由器有两个ARP模块，每个都有自己的ARP表。同样的MAC地址可能在两张表中都出现吗?<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/w9.png" alt="?"></p>
</li>
</ol>
<p><strong>路由器中有多个ARP表，每个接口都有一个ARP表。因此，如果路由器有多个接口，它就会有多个ARP表。</strong></p>
<blockquote>
<p>会把。。。</p>
</blockquote>
<ol start="13">
<li><p>比较10BASE-T、100BASE-T和吉比特以太网的帧结构。它们有什么不同吗?</p>
<blockquote>
<p>帧格式相同。</p>
</blockquote>
</li>
<li><p>考虑图5-15。在4.4节的寻址意义下，有多少个子网呢?</p>
<blockquote>
<p>1个子网(路由器划分子网，所有的主机交换机都在一根链路)</p>
</blockquote>
</li>
<li><p>在一个支持802.1Q协议交机上能够配置的VLAN的最大数量是多少?</p>
<blockquote>
<p>2^12个<br>IEEE 802.1Q是一个中继标准，802.1Q修改原始的以太网帧，插入4字节字段，通过这个字段标识带有VLAN 成员信息的以太帧。 由于标准规定用于标示VLAN ID的位置只有12bit，2的12次方=4096 也就是说最大4K个vlan</p>
</blockquote>
</li>
<li><p>假设支持K个VLAN组的N台交换机经过一个线协议连接起来。连接这些交换机需要多少端口?评价你的答案。</p>
<blockquote>
<p>互相连接，最少需要2N-2个端口。</p>
</blockquote>
</li>
</ol>
<h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><ol>
<li>假设某分组的信息内容是比特模式1110011010011101，并且使用了偶校验方案。在采用二维奇偶校验方案的情况下，包含该检验比特的字段的值是什么?你的回答应该使用最小长度检验和字段。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t1.png" alt="?"></li>
</ol>
<p><strong>第i+j+1位是一定可以被满足的</strong></p>
<ol start="2">
<li><p>说明(举一个不同于图5-5中那个的例子) 二维奇偶校验能够纠正和检测单比特差错。说明(举一个例子)某些双比特差错能够被检测但不能纠正。<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t2.png" alt="?"></p>
</li>
<li><p>考虑5比特生成多项式，G=10011，并且假设D的值为1010101010。R的值是什么?</p>
<blockquote>
<p>r的位数等于G-1，D=D拼接R位0，进行模二不进位运算得r=0100</p>
</blockquote>
</li>
<li><p>考虑上一个习题，这时假设D具有值:<br>a. 1001010101<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t5.jpg" alt="?"><br>b. 0101101010<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t4.jpg" alt="?"><br>c. 1010100000<br><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t3.jpg" alt="?"></p>
</li>
<li><p>在这道习题中，我们探讨CRC的某些性质。对于在5.2.3 节中给出的生成多项式G(=1001)，回答下列问题:<br>a.为什么它能够检测数据D中的任何单比特差错?</p>
<blockquote>
<p>因为如果发生任意单比特差错，生成多项式变无法整除，因此可以检测到。<br>b.上述G能够检测任何奇数比特差错吗?为什么?<br>对此题而言，一个关键点是：G 能被 11（二进制）整除，但任意奇数比特差错都不能整除11，因此也不能整除 G，所以可以检测出奇数比特差错。</p>
</blockquote>
</li>
<li><p>如图5-33所示，考虑通过两台路由器互联的3个局域网。</p>
</li>
</ol>
<p>a. 对所有的接口分配IP地址。对子网1使用形式为192.168.1.xxx的地址对子网2使用形式为1921682xx的地址，对子网3使用形式为1921683x的地址。</p>
<blockquote>
<p>A 192.168.1.1<br>B 192.168.1.2<br>左路由左接口 192.168.1.3<br>C 192.168.2.1<br>D 192.168.2.2<br>左路由右接口 192.168.2.3<br>右路由左接口 192.168.2.4<br>E 192.168.3.1<br>F 192.168.3.2<br>右路由右接口 192.168.3.3</p>
</blockquote>
<p>b. 为所有的适配器分配MAC地址。</p>
<blockquote>
<p>A 01-01-01-01-01-01<br>B 02-02-02-02-02-02<br>左路由左接口 03-03-03-03-03-03<br>C 04-04-04-04-04-04<br>D 05-05-05-05-05-05<br>左路由右接口 06-06-06-06-06-06<br>右路由左接口 07-07-07-07-07-07<br>E 08-08-08-08-08-08<br>F 09-09-09-09-09-09<br>右路由右接口 0A-0A-0A-0A-0A-0A</p>
</blockquote>
<p>c. 考虑从主机E向主机B发送一个IP 数据报。假设所有的ARP 表都是最新的。就像在5.4.1节中对单路由器例子所做的那样，列举出所有步骤。</p>
<blockquote>
<p>主机E通过子网掩码发现是去别的网段的，首先查询转发表，且向ARP表查询右路由右接口IP地址对应的MAC地址（查网关），向右路由右接口发送数据报。<br>到达右路由右接口后，通过路由器的转发到右路由左接口。<br>右路由左接口向ARP表查询左路由右接口IP地址对应的MAC地址（发现是直链网络，找mac），向左路由右接口发送数据报。<br>到达左路由右接口后，通过路由器的转发到左路由左接口。<br>右路由左接口向ARP表查询主机BIP地址对应的MAC地址，向主机B发送数据报。<br>主机B收到数据报，提取处报文内容向上层传递。</p>
</blockquote>
<p>d. 重复(c)，现在假设在发送主机中的ARP表为空(并且其他表都是最新的)。</p>
<blockquote>
<p>主机E首先查询转发表，知道应该向右路由右接口IP地址发送数据包，但是没有该IP地址的MAC地址，于是发送ARP广播查询报文。<br>主机E收到查询报文后，可以构造一个数据报发送给右路由右接口。</p>
</blockquote>
<p><img src="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%94%E7%AB%A0%E9%93%BE%E8%B7%AF%E5%B1%82/t6.png" alt="?"></p>
<ol start="15">
<li>考虑图5-33。现在我们用一台交换机代替子网1和子网2之间的路由器，并且将子网2和子网3之间的路由器标记为R1。<br>a. 考虑从主机E向主机F发送一个IP数据报。主机E将请求路由器RI帮助转发该数据报吗?为什么?在包含P数据报的以太网帧中，源和目的P和MAC地址分别是什么?<blockquote>
<p>主机E不请求路由器R1帮助转发该数据报。<br>源IP地址：192.168.3.1<br>目的IP地址：192.168.3.2<br>源MAC地址：08-08-08-08-08-08<br>目的MAC地址：09-09-09-09-09-09</p>
</blockquote>
</li>
</ol>
<p>b.假定E希望向B发送一个IP数据报，假设E的ARP缓存中不包含B的MAC地址。E将执行ARP查询来发现B的MAC地址吗?为什么?在交付给路由器R1的以太网帧(包含发向B的IP数据报)中，源和目的IP和MAC地址分别是什么?</p>
<blockquote>
<p>E不执行ARP协议来发现B的MAC地址。因为E和B并不在一个局域网中。<br>源IP地址：192.168.3.1<br>目的IP地址：192.168.1.2（目的ip）<br>源MAC地址：08-08-08-08-08-08<br>目的MAC地址：0A-0A-0A-0A-0A-0A(网关的mac)</p>
</blockquote>
<p>c.假定主机A希望向主机B发送一个IP数据报，A的ARP缓存不包含B的MAC地址，B的ARP缓存也不包含A的MAC地址。进一步假定交换机S1的转发表仅包含主机B和路由器RI的表项。因此，A将广播一个ARP请求报文。<br>一旦交换机S1收到ARP请求报文将执行什么动作?</p>
<blockquote>
<p>①交换机 S1 将通过其两个接口广播以太网帧，因为接收到的 ARP 帧的目标地址是广播地址。 它了解到 A 通过 S1 面向子网 1 的接口，连接到 S1 上，并且 S1 将更新其转发表，以包含主机 A 的条目。</p>
</blockquote>
<p>路由器RI也会收到这个ARP请求报文吗? 如果收到的话。R将向子网3转发该报文吗?</p>
<blockquote>
<p>②是的，路由器 R1 也接收这个 ARP 请求消息，但是 R1 不会将消息转发到子网 3。</p>
</blockquote>
<p>一但B收到这个ARP请求报文，它将向主机A回发一个ARP响应报文。但是它将发送一个ARP查询报文来请求A的MAC地址吗?为什么?</p>
<blockquote>
<p>③B 不会发送 ARP 查询消息来要求 A 的 MAC 地址，因为这个地址可以从 A的查询消息中获得。之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。</p>
</blockquote>
<p>一旦交换机SI收到来自主机B的一个ARP 响应报文，它将做什么?</p>
<blockquote>
<p>④一旦交换机 S1 接收到 B 的响应消息，它将在其转发表中为主机 B 添加一个条目，然后将接收到的帧删除，因为目标主机 A 与主机 B 在同一接口上(即 A 和 B 在同一局域网段上)。【注意 A 的帧中是广播 MAC 地址，S1 收到帧后是不会阻断广播帧的广播的，因此①中 S1 会通过两个接口转发，而在④中 S1 收到的帧目的地址明确是 A 的 MAC 地址，因此1 不会转发到右边</p>
</blockquote>
<ol start="17">
<li>前面讲过，使用CSMA/CD协议，适配器在碰撞之后等待K·512比特时间，其中K是随机选取的。对于K=100对于一个10Mbps的广播信道，适配器返回到第二步要等多长时间?对于100Mbps的广播信道来说呢?<blockquote>
<p>10Mbps的信道： 51.2μs * 100 = 5.12ms<br>100Mbps的信道： 5.12μs * 100 = 512μs</p>
</blockquote>
</li>
</ol>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>人生不止有技术</title>
    <url>/2023/06/03/%E4%BA%BA%E7%94%9F%E4%B8%8D%E6%AD%A2%E6%9C%89%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="如果你非常好奇，请与我联系。" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="e845ab3a0fd03e3d26c8d36ecbf293acae42838bf485931ce6058482b484caa5">a01f057783bd7cb174eae584024014527fcd8d3df0c56927e0f8d20de73354fc0950b187dad363fb3334b52690645a919446f5d8a5410c549d6986b01fdcda5581f908ec60f0e5656e20947a8dc2b5d6aac609121533990668bdea0fbd82b5deb06866a4cda73e4267c348b7115f6b3ea9d3598bb54d7e46cfe6d96d50c4e626a1cb12da3eb1d78e6f734b5ce877240f87681c830ada4ab36cdbdf2d692d9c74b0186626b833189be4ec1bf0ed7224251771380a0298a74d64f22c97740387e30a5640ead2f3b721d363058367383d3a61f25c298b9ef884538a342e51f8ed9b2c28d015ae77901a1030388b69339660bc93126e454b0ef6bb03cbdc2cd1ad7ebe6e921adc519fe7295d15a73cad664e87fac481830f516d3aff2986e2cd5af725c04115e4fb5d2ee09aff1e78fe6804a3d7debddedb6ec1eae9cb1ac227f23ff2de0a8d4f7c5745d562c5b5c81f9bfb529d6762fcffa5ddb6dc3ece99536a83c40e2bbc7be76ab58619837cd66c410de138f7af9434f3dcaabeece6b963af856c7faa6e066ae5956792f6648945adc5</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络各层网络设备</title>
    <url>/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
  </entry>
  <entry>
    <title>计算机网络-第四章网络层</title>
    <url>/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>与运输层和应用层不同的是，在网络中的每一台主机和路由器中都有一个网络层部分。</p>
<p><strong>在本章中，我们将对网络层的转发（forwarding）功能和路由选择（routing)功能做重要区分。转发涉及分组在单一的路由器中从一条入链路到一条出链路的传送。路由选择涉及一个网络的所有路由器，它们经路由选择协议共同交互，以决定分组从源到目的地结点所采用的路径。</strong></p>
<p>为了加深对分组转发的理解，我们将“进入”路由器内部来观察它的硬件体系结构和组织。接下来我们将观察在因特网中的分组转发，以及令人称颂的网际协议（P)。我们将研究网络层编址和 IPv4的数据报格式。然后我们将探讨网络地址转换（NAT)、数据报分段、因特网控制报文协议（ICMP) 和IPv6。</p>
<p>然后我们将注意力转向网络层的路由选择功能。我们将看到路由选择算法的任务是决定从发送方到接收方的好的路径（等价地为路由)。我们将首先学习路由选择算法的理论，关注两种最为流行的算法类型:链路状态和距离矢量算法。因为路由选择算法的复杂性随着网络路由器数量的增加会有相当大的增长，因此我们也会关注等级制路由选择方法。当我们涉及因特网的自治系统内部的路由选择协议（RIP OSPF 和IS-IS）)和因特网的自治系统之间的路由选择协议（BGP） 时，我们将看到理论是如何付诸实践的。最后我们讨论广播和多播路由选择。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>假设H1正在向H2发送信息,H1中的网络层取得来自于H1运输层的报文段，将每个报文段封装成一个数据报(即一个网络层的分组)，然后将该数据报向相邻路由器R1发送。在接收方主机H2，网络层接收来自相邻路由器R2的数据报，提取出运输层报文段，并将其向上交付给H2的运输层。</p>
<p>路由器的主要作用便是将数据报从入链路转发到出链路。注意到图4-1中所示路由器具有截断的协议栈，即没有网络层以上的部分，因为（除了控制目的外)<strong>路由器不运行我们在第2、3章学习过的应用层和运输层协议</strong>。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/1.1.png" alt="?"></p>
<h3 id="转发和路由选择"><a href="#转发和路由选择" class="headerlink" title="转发和路由选择"></a>转发和路由选择</h3><p>网络层的作用从表面上看极为简单，即将分组从台发送主机移动到一台接收主机。为此,需要两种重要的网络层功能:</p>
<p><strong>转发。</strong> 当一个分组到达路由器的一条输入链路时，路由器必须将该分组移动到适当的输出链路。例如，来自主机H1到路由器R1的一个分组，必须向在H2路径上的下一台路由器转发.</p>
<p><strong>路由选择。</strong> 当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法被称为路由选择算法（routing algorithm)。例如,一个路由选择算法将决定分组从到H流动所遵循的路径。</p>
<p><strong>转发是指数据包从一个接口进入路由器，并通过另一个接口离开路由器的过程。路由选择是指路由器在转发数据包时选择哪一个接口作为出口的过程。</strong> 在路由选择过程中，路由器会根据路由表中的路由信息和网络拓扑结构来选择最佳的路径，以确保数据包能够快速、准确地到达目的地。转发和路由选择是路由器的两个基本功能，它们共同构成了路由器的核心技术。</p>
<p>每台路由器具有一张转发表 （forwarding table)。路由器通过检查到达分组首部字段的值来转发分组，然后使用该值在该路由器的转发表中索引查询。存储在转发表项中的该首部的值指出了该分组将被转发的路由器的输出链路接口。分组首部中的该值可能是该分组的目的地址或该分组所属连接的指示，这取决于网络层协议。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/1.2.png" alt="?"></p>
<p>路由选择算法可能是集中式的（例如，算法在某个中心场点执行，并向每台路由器下载路由选择信息)，或是分布式的（即，使用运行在每台路由器上的分布式路由选择算法的一部分)。</p>
<p>分组交换机和路由器。分组交换机是一种通用的设备，根据分组首部字段中的值，从输入链路接口到输出链路接口转移分组。<strong>而路由器是一种特殊的分组交换机</strong>，基于网络层字段中的值做转发决定。需要注意的是，市场销售将<strong>具有以太网接口的路由器称为“三层交换机”</strong>，但实际上它们是三层设备，混淆了相关概念。因此，为了避免混淆，本章中使用术语路由器代替分组交换机。在谈论虚电路网络中的分组交换机时，也将使用词汇路由器。</p>
<p>我们刚才说过网络层有两个重要的功能，转发和路由选择。但我们很快将看到在某些计算机网络中，实际上有第三种重要的网络功能，即连接建立（connection setup)。</p>
<h3 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h3><p>其他的网络体系结构已定义和实现了许多超过<strong>因特网的尽力而为服务的服务模型。</strong><br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/1.3.png" alt="?"></p>
<p>恒定比特率（Constant Bit Rate，CBR）ATM网络服务这是第一个被标准化的ATM 服务模型，它反映了电话公司对 ATM的早期兴趣以及 CBR 服务在承载实时、恒定比特率的音频和视频流量方面的适用性。使用CBR服务，ATM 信元流以如下方式被承载跨越网络，即一个信元的端到端时延、信元端到端时延中的可变性（即时延抖动)及丢失或推迟交付的信元的比率都确保在特定值以下。</p>
<p>可用比特率(Available Bit Rate, ABR)ATM网络服务。与因特网服务模型一样，ABR 服务下的信元也许会丢失,然而与因特网不同的是,信元不能被重排序（虽然它们可能丢失)，对于使用ABR 服务的连接来说，最小信元传输速率（MCR)是可以得到保证的。如果在给定时间内网络有足够的空闲资源，发送方也可以用比 MCR更高的速率成功地发送数据。</p>
<h2 id="虚电路和数据报网络"><a href="#虚电路和数据报网络" class="headerlink" title="虚电路和数据报网络"></a>虚电路和数据报网络</h2><p><strong>网络层也能够在两台主机之间提供无连接服务或连接服务。</strong> 网络层的连接和无连接服务在许多方面与运输层的面向连接和无连接服务类似。例如，网络层连接服务以源和目的主机间的握手开始;网络层无连接服务则没有任何握手预备步骤。</p>
<p>尽管网络层连接和无连接服务与运输层面向连接和无连接服务有类似之处，但也存在重大差异:</p>
<ol>
<li><p>在网络层中，这些服务是由网络层向运输层提供的主机到主机的服务。在运输层中，这些服务则是运输层向应用层提供的进程到进程的服务。</p>
</li>
<li><p>在至今为止的所有主要的计算机网络体系结构中（因特网、ATM、帧中继等)，网络层或者提供了主机到主机的无连接服务，或者提供了主机到主机的连接服务,而不同时提供这两种服务。仅在网络层提供连接服务的计算机网络称为虚电路(Virtual-Circuit, VC）网络;仅在网络层提供无连接服务的计算机网络称为数据报网络（datagram network)。</p>
</li>
<li><p>在运输层实现面向连接的服务与在网络层实现连接服务是根本不同的。我们在前面一章看到，运输层面向连接服务是在位于网络边缘的端系统中实现的;我们很快看到，网络层连接服务除了在端系统中，也在位于网络核心的路由器中实现。</p>
</li>
</ol>
<h3 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h3><p><strong>虽然因特网是一个数据报网络，但许多其他网络体系结构（包括ATM、帧中继的体系结构）却是虚电路网络</strong>,因此在网络层使用连接。这些网络层连接被称为虚电路。</p>
<p>一条虚电路的组成如下:<br>①源和目的主机之间的路径（即一系列链路和路由器);<br>②VC号，沿着该路径的每段链路的一个号码;<br>③沿着该路径的每台路由器中的转发表表项。<br>属于一条虚电路的分组将在它的首部携带一个VC号。因为一条虚电路在每条链路上可能具有不同的VC号，每台中间路由器必须用一个新的VC号替代每个传输分组的VC号。该新的VC号从转发表获得。</p>
<p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/1.4.png" alt="?"><br>假定该网络为该虚电路选择路径A-R1-R2-B并为这条路径上的这3条链路分配VC号12、22和 32。在这种情况下,当在这条虚电路中的分组离开主机A时,在该分组首部中的VC字段的值是12;当它离开R1时，该值是22，而当它离开R2时,该值是32。</p>
<p><strong>在虚电路网络中，该网络的路由器必须为进行中的连接维持连接状态信息（connec-tion state information)。特别是，每当跨越一台路由器创建一个新连接，必须在该路由器的转发表中增加一个新的连接项;每当释放一个连接，必须从该表中删除该项。值得注意的是，即使没有VC号转换，仍有必要维持连接状态信息，该信息将 VC号与输出接口号联系起来。</strong></p>
<p>在虚电路中有3个明显不同的阶段:<br><strong>虚电路建立</strong>。在建立阶段，发送运输层与网络层联系，指定接收方地址，等待网络建立虚电路。网络层决定发送方与接收方之间的路径，即该虚电路的所有分组要通过的一系列链路与路由器。网络层也为沿着该路径的每条链路决定一个 VC号。最后，网络层在沿着路径的每台路由器的转发表中增加一个表项。在虚电路建立期间，网络层还可以预留该虚电路路径上的资源（如带宽)。</p>
<p><strong>数据传送</strong>。如图4-4中所示，一旦创建了虚电路，分组就可以开始沿该虚电路流动了。</p>
<p><strong>虚电路拆除</strong>。当发送方（或接收方）通知网络层它希望终止该虚电路时，就启动这个阶段。然后网络层通常将通知网络另一侧的端系统结束呼叫，并更新路径上每台分组路由器中的转发表以表明该虚电路已不存在了</p>
<p><strong>运输层的连接建立仅涉及两个端系统。在运输层的连接建立期间，两个端系统独自决定运输层连接的参数(如初始序号与流量控制窗口长度)。虽然这两个端系统已经知道该运输层连接，但网络中的路由器则对这些完全不知情。<br>对于一个虚电路网络层，沿两个端系统之间路径上的路由器都要参与虚电路的建立，且每台路由器都完全知道经过它的所有虚电路.</strong><br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/1.5.png" alt="?"></p>
<p>端系统向网络发送指示虚电路启动与终止的报文。以及路由器之间传递的用于建立虚电路（即修改路由器表中的连接状态）的报文，它们被称为信令报文（signaling mes-sage)，用来交换这些报文的协议常称为信令协议（signaling protocol)。</p>
<h3 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h3><p>在数据报网络中，每当一个端系统要发送分组，它就为该分组加上目的端系统的地址，然后将分组推进网络中。无需建立任何虚电路，路由器不维护任何虚电路的状态信息(因为没有虚电路!)。<br>当分组从源到目的地传输，它通过一系列路由器传递。这些路由器中的每台都使用分组的目的地址来转发该分组。每台路由器有一个将目的地址映射到链路接口的转发表;当分组到达路由器时，路由器使用该分组的目的地址在转发表中查找适当的输出链路接口。然后路由器有意将分组向该输出链路接口转发<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/2.1.png" alt="?"></p>
<p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/2.2.png" alt="?"></p>
<h4 id="前缀匹配"><a href="#前缀匹配" class="headerlink" title="前缀匹配"></a>前缀匹配</h4><p>使用这种风格的转发表，路由器用分组的目的地址的前缀（prefix）与该表中的表项进行匹配:如果存在一个匹配项，则路由器向与该匹配项相联系的链路转发分组。如果一个前缀不匹配前3项中的任何一项，则路由器向链路接口3转发该分组。</p>
<p>一个目的地址可能与不止一个表项相匹配。例如，地址11001000 00010111 00010000 10101010的前24比特与表中的第二项匹配，而该地址的前21比特与表中的第三项匹配。当有多个匹配时，该路由器使用最长前缀匹配规则（longestprefix matching rule);即在该表中寻找最长的匹配项,并向与最长前缀匹配相关联的链路接口转发分组。</p>
<h4 id="更新转发表"><a href="#更新转发表" class="headerlink" title="更新转发表"></a>更新转发表</h4><p>虽然在数据报网络中的路由器不维持连接状态信息,但它们在其转发表中维持了转发状态信息。然而，转发状态信息表变化的时间尺度相对要慢。在数据报网络中的转发表是通过路由选择算法进行修改的，这通常每1~5分钟左右更新一次转发表。</p>
<p>在虚电路网络中，无论何时通过路由器建立一条新的连接，或无论何时通过路由器拆除一条现有的连接，路由器中的转发表就被更新。对一台第一层主干路由器而言，这很容易以微秒的时间尺度进行更新。</p>
<h3 id="虚电路和数据报网络的由来"><a href="#虚电路和数据报网络的由来" class="headerlink" title="虚电路和数据报网络的由来"></a>虚电路和数据报网络的由来</h3><p>虚电路的概念来源于电话界，它采用了真正的电路。由于呼叫建立及每呼叫的状态要在网络中的路由器上维持，一个面向虚电路的网络显然比数据报网络要复杂得多。</p>
<p>因特网作为一种数据报网络，是由将计算机连接在一起的需求发展而来的。由于端系统设备复杂得多，因特网架构师们选择使网络层服务模型尽可能简单。另外的功能（例如,按序传送，可靠数据传输、拥塞控制与 DNS名字解析)在端系统中的更高层实现。这正好与电话网模型相反。</p>
<p>由于所产生的因特网服务模型使服务保证最少，它对网络层施加了最小限度的需求。这使得互联使用各种不同链路层技术而且具有十分不同的传输速率和丢包特性的网络变得更加容易。这些链路层技术包括卫星、以太网、光纤或无线。</p>
<p>诸如电子邮件、Web 等应用，甚至如 DNS 这样的网络基础设施都是在位于网络边缘的主机（服务器）上实现的。增加一个新服务只需连接一台主机到网络中，并定义一个新的应用层协议（如HTTP)即可，这种能力可以使如 Web之类的新服务能在相当短的时间内在因特网上得以部署。</p>
<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><p>网络层的转发功能(forwarding function)，即实际将分组从一台路由器的入链路传送到适当的出链路。</p>
<p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/3.1.png" alt="?"><br><strong>输入端口：</strong> 输入端口执行几项关键功能。它要执行将一条输入的物理链路与路由器相连接的物理层功能,这显示在图4-6中输入端部分最左侧的方框与输出端口部分最右侧的方框中。</p>
<p>它还要执行需要与位于入链路远端的数据链路层交互的数据链路层功能，这表示在输入与输出端口部分的中间方框中。</p>
<p>也许更为重要的是，在输入端口还要完成查找功能，这显示在输入端口最右侧的方框中。正是在这里，通过查询转发表决定路由器的输出端口，到达的分组通过路由器的交换结构将转发到输出端口。控制分组（如携带路由选择协议信息的分组）从输入端口转发到路由选择处理器。注意这里的端口一词，是指路由器的物理输入和输出接口，这完全不同于网络应用程序和套接字相联系的软件端口。</p>
<p><strong>交换结构：</strong> 交换结构将路由器的输入端口与输出端口相连接。这种交换结构完全包含在路由器中,即它是一个网络路由器中的网络!</p>
<p><strong>输出端口：</strong> 输出端口存储从交换结构接收的分组，并通过执行必要的链路层和物理层功能在输入链路上传输这些分组。当一条链路是双向的（即承载两个方问的流量)时，输出端口通常是与该链路的输入端口在同一线路卡上成对出现的。</p>
<p><strong>路由选择处理器：</strong> 路由选择处理器执行路由选择协议,维护路由选择表以及连接的链路状态信息,并为路由器计算转发表。它还执行网络管理功能.</p>
<p>一台路由器的输入端口、输出端口和交换结构共同实现了这种转发功能，并且总是用硬件实现。这些转发功能有时总称为路由器转发平面（router forwarding plane)。</p>
<p>当转发平面以纳秒时间尺度运行时，路由器的控制功能（即执行路由选择协议、对上线或下线的连接链路进行响应，管理功能)，在毫秒或秒时间尺度上运行。这些路由器控制平面 （router control plane）通常用软件实现并在路由选择处理器上执行(通常是一种传统的CPU)。</p>
<h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3><p>输入端口的线路端接功能与链路层处理实现了用于各个输入链路的物理层和链路层。在输入端口中执行的查找对于路由器的运行是至关重要的。正是在这个地方,路由器使用转发表来查找输出端口，使得到达的分组将能经过交换结构转发到该输出端口。</p>
<p>转发表是由路由选择处理器计算和更新的，但转发表的一份影子副本通常会被存放在每个输入端口。转发表从路由选择处理器经过独立总线（例如一个 PCI总线）复制到线路卡,在图4-6中该总线由从路由选择处理器到输入线路卡的虚线所指示。有了影子副本，转发决策能在每个输入端口本地做出,无须调用中央路由选择处理器，因此避免了集中式处理的瓶颈。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/3.2.png" alt="?"></p>
<p>假定转发表已经存在，从概念上讲表查找是简单的，即我们只是搜索转发表查找最长前缀匹配。一旦通过查找确定了某分组的输出端口，则该分组就能够发送进入交换结构。在某些设计中，如果来自其他输人端口的分组当前正在使用该交换结构，一个分组可能会在进入交换结构时被暂时阻塞。因此，一个被阻塞的分组必须要在输入端口处排队,并等待稍后被及时调度以通过交换结构。</p>
<p>尽管“查找”在输入端口处理中可以说是最为重要的动作，但必须采取许多其他动作:<br>①必须出现物理层和链路层处理;<br>②必须检查分组的版本号、检验和以及寿命字段，并且重写后两个字段<br>③必须更新用于网络管理的计数器（如接收到的iP数据报的数目)。</p>
<h3 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h3><p>交换结构位于一台路由器的核心部位。正是通过这种交换结构，分组才能实际地从一个输入端口交换(即转发)到一个输出端口中。交换可以用许多方式完成。</p>
<h4 id="三种交换技术"><a href="#三种交换技术" class="headerlink" title="三种交换技术"></a>三种交换技术</h4><p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/3.3.png" alt="?"></p>
<h4 id="经内存交换"><a href="#经内存交换" class="headerlink" title="经内存交换"></a>经内存交换</h4><p>最简单、最早的路由器是传统的计算机在输入端口与输出端口之间的交换是在CPU(路由选择处理器）的直接控制下完成的。输入与输出端口的功能就像在传统操作系统中的I/O设备一样。一个分组到达一个输入端口时，该端口会先通过中断方式向路由选择处理器发出信号。于是，该分组从输入端口处被复制到处理器内存中。路由选择处理器则从其首部中提取目的地址,在转发表中找出适当的输出端口，并将该分组复制到输出端口的缓存中。<br>许多现代路由器通过内存进行交换。然而，与早期路由器的一个主要差别是，目的地址的查找和将分组存储（交换)进适当的内存存储位置是由输入线路卡来处理的。在某些方面，经内存交换的路由器看起来很像共享内存的多处理机，用一个线路卡上的处理将分组交换（写)进适当的输出端口的内存中。</p>
<h4 id="经总线交换"><a href="#经总线交换" class="headerlink" title="经总线交换"></a>经总线交换</h4><p>在这种方法中，输入端口经一根共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预。通常按以下方式完成该任务:让输入端口为分组预先计划一个交换机内部标签（首部)，指示本地输出端口，使分组在总线上传送和传输到输出端口。该分组能由所有输出端口收到,但只有与该标签匹配的端口才能保存该分组。然后标签在输出端口被去除，因为其仅用于交换机内部来跨越总线。如果多个分组同时到达路由器每个位于不同的输出端口，除了一个分组外所有其他分组必须等待，因为一次只有一个分组能够跨越总线。因为每个分组必须跨过单一总线，故路由器的交换带宽受总线速率的限制;在我们环状交叉路的类比中，这相当于环状交叉路一次仅包含一辆汽车。尽管如此，对于运行在小型局域网和企业网中的路由器来说，通过总线交换通常是足够的。</p>
<h4 id="经互联网络交换"><a href="#经互联网络交换" class="headerlink" title="经互联网络交换"></a>经互联网络交换</h4><p>克服单一、共享式总线带宽限制的一种方法是，使用一个更复杂的互联网络，例如过去在多处理器计算机体系结构中用来互联多个处理器的网络。纵横式交换机就是一种由2N条总线组成的互联网络，它连接N个输入端口与N个输出端口，如图所示。每条垂直的总线在交叉点与每条水平的总线交叉，交叉点通过交换结构控制器（其逻辑是交换结构自身的一部分）能够在任何时候开启和闭合。当某分组到达端口A ,需要转发到端口Y，交换机控制器闭合总线A和Y交叉部位的交叉点，然后端口A在其总线上发送该分组，该分组仅由总线Y安排接收。注意到来自端口B的一个分组在同一时间能够转发到端口X,因为A到Y和B到X的分组使用不同的输入和输出总线。因此，与前面两种交换方法不同，纵横式网络能够并行转发多个分组。然而，如果来自两个不同输入端口的两个分组其目的地为相同的输出端口，则一个分组必须在输入端等待，因为在某个时刻经给定总线仅有一个分组能够发送。</p>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3><p>输出端口处理取出存放在输出端口内存中的分组并将其发送到输出链路上。这包括选择和取出排队的分组进行传输，执行所需的链路层和物理层传输功能。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/3.4.png" alt="?"></p>
<h3 id="何处出现排队"><a href="#何处出现排队" class="headerlink" title="何处出现排队"></a>何处出现排队</h3><p>路由器排队的原因是因为交换结构比输入输出快，每条线路只能同时输出一个分组，导致路由器需要对收到的分组进行排队，以便逐个输出。</p>
<h3 id="路由选择控制平面"><a href="#路由选择控制平面" class="headerlink" title="路由选择控制平面"></a>路由选择控制平面</h3><p>我们已经隐含地假设路由选择控制平面全部驻留并运行在路由器中的路由选择处理器上。<strong>网络范围的路由选择控制平面因此是分布式的</strong>，即不同部分（例如路由选择算法）执行在不同的路由器上并且通过彼此发送控制报文进行交互。实际上，今天因特网路由器和路由选择算法正是以这种方式运行的。此外，路由器和交换机厂商将它们的硬件数据平面和软件控制平面绑在一起放入封闭（但可互操作）的平台中，成为一种垂直综合的产品。</p>
<h2 id="网际协议-因特网中的转发和编址"><a href="#网际协议-因特网中的转发和编址" class="headerlink" title="网际协议:因特网中的转发和编址"></a>网际协议:因特网中的转发和编址</h2><p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.1.png" alt="?"></p>
<h3 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h3><p>网络层分组被称为数据报<br><strong>IPV4报文</strong><br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.2.png" alt="?"></p>
<p>IPv4数据报中的关键字段如下:<br><strong>版本号</strong>4。这4比特规定了数据报的IP协议版本。通过查看版本号,路由器能够确定如何解释IP数据报的剩余部分。不同的IP版本使用不同的数据报格式。</p>
<p><strong>首部长度</strong>4。因为一个 IPv4 数据报可包含一些可变数量的选项（这些选项包括在IPv4数据报首部中)，故需要用这4比特来确定IP数据报中数据部分实际从哪里开始。大多数iP数据报不包含选项，所以一般的IP数据报具有20字节的首部。</p>
<p><strong>服务类型</strong>8。服务类型（TOS) 比特包含在IPv4首部中，以便使不同类型的iP数据报（例如，一些特别要求低时延、高吞吐量或可靠性的数据报）能相互区别开来。例如，将实时数据报（如用于IP电话应用)与非实时流量（如FTP)区分开也许是有用的。提供特定等级的服务是一个由路由器管理员决定的策略问题。</p>
<p><strong>数据报长度</strong>16。这是IP数据报的总长度（首部加数据)，最长为16比特，所以iP数据报的理论最大长度为65535字节。然而，数据报很少有超过1500字节的。<br><strong>标识、标志、片偏移</strong>16,3,13。这三个字段与所谓IP分片有关。新版本的IP（即IPv6)不允许在路由器上对分组分片。</p>
<p><strong>寿命</strong>8。寿命（Time-To-Live,TTL)字段用来确保数据报不会永远（如由于长时间的路由选择环路）在网络中循环。每当数据报由一台路由器处理时，该字段的值减1。若TTL字段减为0，则该数据报必须丢弃。</p>
<p><strong>协议</strong>8。该字段仅在一个iP数据报到达其最终目的地才会有用。该字段值指示了IP数据报的数据部分应交给哪个特定的运输层协议。例如，值为6表明数据部分要交给TCP,而值为17表明数据要交给UDP。注意在iP数据报中的协议号所起的作用，类似于运输层报文段中端口号字段所起的作用。协议号是将网络层与运输层绑定到一起的粘合剂，而端口号是将运输层和应用层绑定到一起的粘合剂。链路层帧也有一个特殊字段用于将链路层与网络层绑定到一起。</p>
<p><strong>首部检验和</strong>16。首部检验和用于帮助路由器检测收到的IP数据报中的比特错误。</p>
<p>首部检验和是这样计算的:将首部中的每2个字节当作一个数，用反码运算对这些数求和。该和的反码（被称为因特网检验和）存放在检验和字段中。路由器要对每个收到的IP数据报计算其首部检验和，如果数据报首部中携带的检验和与计算得到的检验和不一致，则检测出是个差错。路由器一般会丢弃检测出错误的数据报。注意到在每台路由器上必须重新计算检验和并再次存放到原处,因为TTL字段以及可能的选项字段会改变</p>
<p>此时，一个经常问到的问题是:为什么 TCP/IP在运输层与网络层都执行差错检测?这种重复检测有几种原因。首先，注意到在iP层只对iP首部计算了检验和，而TCP/UDP检验和是对整个TCP/UDP报文段进行的。其次，TCP/UDP与IP不一定都必须属于同一个协议栈。原则上TCP能运行在一个不同的协议（如ATM)上,而IP能够携带不一定要传递给TCP/UDP的数据。</p>
<p><strong>源和目的IP地址</strong>32，32。当某源生成一个数据报时，它在源IP字段中插入它的IP地址，在目的IP地址字段中插入其最终目的地址。通常源主机通过DNS查找来决定目的地址。</p>
<p><strong>选项</strong>？。选项字段允许iP首部被扩展。首部选项意味着很少使用，因此决定对每个数据报首部不包括选项字段中的信息，这样能够节约开销。然而，选项的可能存在的确是件复杂的事，因为数据报头长度可变，故不能预先确定数据字段从何处开始。而且还因为有些数据报要求处理选项，而有些数据报则不要求，故导致一台路由器处理一个IP数据报所需的时间变化很大。这些考虑对于高性能路由器和主机上的iP处理来说特别重要。由于这样或那样的原因，在IPv6首部中已去掉了iP选项。</p>
<p>**数据（有效载荷)**。我们来看看最后的也是最重要的字段，这是数据报存在的首要理由!在大多数情况下，IP数据报中的数据字段包含要交付给目的地的运输层报文段（TCP或UDP)。然而，该数据字段也可承载其他类型的数据，如 ICMP报文。</p>
<p>注意到一个IP数据报有总长为20字节的首部（假设无选项)。如果数据报承载一个TCP报文段，则每个（无分片的） 数据报共承载了总长40字节的首部(20字节的iP首部加上20字节的TCP首部)以及应用层报文。</p>
<h4 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h4><p>并不是所有链路层协议都能承载相同长度的网络层分组。有的协议能承载大数据报,而有的协议只能承载小分组。以太网能句够多承载个超1500字节的数据，而某些广域网链路的帧可承载不超过576字节的数据。一个链路层帧能承载的最大数据量叫做最大传送单元(（Maximum Transmission Unit,MTU)。</p>
<p>当一台目的主机从相同源收到一系列数据报时，它需要确定这些数据报中的某些是否是一些原来较大的数据报的片。如果某些数据报是片的话，则它必须进一步确定何时收到了最后一片，并且如何将这些接收到的片拼接到一起以形成初始的数据报。为了让目的主机执行这些重新组装任务，IPv4的设计者将标识、标志和片偏移字段放在IP数据报首部中。当生成一个数据报时，发送主机在为该数据报设置源和目的地址的同时再贴上标识号。发送主机通常将为它发送的每个数据报的标识号加1。当某路由器需要对一个数据报分片时，形成的每个数据报（即片)具有初始数据报的源地址、目的地址与标识号。当目的地从同一发送主机收到一系列数据报时，它能够检查数据报的标识号以确定哪些数据报实际上是同一较大数据报的片。由于IP是一种不可靠的服务，一个或多个片可能永远到达不了目的地。因为这种原因，为了让目的主机绝对地相信它已收到了初始数据报的最后一个片,最后一个片的标志比特被设为0，而所有其他片的标志比特被设为1。另外，为了让目的主机确定是否丢失了一个片（且能按正确的顺序重新组装片)，使用偏移字段指定该片应放在初始IP数据报的哪个位置。</p>
<p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.3.png" alt="?"><br><strong>除了最后一片的所有初始有效载荷数据的数量应当是8字节的倍数，并且偏移值应当被规定以8字节块为单位。</strong></p>
<p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.4.png" alt="?"></p>
<p>在目的地,数据报的有效载荷仅当在IP层已完全重构为初始IP数据报时，才被传递给目的地运输层。如果一个或多个片没有到达目的地，则该不完整的数据报被丢弃且不会交给运输层。但是，如我们在前一章知道的那样，若在运输层正使用着TCP,则TCP将通过让源以初始数据报来重传数据,以恢复这次丢包。</p>
<h3 id="IPv4-编址"><a href="#IPv4-编址" class="headerlink" title="IPv4 编址"></a>IPv4 编址</h3><h4 id="简述一下主机与路由器连入网络的方法。"><a href="#简述一下主机与路由器连入网络的方法。" class="headerlink" title="简述一下主机与路由器连入网络的方法。"></a>简述一下主机与路由器连入网络的方法。</h4><p>一台主机通常只有一条链路连接到网络;当主机中的iP想发送一个数据报时，它就在该链路上发送。主机与物理链路之间的边界叫做接口 (interface)。现在考虑一台路由器及其接口。因为路由器的任务是从链路上接收数据报并从某些其他链路转发出去，路由器必须拥有两条或更多条链路与它连接。路由器与它的任意一条链路之间的边界也叫做接口。一台路由器因此有多个接口，每个接口有其链路。因为每台主机与路由器都能发送和接收iP数据报，IP要求每台主机和路由器接口拥有自己的IP地址。因此，<strong>一个iP地址技术上是与一个接口相关联的，而不是与包括该接口的主机或路由器相关联的。</strong></p>
<p>每个iP地址长度为32比特（等价为4字节)，因此总共有2^32个可能的iP地址。由于2^10近似地表示10^3，故容易看出约有40亿个可能的IP地址。</p>
<p>这些地址一般按所谓点分十进制记法（dotted- decimal notation)书写，即地址中的每个字节用它的十进制形式书写,各字节间以句号（点）隔开。例如，考虑IP地址193.32.216.9，193是该地址第一个8比特的十进制等价数，32是该地址第二个8比特的十进制等价数，依次类推。</p>
<p>在全球因特网中的每台主机和路由器上的每个接口，必须有一个全球唯一的IP地址(在NAT后面的接口除外)。然而，这些地址不能随意地自由选择。一个接口的iP地址的一部分需要由其连接的子网来决定。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.5.png" alt="?"></p>
<p>用iP的术语来说，互联这3个主机接口与1个路由器接口的网络形成一个子网。(在因特网文献中，子网也称为P网络或直接称为网络。)iP编址为这个子网分配一个地址:223.1.1.0/24,其中的/24记法，有时称为子网掩码（networkmask)，指示了32比特中的最左侧24比特定义了子网地址。因此子网223.1.1.0/24是由3台主机接口（223.1.1.1、223.1.1.2和223.1.1.3）和1个路由器接口(223.1.1.4)组成。任何其他要连到223.1.1.0/24网络的主机都要求其地址具有223.1.1. xxx的形式。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.6.png" alt="?"></p>
<p><strong>特殊的ip:</strong></p>
<ol>
<li>子网号全为0代表本网络</li>
<li>主机号全为0代表本主机</li>
<li>主机号全为1代表广播</li>
<li>127.0.0.1本地回环地址，数据到达本网络层后再传回高层</li>
<li>（1）10.0.0.0——10.255.255.255<br>（2）172.16.0.0——172.31.255.255<br>（3）192.168.0.0——192.168.255.255</li>
</ol>
<p><strong>为了确定子网，分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口端接这些隔离的网络的端点。这些隔离的网络中的每一个都叫做一个子网(subnet)。</strong><br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.7.png" alt="?"></p>
<p>因特网的地址分配策略被称为无类别域间路由选择（Classless Interdomain Routing,CIDR)将子网寻址的概念一般化了。<br>形式为a.b.c.d/x的地址的x最高比特构成了IP地址的网络部分，并且经常被称为该地址的前缀（prefix)（或网络前缀)。一个组织通常被分配一块连续的地址，即具有相同前缀的一段地址。在这种情况下该组织内部的设备的IP地址将共享共同的前缀。</p>
<p>假设该ISP向外界通告，它应该发送所有地址的前20比特与200. 23.16.0/20相符的数据报。外界的其他部分不需要知道在地址块200. 23.16.0/20内实际上还存在其他组织，每个组织有自己的子网。这种使用单个网络前缀通告多个网络的能力通常称为地址聚合 （address aggregation)，也称为路由聚合（route aggregation）或路由摘要（routesummarization)。</p>
<p>一个地址的剩余32-x比特可认为是用于区分该组织内部设备的，其中的所有设备具有相同的网络前缀。当该组织内部的路由器转发分组时，才会考虑这些比特。</p>
<p>这些较低阶比特可能具有另外的子网结构。例如，假设某CIDR化的地址a. b.c.d/21的前21比特定义了该组织的网络前缀，它对该组织中的所有主机的IP地址来说是共同的。其余的11比特标识了该组织内的主机。该组织的内部结构可以采用这样的方式，使用这最右边的11比特在该组织中划分子网，就像前面所讨论的那样。例如，a.b.c.d/24可能表示该组织内的特定子网。</p>
<p><strong>在CIDR被采用之前，IP地址的网络部分被限制为长度为8、16或24比特，这是一种称为分类编址（classful addressing)的编址方案，这是因为具有8、16和24比特子网地址的子网分别被称为A、B和C类网络。按这种方式支持的主机高不成，低不就。</strong></p>
<p>如果还不提及另一种类型的iP地址，即IP广播地址255.255.255.255，那将是我们的不负责任。当一台主机发出一个目的地址为255.255. 255.255的数据报时，该报文会交付给同一个网络中的所有主机。路由器也会有选择地向邻近的子网转发该报文(虽然它们通常不这样做)。</p>
<h4 id="分配ip"><a href="#分配ip" class="headerlink" title="分配ip"></a>分配ip</h4><ol>
<li><p><strong>获取一块地址</strong><br>为了获取一块IP地址用于一个组织的子网，某网络管理员也许首先会与他的ISP联系，该ISP可能会从已分给它的更大地址块中提供一些地址。例如，该ISP也许自己已被分配了地址块200.23.16.0/20。该ISP可以依次将该地址块分成8个长度相等的连续地址块，为本ISP支持的最多达8个组织中的一个分配这些地址块中的一块<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.8.png" alt="?"></p>
</li>
<li><p>获取主机地址:<strong>动态主机配置协议DHCP</strong><br>某组织一旦获得了一块地址，它就可为本组织内的主机与路由器接口逐个分配P地址。系统管理员通常手工配置路由器中的IP地址（常常在远程通过网络管理工具进行配置)。主机地址也能手动配置，但是这项任务目前通常更多的是使用动态主机配置协议(Dynamic Host Configuration,DHCP)来完成。DHCP 允许主机自动获取（被分配）一个iP地址。网络管理员能够配置DHCP,以使某给定主机每次与网络连接时能得到一个相同的iP地址，或者某主机将被分配一个临时的IP地址（temporary IP address),该地址在每次与网络连接时也许是不同的。除了主机P地址分配外，DHCP还允许一台主机得知其他信息，例如它的子网掩码、它的第一跳路由器地址（常称为默认网关）与它的本地DNS服务器的地址.</p>
</li>
</ol>
<p>DHCP是一个客户-服务器协议。客户通常是新达到的主机，它要获得包括自身使用的IP地址在内的网络配置信息。在最简单场合下，每个子网将具有一台 DHCP服务器。如果在某子网中没有服务器则需要一个DHCP 中继代理（通常是一台路由器)，这个代理知道用于该网络的 DHCP服务器的地址。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.9.png" alt="?"></p>
<blockquote>
<p>0.0.0.0是一个特殊的IP地址，表示“任何主机”，在网络中用于广播或路由表中的默认路由。它通常用于DHCP服务器分配IP地址时，表示客户端尚未分配到IP地址。</p>
</blockquote>
<blockquote>
<p>而255.255.255.255是一个广播地址，表示将数据包发送给同一网络中的所有主机。它通常用于ARP协议中，用于请求网络中所有主机的MAC地址。</p>
</blockquote>
<blockquote>
<p>子网号全1也被称为“本地广播地址”，因为它是在本地网络中广播数据包的一种方式。当一个主机发送一个数据包到子网号全1时，该数据包将会在本地网络中传递给所有主机，包括发送者本身。<br>但是，子网号全1并不是一般意义上的广播地址，因为它只在本地网络中有效，而不会被路由到其他网络。而255.255.255.255是全局广播地址，它可以在整个网络中广播数据包，包括跨越多个子网和网络。</p>
</blockquote>
<p>下图中src发送者：dhcp服务器端口67，客户端68<br>dest目标：255，255，255，255广播给所有人<br>yiaddr：服务器分给用户的地址<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.10.png" alt="?"></p>
<p><strong>DHCP服务器发现。</strong>一台新到的主机的首要任务是发现一个要与其交互的 DHCP服务器。这可通过使用一个 DHCP发现报文（DHCP discover message）来完成,客户在UDP分组中向端口67发送该发现报文。但是这个数据报应发给谁呢?主机甚至不知道它所连接网络的P地址，更不用说用于该网络的DHCP服务器地址了。在这种情况下，DHCP客户生成包含DHCP发现报文的IP数据报，其中使用广播目的地址255.255. 255.255并且使用“本主机”源地址0.0.0.0。DHCP客户将该IP数据报传递给链路层，链路层然后将该帧广播到所有与该子网连接的子网</p>
<p><strong>DHCP服务器提供。</strong> DHCP服务器收到一个 DHCP发现报文时，用DHCP提供报文(DHCP offer message）向客户作出响应，仍然使用IP广播。因为在子网中可能有几个DHCP 服务器，客户端会收到这些Offer报文并从中选择一个最合适的DHCP服务器。每台服务器提供的报文包含有收到的发现报文的事务ID、向客户推荐的IP地址、网络掩码以及IP地址租用期（address lease time)，即IP地址有效的时间量。服务器租用期通常设置为几小时或几天 [ Droms 2002]</p>
<p><strong>DHCP请求。</strong>新到达的客户从一个或多个服务器提供中选择一个，并向选中的服务器提供用一个 DHCP 请求报文（DHCP request message）进行响应，回显配置参数。</p>
<p><strong>DHCP ACK。</strong>服务器用 DHCP ACK报文（DHCP ACK message)对DHCP请求报文进行响应,证实所要求的参数。</p>
<ol start="3">
<li><strong>网络地址转换</strong></li>
</ol>
<p>NAT使能路由器对于外部世界来说甚至不像一台路由器。NAT 路由器对外界的行为反过来就如同一个具有单一IP地址的单一设备。在图中，所有离开家庭路由器流向更大因特网的报文都拥有一个源IP地址138.76.29.7，且所有进入家庭的报文都拥有同一个目的IP地址138.76.29.7。</p>
<p>从本质上讲，NAT使能路由器对外界隐藏了家庭网络的细节。路由器从 ISP 的 DHCP服务器得到它的地址，并且路由器运行一个 DHCP服务器，为位于NAT-DHCP 路由器控制的家庭网络地址空间中的计算机提供地址。</p>
<p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.12.png" alt="?"></p>
<p><strong>如果从广域网到达NAT路由器的所有数据报都有相同的目的IP地址</strong>（特别是对 NAT路由器广域网一侧的接口)，那么该路由器怎样知道它应将某个分组转发给哪个内部主机呢?技巧就是使用在NAT路由器上的一张NAT转换表(NAT translation table)，并且在表项中包含了端口号及其IP地址。</p>
<p>如果对等方A不在一个NAT的后面，则该NAT问题能够绕过去。在这种情况下，对等方A能够首先通过一个中间对等方C与对等方B联系，其中C不位于NAT之后并与B已经创建了一条进行中的TCP连接。对等方A则能够经对等方C请求对等方B，发起直接返回对等方A的一条TCP连接。一且对等方A和B之间创建一条直接的P2P TCP连接这两个对等方就能够交换报文或文件。这种雇佣关系被称为连接反转 （connection reversal),实际上被许多P2P应用程序用于NAT 穿越（NAT traversal)。</p>
<p>如果对等方A和对等方B都在它们自己的NAT后面，这种情况有些棘手，但是能够使用应用程序进行中继处理。</p>
<p>(NAT穿越是指在网络中使用了NAT（网络地址转换）技术后，需要通过一些方法实现内部网络中的主机访问外部网络或者外部网络中的主机访问内部网络。这种情况通常发生在企业内部网络或者家庭网络中，因为这些网络中的主机使用的是私有IP地址，而外部网络中的主机使用的是公共IP地址。为了让内部网络中的主机能够访问外部网络或者外部网络中的主机能够访问内部网络，需要使用一些技术，如端口映射、UPnP、STUN、TURN等。这些技术可以帮助内部网络中的主机穿越NAT，实现与外部网络的通信。)</p>
<ol start="4">
<li><strong>UPnP</strong></li>
</ol>
<p>NAT穿越正越来越多地由通用即插即用（UPnP） 提供,UPnP是一种允许主机发现并配置邻近NAT的协议「UPnP Forum 2012],UPnP要求主机和NAT都是UPnP兼容的。使用UPnP,在主机上运行的应用程序能够为某些请求的公共端口号请求一个NAT映射，该映射位于其（专用P地址，专用端口号）和（公共IP地址，公共端口号）之间。如果某NAT接受该请求并生成映射，则来自外部的结点能够发起到（公共IP地址，公共端口号)的TCP 连接。此外，UPnP让该应用程序知道（公共P地址，公共端口号)，因此该应用程序能够向外部世界通告它。</p>
<p><strong>我可以理解为，upnp在nat（局域网路由器）上开放了一个端口，并利用nat的公网通知外网他的地址，外网发送请求后，nat将这个端口的消息转发给我们的主机</strong></p>
<h3 id="因特网控制报文协议-ICMP"><a href="#因特网控制报文协议-ICMP" class="headerlink" title="因特网控制报文协议 ICMP"></a>因特网控制报文协议 ICMP</h3><p>ICMP最典型的用途是差错报告。例如，当运行一个 Telnet、FTP或HTTP会话时，你也许会遇到一些诸如“目的网络不可达”之类的错误报文。这种报文就是在ICMP中产生的。在某个位置，IP路由器不能找到一条路径，以通往Telnet、FTP或HTTP应用所指定的主机。该路由器就会向你的主机创建和发出一个类型3的IGMP 报文以指示该错误。</p>
<p>ICMP通常被认为是P的一部分，但从体系结构上讲它是位于P之上的.因为ICMP报文是承载在P分组中的。这就是说，ICMP报文是作为P有效载荷承载的。</p>
<p>在第1章中我们介绍了Traceroute程序，该程序允许我们跟踪从一台主机到世界上任意一台其他主机之间的路由。有趣的是Traceroute是用 ICMP报文来实现的。为了判断源和目的地之间所有路由器的名字和地址，源主机中的Traceroute向目的主机发送一系列普通的IP数据报。这些数据报的每个携带了具有一个不可达UDP端口号的UDP报文段。第一个数据报的TTL为1,第二个的TTL为2,第三个的TTL为3，依次类推。该源主机也为每个数据报启动定时器。当第n个数据报到达第n台路由器时,第n台路由器观察到这个数据报的TTL正好过期。根据IP协议规则，路由器丢弃该数据报并发送一个 ICMP告警报文给源主机（类型11编码0)。该告警报文包含了路由器的名字与它的IP地址。当该ICMP报文返回源主机时，源主机从定时器得到往返时延，从 ICMP报文中得到第n台路由器的名字与IP地址。</p>
<h3 id="ipv6"><a href="#ipv6" class="headerlink" title="ipv6"></a>ipv6</h3><p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.14.png" alt="?"></p>
<p>扩大的地址容量。IPv6将IP地址长度从32比特增加到128比特。这就确保全世界将不会用尽IP地址。<br>IPv6还引人了一种称为任播地址（anycast address）的新型地址，这种地址可以使数据报交付给一组主机中的任意一个。（例如，这种特性可用于向一组包含给定文档的镜像站点中的最近的一个发送一个 HTTP GET报文。）</p>
<p><strong>版本。</strong> 该4比特字段用于标识IP版本号。毫不奇怪，IPv6将该字段值设为6。注意到将该字段值置为4并不能创建一个合法的IPv4数据报。(如果这样的话，事情就简单多了，参见下面有关从IPv4向IPv6迁移的讨论。)</p>
<p><strong>流量类型。</strong> 该8比特字段与我们在IPv4中看到的TOS字段的含义相似。</p>
<p><strong>流标签。</strong> 该20比特的字段用于标识一条数据报的流。</p>
<p><strong>有效载荷长度</strong>。该16比特值作为一个无符号整数，给出了IPv6数据报中<strong>跟在定长的40字节数据报首部后面</strong>的字节数量。</p>
<p><strong>下一个首部。</strong> 该字段标识数据报中的内容（数据字段)需要交付给哪个协议（如TCP或 UDP）。该字段使用与IPv4首部中协议字段相同的值。</p>
<p><strong>跳限制。</strong> 转发数据报的每台路由器将对该字段的内容减1。如果跳限制计数到达0时，则该数据报将被丢弃。</p>
<p><strong>源地址和目的地址。</strong> IPv6 128比特地址的各种格式在RFC 4291中进行了描述。</p>
<p><strong>数据。</strong> 这是IPv6数据报的有效载荷部分。当数据报到达目的地时，该有效载荷就从P 数据报中移出，并交给在下一个首部字段中指定的协议处理。</p>
<h4 id="从-IPv4到-IPv6的迁移"><a href="#从-IPv4到-IPv6的迁移" class="headerlink" title="从 IPv4到 IPv6的迁移"></a>从 IPv4到 IPv6的迁移</h4><p>引入IPv6使能结点的最直接方式可能是一种双栈(dual- stack）方法，即使用该方法的IPv6结点还具有完整的IPv4实现。这样的结点被称为IPv6/IPv4结点,它有发送和接收IPv4与IPv6两种数据报的能力。当与IPv4结点互操作时，IPv6/IPv4结点可使用IPv4 数据报:当与IPv6结点互操作时，它又能使用IPv6。IPv6/IPv4结点必须具有IPv6与 IPv4 两种地址。此外，它们还必须能确定另个结点是否是IPv6使能的或仅IPv4使能的。这个问题可使用 DNS来解决，若要解析的结点名字是IPv6使能的，则 DNS会返回一个IPv6地址，否则返回一个IPv4地址。当然，如果发出DNS请求的结点是仅IPv4使能的，则DNS 只返回一个IPv4地址。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.15.png" alt="?"></p>
<p>另一种双栈方法，叫做建隧道（tunneling)）。该方法能解决上述问题，允许如E接收源于A的IPv6数据报。隧道依据的基本思想如下:假定两个IPv6结点（如图4-25中的B和E）要使用IPv6数据报进行交互，但它们是经由中间IPv4路由器互联的。我们将两台IPv6路由器之间的中间IPv4路由器的集合称为一个隧道（tunnel),如图4-26所示。借助于隧道，在隧道发送端的IPv6结点（如B)可将整个IPv6数据报放到一个 IP4 数据报的数据（有效载荷）字段中。于是，该IPv4数据报的地址设为指向隧道接收端的IPv6结点（如E)，再发送给隧道中的第一个结点（如C)。隧道中的中间IPv4 路由器在它们之间为该数据报提供路由，就像对待其他数据报一样，完全不知道该IPv4数据报自身就含有一个完整的IPv6数据报。隧道接收端的IPv6结点最终收到该IPv4数据报（它是该IPv4数据报的目的地!)，并确定该IPv4 数据报含有一个 IPv6数据报，于是从中取出IPv6数据报，然后再为该IPv6数据报提供路由，就好像它是从一个直接相连的IPv6邻居那里接收到该IPv6数据的一样。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.16.png" alt="?"></p>
<h3 id="涉足IP安全性"><a href="#涉足IP安全性" class="headerlink" title="涉足IP安全性"></a>涉足IP安全性</h3><p>IPsec已被设计为与 IPv4 和 IPv6向后兼容。特别是，为了享受IPsec带来的好处,我们不需要替换因特网中的所有路由器和主机中的协议栈。例如,使用运输模式（两种IPsec“模式”之一-)时，如果两台主机要安全地通信，IPsec仅需要在这两台主机中可用。所有其他路由器和主机能够继续运行普通的IPv4 。</p>
<p>为了具体起见,我们这里将关注IPsec的运输模式使用这种模式,两台主机首先在它们之间创建一个IPsec 会话。(因此IPsec是面向连接的!）使用适当的会话，在这两台主机之间发送的所有TCP和UDP报文段都享受IPsec提供的安全性服务。在发送端，运输层向IPsec传递一个报文段。IPsec 然后加密该报文段在报文段上添加附加的安全性字段，并且在一个普通的iP数据报中封装得到的有效载荷。(实际中比上述过程要复杂一点，我们将在第8章详细讨论。）发送主机接下来向因特网中发送数据报，因特网则将数据报传送到目的主机。在那里，IPsec解密报文段并将脱密的报文段传送给运输层。</p>
<h3 id="sdn"><a href="#sdn" class="headerlink" title="sdn"></a>sdn</h3><p>SDN是软件定义网络（Software Defined Networking）的缩写，是一种新型的网络架构，它将网络控制平面与数据平面分离，通过中央控制器对网络进行集中管理和控制。SDN的主要思想是将网络控制逻辑从网络设备中分离出来，放在一个中央控制器中，通过控制器来管理整个网络，网络设备只负责数据转发。这样可以使网络更加灵活、可编程、可扩展和可自动化，为网络的管理和运维提供了更加便捷的方式。SDN技术已经被广泛应用于数据中心网络、企业网络、运营商网络等各种场景。</p>
<p>SDN和传统网络架构（也称为传统网络）的最大差异在于网络控制的方式。传统网络通常是集中式的，网络设备（如交换机、路由器）通过自身的逻辑来处理网络流量，网络管理员通过命令行或图形界面来配置和管理网络设备。而SDN采用分离控制和数据平面的方式，将网络控制逻辑从网络设备中分离出来，放在一个中央控制器中，通过控制器来管理整个网络，网络设备只负责数据转发。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/q8.png" alt="?"><br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/q9.png" alt="?"><br>与传统网络相比，SDN有以下优点：</p>
<blockquote>
<ol>
<li><p>灵活性：SDN可以根据需求动态调整网络流量，实现灵活的网络配置和&gt;管理。</p>
</li>
<li><p>可编程性：SDN的中央控制器可以通过编程来实现各种网络功能和服&gt;务，例如负载均衡、安全策略等。</p>
</li>
<li><p>可扩展性：SDN可以轻松地扩展网络规模，支持大规模的网络部署。</p>
</li>
<li><p>可自动化：SDN可以通过自动化技术来实现网络的自动化管理和运维。</p>
</li>
</ol>
<p>相比之下，传统网络的优点在于：</p>
<ol>
<li><p>稳定性：传统网络的集中式控制方式可以保证网络的稳定性和可靠性。</p>
</li>
<li><p>成熟性：传统网络技术已经经过多年的发展和实践，具有成熟的技术和&gt;丰富的经验。</p>
</li>
<li><p>易用性：传统网络的管理方式相对简单，网络管理员可以通过命令行或&gt;图形界面来进行网络配置和管理。</p>
</li>
</ol>
<p>总之，SDN相对于传统网络来说，具有更高的灵活性、可编程性、可扩展性和可自动化性，但在稳定性和易用性方面还需要进一步的发展和完善。</p>
</blockquote>
<h2 id="路由表和转发表"><a href="#路由表和转发表" class="headerlink" title="路由表和转发表"></a>路由表和转发表</h2><p><strong>当一个数据包到达路由器时，路由器会根据目标IP地址查询路由表，找到与该IP地址最匹配的路由表项，并获取下一跳路由器的IP地址。然后，路由器会根据FIB表项查找出与该下一跳IP地址相对应的出接口，从而将数据包转发到正确的接口上，继续向目的地前进。</strong></p>
<p>路由表是告诉路由器数据包该往哪里走，能到哪里；而转发表是告诉路由器数据包怎么走，该从哪个接口转发出去。</p>
<p>假设有以下路由表和转发表：</p>
<p>路由表：</p>
<table>
<thead>
<tr>
<th>目的网络</th>
<th>子网掩码</th>
<th>下一跳路由器</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.1.0</td>
<td>255.255.255.0</td>
<td>192.168.0.1</td>
</tr>
<tr>
<td>192.168.2.0</td>
<td>255.255.255.0</td>
<td>192.168.0.2</td>
</tr>
<tr>
<td>192.168.3.0</td>
<td>255.255.255.0</td>
<td>192.168.0.1</td>
</tr>
<tr>
<td>192.168.4.0</td>
<td>255.255.255.0</td>
<td>192.168.0.3</td>
</tr>
</tbody></table>
<p>转发表：</p>
<table>
<thead>
<tr>
<th>下一跳路由器</th>
<th>出接口</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.0.1</td>
<td>eth0</td>
</tr>
<tr>
<td>192.168.0.2</td>
<td>eth1</td>
</tr>
<tr>
<td>192.168.0.3</td>
<td>eth2</td>
</tr>
</tbody></table>
<p>假设一个数据包的目的IP地址为192.168.3.5，那么路由器会查询路由表，找到192.168.3.0/24对应的路由表项，并获取下一跳路由器的IP地址192.168.0.1。然后，路由器会查询转发表，找到与该下一跳IP地址相对应的出接口eth0，从而将数据包转发到eth0出口，继续向目的地前进。</p>
<h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><p>当分组到达一台路由器时，该路由器索引其转发表并决定该分组被指向的链路接口。我们也知道路由选择算法在网络路由器中运行、交换和计算信息，用这些信息配置这些转发表。</p>
<p>主机通常直接与一台路由器相连接，该路由器即为该主机的默认路由器(default router)又称为该主机的第一跳路由器(rst-hop router)。每当主机发送一个分组时，该分组被传送给它的默认路由器。我们将源主机的默认路由器称作源路由器(sourcerouter)，把目的主机的默认路由器称作目的路由器 (destination router)。一个分组从源主机到目的主机的路由选择问题显然可归结为从源路由器到目的路由器的路由选择问题。</p>
<p>路由选择算法的目的是简单的:给定一组路由器以及连接路由器的链路，路由选择算法要找到一条从源路由器到目的路由器的“好”路径。可以用图来形式化描述路由选择问题。我们知道图(graph)G=(N，E)是一个N个结点和E条边的集合，其中每条边是取自N的一对结点。在网络层路由选择的环境中，图中的结点表示路由器，这是做出分组转发决定的点;连接这些结点的边表示这些路由器之间的物理链路。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.17.png" alt="?"></p>
<p>在图抽象中为各条边指派了费用后，<strong>路由选择算法的自然目标是找出从源到目的地间的最低费用路径。</strong></p>
<h3 id="路由选择算法分类："><a href="#路由选择算法分类：" class="headerlink" title="路由选择算法分类："></a>路由选择算法分类：</h3><p><strong>根据该算法是全局式的还是分散式区分。</strong><br>全局式路由选择算法(globalroutingalgorithm)用完整的、全局性的网络知识计算出从源到目的地之间的最低费用路径。也就是说，该算法以所有结点之间的连通性及所有链路的费用为输入。这就要求该算法在真正开始计算以前，要以某种方式获得这些信息。计算本身可在某个场点(集中式全局路由选择算法)进行，或可在多个场点重复进行。然而这里的主要区别在于，全局式算法具有关于连通性和链路费用方面的完整信息。实践中，具有全局状态信息的算法常被称作链路状态(LinkState，LS)算法，因为该算法必须知道网络中每条链路的费用。</p>
<p>分散式路由选择算法(decentralized routingalgorithm)以选代、分布式的方式计算出最低费用路径。没有结点拥有关于所有网络链路费用的完整信息，而每个结点仅有与其直接相连链路的费用知识即可开始工作。然后，通过迭代计算过程并与相邻结点(即与该结点相连链路的另一端的结点)交换信息，一个结点逐渐计算出到达某目的结点或一组目的结点的最低费用路径。距离向量(Distance-VectorDV)算法的分散式路由选择算法。之所以叫做DV算法，是因为每个结点维护到网络中所有其他结点的费用(距离)估计的向量。</p>
<p><strong>根据算法是静态的还是动态的进行分类。</strong><br>在静态路由选择算法(static routing algorithm)中，随着时间的流，路由的变化是非常缓慢的，通常是人工干预进行调整(如人为手工编辑一台路由器的转发表)。动态路由选择算法(dynamicroutingalgorithm)能够当网络流量负载或拓扑发生变化时改变路由选择路径一个动态算法可周期性地运行或直接响应拓扑或链路费用的变化而运行。虽然动态算法易于对网络的变化做出反应，但也更容易受诸如路由选择循环、路由振荡之类问题的影响。</p>
<p><strong>根据它是负载敏感的还是负载迟钝的进行划分。</strong><br>在负载敏感算法(load-sensitivealgorithm)中链路费用会动态地变化以反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路与高费用相联系，则路由选择算法趋向于绕开该拥塞链路来选择路由。而早期的ARPAnet 路由选择算法就是负载敏感的，所以遇到了许多难题[Huitema 1998]。当今的因特网路由选择算法(如RIPOSPF和BGP)都是负载迟钝的(load-insensitive)，因为某条链路的费用不明显地反映其当前(或最近)的拥塞水平。</p>
<h3 id="链路状态路由选择算法（LS算法-全局式路由选择算法）"><a href="#链路状态路由选择算法（LS算法-全局式路由选择算法）" class="headerlink" title="链路状态路由选择算法（LS算法  全局式路由选择算法）"></a>链路状态路由选择算法（LS算法  全局式路由选择算法）</h3><p>在链路状态算法中，网络拓扑和所有的链路费用都是已知的，也就是说可用作LS算法的输人。<strong>实践中这是通过让每个结点向网络中所有其他结点广播链路状态分组来完成的</strong> ，其中每个链路状态分组包含它所连接的链路的特征和费用。在实践中(例如使用因特网的OSPF路由选择协议），这经常由链路状态广播(likstatebroadcast)算法[Perlman 1999]来完成。<br><strong>结果是所有结点具有了该网络的等同的、完整的视图。于是每个结点都能够像其他结点一样，运行LS算法并计算出相同的最低费用路径集合。</strong></p>
<p>运用迪杰斯特拉算法得<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.18.png" alt="?"><br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.19.png" alt="?"></p>
<p>该算法的计算复杂性是什么?即给定n个结点(不算源结点)，在最坏情况下要经过多少次计算，才能找到从源结点到所有目的结点的最低费用路径?在第一次迭代中，我们需要搜索所有的n个结点以确定出结点w-w不在N中且具有最低费用。在第二次迭代时，我们需要检查n-1个结点以确定最低费用。第三次对n-2个结点迭代，依次类推。总之，我们在所有迭代中需要搜寻的结点总数为n(n+1)/2，因此我们说前面实现的链路状态算法在最差情况下复杂性为0(n)。</p>
<h3 id="距离向量路由选择算法-DV"><a href="#距离向量路由选择算法-DV" class="headerlink" title="距离向量路由选择算法 (DV)"></a>距离向量路由选择算法 (DV)</h3><p>距离向量(Distance-Vector，DV)算法是一种迭代的、异步的和分布式的算法，而LS算法是一种使用全局信息的算法。说它是分布式的，是因为每个结点都要从一个或多个直接相连邻居接收某些信息，执行计算，然后将其计算结果分发给邻居。说它是迭代的，是因为此过程一直要持续到邻居之间无更多信息要交换为止。(有趣的是，此算法是自我终止的，即没有计算应该停止的信号，它就停止了。) 说它是异步的，是因为它不要求所有结点相互之间步伐一致地操作。</p>
<p>前面讲过LS算法是一种全局算法，在于它要求每个结点在运行 Dijkstra算法之前，首先获得该网络的完整信息。DV算法是分布式的，它不使用这样的全局信息。实际上，结点具有的唯一信息是它到直接相连邻居的链路费用和它从这些邻居接收到的信息。每个结点等待来自任何邻居的更新（第10～11行)，当接收到一个更新时计算它的新距离向量（第14行)并向它的邻居分布其新距离向量(第16~17行)。许多类似DV 的算法在实践中被用于多种路由选择协议中,包括因特网的RIP和 BGP、ISO IDRP Novell IPX和早期的 ARPAnet。</p>
<p><strong>涉及到动态规划，暂时跳过。。。</strong></p>
<h4 id="层次路由选择"><a href="#层次路由选择" class="headerlink" title="层次路由选择"></a>层次路由选择</h4><p><strong>规模。</strong> 随着路由器数目变得很大，涉及路由选择信息的计算、存储及通信（例如LS更新或最低费用路径的变化)的开销将高得不可实现。当今的公共因特网由数亿台主机组成。在这些主机中存储的路由选择信息显然需要巨大容量的内存。在公共因特网上的所有路由器中广播IS更新所需的开销将导致没有剩余的带宽用来发送数据分组!在如此大量的路由器中迭代的距离向量算法将肯定永远无法收敛!显然，必须采取一些措施以减少公共因特网这种大网络中的路由选择计算的复杂性。</p>
<p><strong>管理自治。</strong> 虽然研究人员倾向于忽略这样的问题，如某公司要求按自己的意愿运行路由器（如运行其选择的某种路由选择算法)，或对外部隐藏其网络的内部组织面貌，但这些都是需要考虑的重要因素。在理想情况下，一个组织应当能够按自己的愿望运行和管理其网络，还要能将其网络与其他外部网络相连接。</p>
<p>这两个问题都可以通过将路由器组织进自治系统（Autonomous System, AS）来解决,每个 AS 由一组通常处在相同管理控制下的路由器组成<br>(例如，由相同的ISP运营或属于相同的公司网络)。<strong>在相同的AS 中的路由器都全部运行同样的路由选择算法</strong>（如一种LS或DV算法)，且拥有彼此的信息。在一个自治系统内运行的路由选择算法叫做自治系统内部路由选择协议（intra - autonomoussystem routing protocol)。当然，将AS彼此互联是必需的，因此在一个AS内的一台或多台路由器将有另外的任务，即<strong>负责向在本AS之外的目的地转发分组。这些路由器被称为网关路由器</strong></p>
<p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/q1.png" alt="?"><br>同时注意到路由器1b、1c、2a和3a都是网关路由器。</p>
<p><strong>选择合适的网关</strong><br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/q2.png" alt="?"></p>
<p>DV（Distance Vector）和LS（Link State）是两种不同的路由选择算法，RIP和OSPF则是基于这两种算法设计的路由选择协议。</p>
<p>RIP（Routing Information Protocol）是一种基于DV算法的距离矢量路由选择协议，它使用跳数（hop count）作为路径选择的度量标准。</p>
<p>OSPF（Open Shortest Path First）是一种基于LS算法的链路状态路由选择协议，它使用链路状态信息来计算最短路径，并支持多种度量标准。</p>
<p>因此，可以说RIP和OSPF是基于不同路由选择算法设计的路由选择协议，RIP使用DV算法，而OSPF使用LS算法。同时，DV和LS也可以用来设计其他路由选择协议，例如BGP（Border Gateway Protocol）就是一种基于LS算法的路径矢量路由选择协议。</p>
<h2 id="因特网中的路由选择"><a href="#因特网中的路由选择" class="headerlink" title="因特网中的路由选择"></a>因特网中的路由选择</h2><p>路由选择协议的任务就是要确定数据报在源与目的地之间采用的路径。<br>一个AS是一个处于相同的管理与技术控制下的路由器的集合在AS之间都运行相同的路由选择协议。每个AS通常又都包含多个子网。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/q7.png" alt="?"></p>
<h3 id="因特网中自治系统内部的路由选择-RIP"><a href="#因特网中自治系统内部的路由选择-RIP" class="headerlink" title="因特网中自治系统内部的路由选择:RIP"></a>因特网中自治系统内部的路由选择:RIP</h3><p>AS内部路由选择协议用于确定在一个AS内执行路由选择的方式。AS内部路由选择协议又称为内部网关协议(interior gateway protocol)。历史上有两个路由选择协议曾被广泛用于因特网上自治系统内的路由选择:路由选择信息协议(RoutingInformation ProtocolRIP)与开放最短路优先(Open Shortest Path FirstOSPF)。与0SPP密切相关的路由选择协议是IS-IS协议。</p>
<p>RIP是一种距离向量协议，其运行方式很像理想化DV协议。<br>RIP版本使用跳数作为其费用测度即每条链路的费用为1。RIP使用术语跳，跳是沿着从源路由器到目的子网(包括目的子网)的最短路径所经过的子网数量。</p>
<p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/q3.png" alt="?"></p>
<p>1条路径的最大费用被限制为15，因此RIP的使用限制在网络直径不超过15跳的自治系统内。在RIP中路由选择更新信息在邻居之间通过使用一种RIP响应报文(RIPreponsemessage)来交换，大约每30秒相互交换一次。由一台路由器或主机发出的响应报文包含了一个该AS内的多达25个目的子网的列表，以及发送方到其中每个子网的距离。响应报文又被称作RIP通告(RIPadvertisement)。</p>
<p><strong>每台路由器维护一张称为路由选择表(routingtable)的RIP表。一台路由器的路由选择表包括该路由器的距离向量和该路由器的转发表。</strong><br>图显示了路由器D的转发表注意到该转发表有3列。第一列用于目的子网，第二列指示了沿着最短路径到目的子网的下一个路由器的标识，第三列指出了沿着最短路径到目的子网的跳数(即需要穿越的子网数，包括目的子网)。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.20.png" alt="?"></p>
<p>30秒后互相通告更新<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/4.21.png" alt="?"></p>
<p>RIP路由器大约每30秒相互交互通告。如果一台路由器一旦超过180秒没有从邻居听到报文，则该邻居不再被认为是可达的;即要么其邻居死机了，要么连接的链路中断了。当这种情况发生时，RIP 修改本地路由选择表，然后通过向相邻路由器(那些仍然可达的路由器) 发送通告来传播该信息。</p>
<p>路由器也可通过使用RIP 请求报文，请求其邻居到指定目的地的费用。路由器在 UDP上使用端口520相发送RIP请求与响应报文。封装在标准iP数据报中的UDP报文段在路器之间传输。RIP使用一个位于网络层协议(IP)之上的运输层协议(UDP)来实现网络层功能(一种路由选择算法)</p>
<p>RIP在一个UNIX系统中通常是如何实现的?<br>例如一台用作路由器的UNIX工作站。一个称为routed的进程执行RIP，即维护路由选择信息并与相邻路由器中的routed进程交换报文。因为RIP是被当作一个应用层进程来实现的(虽然它是一个能操作UNIX 内核中的转发表的特殊进程)，它能在一个标准套接字上发送和接收报文并且使用一个标准的运输层协议。如显示的那样，RIP 是一个运行在UDP上的应用层协议(参见第2章)。</p>
<p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/q4.png" alt="?"></p>
<h3 id="因特网中自治系统内部的路由选择-OSPF"><a href="#因特网中自治系统内部的路由选择-OSPF" class="headerlink" title="因特网中自治系统内部的路由选择:OSPF"></a>因特网中自治系统内部的路由选择:OSPF</h3><p>OSPF和它的关系密切的表兄弟IS-S通常都设置在上层的ISP中，而RIP却被设置在下层ISP和企业网中。</p>
<p>OSPF的核心就是一个使用洪泛链路状态信息的链路状态协议和一个 Dikstra 最低费用路径算法。使用OSPF一台路由器构建了一幅关于整个自治系统的完整拓扑图 (即一个图)。于是，路由器在本地运行Diikstra的最短路径算法，以确定一个以自身为根结点的到所有子网的最短路径树各条链路费用是由网络管理员配置的。管理员也许会选择将所有链路费用设为1，因而实现了最少跳数路由选择，或者可能会选择将链路权值按与链路容量成反比来设置，从而不鼓励流量使用低带宽链路。</p>
<p>使用OSPF时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每当一条链路的状态发生变化时(如费用的变化或连接/中断状态的变化)，路由器就会广播链路状态信息。即使链路状态未发生变化，它也要周期性地(至少每隔30分钟一次)广播链路状态。</p>
<p>OSPF报文直接由IP承载。对OSPF其上层协议的值为89。因OSPF协议必须自己实现诸如可靠报文传输、链路状态广播等功能。OSPF协议还要检查链路正在运行(通过向相连的邻居发送HELLO报文)，并允许OSPF路由器获得相邻路由器的网络范围链路状态的数据库。</p>
<h3 id="自治系统间的路由选择-BGP"><a href="#自治系统间的路由选择-BGP" class="headerlink" title="自治系统间的路由选择:BGP"></a>自治系统间的路由选择:BGP</h3><p>BGP为每个AS提供了进行以下工作的手段:<br>1)从相邻AS处获得子网可达性信息。<br>2)向本AS内部的所有路由器传播这些可达性信息。<br>3)基于可达性信息和AS策略，决定到达子网的“好”路由。</p>
<h4 id="bgp基础"><a href="#bgp基础" class="headerlink" title="bgp基础"></a>bgp基础</h4><p>在BGP中，路由器对通过使用179端口的半永久TCP连接来交换路由选择信息。对于每条直接连接位于两个不同的AS中的路由器的链路而言，通常有一条这样的BGP TCP连接。</p>
<p>对于每条TCP连接，位于该连接端点的两台路由器称为BGP对等方(BCPpeers)，沿着该连接发送所有BGP报文的TCP连接称为BGP会话(BGP session)。此外跨越两个AS的BGP会话称为外部BGP(eBGP)会话(external BGP session)，在同一个AS中的两台路由器之间的BCP会话称为内部BGP(BGP)会话(internal BGP session)。在图4-40中eBGP会话显示为长虚线，iBGP会话显示为短虚线。<br>ebcp(tcp连接) ibgp（半tcp连接）<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/q5.png" alt="?"></p>
<blockquote>
<p>假设开了一个公司，要配置网络</p>
</blockquote>
<ol>
<li>接入本地isp，获得ip分配</li>
<li>和因特网注册机构签约，设置域名，dns</li>
<li>设置dns，写入服务器地址</li>
<li>本地isp使用bgp传播你的地址</li>
</ol>
<p>BGP使得每个AS知道经过其相邻AS可达哪些目的地。<strong>在BGP中，目的地不是主机而是CDIR化的前缀(prefix)，每个前缀表示一个子网或一个子网的集合。</strong></p>
<p>因此，例如假定有4个子网与AS2相连:138.16.64/24，138.1665/24，13816.66/24和138.1667/24则AS2能为这4个子网聚合这些前缀，并使用BGP向AS1通告单一前缀1381664/22。<br>举另一个例子，假定这4个子网中的前3个在AS2中第四个子网1381667/24位于AS3中，因为路由器使用最长前缀匹配来转发数据报，所以AS3向AS1通告更特定的前缀13816.67/24而AS2仍然AS1通告聚合的前缀138.1664/22。</p>
<p>as之间通过ebgp来传递不同as的前缀，as之内通过ibgp传递别的as的前缀，然后一直重复，as之间就互相知道前缀了</p>
<p>当一台路由器(网关或不是网关) 得知一个新前缀时，它为该前缀在其转发表中创建一个项.</p>
<h4 id="路径属性和BGP路由"><a href="#路径属性和BGP路由" class="headerlink" title="路径属性和BGP路由"></a>路径属性和BGP路由</h4><p>在BGP中，一个自治系统由其全局唯一的自治系统号(Autonomous System Number，ASN)所标识。</p>
<p>当一台路由器通过BGP会话通告一个前缀时，它在前缀中包括一些BGP属性(BGPattribute)。用BGP术语来说，带有属性的前缀被称为一条路由(route)。因此，BGP对等方彼此通告路由。两个较为重要的属性是AS-PATH和NEXT-HOP。</p>
<p>AS-PATH。该属性包含了前缀的通告已经通过的那些AS。当一个前缀传送到一个AS时该AS将它的ASN增加到AS-PATH属性中。路由器使用该AS-PATH属性来检测和防止循环通告特别是如果一台路由器看到它的AS被包括在该路径列表中，它将拒绝该通告。</p>
<p>NEXT-HOP。 没看。。。</p>
<h4 id="BGP-路由选择"><a href="#BGP-路由选择" class="headerlink" title="BGP 路由选择"></a>BGP 路由选择</h4><p>路由器可能知道到达任何一条前缀的多条路由，在这种情况下路由器必须在可能的路由中选择一条。进入这个路由选择进程的输入是被路由器知道并接受的所有路由的集合。如果对相同前缀存在两条或多条路由，则 BGP顺序地调用下列消除规则，直到留下一条路由。</p>
<blockquote>
<p>路由被指派一个本地偏好值作为它们的属性之一。一条路由的本地偏好可能由该路由器设置或可能由在相同AS中的另一台路由器学习到。这是一条由AS的网络管理员决定的决策。(我们随后将更为详细地讨论BGP 策略问题。)具有最高本地偏好值的路由将被选择。</p>
</blockquote>
<blockquote>
<p>在余下的路由中（所有都具有相同的本地偏好值)，具有最短AS-PATH的路由将被选择。如果该规则是路由选择的唯一规则的话，则BGP将使用一种距离向量算法来决定路径，其中距离测度使用AS跳的数目而不是路由器跳的数目。</p>
</blockquote>
<blockquote>
<p>在余下的路由中（所有都具有相同的本地偏好和相同的AS- PATH长度)，将选择具有最靠近NEXT- HOP路由器的路由。这里，最靠近是指具有最低费用路径的费用的路由器，它由 AS内部算法来决定。如在4.5.3节中所讨论的那样，该进程经常被称为热土豆路由选择。</p>
</blockquote>
<blockquote>
<p>如果仍留下多条路由，该路由器使用BGP标识符来选择路由。</p>
</blockquote>
<p>IBGP（Interior Border Gateway Protocol，内部边界网关协议）和OSPF（Open Shortest Path First，开放式最短路径优先）都是AS（自治系统）内的路由协议，但是它们有以下区别：</p>
<blockquote>
<ol>
<li><p>网络拓扑类型：IBGP适用于较大的AS网络，可以跨越多个自治系统，而&gt;OSPF适用于单个自治系统内的网络。</p>
</li>
<li><p>路由选择方式：IBGP使用基于路径的路由选择方式，即选择最短的AS路&gt;径。而OSPF使用基于链路状态的路由选择方式，即选择最短的路径。</p>
</li>
<li><p>路由信息的传递：IBGP需要在AS内部的不同路由器之间建立全网互联的&gt;BGP邻居关系，以实现路由信息的传递。而OSPF通过交换链路状态信息&gt;（LSA）来更新路由表。</p>
</li>
<li><p>发送路由信息的对象不同：IBGP是在AS内部的不同路由器之间传递路由&gt;信息的，而OSPF是在同一个自治系统内的不同路由器之间传递路由信息&gt;的。</p>
</li>
</ol>
<p>因此，IBGP和OSPF在实现方式、适用范围、路由选择方式和路由信息传递方式等方面存在差异。</p>
</blockquote>
<blockquote>
<p>1、<strong>IGP的能力限制，</strong> IGP处理路由的条目有限，而目前internet上核心路由器的路由表已经超过10万条。假如没有IBGP，那么这些路由只能采取重分发的方式直接导入到IGP中，这样做的缺点很明显：<br>第一，IGP协议的作者并没有打算让IGP来处理如此大量的路由，IGP本身也无法处理这样大的路由数量；<br>第二，<strong>BGP不会定期更新</strong> 。如果非要让IGP来处理，那么根据IGP的处理原则，假如这10万路由中任何一条路由发生变化，那么运行IGP的路由器就不得不重新计算路由，更为严重的是，假如其中某一条路由出现路由抖动的情况，例如端口反复UP/DOWN，这会导致所有的IGP路由器每时每刻都不得不把10万条路由重新计算一遍，这种计算量对于绝大多数路由器来说是无法负担的。另外对于运行RIP V1的路由器来说，10万条路由的定期更新，这根本就是无法接受的事情，除去带宽占用率不谈，也只有少量高端的GSR以及TSR能够有这样的性能吧。<br>例如：假定AS100/200/300各有100台路由器，而AS100中有1W条路由要传递要AS300中，而AS200的路由器不需要学习AS100的路由。如果没有IBGP的话，那么这1W条路由都必须被重分发到AS200的IGP中去，这样的话，相当于AS200中所有的100台路由器都增加了1W条路由。如果利用IBGP的话，那么AS200中只有运行IBGP的路由器会学习到这1W条路由，其它运行IGP的路由器都不会学习到这1W条路由。并且由于BGP的路由控制能力大大强于IGP的路由控制能力，因此运行IBGP的路由器比运行IGP的路由器能更好的对这1W条路由做一些路由策略的处理，从而保证整个AS内部的路由器学习到的路由数目可以控制在可接受的范围之内。<br>　　2、路由环路的问题。BGP是靠路由属性来防止路由环路的，例如AS_PATH属性，假如说没有IBGP协议，那么当所有BGP路由重分发到IGP中后，路由属性必然丢失，这就破坏了BGP的路由环路防止机制，产生了路由环路的隐患。   </p>
</blockquote>
<p>　　<br>那么引申一下，既然IBGP能够传送所有的路由前缀，为什么还需要IGP？</p>
<blockquote>
<p>1、IBGP之间是TCP连接，也就意味着IBGP邻居采用的是逻辑连接的方式，&gt;两个IBGP连接不一定存在实际的物理链路。所以需要有IGP来提供路由，以&gt;完成BGP路由的递归查找。<br>　　2、BGP协议本身实际上并不发现路由，BGP将路由发现的工作全部移交&gt;给了IGP协议，它本身着重于路由的控制。因此，如果没有IGP，那么BGP也&gt;就毫无用处了。</p>
</blockquote>
<p>　　EBGP与IBGP的区别：</p>
<blockquote>
<p>　　1、路由环路的避免措施不一样，IBGP强制规定ibgp speaker不允许&gt;把从一个ibgp邻居学习到的前缀传递给其它ibgp邻居，因此IBGP要求逻辑&gt;全连接。EBGP没有这样的要求，EBGP对路由环路的避免是通过AS_PATH属&gt;性来实现的。<br>　　2、使用的BGP属性不同，例如IBGP可以传递LOCAL_PREF（本地优先属&gt;性），而EBGP不行。<br>　　3、IBGP有同步的要求，而EBGP没有同步的要求<br>　　4、IBGP不需要IBGP邻居之间有物理连接，只需要逻辑连接即可，而&gt;EBGP下一般情况下都要求EBGP邻居之间存在物理连接。</p>
</blockquote>
<p><strong>表项是怎样进入路由器的转发表的?</strong></p>
<ol>
<li><p>为使一个前缀进入路由器的转发表，路由器必须首先知晓该前缀（对应于一个子网或子网的一个聚合)。如我们已经学习的那样，经过BGP路由通告，该路由器知道了前缀。这种通告可能（从位于另一个 AS中的一台路由器)经一个eBGP会话，或者(从位于相同 AS中的一台路由器）经一个iBGP会话发送给ta</p>
</li>
<li><p>该路由器则使用它的AS内部路由选择协议（通常为0SPF)来确定通向NEXT-HOP路由器的最短路径。路由器最后通过指出沿最短路径的第一段链路,确定端口号以关联其前缀。路由器则能够最终将前缀-端口对加入其转发表!</p>
</li>
</ol>
<h2 id="广播和多播路由选择"><a href="#广播和多播路由选择" class="headerlink" title="广播和多播路由选择"></a>广播和多播路由选择</h2><p>在广播路由选择 （broadcast routing）中，网络层提供了从一种源结点到网络中的所有其他结点交付分组的服务;多播路由选择（multicast routing）使单个源结点能够向其他网络结点的一个子集发送分组的副本。</p>
<h3 id="广播路由选择算法"><a href="#广播路由选择算法" class="headerlink" title="广播路由选择算法"></a>广播路由选择算法</h3><p>经第一跳仅发送分组的单个副本，然后让第一跳后面其他端的结点生成并转发任何附加的所需副本。这就是说,让网络结点本身（而不只是源结点）生成分组的冗余副本将更加有效。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/q6.png" alt="?"></p>
<h4 id="无控制洪泛"><a href="#无控制洪泛" class="headerlink" title="无控制洪泛"></a>无控制洪泛</h4><p>实现广播的最显而易见的技术是洪泛（flooding)方法，该方法要求源结点向它的所有邻居发送分组的副本。当某结点接收了一个广播分组时，它复制该分组并向它的所有邻居（除了从其接收该分组的那个邻居)转发之。显然,如果图是相连的，这种方案将最终将广播分组的副本交付给该图中的所有结点。</p>
<p>如果该图具有圈，则每个广播分组的一个或多个分组副本将无休无止地循环。</p>
<h4 id="受控洪泛"><a href="#受控洪泛" class="headerlink" title="受控洪泛"></a>受控洪泛</h4><h3 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h3><p><strong>一台主机除了有唯一的IP地址外，它也可以加入多播组并获得一个多播地址。</strong></p>
<p>使用广播服务分组被交付给网络的所有结点。使用多播(multicast)服务，多播分组仅被交付给网络结点的一个子集。</p>
<p>在因特网中，这种表示一组接收方的单一标识就是一个D类多播地址与一个D类地址相关联的接收方小组被称为一个多播组(multicast group)。图中的4台主机(显示为深色)与多播组地址22617.30197相关联，而且它们将接收所有寻址到该多播地址的数据报。我们仍然必须应对的困难在于这样一个事实，每台主机有一个唯一的iP单播地址，该单播地址完全独立于它所参与的多播组的地址。</p>
<p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/w1.png" alt="?"><br><strong>单播和多播</strong><br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/w3.png" alt="?"><br><strong>多播地址</strong><br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/w4.png" alt="?"><br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/w5.png" alt="?"></p>
<h4 id="局域网硬件多播"><a href="#局域网硬件多播" class="headerlink" title="局域网硬件多播"></a>局域网硬件多播</h4><p>由于MAC地址(也称为硬件地址)有多播MAC地址这种类型，因此只要把IPV4多播地址映射成多播MAC地址，即可将IP多播数据报封装在局域网的MAC帧中，而MAC顿首部中的目的MAC地址字段的值，就设置为由IPv4多播地址映射成的多播MAC地址。这样，可以很方便地利用硬件多播来实现局域网内的IP多播<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/w6.png" alt="?"><br><strong>多个ip映射到同一mac地址</strong><br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/e1.png" alt="?"><br><strong>怎么区分？</strong><br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/e2.png" alt="?"></p>
<p><strong>网际组管理协议其作用是让连接在本地局域网上的多播路由器知道本局域网上是否有主机 (实际上是主机中的某个进程)加入或退出了某个多播组。</strong></p>
<p>IGMP仅在本网络有效，使用IGMP并不能知道多播组所包含的成员数量，也不能知道多播组的成员都分布在哪些网络中。</p>
<p><strong>仅使用IGMP并不能在因特网上进行IP多播。连接在局域网上的多播路由器还必须和因特网上的其他多播路由器协同工作，以便把IP多播数据报用最小的代价传送给所有的多播组成员，这就需要使用多播路由选择协议</strong></p>
<p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/e3.png" alt="?"></p>
<h4 id="因特网组管理协议"><a href="#因特网组管理协议" class="headerlink" title="因特网组管理协议"></a>因特网组管理协议</h4><p>IGMP版本3运行在一台主机与其直接相连的路由器之间。图4-48显示了3台第一跳多播路由器，每一台都通过一个向外的本地接口与相连的主机连接。在该例中，本地接口连到一个LAN上，且每个LAN都有多台相连的主机，在任意给定时间内至多有几台主机属于一个给定的多播组。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/w2.png" alt="?"></p>
<p>IGMP有三种报文类型<br>成员报告报文<br>成员查询报文<br>离开组报文<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/e4.png" alt="?"><br><strong>igmp只在局域网运行，所以可以设置为ttl=1防止外传，ttl在跨越不同子网时减一</strong></p>
<p><strong>加入多播组</strong><br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/e5.png" alt="?"><br>假设c已经加入了一个多播组，d没加入，现在ab都想加入另一个多播组，b发送igmp报文，d收到后发现是多播报文直接丢弃，c发现后接受，但是在链路层发现mac地址（此地址是多播地址映射而来）不对，发现不是自己组的丢弃，a接收后发现mac和ip都对接受，并取消自己的igmp加入报文（和b重复了），r1收到报文后假如多播组列表。</p>
<p><strong>监视变化</strong><br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/e6.png" alt="?"></p>
<p>224.0.0.1：特殊的IP多播地址，在本网络中所有参加多播的主机和路由器的网际层都会接受该多播数据报</p>
<p>r1发送监视报文确认还有这个组的成员吗，所有的多播组（不管那个组）都接受，经过mac和ip对照后接受，解析igmp报文后，本组的在随即延迟后进行响应（退避算法）发送报告报文，所有人都接受，重复加入多播组的步骤。</p>
<p><strong>退出多播组</strong><br>当主机要退出某个多播组时，可主动发送个离开组报文而不必等待多播路由器的查询。这样可使多播路由器能够更快地发现某个组有成员离开</p>
<p>224.0.0.2：特殊的IP多播地址在本网络中的所有多播路由器的网际层都会接受该多播数据报。这个地址只有多播组路由器接受<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/e7.png" alt="?"><br>路由器收到退出报文后还会发送一个查询报文，此报文地址是多播组地址不是224.0.0.1（224.0.0.1 是所有主机的多播地址，而不是组播地址，因此不能用于通知组成员退出情况）</p>
<h3 id="多播路由选择协议"><a href="#多播路由选择协议" class="headerlink" title="多播路由选择协议"></a>多播路由选择协议</h3><p>多播路由选择协议的主要任务是: 在多播路由器之间为每个多播组建立一个多播转发树多播转发树连接多播源和所拥有该多播组成员的路由器。<br>目前有以下两种方法来构建多播转发树</p>
<h4 id="基于源树-Source-Base-Tree-多播路由选择"><a href="#基于源树-Source-Base-Tree-多播路由选择" class="headerlink" title="基于源树 (Source-Base Tree)多播路由选择"></a>基于源树 (Source-Base Tree)多播路由选择</h4><p>利用反向路径广播RPB算法生成的广播转发树，不会存在环路，[因此可以避免广播分组在环路中兜圈RPB算法的要点是:每一台路由器在收到一个广播分组时，先检查该广播分组是否是从源点经最短路径专送来的。<br>若是，本路由器就从自己除刚才接收该广播分组的接口的所有其他接口转发该广播分组。<br>否则，丢弃该广播分组。如果本路由器有好几个邻居路由器都处在到源点的最短路径上，也就是存在好几条同样长度的最短路径，那么只能选取一条最短路径。选取的规则是这几条最短路径中的邻居路由器的IP地址最小的那条最短路径。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/e8.png" alt="?"></p>
<p>若有相同的距离则选择ip地址小的<br>路由器在确保连通性（自己去掉不会影响别的路由器）的情况下使用igmp报文获知自己是不是组播路由器，是则保留枝干，不是则向上游剪枝，其下的主机若加如多播则重新嫁接枝干</p>
<h4 id="组共享树-Group-Shared-Tree-多播路由选择"><a href="#组共享树-Group-Shared-Tree-多播路由选择" class="headerlink" title="组共享树 (Group-Shared Tree)多播路由选择"></a>组共享树 (Group-Shared Tree)多播路由选择</h4><p>从多播路由器开始向核心路由构建网络<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/e9.png" alt="?"></p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol>
<li>我们回顾一下在本书中使用的某些术语。前面讲过运输层的分组名字是报文段，数据链路层的分组名字是帧。网络层分组的名字是什么?前面讲过路由器和链路层交换机都被称为分组交换机。路由器与链路层交换机间的根本区别是什么?回想我们对数据报网络和虚电路网络都使用词汇路由器。<blockquote>
<p>网络层数据包是一种数据报.路由器根据数据包的IP(第3层)地址转发数据包。链路层交换机根据分组的MAC(第2层)地址转发分组.</p>
</blockquote>
</li>
<li>在数据报网络中，网络层的两个最重要功能是什么?虚电路网络中网络层的3个最重要的功能是什么?<blockquote>
<p>数据平面的主要功能是转发数据包，转发数据报从它们的输入链路到它们的输出链路。例如,数据平面S输入端口执行终止传入物理链路的物理层功能在路由器处，执行链路层功能以在另一个路由器上与链路层互操作传入链路的一侧，并在输入端口上执行查找功能。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>控制平面的主要功能是路由，即确定数据包从源到目的地的路径。控制平面负责执行路由协议，响应连接的上下链路，与远程控制器通信，并执行管理功能。<br>3. 路由选择和转发的区别是什么?<br>路由和转发之间的主要区别在于转发是路由器S将分组从其输入接口传送到其输出接口的本地动作，和转发发生在非常短的时标(通常为几纳秒),并且因此通常以硬件实现。路由是指网络范围确定数据包从来源接收到的端到端路径的过程目的地。路由发生在更长时间的时标上(通常是秒)，以及通常用软件实现。<br>4. 在数据报网络和虚电路网络中的路由器都使用转发表吗?如果是，描述用于这两类网络的转发表。<br>转发表在路由器中的作用是保存条目，以确定数据报通过路由器的哪个输出接口<br>5. 描述网络层能为单个分组提供的某些假想的服务。对分组流进行相同的描述。因特网的网络层为你提供了这些假想服务吗?ATM的CBR服务模型提供了这些假想服务吗?ATM的ABR服务模型提供了这些假想服务吗?<br>Internet网络层的服务模式是尽力而为的服务.使用该服务模型，无法保证按发送顺序接收数据包，无法保证其最终交付，不能保证端到端的延迟，也没有最小的带宽保证。<br>7. 讨论为什么在高速路由器的每个输入端口都存储转发表的影子副本。<br>利用阴影复制,在每个输入端口处本地地进行转发查找,而无需调用集中式路由处理器。这种分散的方法避免在路由器内的单个点创建查找处理瓶颈。<br>8. 在4.3节中讨论了3类交换结构。列出并简要讨论每一类交换结构。哪一种(如果有的话) 能够跨越交换结构并行发送多个分组?<br>经内存交换；经总线交换；经互联网络交换。【内存式；总线式；纵横式。P207 三种交换技术的简单图像要能画出来】 经互联网络交换可以并行转发数据包，但要求所有数据包被转发到不同的输出端口。<br>9. 描述在输人端口会出现分组丢失的原因。描述在输人端口如何消除分组丢失(不使用无限大缓存区)。<br>如果数据包到达路由器的速率超过交换结构的速率，则数据包需要在输入端口排队。 如果这种速率不匹配持续存在，队列将越来越大，最终溢出输入端口缓冲区，导致丢包。 如果交换结构的速度至少是输入速度的 n 倍，其中 n 是输入端口数，则可以消除分组丢失<br>10. 描述在输出端口出现分组丢失的原因。通过增加交换结构速率，能够防止这种丢失吗?<br>交换结构对某输出端口的发送速度快于输出端口的输出速度，会造成排队现象，排队过长就会发生丢失。<br>增加交换结构的速率对丢失现象起到相反的作用。速率越高丢失越多。<br>(这是因为增加交换结构的速率会导致更多的数据包同时进入交换结构，从而增加了竞争和冲突的可能性，造成了数据包的丢失。此外，高速率也可能导致交换结构的缓存空间不足，进一步加剧了丢包现象。因此，在设计交换结构时需要综合考虑速率和缓存空间等因素，以最优的方式平衡各种需求。)<br>11. 什么是HOL阻塞?它出现在输人端口还是输出端口?<br>如果一个输入端口的前部分组正在阻塞，后面的所有分组也不能被发送，即使后面的分组的输出端口是空闲的。出现在输入端口。<br>12. 路由器有iP地址吗?如果有，有多少个?<br>路由器有IP地址，且一个端口一个IP地址。<br>13. IP地址223.1.3.27的32比特二进制等价形式是什么?<br>11011111 00000001 00000011 00011011<br>14. 考察使用DHCP的主机，获得它的IP地址、网络掩码、默认路由器和其本地DNS服务器的iP地址。列出这些值。<br>IP地址：192.168.2.239<br>子网掩码：255.255.255.0<br>默认路由器：192.168.2.1<br>本地DNS服务器：192.168.2.1</p>
</blockquote>
<blockquote>
<p>(输入cmd，点击确定<br>输入ipconfig/all，点回车键<br>找到DHCP服务器，后面的那串数字就是系统分配的DHCP的IP地址)</p>
</blockquote>
<ol start="15">
<li><p>假设在一个源主机和一个目的主机之间有3 台路由器。不考虑分片，一个从源主机发送给目的主机的IP报文将通过多少个接口?为了将数据报从源移动到目的地需要检索多少个转发表?</p>
<blockquote>
<p>8个接口。检索3次转发表。</p>
</blockquote>
</li>
<li><p>假设某应用每20ms生成一个40字节的数据块，每块封装在一个TCP报文段中TCP报文段再封装在一个iP数据报中。每个数据报的开销有多大?应用数据所占百分比是多少?</p>
<blockquote>
<p>40字节数据+20字节TCP首部+20字节IP首部 = 80字节<br>应用数据所占百分比为50%</p>
</blockquote>
</li>
<li><p>假定主机A向主机B发送封装在一个IP数据报中的TCP报文段。当主机B接收到该数据报时，主机B中的网络层怎样知道它应当将该报文段(即数据报的有效载荷)交给TCP而不是UDP或某个其他东西呢?</p>
<blockquote>
<p>IP协议中有上层协议字段，指示了应该交给的上层协议。</p>
</blockquote>
</li>
<li><p>假定你购买了一个无线路由器并将其与电缆调制解调器相连。同时假定ISP动态地为你连接的设备(即你的无线路由器)分配一个iP 地址。还假定你家有5台PC均使用802.11以无线方式与该无线路由器相连。怎样为这5台PC分配P地址?该无线路由器使用NAT吗?为什么?</p>
<blockquote>
<p>一般使用DHCP协议自动分配地址，DHCP服务器即是无线路由器。<br>一般的无线路由器是使用NAT的。因为它使用的是局域网地址，并非公网地址。</p>
</blockquote>
</li>
<li><p>比较并对照IP4和IP6首部字段。它们有某些字段是相同的吗?</p>
<blockquote>
<p>版本，服务类型，上层协议，寿命，源地址和目的地址（位数不同）</p>
</blockquote>
</li>
<li><p>有人说当IPv6建隧道通过IPv4路由器时IP6将IP4 隧道作为链路层协议。你同意这种说法吗?为什么?</p>
<blockquote>
<p>可以这样理解。因为IPV6数据报被封装在IPV4数据报中，对IPV6报文来讲隧道就相当于过了一跳路由器，因此比较像链路层协议。</p>
</blockquote>
</li>
<li><p>比较和对照链路状态和距离向量路由选择算法。</p>
<blockquote>
<p>链路状态算法：<br>全局式路由选择算法，需要广播<br>距离向量路由选择算法：<br>分散式路由选择算法，只需要通知相连点</p>
</blockquote>
</li>
<li><p>讨论因特网的等级制组织是怎样使得其能够扩展为数以百万计用户的</p>
<blockquote>
<p>不同的ISP构建了不同的自治系统，自治系统内部采用内部路由选择协议。自治系统之间使用自治系统间路由选择协议。<br>其次，OSPF协议还可以配置为多个区域，区域内运行自己的OSPF协议。</p>
</blockquote>
</li>
<li><p>每个自治系统使用相同的AS内部路由选择算法是必要的吗?为什么?</p>
<blockquote>
<p>是不必要的。不同的AS情况可能不同，适合采用的路由选择算法也不同，且只要选择了相同的AS间路由协议，就不会影响对外的路由选择。</p>
</blockquote>
</li>
<li><p>考虑图4-37。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/t2.png" alt="?"><br>从D中的初始表开始，假设D收到来自A的以下通告:<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/t1.png" alt="?"><br>D中的表将会改变吗?如果是，应怎样变化?</p>
<blockquote>
<p>不变（吓一跳相同直接更新，吓一跳不同则对比，若来的更短更新）</p>
</blockquote>
</li>
<li><p>比较并对照RIP与OSPF使用的通告。</p>
<blockquote>
<p>RIP通告的内容是路由器的转发表，也包含目的地的跳数。只向连接的点通告。<br>OSPF通告的内容是某链路的状态信息，向所有自治系统内的路由器通告。</p>
</blockquote>
</li>
<li><p>填空:RIP通告通常宣称到各目的地的跳数，而BGP更新却宣称到各目的地的</p>
<blockquote>
<p>AS-PATH和NEXT-HOP</p>
</blockquote>
</li>
<li><p>为什么在因特网中用到了不同类型的AS间与AS内协议?</p>
<blockquote>
<p>AS内协议和AS间协议处理的问题不同，比如AS内协议要求性能，但不要求规模和特殊策略，但是AS间协议对规模，可扩展性和策略要求较多。</p>
</blockquote>
</li>
<li><p>定义和对比下列术语:子网，前缀和 BGP路由。</p>
<blockquote>
<p>子网是IP在一个网段内，里面有许多主机，IP相近，前缀相同。<br>前缀是一个子网的标识，具有相同前缀的IP在一个子网内。<br>BGP路由是在AS间的路由选择协议。<br>AS与子网不是同一个概念，AS的范围一般比子网要大，一个路由器端口连接的是一个子网。多个子网和路由器在一个为AS。不过经过路由聚合，AS对于外部可能表示为一个子网的形式。</p>
</blockquote>
</li>
<li><p>BGP是怎样使用NEXT-HOP属性的?它是怎样使用AS-PATH属性的?</p>
<blockquote>
<p>NEXT-HOP属性，用来决定转发表下一条路由，知道通往的是哪个AS网关路由器。<br>AS-PATH属性用来检测和防止循环通告，它的长度还能用来确定路由选择。</p>
</blockquote>
</li>
<li><p>描述一个较高层ISP的网络管理员在配置BGP时是如何实现策略的。</p>
<blockquote>
<p>使用输入策略，比如设置某些属性，过滤到不符合属性的路由信息。</p>
</blockquote>
</li>
<li><p>通过多个单播实现广播抽象与通过支持广播的单个网络(路由器)实现广播抽象之间有什么重要区别?</p>
<blockquote>
<p>单播是指的分组被复制，然后分别通过独立的路由选择到达目的地。<br>广播则是直接使用路由器，在向多个端口转发时才复制报文。</p>
</blockquote>
</li>
<li><p>对于我们学习的广播通信的3种一般方法(无控制洪泛、受控洪泛和生成树广播) 中的每种，下列说法是正确的吗?你可以假定分组不会因缓存溢出而丢失，所有分组以它们发送的顺序交付给链路。<br>a.一个结点可能接收到同一个分组的多个副本<br>b.一个结点可能通过相同的出链路转发多个分组的副本。</p>
<blockquote>
<p>无控制洪泛：<br>a. 正确 b. 正确<br>受控洪泛：<br>a. 正确 b. 错误<br>生成树广播：<br>a. 错误 b. 错误</p>
</blockquote>
</li>
<li><p>当一台主机加人一个多播组时，它必须将其iP地址改变为它所加人的多播组的地址吗?</p>
<blockquote>
<p>不需要(不是必须的。当一台主机加入一个多播组时，它会在网络上发送一个IGMP报文，告知网络中的路由器它想要接收该多播组的数据。主机的IP地址不会改变，它仍然保持原来的IP地址。路由器会根据这个IGMP报文来知道哪些主机加入了哪些多播组，并将多播数据转发给这些主机。是的，主机在加入多播组时，会加入到一个特定的多播组地址。这个多播组地址是一个特殊的IP地址，用来标识一个多播组。当主机想要接收该多播组的数据时，它需要指定这个多播组地址作为目的IP地址。但是主机的源IP地址不会改变，仍然是它原来的IP地址。路由器会根据多播组地址来转发多播数据，而不是根据主机的IP地址。)</p>
</blockquote>
</li>
<li><p>IGMP和广域多播路由选择协议所起的作用是什么?</p>
<blockquote>
<p>IGMP通知一台路由器想要加入或退出多播组。<br>多播路由选择算法的作用是使得多播组的成员接收报文，但是非多播组的成员尽量少接收报文。因于此选择多播报文的路径。</p>
</blockquote>
</li>
<li><p>在多播路由选择场合中，一棵组共享的树与一棵基于源的树之间有什么区别?</p>
<blockquote>
<p>共享的树是所有组成员都使用这一棵树的路径来发送/接收多播报文。<br>基于源的树是指每个成员都有一颗独立的路由树，根据这个树来发送多播报文。</p>
</blockquote>
</li>
</ol>
<h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><ol>
<li>在本题中，考虑虚电路网络和数据报网络的某些优缺点。<br>a.假设路由器遇到了可能经常会引起它无法正常运转的情况。提出理由说明是虚电路体系结构还是数据报体系结构更好，为什么?<blockquote>
<p>数据报网络更好，如果无法运转时可以使用其他的路线继续发送。如果是虚电路就需要重新建立连接了。</p>
</blockquote>
</li>
</ol>
<p>b对于源和目的结点间传输流量的排他性使用，假设该源和目的结点要求，在沿源到目的地的路径上的所有路由器总能提供固定的容量。提出理由说明是虚电路体系结构还是数据报体系结构更好，为什么?</p>
<blockquote>
<p>虚电路体系更好，因为提供固定的容量正好能搭建一个虚电路。</p>
</blockquote>
<p>c假设网络中的链路和路由器从不出故障，并且所有源/目的地对之间所使用的路径保持不变。在这种情况下，虚电路或数据报体系结构哪个控制流量开销会更多?为什么?</p>
<blockquote>
<p>数据报体系的控制流量开销更多，因为数据报需要更大报文首部。</p>
</blockquote>
<ol start="2">
<li>考虑一个虚电路网络。假定其VC号是一个8比特字段。<br>a.链路能够承载的虚电路的最大数量是多少?<blockquote>
<p>256个</p>
</blockquote>
</li>
</ol>
<p>b.假定某中心结点在连接建立时确定了路径和VC号。假定沿着某虚电路的路径在每段链路使用相同的VC号。描述在连接建立时中心结点如何确定VC号。进行中虚电路比在(a)中确定的最大值要少，也没有相同的未用 VC号，这种情况可能出现吗?</p>
<blockquote>
<p>可能的确定方法：有一个虚电路表，记录当前已经使用的VC号，中心结点设定一个未被使用的VC号。这样设置就不会出现比确定的最大值少的情况。</p>
</blockquote>
<p>c.假定沿着某条虚电路的路径允许不同的VC号。在连接建立期间，在端到端路径确定以后，描述链路如何以分散方式而不依赖中心结点选择它们的VC号并配置它们的转发表</p>
<blockquote>
<p>链路只需要向它的下一跳协商，VC号不与当前结点和下一跳结点中的其它VC号重复即可。</p>
</blockquote>
<ol start="3">
<li><p>在虚电路网络中的基本转发表具有4列。在这些列中的值的含义是什么?在数据报网络中的基本转发表有两列。在这些列中的值的含义是什么?</p>
<blockquote>
<p>虚电路网络：<br>入接口，入VC号，出接口，出VC号<br>数据报网络：<br>目的子网，出接口</p>
</blockquote>
</li>
<li><p>考虑下列网络<br>a假定网络是一个数据报网络。显示路由器A中的转发表，其中所有指向主机 H3的流量通过接口3转发。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">目的地址</th>
<th align="center">出接口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">H1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">H2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">H3</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>b假定网络是一个数据报网络。你能写出路由器A中的转发表吗?其中所有从H1指向主机3的流量通过接口3转发，而所有从H2指向主机H3的流量通过接口4转发。提示:这是一个技巧问题。</p>
<table>
<thead>
<tr>
<th align="center">入接口</th>
<th align="center">目的地址</th>
<th align="center">出接口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">H2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">H1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">H3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">H3</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p>c现在假定网络是虚电路网络，在H1和H3之间有一个进行中的呼叫，H2和H之间有另一个进行0中的呼叫。写出路由器A中的转发表，其中所有从H1指向主机H3的流量通过接口3转发，而所有从H2指向主机H3的流量通过接口4转发。</p>
<blockquote>
<p>设H1-H3各段的VC号为 01 02 03 04<br>设H2-H3各段的VC号为 05 06 07 08 </p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">入接口</th>
<th align="center">入VC号</th>
<th align="center">出接口</th>
<th align="center">出VC号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">01</td>
<td align="center">3</td>
<td align="center">02</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">05</td>
<td align="center">4</td>
<td align="center">06</td>
</tr>
<tr>
<td align="center">d假设场景与(c)中相同，写出在结点B、C和D中的转发表</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>路由器B:  </p>
<table>
<thead>
<tr>
<th align="center">入接口</th>
<th align="center">入VC号</th>
<th align="center">出接口</th>
<th align="center">出VC号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">02</td>
<td align="center">2</td>
<td align="center">03</td>
</tr>
</tbody></table>
<p>路由器C:  </p>
<table>
<thead>
<tr>
<th align="center">入接口</th>
<th align="center">入VC号</th>
<th align="center">出接口</th>
<th align="center">出VC号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">06</td>
<td align="center">2</td>
<td align="center">07</td>
</tr>
</tbody></table>
<p>路由器D:  </p>
<table>
<thead>
<tr>
<th align="center">入接口</th>
<th align="center">入VC号</th>
<th align="center">出接口</th>
<th align="center">出VC号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">03</td>
<td align="center">3</td>
<td align="center">04</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">07</td>
<td align="center">3</td>
<td align="center">08</td>
</tr>
</tbody></table>
<p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/t3.png" alt="?"></p>
<ol start="5">
<li>考虑一个用2比特字段表示VC号的虚电路网络。假定该网络要通过4条链路(链路A、链路B链路C和链路D)建立一条虚电路。假定这些链路中的每条当前都承载两条其他的虚电路，这些其他虚电路的VC号如下:<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/t4.png" alt="?"><br>在回答下列问题时，记住每个现有的虚电路可能通过这4条链路之一。<br>a如果每条虚电路要求沿着其路径使用相同的VC号，能为该新的虚电路分配什么样的VC号?<blockquote>
<p>VC号分别为 00，01，10，11  </p>
</blockquote>
</li>
</ol>
<p>b.如果每条虚电路沿其路径允许不同的链路使用不同的VC号(因此转发表必须执行VC号转换)能够使用4个VC号的多少种不同的组合(一种组合用于这4条链路之一)?</p>
<blockquote>
<p>buhui</p>
</blockquote>
<ol start="6">
<li><p>在本书中我们使用术语面向连接服务来描述运输层服务，使用术语连接服务描述网络层服务。在术语中为何有这种微妙的差异?</p>
<blockquote>
<p>网络层提供了主机之间的连接服务，运输层则使用这个服务建立进程间的连接。  </p>
</blockquote>
</li>
<li><p>假设两个分组在完全相同的时刻到达一台路由器的两个不同输人端口。同时假设在该路由器中没有其他分组。<br>a假设这两个分组朝着两个不同的输出端口转发。当交换结构使用一条共享总线时，这两个分组可能在相同时刻通过交换结构转发吗?</p>
<blockquote>
<p>不能 </p>
</blockquote>
</li>
</ol>
<p>b假设这两个分组朝着两个不同的输出端口转发。当交换结构使用纵横方式时，这两个分组可能在6相同时刻通过交换结构转发吗?</p>
<blockquote>
<p>可以</p>
</blockquote>
<p>c假设这两个分组朝着相同的输出端口转发。当交换结构使用纵横方式时。这两个分组可能在相同0时刻通过交换结构转发吗?</p>
<blockquote>
<p>bu能<br>8. <img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/t5.png" alt="?"><br>最好方法：2个时隙  </p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">入端口号</th>
<th align="center">端口号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">X</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">Z</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">X</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">Y</td>
</tr>
</tbody></table>
<p>最差方法：3个时隙  </p>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">入端口号</th>
<th align="center">端口号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">X</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">Z</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">X</td>
</tr>
</tbody></table>
<ol start="10">
<li><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/t6.png" alt="?"><br>提供一个具有4个表项的转发表，使用最长前缀匹配，转发分组到正确的链路接口</li>
</ol>
<table>
<thead>
<tr>
<th align="center">目的子网</th>
<th align="center">出接口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">224.0.0.0/22</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">224.64.0.0/16</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">224.64.0.0/22</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">其它</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>描述你的转发表是如何为具有下列目的地址的数据报决定适当链路接口的。<br>11001000 10010001 01010001 01010101<br>11100001 01000000 11000011 00111100<br>11100001 10000000 00010001 01110111</p>
<blockquote>
<p>323</p>
</blockquote>
<ol start="11">
<li><p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/t7.png" alt="?"></p>
<blockquote>
<p>0/6, 2^6个<br>64/5, 2^5个<br>96/5, 2^5个<br>128/6, 2^6个<br>160/6, 2^6个<br>前缀匹配到主机位上</p>
</blockquote>
</li>
<li><p><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/t8.png" alt="?"></p>
<blockquote>
<p>0/7, 2^7个<br>128/6, 2^6个<br>244/5, 2^5个<br>96/5, 2^5个</p>
</blockquote>
</li>
<li><p>考虑互联3个子网(子网1、子网2和子网3)的一台路由器。假定在这3个子网的每个子网中的所有接口要求具有前缀223.1.17/24。还假定子网1要求支持多达60个接口，子网2要求支持多达90个接口和子网3要求支持多达12个接口。提供3个满足这些限制的网络地址(形式为.b.cd/x</p>
<blockquote>
<p>子网2： 223.1.17.0/25<br>子网1： 223.1.17.128/26<br>子网3： 223.1.17.192/26</p>
</blockquote>
</li>
<li><p>在4.2.2节中给出了一个转发表(使用最长前缀匹配)的例子，使用ab.cd/x记法代替二进制字符串记法，重写该转发表。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">目的子网</th>
<th align="center">出接口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200.23.16.0/11</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">200.23.24.0/8</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">200.23.24.0/11</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">其他</td>
<td align="center">3</td>
</tr>
</tbody></table>
<ol start="16">
<li>考虑具有前缀128.119.40.128/26的一个子网。给出能被分配给该网络的一个iP地址(形式为xxxxxxxxxxxx)的例子。假定一个ISP拥有形式为128.119.40.64/26的地址块。假定它要从该地址块生成4个子网，每块具有相同数量的iP地址。这4个子网(形式为bcd/x)的前缀是什么?<blockquote>
<p>IP地址例子: 128.119.40.129<br>四个子网：  </p>
</blockquote>
</li>
<li>119.40.128/5  </li>
<li>119.40.160/5  </li>
<li>119.40.192/5  </li>
<li>119.40.224/5  </li>
</ol>
<p><strong>(主机位32-26=6，共2^6=64个主机，平均每个子网16个主机，需要5位主机位，注意：全0全1不能用4位主机位还剩14个地址)</strong></p>
<ol start="17">
<li>考虑图4-17中显示的拓扑。(在12:00以顺时针开始)标记具有主机的3个子网为网络AB和C标记没有主机的子网为网络D、E和F。</li>
</ol>
<p>a为这6个子网分配网络地址，要满足下列限制:所有地址必须从214.97.254/23 起分配;子网A应当具有足够地址以支持250个接口:子网B应当具有足够地址以支持120个接口:子网C应当具有足够地址以支持120个接口。当然，子网D、E和F应当支持两个接口。对于每个子网，分配采用的形式是abcd/x或abcd/xefgh/y。</p>
<blockquote>
<p>A: 214.97.254.0/24 去掉 214.97.254.0/30<br>B: 214.97.255.0/25 去掉 214.97.255.0/30<br>C: 214.97.255.128/25 去掉 214.97.255.128/30<br>D: 214.97.254.0/30<br>E: 214.97.255.0/30<br>F: 214.97.255.128/30<br><strong>始终牢记减去一个全0一个全1</strong></p>
</blockquote>
<ol start="19">
<li><p>考虑向具有700字节MTU的一条链路发送一个2400字节的数据报。假定初始数据报标有标识号422。将会生成多少个分片?在生成相关分片的数据报中的各个字段中的值是多少?</p>
<blockquote>
<p>700字节的MTU，承载的传输层数据为680字节(减去每个数据包的20B)，因此生成4个分片。<br>第一个分片： 标识号：422, 偏移：0, 标志：1<br>第二个分片： 标识号：422, 偏移：85, 标志：1<br>第三个分片： 标识号：422, 偏移：170, 标志：1<br>第四个分片： 标识号：422, 偏移：255, 标志：0  </p>
</blockquote>
</li>
<li><p>假定在源主机A和目的主机B之间的数据报被限制为1500字节(包括首部)。假设IP首部为20字节要发送一个5MB组成的MP3需要多少个数据报?解释你的答案是如何计算的。</p>
<blockquote>
<p>1500字节的MTU，承载的应用层数据为1460字节 (tcp20B,ip20B)<br>5MB为5242880字节，因此需要3592个数据报。 </p>
</blockquote>
</li>
</ol>
<p><strong>注意是数据包分片，还是应用层传下来的数据</strong></p>
<ol start="21">
<li>考虑在图4-22中建立的网络。假定SP此时为路由器分配地址24.34.112235以家庭网络的网络地址是192.168.1/24。<br>a.在家庭网络中为所有接口分配地址。<blockquote>
<p>主机1： 192.168.0.1<br>主机2： 192.168.0.2<br>主机3： 192.168.0.3<br>路由器家庭网络端口： 192.168.0.4 </p>
</blockquote>
</li>
</ol>
<p>b.假定每台主机具有两个进行中的TCP连接，所有都是对主机128.119.40.86的80端口的。在NAT转换表中提供6个对应表项。</p>
<table>
<thead>
<tr>
<th align="center">WAN端</th>
<th align="center">LAN端</th>
</tr>
</thead>
<tbody><tr>
<td align="center">24.34.112.235, 10001</td>
<td align="center">192.168.0.1, 12345</td>
</tr>
<tr>
<td align="center">24.34.112.235, 10001</td>
<td align="center">192.168.0.1, 1234</td>
</tr>
<tr>
<td align="center">24.34.112.235, 10002</td>
<td align="center">192.168.0.2, 2345</td>
</tr>
<tr>
<td align="center">24.34.112.235, 10002</td>
<td align="center">192.168.0.2, 2375</td>
</tr>
<tr>
<td align="center">24.34.112.235, 10003</td>
<td align="center">192.168.0.2, 3345</td>
</tr>
<tr>
<td align="center">24.34.112.235, 10003</td>
<td align="center">192.168.0.2, 3845</td>
</tr>
</tbody></table>
<ol start="22">
<li>假设你有兴趣检测NAT后面的主机数量。你观察到在每个iP分组上iP 层顺序地标出一个标识号.由一台主机生成的第一个iP分组的标识号是一个随机数，后继iP分组的标识号是顺序分配的。假设由NAT后面主机产生的所有IP分组都发往外部。</li>
</ol>
<p>a基于这个观察，假定你能够俘获由 NAT 向外部发送的所有分组你能概要给出一种简单的技术来检测 NAT后面不同主机的数量吗?评估你的答案。</p>
<blockquote>
<p>可以来检测不同主机的数量。<br>检测IP分组的标识号。最开始遇到分组标识号时，记录下来，识别为一个主机。<br>后面遇到标识号如果是记录中某标识号的顺序后继，则更新记录中的标识号。<br>如果不是，则识别一个新主机，添加进记录中。  </p>
</blockquote>
<p>b.如果标识号不是顺序分配而是随机分配的，这种技术还能正常工作吗?评估你的答案</p>
<blockquote>
<p>无法工作，因为分不清是新主机还是同一主机的不同报文。</p>
</blockquote>
<ol start="23">
<li><p>在这个习题中，我们将探讨NAT对P2P应用程序的影响。假定具有用户名Amold的对等方通过查询发现，具有用户名Bermard的对等方有一个要下载的文件。同时假定Berard和Arnod都位于NAT后面。尝试设计一种技术使得Amold与Bernard创建一条TCP连接，而不对NAT做应用特定的配置。如果你难以设计这样的技术，试讨论其原因。</p>
<blockquote>
<p>因为两方都处在NAT后面，只能主动发起连接，不能当作服务器去接收连接，因为NAT表中没有对应项。<br>即使查找某一方已经连接的主机中，让其与该主机发起连接，但是也无法直接转换为两方都是NAT后的对等方连接。 </p>
</blockquote>
</li>
<li><p>观察图4-27，列举从y到u不包含任何环路的路径。</p>
<blockquote>
<p>y v u, y t u 等等。。</p>
</blockquote>
</li>
<li><p>重复习题P24，列举从x到z到u以及到w的不含任何环路的路径。</p>
<blockquote>
<p>x-y-z等<br>z-y-x-u等<br>z-w等</p>
</blockquote>
</li>
<li><p>考虑下面的网络。对于标明的链路费用，用 Dikstra的最短路径算法计算出从x到所有网络结点的最短路径。通过计算一个类似于表4-3的表，说明该算法是如何工作的。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/t9.png" alt="?"></p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">N’</th>
<th align="center">D(y), p(y)</th>
<th align="center">D(z), p(z)</th>
<th align="center">D(v), p(v)</th>
<th align="center">D(u), p(u)</th>
<th align="center">D(w), p(w)</th>
<th align="center">D(t), p(t)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">x</td>
<td align="center">6,x</td>
<td align="center">8,x</td>
<td align="center">3,x</td>
<td align="center">∞</td>
<td align="center">6,x</td>
<td align="center">∞</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">xv</td>
<td align="center">6,x</td>
<td align="center">8,x</td>
<td align="center"></td>
<td align="center">6,v</td>
<td align="center">6,x</td>
<td align="center">7,v</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">xvy</td>
<td align="center"></td>
<td align="center">8,x</td>
<td align="center"></td>
<td align="center">6,v</td>
<td align="center">6,x</td>
<td align="center">7,v</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">xvyu</td>
<td align="center"></td>
<td align="center">8,x</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">6,x</td>
<td align="center">7,v</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">xvyuw</td>
<td align="center"></td>
<td align="center">8,x</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">7,v</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">xvyuwt</td>
<td align="center"></td>
<td align="center">8,x</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">xvyuwtz</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ol start="28">
<li>考虑下图所示的网络，假设每个结点初始时知道到它的每个邻居的费用。考虑距离向量算法，并显示在结点z中的距离表表项。</li>
</ol>
<p>初始表<br>结点u的表：  </p>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">∞</td>
<td align="center">2</td>
<td align="center">∞</td>
</tr>
<tr>
<td align="center">v</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
</tr>
</tbody></table>
<p>结点v的表：  </p>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
</tr>
<tr>
<td align="center">v</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">∞</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
</tr>
</tbody></table>
<p>结点x的表：  </p>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">∞</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
</tr>
</tbody></table>
<p>结点y的表：  </p>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">2</td>
<td align="center">∞</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">∞</td>
</tr>
</tbody></table>
<p>结点z的表：  </p>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
<td align="center">∞</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">∞</td>
<td align="center">6</td>
<td align="center">2</td>
<td align="center">∞</td>
<td align="center">0</td>
</tr>
</tbody></table>
<ol>
<li>第1次迭代<br>结点u的表：（变化）  </li>
</ol>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">v</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">∞</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">2</td>
<td align="center">∞</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">∞</td>
</tr>
</tbody></table>
<p>结点v的表：（变化）  </p>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">∞</td>
<td align="center">2</td>
<td align="center">∞</td>
</tr>
<tr>
<td align="center">v</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">∞</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">∞</td>
<td align="center">6</td>
<td align="center">2</td>
<td align="center">∞</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>结点x的表：（变化）  </p>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">∞</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">2</td>
<td align="center">∞</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">∞</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">∞</td>
<td align="center">6</td>
<td align="center">2</td>
<td align="center">∞</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>结点y的表：（变化）  </p>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">∞</td>
<td align="center">2</td>
<td align="center">∞</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">∞</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">5</td>
</tr>
</tbody></table>
<p>结点z的表：（变化）  </p>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">∞</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">∞</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">7</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">0</td>
</tr>
</tbody></table>
<ol start="2">
<li>第2次迭代<br>结点u的表：（变化）  </li>
</ol>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">v</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">5</td>
</tr>
</tbody></table>
<p>结点v的表：  </p>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">v</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">7</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>结点x的表：  </p>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">7</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>结点y的表：  </p>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">5</td>
</tr>
</tbody></table>
<p>结点z的表：（变化）  </p>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">6</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">0</td>
</tr>
</tbody></table>
<ol start="2">
<li>第3次迭代<br>结点v的表：  </li>
</ol>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">v</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">6</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>结点x的表：  </p>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">v</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">6</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>结点y的表：  </p>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">u</th>
<th align="center">v</th>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">5</td>
</tr>
</tbody></table>
<ol start="29">
<li><p>考虑一个一般性拓扑(即不是以上所显示的特定网络) 和一个同步版本的距离向量算法。假设每次迭代时，一个结点与其邻居交换其距离向量并接收它们的距离向量。假定算法开始时，每个结点只知道到其直接邻居的费用，在该分布式算法收敛前所需的最大迭代次数是多少?评估你的答案。</p>
<blockquote>
<p>收敛前所需的最大迭代次数是最长的无环路径。 </p>
</blockquote>
</li>
<li><p>考虑下图所示的网络段。x只有两个相连邻居w与y。w有一条通向目的地(没有显示)的最低费用路径，其值为5;y有一条通向目的地u的最低费用路径其值为6。从与y到u(以及w与y之间)的完整路径未显示出来。网络中所有链路费用皆为正整数值。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/y2.png" alt="?"><br>a给出x对目的地w、y和u的距离向量。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">从/到</th>
<th align="center">x</th>
<th align="center">w</th>
<th align="center">y</th>
<th align="center">u</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">w</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">5</td>
</tr>
</tbody></table>
<p>b.给出对c(x，w)或c(x，y)的链路费用的变化，使得执行了距离向量算法后，x将通知其邻居有一条通向u的新最低费用路径。</p>
<p>c.给出对c(x，w)或c(x，r)的链路费用的变化，使得执行了距离向量算法后，x将不通知其邻居有一条通向”的新最低费用路径。</p>
<ol start="35">
<li><p>描述在BGP中是如何检测路径中的环路的。</p>
<blockquote>
<p>如果路由器收到一个通告发现它所在的AS包含在AS-PATH中，则他将拒绝这个通告。</p>
</blockquote>
</li>
<li><p>一台BCP路由器将总是选择具有最短AS路径长度的无环路由吗?评估你的答案。</p>
<blockquote>
<p>不一定，因为路由器会被设置一些偏好，从而选择一些特殊的路径。</p>
</blockquote>
</li>
<li><p>考虑下图所示的网络。假定AS3和AS2正在运行OSPF作为其AS内部路由选择协议。假定AS1和AS4正在运行RIP作为其AS内部路由选择协议。假定AS间路由选择协议使用的是eBGP和iBGP。假定最初在AS2和AS4之间不存在物理链路。<br><img src="/2023/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/y3.png" alt="?"><br>a.路由器3c从下列哪个路由选择协议学习到了前缀x:OSPF、RIP、eBGP或iBGP?</p>
<blockquote>
<p>eBGP</p>
</blockquote>
</li>
</ol>
<p>b.路由器3a从哪个路由选择协议学习到了前缀x?</p>
<blockquote>
<p>iBGP</p>
</blockquote>
<p>c.路由器1c从哪个路由选择协议学习到了前缀x?</p>
<blockquote>
<p>eBGP</p>
</blockquote>
<p>d路由器1d从哪个路由选择协议学习到了前缀x?</p>
<blockquote>
<p>iBGP</p>
</blockquote>
<ol start="38">
<li>参考上一习题，一旦路由器1d知道了x的情况，它将一个表项(x，)放人其转发表中。</li>
</ol>
<p>a.对这个表项而言，I将等于1还是2?用一句话解释其原因。</p>
<blockquote>
<p>因为I1是到1c的最短路径</p>
</blockquote>
<p>b现在假定在AS2和AS4之间有一条物理链路，显示为图中的虚线。假定路由器1d知道经AS2以及经AS3能够访问到x。I将设置为还是L?用一句话解释其原因。</p>
<blockquote>
<p>2<br>因为在AS-PATH长度相同时，I2的内部路径最短</p>
</blockquote>
<p>c.现在假定有另一个AS，它称为AS5，其位于路径AS2和AS4之间(没有显示在图中)。假定路由器ld知道经AS2AS5AS4以及经AS3AS4能够访问到。将设置为还是L?用一话解释其原因</p>
<blockquote>
<p>I1<br>因为在AS-PATH长度更短</p>
</blockquote>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计网中的反码</title>
    <url>/2023/06/01/%E8%AE%A1%E7%BD%91%E4%B8%AD%E7%9A%84%E5%8F%8D%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>计网中udp报文头部中有一项检验和，书中这么说：</p>
<blockquote>
<p>发送方的UDP对报文段中的<strong>所有16比特字的和进行反码运算，求和时遇到的任何溢出都被回卷</strong>。得到的结果被放在UDP报文段中的检验和字段。</p>
</blockquote>
<p>书中是这么算的：<br><img src="/2023/06/01/%E8%AE%A1%E7%BD%91%E4%B8%AD%E7%9A%84%E5%8F%8D%E7%A0%81/1.png" alt="?"></p>
<blockquote>
<p><strong>注意到最后一次加法有溢出，它要被回卷。</strong><br><strong>反码运算就是将所有的0换成1，所有的1转换成0。因此，该和0100101011000010的反码运算结果是1011010100111101</strong></p>
</blockquote>
<p>这个“反码”和我们理解的反码不太一样，我们理解的反码是：<br><strong>原码为正的数不变，原码为负的数除了符号位其他取反。</strong><br>在书中他把所有的数都取了反，其实这里是因为翻译问题。</p>
<blockquote>
<p>one’s complement该单词直译为一的补数，这样理解就会十份直观，这个词的意思就是不管正负都按位取反，但在中文资料里将其等价为了反码(ones’ complement system or ones’ complement arithmetic)（一补数系统或算数一的补数）,意思是负数用1补数来表示，而正数保持原样，这是规定。因此而书本上明显是混淆了这两个概念，导致了理解的困难</p>
</blockquote>
<p><strong>这里的反码叫做二进制反码</strong><br>定义:将一个二进制数中的1变为0、0变为1以后所得的数。例如，1101010的反码为0010101。<br><strong>这种反码无视正负号</strong></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机中的原码、补码、反码</title>
    <url>/2023/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="机器数："><a href="#机器数：" class="headerlink" title="机器数："></a>机器数：</h4><p>一个数在计算机的存储形式是二进制数，我们称这些二进制数为机器数，机器数是有符号，在计算机中用机器数的最高位存放符号位，0表示正数，1表示负数。</p>
<h4 id="机器数的真值："><a href="#机器数的真值：" class="headerlink" title="机器数的真值："></a>机器数的真值：</h4><p>因为带有符号位，所以机器数的形式值不等于其真值，以机器数1000 0110为例，其真正表示的值为-6，而形式值为134。将带符号的机器数的真正表示的值称为机器数的真值。<br><strong>0表示+，1表示-</strong></p>
<h4 id="原码："><a href="#原码：" class="headerlink" title="原码："></a>原码：</h4><p>原码的表示与机器数真值表示的一样，即用第一位表示符号，其余位表示数值，例如的十进制的的正负1，用8位二进制的原码表示如下：<br>+1= 0000 0001<br>-1= 1000 0001 </p>
<h4 id="反码："><a href="#反码：" class="headerlink" title="反码："></a>反码：</h4><p>反码的表示方法为：<br>正数的反码是其原码本身。<br>负数的反码是在其原码的基础上，符号位不变，其余各位取反。<br>+1= 原：0000 0001 = 反：0000 0001<br>-1= 原：1000 0001 = 反：1111 1110 </p>
<h4 id="补码："><a href="#补码：" class="headerlink" title="补码："></a>补码：</h4><p>补码的表示方法为：<br>正数的补码是其原码本身。<br>负数的补码是在其原码的基础上，符号位不变，其余各位取反后加1（即在反码的基础上加1）。<br>+1= 原：0000 0001 = 反：0000 0001 = 补：0000 0001 </p>
<p>-1= 原：1000 0001 = 反：1111 1110 = 补：1111 1111</p>
<p><strong>计算机只存储补码</strong></p>
<h2 id="为何使用原码、反码、补码"><a href="#为何使用原码、反码、补码" class="headerlink" title="为何使用原码、反码、补码"></a>为何使用原码、反码、补码</h2><p>1.使用原码运算</p>
<p>计算十进制表达式：1-1 = 0；<br>1 - 1 = 1 + (-1)<br>= 原：[ 0000 0001 ] + 原：[ 1000 0001 ]<br>= 原：[ 1000 0010 ] = -2<br>如果用原码表示，让符号位也参与计算，对于减法来说，结果是不正确的。这也是计算机内部在存储数据时不使用原码的原因，<strong>为了解决这一问题，出现了反码。</strong></p>
<p>2.使用反码运算<br>计算十进制表达式：1-1 = 0</p>
<p>1 - 1 = 1 + (-1)<br>= 原：[ 0000 0001 ] + 原：[ 1000 0001 ]<br>= 反：[ 0000 0001 ] + 反：[ 1111 1110 ]<br>= 反：[ 1111 1111 ] = 原： [ 1000 0000 ] = -0<br>通过计算我们发现用反码计算减法，结果的真值部分是正确的。而唯一的问题出现在”0”这个特殊的数值上，虽然人们理解上**+0和-0<strong>是一样的，但是0带符号是没有任何意义的，而且会有[0000 0000]原和[1000 0000]原两个编码表示0。</strong>为了解决-0这一问题，出现了补码。**</p>
<p>3.使用补码运算<br>1 - 1 = 1 + (-1)<br>= 原：[ 0000 0001 ] + 原：[ 1000 0001 ]<br>= 补：[ 0000 0001 ] + 补：[ 1111 1111 ]<br>= 补： [ 0000 0000 ] = 原： [ 0000 0000 ] = 0<br>这样0用[0000 0000]表示，而以前出现问题的-0则不存在了，而且人们还发现可以用[1000 0000]表示-128，-128的推算过程如下：<br>(-1) + (-127) = -128<br>= 原：[1000 0001] + 原：[ 1111 1111 ]<br>= 补：[ 1111 1111 ] + 补：[ 1000 0001 ]<br>= 补：[ 1000 0000 ]</p>
<p>注意：因为实际上是使用以前的-0的补码来表示-128，所以-128并没有原码和反码表示，只要补码是[1000 0000]，其十进制数值就为-128。</p>
]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>求余和取模</title>
    <url>/2023/05/29/%E6%B1%82%E4%BD%99%E5%92%8C%E5%8F%96%E6%A8%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>求余符号看分子（被除数）</p>
<p>取模符号看分母（除数）。</p>
<p>C/C++的%是求余运算，python的%是取模运算。</p>
<p>c++在计算-1%256时，结果应该是255，因为-1除以256的商为0，余数为-1，而取模运算会将余数调整到0~255之间，所以最终结果为255。</p>
]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer-C++基础</title>
    <url>/2023/05/29/C-Primer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/2023/05/29/C-Primer/1.png" alt="?"></p>
<h1 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h1><p>C++是一种静态数据类型语言，它的类型检查发生在编译时。因此，编译器必须知道程序中每一个变量对应的数据类型。</p>
<p>数据类型是程序的基础:它告诉我们数据的意义以及我们能在数据上执行的操作。</p>
<h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><h3 id="算术类型"><a href="#算术类型" class="headerlink" title="算术类型"></a>算术类型</h3><p>算术类型分为两类:整型（integral type，包括字符和布尔类型在内）和浮点型。<br>算术类型的尺寸（也就是该类型数据所占的比特数）在不同机器上有所差别。<br><img src="/2023/05/29/C-Primer/2.png" alt="?"></p>
<p>布尔类型( bool）的取值是真（true）或者假（false）。</p>
<p>基本的字符类型是char,一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个 char的大小和一个机器字节一样。</p>
<p>其他字符类型用于扩展字符集，如wchar_t、char16_t、char32_t。wchar_t类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型 char16_t和char32_t则为Unicode字符集服务(Unicode是用于表示所有自然语言中字符的标准)。</p>
<h4 id="内置类型的机器实现"><a href="#内置类型的机器实现" class="headerlink" title="内置类型的机器实现"></a>内置类型的机器实现</h4><blockquote>
<p>大多数计算机以2的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为“字节(byte”,存储的基本单元称为“字(word”,它通常由几个字节组成。在C++语言中,一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由8比特构成，字则由32或64比特构成,也就是4或8字节。<br><img src="/2023/05/29/C-Primer/3.png" alt="?"></p>
<p>如果位置736424处的对象类型是float,并且该机器中float 以32比特存储,那么我们就能知道这个对象的内容占满了整个字。这个float数的实际值依赖于该机器是如何存储浮点数的。或者如果位置736424处的对象类型是unsigned char,并且该机器使用ISO-Latin-1字符集，则该位置处的字节表示一个分号。</p>
</blockquote>
<h4 id="带符号类型和无符号类型"><a href="#带符号类型和无符号类型" class="headerlink" title="带符号类型和无符号类型"></a>带符号类型和无符号类型</h4><p>除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的(signed）和无符号的(unsigned）两种。带符号类型可以表示正数、负数或0，无符号类型则仅能表示大于等于0的值。</p>
<p><strong>类型int、short、long和 long long都是带符号的</strong>，通过在这些类型名前添加unsigned就可以得到无符号类型，例如unsigned long。类型unsigned int可以缩写为unsigned。</p>
<p>与其他整型不同，字符型被分为了三种:char、 signed char和unsigned char.特别需要注意的是:类型char和类型signed char并不一样。尽管字符型有三种，但是字符的表现形式却只有两种:带符号的和无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。</p>
<p>C++标准并没有规定带符号类型应如何表示，<strong>但是约定了在表示范围内正值和负值的量应该平衡</strong>。因此，8比特的signed char理论上应该可以表示-127至127区间内的值，大多数现代计算机将实际的表示范围定为-128至127。</p>
<h4 id="如何选择类型"><a href="#如何选择类型" class="headerlink" title="如何选择类型"></a>如何选择类型</h4><p>当明确知晓数值不可能为负时,选用无符号类型。</p>
<p>在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。因为类型 char在一些机器上是有符号的,而在另一些机器上又是无符号的，所以如果使用char进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是signed char或者unsigned ch</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型转换(convert）为另一种相关类型。<br>当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool b = 42; // b为真</span><br><span class="line">int i = b; // i的值为1</span><br><span class="line">i = 3.14; // i的值为3</span><br><span class="line">double pi = i; //pi的值为3.0</span><br><span class="line">unsigned char c = -l; //假设 char占8比特，c的值为255</span><br><span class="line">signed char c2 = 256; //假设char 占8比特，c2的值是未定义的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为false,否则结果为true。</p>
<p>当我们把一个布尔值赋给非布尔类型时，初始值为false 则结果为0，初始值为true则结果为1。</p>
<p>当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。</p>
<p>当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。</p>
<p>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。<br>例如，8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小unsigned char所得的结果是255。（负数就从该符号的范围倒着数）</p>
<p><a href="https://codecodegogogo.github.io/2023/05/29/%E6%B1%82%E4%BD%99%E5%92%8C%E5%8F%96%E6%A8%A1/">求模和取余</a></p>
<p>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的(undefined)。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。</p>
<h4 id="避免无法预知和依赖于实现环境的行为"><a href="#避免无法预知和依赖于实现环境的行为" class="headerlink" title="避免无法预知和依赖于实现环境的行为"></a>避免无法预知和依赖于实现环境的行为</h4><p>程序也应该尽量避免依赖于实现环境的行为。如果我们把int的尺寸看成是一个确定不变的已知值，那么这样的程序就称作不可移植(nonportable)。当程序移植到别的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误可不是一件轻松愉快的工作。</p>
<p>在第一个输出表达式里，两个(负）整数相加并得到了期望的结果。在第二个输出表达式里，相加前首先把整数-42转换成无符号数。把负数转换成无符号数类似于直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned u = 10;int i = -42;</span><br><span class="line">std: : cout&lt;&lt; i +i&lt;&lt; std: :endl; //输出-84</span><br><span class="line">std::cout &lt;&lt; u +i &lt;&lt; std::endl;1/如果int占32位，输出4294967264</span><br></pre></td></tr></table></figure>
<p><strong>当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (unsigned u = 10; u &gt;= 0; --u)</span><br><span class="line">std: : cout&lt;&lt; u &lt;&lt; std: :endl;</span><br></pre></td></tr></table></figure>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> u = <span class="number">10</span>, u2 = <span class="number">42</span>;</span><br><span class="line">std::cout &lt;&lt; u2 - u &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; u - u2 &lt;&lt; std::endl;</span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>, i2 = <span class="number">42</span>;</span><br><span class="line">std::cout &lt;&lt; i2 - i &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; i - i2 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; i - u &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; u - i &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">4294967264</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">-32</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>


<h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3><h4 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h4><p>我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以0x或0x开头的代表十六进制数。例如，我们能用下面的任意一种形式来表示数值20:<br>20/* 十进制*/<br>024/<em>八进制</em>/<br>0x14/<em>十六进制</em>/</p>
<p>浮点型字面值表现为一个小数或以科学计数法表示的指数,其中指数部分用E或e标识:3.14159<br>3.14159EO<br>0.0e0<br>.001<br>默认的，浮点型字面值是一个double</p>
<h4 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h4><p>由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。<br>‘a’//字符字面值<br>“Hello world! “//字符串字面值<br>字符串字面值的类型实际上是由常量字符构成的数组（ array）。编译器在每个字符串的结尾处添加一个空字符(（ ‘\0’)，因此，字符串字面值的实际长度要比它的内容多1。例如，字面值’A’表示的就是单独的字符A，而字符串”A”则代表了一个字符的数组，该数组包含两个字符:一个是字母A、另一个是空字符。</p>
<h4 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L&#x27; a&#x27;</span><br><span class="line">//宽字符型字面值，类型是wchar_t</span><br><span class="line">u8&quot;hi ! &quot;</span><br><span class="line">l / utf-8字符串字面值（utf-8用8位编码一个Unicode字符）</span><br><span class="line">42ULL</span><br><span class="line">//无符号整型字面值，类型是unsigned long</span><br><span class="line">long</span><br><span class="line">1E-3F</span><br><span class="line">//单精度浮点型字面值，类型是float</span><br><span class="line">3.14159L</span><br><span class="line">//扩展精度浮点型字面值，类型是long double```</span><br><span class="line">![?](./C-Primer/4.png)</span><br></pre></td></tr></table></figure>
<h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指出下述字面值的数据类型并说明每一组内几种字面值的区别：</span><br><span class="line"></span><br><span class="line">(a) ‘a’, L’a’, “a”, L&quot;a&quot;</span><br><span class="line">(b) 10, 10u, 10L, 10uL, 012, 0xC</span><br><span class="line">© 3.14, 3.14f, 3.14L</span><br><span class="line">(d) 10, 10u, 10., 10e-2</span><br><span class="line">（a）字符字面值，宽字符字面值，字符串字面值，宽字符串字面值；</span><br><span class="line">（b）整形字面值，无符号整形字面值，长整形字面值，无符号长整形字面值，八进制整形字面值，十六进制整形字面值；</span><br><span class="line">（c）浮点型字面值，单精度浮点型字面值，扩展精度浮点型字面值；</span><br><span class="line">（d）整形字面值，无符号整形字面值，浮点型字面值，浮点型字面值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量提供一个具名的、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。对C++程序员来说，“变量 (variable)”和“对象(obiect)”一般可以百换使用。</p>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>变量定义的基本形式是:首先是类型说明符(type specifier)，随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。列表中每个变量名的类型都由类型说明符指定，定义时还可以为一个或多个变量赋初值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sum=0，value，</span><br><span class="line">units sold=0;</span><br><span class="line">// sum、value和units sold都是int// sum和unitssold初值为0</span><br></pre></td></tr></table></figure>
<h4 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h4><p>当对象在创建时获得了一个特定的值，我们说这个对象被初始化(initialized)了。用于初始化变量的值可以是任意复杂的表达式。当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。因此在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。</p>
<blockquote>
<p>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p>
</blockquote>
<h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><p>C++语言定义了初始化的好几种不同形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int unitssold=0;</span><br><span class="line">int unitssold=&#123;0&#125;;</span><br><span class="line">int unitssold(0);</span><br><span class="line">int unitssold&#123;0&#125;;</span><br></pre></td></tr></table></figure>
<p>作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用，这种初始化的形式被称为列表初始化 (list initialization)。现在，无论是初始化对象还是某些时候为对象赋新值，都可以使用这样一组由花括号括起来的初始值了。</p>
<p>当用于内置类型的变量时，这种初始化形式有一个重要特点:<strong>如果我们使用列表初始化且初始值存在丢失信息的风险</strong>，则编译器将报错:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long doubleld=3.1415926536;</span><br><span class="line">// 错误:转换未执行，因为存在丢失信息的危险</span><br><span class="line">inta&#123;ld&#125;，b=&#123;ld&#125;;</span><br><span class="line">//正确:转换执行，且确实丢失了部分值</span><br><span class="line">int c(ld)，d=ld;</span><br></pre></td></tr></table></figure>
<p>使用 long double 的值初始化 int 变量时可能丢失数据,所以编译器拒绝了 a和b的初始化请求。其中，至少ld 的小数部分会丢失掉，而且 nt 也可能存不下d 的整数部分。</p>
<h4 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h4><p>如果定义变量时没有指定初值，则变量被默认初始化(default initialized)，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。</p>
<p>如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。<br><strong>定义于任何函数体之外的变量被初始化为 0。定义在函数体内部的内置类型变量将不被初始化</strong> (uninitialized)。<br>一个未被初始化的内置类型变量的值是未定义的，如果试图贝或以其他形式访问此类值将引发错误。</p>
<p>每个类各自决定其初始化对象的方式。而且，<strong>是否允许不经初始化就定义对象也由类自己决定</strong>。如果类允许这种行为，它将决定对象的初始值到底是什么。绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。</p>
<blockquote>
<p>定义于任何函数体之外的变量被初始化为 0。<br>定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。<br>类的对象如果没有显式地初始化，则其值由类确定</p>
</blockquote>
<h4 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h4><blockquote>
<p>解释下列定义的含义，对于非法的定义，请说明错在何处并将其改正。<br>(a) std::cin &gt;&gt; int input_value;<br>(b) int i = { 3.14 };<br>(c)double salary = wage = 9999.99;<br>(d) int i = 3.14;<br>（编译时记得使用C++11标准编译”-std=c++11”）<br>(a)非法，&gt;&gt;运算符后不能定义；<br>(b)非法，不能执行强制转换；<br>©非法，同一语句的初始化应该分别进行；<br>(d)合法，已强制转换。</p>
</blockquote>
<blockquote>
<p>下列变量的初值分别是什么？<br>std::string global_str;<br>int global_int;<br>int main()<br>{<br>    int local_int;<br>    std::string local_str;<br>}</p>
<p>global_str,local_str为空字符串；<br>global_int为0；<br>local_int未初始化，没有初始值</p>
</blockquote>
<h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译。</p>
<p>如果将程序分为多个文件，则需要有在文件间共享代码的方法。例如，一个文件的代码可能需要使用另一个文件中定义的变量。一个实际的例子是 std::cout和std::cin,它们定义于标准库，却能被我们写的程序使用。</p>
<p>为了支持分离式编译，C++语言将声明和定义区分开来。声明(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义(definition)负责创建与名字关联的实体。</p>
<p>变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。</p>
<p>如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//声明i而非定义i</span><br><span class="line">externint i;</span><br><span class="line">intj;//声明并定义了</span><br></pre></td></tr></table></figure>


<p>任何包含了显式初始化的声明即成为定义。我们能给由extern 关键字标记的变量赋一个初始值，但是这么做也就抵消了extern 的作用。extern 语句如果包含初始值就不再是声明，而变成定义了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern doublepi=3.1416;//定义  </span><br></pre></td></tr></table></figure>

<p><strong>在函数体内部，如果试图初始化一个由extern 关键字标记的变量，将引发错误。</strong></p>
<p>变量能且只能被定义一次，但是可以被多次声明</p>
<h4 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h4><blockquote>
<p>指出下面的语句是声明还是定义：</p>
<p>(a) extern int ix = 1024;<br>(b) int iy;<br>(c)extern int iz;<br>（a）定义；<br>（b）定义；<br>（c）声明。</p>
</blockquote>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>C++的标识符(identifier)由字母、数字和下画线组成，其中必须以字母或下画线开头。标识符的长度没有限制，但是对大小写字母敏感:</p>
<p>同时，C++也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。</p>
<p>练习</p>
<blockquote>
<p>请指出下面的名字中哪些是非法的？</p>
<p>(a) int double = 3.14;<br>(b) int _;<br>(c)int catch-22;<br>(d) int 1_or_2 = 1;<br>(e) double Double = 3.14;<br>（a）非法，关键词；<br>（b）合法；<br>（c）非法；<br>（d）非法，字母、下划线开头；<br>（e）合法。</p>
</blockquote>
<h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>作用域(scope)是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以花括号分隔。<br>作用域能彼此包含，被包含(或者说被嵌套)的作用域称为内层作用域(inner scope),包含着别的作用域的作用域称为外层作用域(outer scope)。<br>作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时,允许在内层作用域中重新定义外层作用域已有的名字:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//输出#3:显式地访问全局变量reused;</span><br><span class="line">std::cout&lt;&lt;::reused&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>

<h4 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h4><blockquote>
<p>下面程序中 j 的值是多少？</p>
<p>int i = 42;<br>int main()<br>{<br>    int i = 100;<br>    int j = i;<br>}</p>
<p>100</p>
</blockquote>
<blockquote>
<p>下面的程序合法吗？如果合法，它将输出什么？</p>
<p>   int i = 100, sum = 0;<br>    for (int i = 0; i != 10; ++i)<br>        sum += i;<br>    std::cout &lt;&lt; i &lt;&lt; “ “ &lt;&lt; sum &lt;&lt; std::endl;</p>
</blockquote>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p>复合类型(compoundtype)是指基于其他类型定义的类型.</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用(reference)为对象起了另外一个名字，引用类型引用(refers to)另外一种类型通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ival=1024;</span><br><span class="line">int &amp;refVal=ival;  //refVal指向ival(是ival的另一个名字)</span><br><span class="line">int &amp;refVal2;  // 报错:引用必须被初始化</span><br></pre></td></tr></table></figure>

<p>在初始化变量时，初始值会被拷贝到新建的对象中。<br>然而定义引用时，程序把引用和它的初始值绑定 (bind)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</p>
<p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">refVal=2;//把2赋给 refVal指向的对象，此处即是赋给了ival</span><br><span class="line">int ii=refVal;//与ii=ival执行结果一样</span><br></pre></td></tr></table></figure>
<p>为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//正确:refVal3绑定到了那个与refVal绑定的对象上，这里就是绑定到ival上</span><br><span class="line">int &amp;refVal3 =refVal;</span><br><span class="line">//利用与 refVal绑定的对象的值初始化变量 i</span><br><span class="line">int i=refVal;   //正确:被初始化为ival的值</span><br></pre></td></tr></table></figure>
<p><strong>因为引用本身不是一个对象，所以不能定义引用的引用。</strong></p>
<h4 id="引用的定义"><a href="#引用的定义" class="headerlink" title="引用的定义"></a>引用的定义</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i=1024，i2=2048;//i和12都是int</span><br><span class="line">int &amp;r=i，r2=i2;//r是一个引用，与i绑定在一起，r2是int </span><br><span class="line">int i3=1024，&amp;ri=i3;  //i3是int，ri是一个引用，与3绑定在一起</span><br><span class="line">int &amp;r3=i3，&amp;r4=2; //r3和r4都是引用</span><br></pre></td></tr></table></figure>

<p>引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int &amp;refVal4=10;  //错误:引用类型的初始值必须是一个对象</span><br><span class="line">double dval=3.14;</span><br><span class="line">int &amp;refVal5=dval; //错误:此处引用类型的初始值必须是 int 型对象</span><br><span class="line">int i=3;</span><br><span class="line">int &amp;refVal5=i;</span><br><span class="line">refVal5=i;  //类型不一样也可以，触发隐式类型转换</span><br></pre></td></tr></table></figure>
<p><strong>除了初始化要注意一些细节。不能换引用值，其他都和普通变量无异。</strong></p>
<h4 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h4><blockquote>
<p>下面的哪个定义是不合法的？为什么？</p>
<p>(a) int ival = 1.01;<br>(b) int &amp;rval1 = 1.01;<br>(c)int &amp;rval2 = ival;<br>(d) int &rval3;<br>（a）合法；隐式类型转换（b）不合法，引用类型的初始值必须是一个对象；<br>（c）合法；（d）不合法，引用类型必须初始化。</p>
</blockquote>
<blockquote>
<p>考察下面的所有赋值然后回答：哪些赋值是不合法的？为什么？哪些赋值是合法的？它们执行了哪些操作？</p>
<p>int i = 0, &amp;r1 = i; double d = 0, &amp;r2 = d;<br>(a) r2 = 3.14159;<br>(b) r2 = r1;<br>(c) i = r2;<br>(d) r1 = d;<br>（a）合法，将3.14159赋值给r2所引用的对象d。<br>（b）合法，将r1所引用的对象i的值赋值给r2所引用的对象d。<br>（c）合法，将r2所引用的对象d的值赋值给i。<br>（d）合法，将d的值赋值给r1所引用的对象i。</p>
</blockquote>
<blockquote>
<p>执行下面的代码段将输出什么结果？</p>
<p>int i, &amp;ri = i;<br>std::cout &lt;&lt; i &lt;&lt; “ “ &lt;&lt; ri &lt;&lt; std::endl;<br>i = 5; ri = 10;<br>std::cout &lt;&lt; i &lt;&lt; “ “ &lt;&lt; ri &lt;&lt; std::endl;<br>随机 随机 10 10</p>
</blockquote>
<p>函数体外初始化为0，函数体内不初始化，i和ri指向同一对象。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针(pointer)是“指向(point to)”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</p>
<h4 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a>获取对象的地址</h4><p>指针存放某个对象的地址，要想获取该地址，需要使用取地址符(操作符&amp;):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ival=42;</span><br><span class="line">int *p=&amp;ival; // p存放变量ival的地址，或者说p是指向变量ival的指针</span><br></pre></td></tr></table></figure>
<p>第二条语句把p定义为一个指向int 的指针，随后初始化p令其指向名为ival的int对象。<strong>因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double dval;</span><br><span class="line">double*pd=&amp;dval;//正确:初始值是 double型对象的地址</span><br><span class="line">double*d2=pd;//正确:初始值是指向 double对象的指针</span><br><span class="line">int*pi=pd;//错误:指针pi的类型和pd的类型不匹配</span><br><span class="line">pi=&amp;dval;//错误:试图把 double型对象的地址赋给 int 型指针</span><br></pre></td></tr></table></figure>
<p>因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。</p>
<h4 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a>利用指针访问对象</h4><p>如果指针指向了一个对象，则允许使用解引用符(操作符*)来访问该对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ival=42;</span><br><span class="line">cout &lt;&lt;*p;// p存放着变量ival的地址，或者说p是指向变量ival的指针</span><br><span class="line">int *p= &amp;ival; // 由符号*得到指针p所指的对象，输出42</span><br></pre></td></tr></table></figure>
<p>对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*p=0;//由符号*得到指针p所指的对象，即可经由p为变量ival赋值</span><br><span class="line">cout &lt;&lt;*p;//输出0</span><br></pre></td></tr></table></figure>
<p>如上述程序所示，为*p 赋值实际上是为 p 所指的对象赋值</p>
<h4 id="某些符号有多重含义"><a href="#某些符号有多重含义" class="headerlink" title="某些符号有多重含义"></a>某些符号有多重含义</h4><p>像&amp;和*这样的符号,既能用作表达式里的运算符,也能作为声明的一部分出现,符号的上下文决定了符号的意义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i=42;</span><br><span class="line">int &amp;r=i; //&amp;紧随类型名出现，因此是声明的一部分，r是一个引用</span><br><span class="line">int *p; //*紧随类型名出现，因此是声明的一部分，p是一个指针</span><br><span class="line">p=&amp;i;   //&amp;出现在表达式中，是一个取地址符</span><br><span class="line">*p=i;   //*出现在表达式中，是一个解引用符</span><br><span class="line">int &amp;r2=*p; &amp;是声明的一部分,*是一个解引用符</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>空指针（null pointer）不指向任何对象，在试图使用个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *pl = nullptr; //等价于int *pl =0;</span><br><span class="line">int *p2 = 0 ; //直接将p2初始化为字面常量0</span><br><span class="line">//需要首先#include cstdlib</span><br><span class="line">int *p3 =NULL;  //等价于int*p3 = 0;</span><br></pre></td></tr></table></figure>

<p>得到空指针最直接的办法就是用字面值nullptr来初始化指针<br>过去的程序还会用到一个名为NULL的预处理变量(preprocessor variable）来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0.</p>
<p>预处理变量不属于命名空间std，它由预处理器负责管理，因此我们可以直接使用预处理变量而无须在前面加上std::，当用到一个预处理变量时，预处理器会自动地将它替换为实际值</p>
<p>把int变量直接赋给指针是错误的操作，即使int变量的值恰好等于0也不行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int zero = 0;</span><br><span class="line">pi = zero;</span><br><span class="line">//错误:不能把int变量直接赋给指针</span><br></pre></td></tr></table></figure>

<h4 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a>赋值和指针</h4><p>指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。</p>
<p>指针和它存放的地址之间就没有这种限制了。和其他任何变量(只要不是引用)一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i=42;</span><br><span class="line">int *pi=0; // pi被初始化，但没有指向任何对象</span><br><span class="line">int *pi2=&amp;i; //pi2被初始化，存有i的地址</span><br><span class="line">int *pi3;  //如果pi3定义域块内，则pi3的值是无法确定的</span><br><span class="line">pi3=pi2; //他们指向同一对象</span><br><span class="line">pi2=0; //pi2不知向那个对象了</span><br></pre></td></tr></table></figure>

<h4 id="其他指针操作"><a href="#其他指针操作" class="headerlink" title="其他指针操作"></a>其他指针操作</h4><p>只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件遵循的规则类似，如果指针的值是0，条件取false，任何非О指针对应的条件值都是true。</p>
<p>对于两个类型相同的合法指针，可以用相等操作符(==）或不相等操作符(!=）来比较它们，比较的结果是布尔类型。如果两个指针存放的地址值相同，则它们相等;反之它们不相等。</p>
<h4 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a>void*指针</h4><p>void*是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double obj = 3.14, *pd = &amp;obj; //正确:void*能存放任意类型对象的地址</span><br><span class="line">void *pv = &amp;obj; // obj可以是任意类型的对象</span><br><span class="line">pv = pd;// pv可以存放任意类型的指针</span><br></pre></td></tr></table></figure>
<p><strong>以 void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象</strong></p>
<h4 id="练习-6"><a href="#练习-6" class="headerlink" title="练习"></a>练习</h4><blockquote>
<p>说明指针和引用的主要区别<br>1.指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象；2.指针无须在定义时赋初值。</p>
</blockquote>
<blockquote>
<p>请叙述下面这段代码的作用。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">int *p1 = &amp;i; </span><br><span class="line">*p1 = *p1 * *p1;</span><br></pre></td></tr></table></figure>
<p>p指向i，i最后的值为1746（42*42）</p>
<blockquote>
<p>请解释下述定义。在这些定义中有非法的吗？如果有，为什么？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">(a) double* dp = &amp;i;</span><br><span class="line">(b) int *ip = i;</span><br><span class="line">(c) int *p = &amp;i;</span><br><span class="line">（a）非法，一个是double*，一个是int*；</span><br><span class="line">（b）非法，一个是int*，一个是int,直接赋值0可以；</span><br><span class="line">（c）合法。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设 p 是一个 int 型指针，请说明下述代码的含义。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (p) // ...</span><br><span class="line">if (*p) // ...</span><br><span class="line">指针是不是空指针；</span><br><span class="line">指针所指的对象是不是0。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在下面这段代码中为什么 p 合法而 lp 非法？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">void *p = &amp;i;</span><br><span class="line">long *lp = &amp;i;</span><br><span class="line">类型不一样，void*可以表示任何类型的对象。</span><br></pre></td></tr></table></figure>

<h3 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h3><p>在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说，一条定义语句可能定义出不同类型的变量:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// i是一个int型的数，p是一个int型指针，r是一个int型引用</span><br><span class="line">int i =1024,*p = &amp;i,&amp;r = i;</span><br></pre></td></tr></table></figure>
<p>int* p基本数据类型是int而非int<em>。</em>仅仅是修饰了p而已，对该声明语句中的其他变量，它并不产生任何作用:</p>
<h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p>一般来说，声明符中修饰符的个数并没有限制。当有多个修饰符连写在一起时，按照其逻辑关系详加解释即可。以指针为例，指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ival =1024;</span><br><span class="line">int *pi = &amp;ival; //pi指向一个int型的数</span><br><span class="line">int * *ppi =&amp;pi; //ppi指向一个int型的指针</span><br></pre></td></tr></table></figure>
<p><img src="/2023/05/29/C-Primer/5.png" alt="?"></p>
<h4 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h4><p>引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">int *p; // p是一个int型指针</span><br><span class="line">int *&amp;r= p; //r是一个对指针p的引用</span><br><span class="line">r = &amp;i; // r引用了一个指针，因此给r赋值&amp;i就是令p指向i</span><br><span class="line">*r= 0; //解引用r得到i，也就是p指向的对象，将i的值改为0</span><br></pre></td></tr></table></figure>
<p>要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义。离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int指针。</p>
<p><strong>面对一条比较复杂的指针或引用的声明语句时,从右向左阅读有助于弄清楚它的真实含义。</strong></p>
<h4 id="练习-7"><a href="#练习-7" class="headerlink" title="练习"></a>练习</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明下列变量的类型和值。</span><br><span class="line"></span><br><span class="line">(a) int* ip, i, &amp;r = i;</span><br><span class="line">(b) int i, *ip = 0;</span><br><span class="line">(c)int* ip, ip2;</span><br><span class="line">（a）指向int的指针，int类型，int的引用；</span><br><span class="line">（b）int类型，int类型的指针；</span><br><span class="line">（c）int类型指针，int类型。</span><br></pre></td></tr></table></figure>


<h2 id="const-限定符"><a href="#const-限定符" class="headerlink" title="const 限定符"></a>const 限定符</h2><p><strong>此书中指针常量一类概念和我们常说的是相反的。<br>本书推崇从右往左看等号左边的符号。<br>指针常量此书中叫做常量指针。 const pointer<br>常量指针称为指向常量的指针  pointer to const</strong></p>
<p>有时我们希望定义这样一种变量,它的值不能被改变。<br>使用关键字const对变量的类型加以限定:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int bufsize = 512;</span><br></pre></td></tr></table></figure>

<p>这样就把bufSize定义成了一个常量。任何试图为buffSize赋值的行为都将引发错误:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bufSize = 512; //错误:试图向const对象写值</span><br></pre></td></tr></table></figure>
<p>因为const对象一旦创建后其值就不能再改变,所以const对象必须初始化。一如既往，初始值可以是任意复杂的表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int i = get_size();</span><br><span class="line">//正确:运行时初始化</span><br><span class="line">const int j= 42;</span><br><span class="line">//正确:编译时初始化</span><br><span class="line">const int k;</span><br><span class="line">//错误:k是一个未经初始化的常量</span><br></pre></td></tr></table></figure>


<p>在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是 const都无关紧要:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i =42;</span><br><span class="line">const int ci = i;//正确:i值被拷贝给了ci</span><br><span class="line">int j= ci; //正确:ci的值被拷贝给了j</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>尽管ci是整型常量，但无论如何ci中的值还是一个整型数。ci的常量特征仅仅在执行改变ci的操作时才会发挥作用。当用ci去初始化j时，根本无须在意ci是不是一个常量。拷贝一个对象的值并不会改变它，一旦拷贝完成，新的对象就和原来的对象没什么关系了。</p>
<p>当以编译时初始化的方式定义一个const对象时，就如对 bufSize的定义一样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int bufSize = 512;//输入缓冲区大小`</span><br></pre></td></tr></table></figure>
<p>编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。</p>
<p><strong>如果想在多个文件之间共享const对象,必须在变量的定义之前添加extern关键字。</strong></p>
<h3 id="练习-8"><a href="#练习-8" class="headerlink" title="练习"></a>练习</h3><blockquote>
<p>下面哪些语句是合法的？如果不合法，请说明为什么？</p>
<p>const int buf;<br>int cnt = 0;<br>const int sz = cnt;<br>++cnt; ++sz;<br>（a）不合法，const int必须初始化；<br>（b）合法；<br>（c）合法；<br>（d）++cnt，合法；++sz，不合法，const int不能改变。</p>
</blockquote>
<h3 id="const-的引用"><a href="#const-的引用" class="headerlink" title="const 的引用"></a>const 的引用</h3><p><strong>此书中指针常量与常量指针和网上相反</strong></p>
<p>可以把引用绑定到 const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用（reference to const)。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int ci = 1024;</span><br><span class="line">const int &amp;rl = ci;1/正确:引用及其对应的对象都是常量</span><br><span class="line">rl = 42;//错误:r1是对常量的引用</span><br><span class="line">int &amp;r2= ci;//错误:试图让一个非常量引用指向一个常量对象</span><br></pre></td></tr></table></figure>

<h3 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="headerlink" title="初始化和对const的引用"></a>初始化和对const的引用</h3><p><strong>普通引用不允许表达式，常引用可以。普通引用不能绑定常量，常引用可以绑定普通变量，他自己不能改此变量但别人可以改。</strong></p>
<p>引用的类型必须与其所引用对象的类型一致，但是有两个例外。<br>第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i =42;·</span><br><span class="line">const int &amp;rl = i;//允许将const int&amp;绑定到一个普通int对象上</span><br><span class="line">const int &amp;r2= 42;//正确:r1是一个常量引用</span><br><span class="line">const int &amp;r3 = r1 * 2;//正确:r3是一个常量引用</span><br><span class="line">int &amp;r4 = r1 * 2; //错误:r4是一个普通的非常量引用</span><br></pre></td></tr></table></figure>


<p>此处ri引用了一个int型的数。对 ri的操作应该是整数运算，但dval却是一个双精度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器把上述代码变成了如下形式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double dval = 3.14;</span><br><span class="line">const int &amp;ri = dval;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//由双精度浮点数生成一个临时的整型常量</span><br><span class="line">const int temp = dval;</span><br><span class="line">const int &amp;ri = temp;</span><br><span class="line">// 让ri绑定这个临时量</span><br></pre></td></tr></table></figure>


<h4 id="对const的引用可能引用一个并非const的对象"><a href="#对const的引用可能引用一个并非const的对象" class="headerlink" title="对const的引用可能引用一个并非const的对象"></a>对const的引用可能引用一个并非const的对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i=42;</span><br><span class="line">int &amp;r1 = i;//引用ri绑定对象i</span><br><span class="line">const int &amp;r2 = i;// r2也绑定对象i，但是不允许通过r2修改i的值</span><br><span class="line">r1 = 0;// r1并非常量，i的值修改为0</span><br><span class="line">r2= 0;//错误:r2是一个常量引用</span><br></pre></td></tr></table></figure>
<p>r2绑定（非常量）整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此，i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像r1一样绑定到i的其他引用来修改。</p>
<h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p>与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针（ pointer to const）不能用于改变其所指对象的值。<strong>这就是我们俗称的常量指针</strong><br>要想存放常量对象的地址，只能使用指向常量的指针:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const double pi = 3.14;</span><br><span class="line">// pi是个常量，它的值不能改变</span><br><span class="line">double *ptr = &amp;pi;</span><br><span class="line">//错误:ptr是一个普通指针</span><br><span class="line">const double *cptr = &amp;pi;</span><br><span class="line">//正确:cptr可以指向一个双精度常量</span><br><span class="line">*cptr = 42;</span><br><span class="line">//错误:不能给*cptr赋值</span><br></pre></td></tr></table></figure>

<p>指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double dval = 3.14;</span><br><span class="line">ll dval是一个双精度浮点数，它的值可以改变</span><br><span class="line">cptr = &amp;dval;</span><br><span class="line">//正确:但是不能通过cptr改变dval的值</span><br></pre></td></tr></table></figure>

<p>和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。</p>
<p><strong>试试这样想吧:所谓指向常量的指针或引用，不过是指针或引用目以为定罢了，它们觉得自已己指向了常量，所以自觉地不去改变所指对象的值。</strong></p>
<h4 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h4><p>指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针(const pointer）必须初始化，<strong>此处的常量指针就是我们俗称的指针常量</strong><br>而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int errNumb = 0;</span><br><span class="line">int *const curErr = &amp;errNumb;</span><br><span class="line">// curErr将一直指向errNumb</span><br><span class="line">const double pi = 3.14159;</span><br><span class="line">const double *const pip = &amp;pi;</span><br><span class="line">// pip 是一个指向常量对象的常量指针</span><br></pre></td></tr></table></figure>

<h4 id="练习-9"><a href="#练习-9" class="headerlink" title="练习"></a>练习</h4><p>下面的哪些初始化是合法的？请说明原因。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = -1, &amp;r = 0;</span><br><span class="line">int *const p2 = &amp;i2;</span><br><span class="line">const int i = -1, &amp;r = 0;</span><br><span class="line">const int *const p3 = &amp;i2;</span><br><span class="line">const int *p1 = &amp;i2;</span><br><span class="line">const int &amp;const r2;</span><br><span class="line">const int i2 = i, &amp;r = i;</span><br><span class="line">1. 不合法，引用必须绑定在一个对象上，0 是一个字面常量，不是一个对象。</span><br><span class="line">2. 合法，p2 是一个指向 i 的常量指针。</span><br><span class="line">3. 合法，i 是一个常量整数，r 是一个绑定在字面常量 0 上的常量引用。</span><br><span class="line">4. 合法，p3 是一个指向 i2 的常量指针。</span><br><span class="line">5. 合法，p1 是一个指向 i2 的指针。</span><br><span class="line">6. 不合法，没有初始值。</span><br><span class="line">7. 合法，i2 是一个整数常量，r 是一个绑定在 i 上的常量引用。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明下面的这些定义是什么意思，挑出其中不合法的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i, *const cp;</span><br><span class="line">int *p1, *const p2;</span><br><span class="line">const int ic, &amp;r = ic;</span><br><span class="line">const int *const p3;</span><br><span class="line">const int *p;</span><br><span class="line">（a）不合法，常量指针未初始化；</span><br><span class="line">（b）不合法，常量指针未初始化；</span><br><span class="line">（c）不合法，常量ic未初始化；</span><br><span class="line">（d）不合法，常量指针未初始化；</span><br><span class="line">（e）合法，指向常量的指针可以不初始化。 本质是指针</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设已有上一个练习中定义的那些变量，则下面的哪些语句是合法的？请说明原因。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i = ic;</span><br><span class="line">p1 = p3;</span><br><span class="line">p1 = &amp;ic;</span><br><span class="line">p3 = &amp;ic;</span><br><span class="line">p2 = p1;</span><br><span class="line">ic = *p3;</span><br><span class="line">（a）合法；</span><br><span class="line">（b）非法，p3是指向const int的指针；</span><br><span class="line">（c）非法，ic是const int；</span><br><span class="line">（d）非法，p3是常量指针，不能再次赋值；</span><br><span class="line">（e）非法，p2是常量指针，不能再次赋值；</span><br><span class="line">（f）非法，ic是const int。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>用名词顶层const( top-level const）表示指针本身是个常量，而用名词底层const (low-level const）表示指针所指的对象是一个常量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">int *const pl = &amp;i;</span><br><span class="line">//不能改变p1的值，这是一个顶层const</span><br><span class="line">const int ci = 42;</span><br><span class="line">//不能改变ci的值，这是一个顶层const</span><br><span class="line">const int *p2= &amp;ci;</span><br><span class="line">//允许改变p2的值，这是一个底层const</span><br><span class="line">const int *const p3 = p2; // 靠右的const是顶层，靠做的是底层const int &amp;r = ci;</span><br><span class="line">//用于声明引用的const都是底层const</span><br></pre></td></tr></table></figure>
<p><strong>作用后不能改变本身的值是顶层，不能改变所指对象的值是底层</strong></p>
<p>当执行对象的铂贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响，<br>底层 const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。<strong>一般来说，非常量可以转换成常量</strong>，反之则不行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *p= p3;</span><br><span class="line">//错误:p3包含底层const的定义，而p没有</span><br><span class="line">p2 = p3;</span><br><span class="line">//正确:p2和p3都是底层const</span><br><span class="line">p2= &amp;i;</span><br><span class="line">//正确:int*能转换成const int*</span><br><span class="line">int &amp;r = ci;</span><br><span class="line">//错误:普通的int&amp;不能绑定到int常量上</span><br><span class="line">const int &amp;r2 = i;</span><br><span class="line">//正确:const int&amp;可以绑定到一个普通int 上</span><br></pre></td></tr></table></figure>

<h4 id="练习-10"><a href="#练习-10" class="headerlink" title="练习"></a>练习</h4><blockquote>
<p>对于下面的这些语句，请说明对象被声明成了顶层const还是底层const？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int v2 = 0; int v1 = v2;</span><br><span class="line">int *p1 = &amp;v1, &amp;r1 = v1;</span><br><span class="line">const int *p2 = &amp;v2, *const p3 = &amp;i, &amp;r2 = v2;</span><br><span class="line">v2不能改变，是顶层const；v1都不是；p1都不是，r1都不是；p2所指的对象不能改变，底层const；p3既是顶层，又是底层；r2底层。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设已有上一个练习中所做的那些声明，则下面的哪些语句是合法的？请说明顶层const和底层const在每个例子中有何体现。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r1 = v2;</span><br><span class="line">p1 = p2;</span><br><span class="line">p2 = p1;</span><br><span class="line">p1 = p3;</span><br><span class="line">p2 = p3;</span><br><span class="line">r1 = v2; // 合法，v2为顶层const</span><br><span class="line">p1 = p2; // 非法，p2为底层const</span><br><span class="line">p2 = p1; // 合法</span><br><span class="line">p1 = p3; // 非法</span><br><span class="line">p2 = p3; // 合法</span><br></pre></td></tr></table></figure>


<h3 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h3><p><strong>常量表达式(const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。</strong>显然，字面值属于常量表达式，用常量表达式初始化的 const对象也是常量表达式。后面将会提到，C++语言中有几种情况下是要用到常量表达式的。<br>一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int max__files = 20;</span><br><span class="line">// max_files是常量表达式</span><br><span class="line">const int limit = max_files + l; // limit是常量表达式</span><br><span class="line">int staff_size= 27;</span><br><span class="line">// staff_size不是常量表达式</span><br><span class="line">const int sz = get_size();</span><br><span class="line">// sz不是常量表达式</span><br></pre></td></tr></table></figure>
<p>尽管staff _size的初始值是个字面值常量，但由于它的数据类型只是一个普通int而非const int，所以它不属于常量表达式。另一方面,<br>尽管sz本身是一个常量，但它<br>的具体值直到运行时才能获取到,所以也不是常量表达式。</p>
<h4 id="constexpr变量"><a href="#constexpr变量" class="headerlink" title="constexpr变量"></a>constexpr变量</h4><p>C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constexpr int mf = 20;</span><br><span class="line">/l20是常量表达式</span><br><span class="line">constexpr int limit = mf + 1;</span><br><span class="line">ll mf + 1是常量表达式</span><br><span class="line">//只有当size是一个constexpr函数时</span><br><span class="line">constexpr int Sz= size() ;</span><br><span class="line">//才是一条正确的声明语句</span><br></pre></td></tr></table></figure>
<h4 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h4><p>常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”(literal type)。<br>到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。自定义类sales_item、IO 库、string 类型则不属于字面值类型，也就不能被定义成constexpr。</p>
<h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><p>随着程序越来越复杂,程序中用到的类型也越来越复杂，它们的名字既难记又容易写错，还无法明确体现其真实目的和含义。有时候根本搞不清到底需要的类型是什么。</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>有两种方法可用于定义类型别名。传统的方法是使用关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef:typedef double wages;// wages是double的同义词</span><br><span class="line">typedef wages base,*p;//base是double的同义词,p是double*的同义词</span><br></pre></td></tr></table></figure>
<p>新标准规定了一种新的方法，使用别名声明（alias declaration）来定义类型的别名:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using ST = Sales_item;</span><br><span class="line">//SI是sales_item的同义词</span><br></pre></td></tr></table></figure>

<h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。然而要做到这一点并非那么容易，有时甚至根本做不到。为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如 double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//由val1和val2相加的结果可以推断出item的类型</span><br><span class="line">auto item = vall + val2;// item初始化为val1和val2相加的结果</span><br></pre></td></tr></table></figure>

<p>使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto i = 0, *p = &amp;i;/正确:i是整数、p是整型指针</span><br><span class="line">auto sz = 0,pi = 3.14;//错误:sz和pi的类型不一致</span><br></pre></td></tr></table></figure>

<h4 id="复合类型、常量和auto"><a href="#复合类型、常量和auto" class="headerlink" title="复合类型、常量和auto"></a>复合类型、常量和auto</h4><p>其次，<strong>auto一般会忽略掉顶层const</strong>，同时底层const则会保留下来,比如当初始值是一个指向常量的指针时:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int ci = i, &amp;cr = ci;</span><br><span class="line">auto b = ci;// b是一个整数（ci的顶层const特性被忽略掉了)</span><br><span class="line">auto c = cr; // c是一个整数（cr是ci的别名，ci本身是一个顶层const)</span><br><span class="line">auto d = &amp;i;// d是一个整型指针（整数的地址就是指向整数的指针)</span><br><span class="line">auto e = sci; // e是一个指向整数常量的指针（对常量对象取地址是一种底层const)</span><br></pre></td></tr></table></figure>
<p><strong>对常量对象取地址是一种底层const</strong></p>
<p><strong>如果希望推断出的auto类型是一个顶层const</strong>，需要明确指出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ci的推演类型是int，f是const int</span><br><span class="line">const auto f = ci;</span><br></pre></td></tr></table></figure>


<p>设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto &amp;g = ci;</span><br><span class="line">// g是一个整型常量引用，绑定到ci</span><br><span class="line">auto &amp;h = 42;</span><br><span class="line">//错误:不能为非常量引用绑定字面值</span><br><span class="line">const auto &amp;j= 42;</span><br><span class="line">//正确:可以为常量引用绑定字面值</span><br></pre></td></tr></table></figure>
<p><strong>如果初始值是一个顶层常量，则定义出来的引用也是一个顶层常量引用。<br>如果初始值是一个非常量，则定义出来的引用也是一个非常量引用。</strong></p>
<p><strong>在C++中，整数值不能直接赋值给指针变量，因为它们的数据类型不同。指针变量必须存储一个有效的内存地址，而整数值只是一个数值，它没有内存地址。</strong></p>
<h4 id="练习-11"><a href="#练习-11" class="headerlink" title="练习"></a>练习</h4><blockquote>
<p>判断下列定义推断出的类型是什么，然后编写程序进行验证。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int i = 42;</span><br><span class="line">auto j = i; const auto &amp;k = i; auto *p = &amp;i; </span><br><span class="line">const auto j2 = i, &amp;k2 = i;</span><br><span class="line">j int；k 常量int的引用；常量int的指针；j2 常量int；k2常量 int的引用。</span><br></pre></td></tr></table></figure>

<h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">decltype(f() ) sum = x; / / sum的类型就是函数f的返回类型</span><br></pre></td></tr></table></figure>
<p>decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量,则decltype返回该变量的类型(包括顶层const和引用在内):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int ci = 0, &amp;cj- ci;decltype(ci) x = 0;</span><br><span class="line">// x的类型是const int</span><br><span class="line">decltype(cj）y= X;</span><br><span class="line">// y的类型是const int&amp;，y绑定到变量x</span><br><span class="line">decltype(cj）z;</span><br><span class="line">//错误:z是一个引用，必须初始化</span><br></pre></td></tr></table></figure>
<p>因为r是一个引用，因此 decltype (r)的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体值而非一个引用。</p>
<p>另一方面，如果表达式的内容是解引用操作，则decltype 将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype(*p)的结果类型就是int&amp;，而非int。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// decltype的表达式如果是加上了括号的变量，结果将是引用decltype((i))d;</span><br><span class="line">//错误:d是int&amp;，必须初始化</span><br><span class="line">decltype(i) e;</span><br><span class="line">//正确:e是一个（未初始化的) int</span><br></pre></td></tr></table></figure>
<p><strong>decltype中表达式产生左值就返回引用</strong><br><strong>切记:decltype ((variable))（注意是双层括号）的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。</strong></p>
<h4 id="练习-12"><a href="#练习-12" class="headerlink" title="练习"></a>练习</h4><blockquote>
<p>关于下面的代码，请指出每一个变量的类型以及程序结束时它们各自的值。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 3, b = 4;</span><br><span class="line">decltype(a) c = a;</span><br><span class="line">decltype((b)) d = a;</span><br><span class="line">++c;</span><br><span class="line">++d;</span><br><span class="line"></span><br><span class="line">a int；b int；c int；d int &amp;。</span><br><span class="line">4；4；4；4。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int&amp;。根据这一特点，请指出下面的代码中每一个变量的类型和值。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 3, b = 4;</span><br><span class="line">decltype(a) c = a;</span><br><span class="line">decltype(a = b) d = a;</span><br><span class="line">a int 3；</span><br><span class="line">b int 4；</span><br><span class="line">c int 3；</span><br><span class="line">d int &amp; 3。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明由decltype 指定类型和由auto指定类型有何区别。请举一个例子，decltype指定的类型与auto指定的类型一样；再举一个例子，decltype指定的类型与auto指定的类型不一样。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果使用引用类型，auto会识别为其引用对象的类型；</span><br><span class="line">decltype会识别为引用的类型；</span><br><span class="line">decltype(())的差别；</span><br><span class="line">顶层const差异。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>23种设计模式</title>
    <url>/2023/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-自定向下-第三章运输层</title>
    <url>/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>运输层协议是在端系统中而不是在路由器中实现的。在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层报文段（segment)。实现的方法（可能）是将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段。然后，在发送端系统中，运输层将这些报文段传递给网络层，网路层将其封装成网络层分组（即数据报）并向目的地发送。</p>
<p>注意到下列事实是重要的:<br>网络路由器仅作用于该数据报的网络层字段;即它们不检查封装在该数据报的运输层报文段的字段。在接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层。运输层则处理接收到的报文段，使该报文段中的数据为接收应用进程使用。<br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/1.png"></p>
<h3 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h3><p>网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信。<br>即使底层网络协议是不可靠的，也就是说网络层协议会使分组丢失、郝改和冗余，运输协议也能为应用程序提供可靠的数据传输服务。另一个例子是（我们在第8章讨论网络安全时将会研究到)，即使网络层不能保证运输层报文段的机密性，运输协议也能使用加密来确保应用程序报文不被入侵者读取。</p>
<h3 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h3><p>UDP(用户数据报协议)，它为调用它的应用程序提供了一种不可靠、无连接的服务。<br>TCP（传输控制协议)，它为调用它的应用程序提供了一种可靠的、面向连接的服务。</p>
<p>UDP和TCP最基本的责任是，将两个端系统间iP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为运输层的多路复用( transport-layer multiplexing）与多路分解（demultiplexing)。</p>
<p>TCP为应用程序提供了几种附加服务。首先，它提供可靠数据传输（reliabledata transfer）。通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据从发送进程交付给接收进程<br>这样，TCP就将两个端系统间的不可靠iP服务转换成了一种进程间的可靠数据传输服务。</p>
<p>TCP 还提供拥塞控制（conges-tion control）。拥塞控制与其说是一种提供给调用它的应用程序的服务，不如说是一种提供给整个因特网的服务，这是一种带来通用好处的服务。不太严格地说，TCP拥塞控制防止任何一条TCP连接用过多流量来淹没通信主机之间的链路和交换设备。TCP力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽。这可以通过调节TCP连接的发送端发送进网络的流量速率来做到。在另一方面，UDP流量是不可调节的。使用UDP传输的应用程序可以根据其需要以其愿意的任何速率发送数据</p>
<h2 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h2><p>在目的主机，运输层从紧邻其下的网络层接收报文段。运输层负责将这些报文段中的数据交付给在主机上运行的适当应用程序进程。</p>
<p><strong>在接收主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字。</strong><br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/2.png"></p>
<p><strong>运输层定位套接字？</strong><br>每个运输层报文段中具有几个字段。在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作称为<strong>多路分解</strong>（demultiplexing)。<br>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层,所有这些工作称为<strong>多路复用</strong>（multiplexing)。</p>
<p>通过上述讨论，我们知道运输层多路复用要求:<br>①套接字有唯一标识符;<br>②每个报文段有特殊字段来指示该报文段所要交付到的套接字。这些特殊字段是源端口号字段（source port number field）和目的端口</p>
<p>端口号是一个16比特的数,其大小在0～65535之间。0～1023范围的端口号称为周知端口号（well- known portnumber)，是受限制的,这是指它们保留给诸如 HTTP。当我们开发一个新的应用程序时必须分配一个端口号。</p>
<h3 id="无连接的多路复用和分解"><a href="#无连接的多路复用和分解" class="headerlink" title="无连接的多路复用和分解"></a>无连接的多路复用和分解</h3><p>服务器端通常分配一个特定的端口号。</p>
<p>客户端当用这种方式创建一个UDP 套接字时，运输层自动地为该套接字分配一个端口号。</p>
<blockquote>
<p>clientSocket = socket(AF_INET, SOCK_DGRAM)</p>
</blockquote>
<p>通过套接字 bind()方法为这个 UDP套接字关联一个特定的端口号</p>
<blockquote>
<p>serverSocket.bind((‘’, Port))</p>
</blockquote>
<h3 id="面向连接的多路复用和分解"><a href="#面向连接的多路复用和分解" class="headerlink" title="面向连接的多路复用和分解"></a>面向连接的多路复用和分解</h3><p>TCP套接字和UDP套接字之间的一个细微差别是，TCP套接字是由一个四元组（源P地址，源端口号，目的IP地址,目的端口号)来标识的。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/3.png"></p>
<p>服务器主机可以支持很多并行的TCP 套接字，每个套接字与一个进程相联系，并由其四元组来标识每个套接字。当一个TCP报文段到达主机时，所有4个字段（源IP地址,源端口，目的P地址，目的端口）被用来将报文段定向（分解）到相应的套接字。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/4.png"></p>
<p>图中主机C向服务器B发起了两个 HTTP会话，主机A向服务器B发起了一个HTTP 会话。主机A与主机C及服务器B都有自己唯一的IP地址，它们分别是A、C、B。主机C为其两个HTTP连接分配了两个不同的源端口号（26145和7532）。因为主机A选择源端口号时与主机C互不相干因此它也可以将源端口号26145分配给其HTTP连接。但这不是问题，即服务器B仍然能够正确地分解这两个具有相同源端口号的连接，因为这两条连接有不同的源IP地址。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/5.png"></p>
<h3 id="web服务器和tcp"><a href="#web服务器和tcp" class="headerlink" title="web服务器和tcp"></a>web服务器和tcp</h3><p>连接套接字与进程之间并非总是有着一一对应的关系。事实上,<strong>当今的高性能Web服务器通常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程。</strong></p>
<blockquote>
<p>这段话的意思是，为了处理大量的客户端请求，现代的高性能Web服务器通常采用多线程或多进程的方式，每个线程或进程使用一个独立的连接套接字来与客户端进行通信。这样可以提高服务器的并发处理能力，同时也避免了多个连接共用一个套接字导致的状态混乱和互相干扰的问题。虽然每个连接都需要使用一个新的连接套接字，但是现代操作系统和网络协议栈已经对套接字的创建和销毁进行了优化，使得创建和销毁套接字的开销非常小，不会对服务器的性能造成太大的影响。</p>
</blockquote>
<p>如果客户与服务器使用持续HTTP,则在整条连接持续期间，客户与服务器之间经由同一个服务器套接字交换 HTTP报文。然而，如果客户与服务器使用非持续HTTP,则对每一对请求/响应都创建一个新的TCP连接并在随后关闭，因此对每一对请求/响应创建一个新的套接字并在随后关闭。这种套接字的频繁创建和关闭会严重地影响一个繁忙的Web服务器的性能（尽管有许多操作系统技巧可用来减轻这个问题的影响)。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>使用UDP时，在发送报文段之前，发送方和接收方的运输层实体之间没有握手。正因为如此,UDP被称为是无连接的。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/6.png"></p>
<p>使用UDP的应用是可以实现可靠数据传输的。这可通过在应用程序自身中建立可靠性机制来完成（例如，可通过增加确认与重传机制来实现，如采用我们将在下一节学习的一些机制)。但这并不是无足轻重的任务，它会使应用开发人员长时间地忙于调试。无论如何，将可靠性直接构建于应用程序中可以使其“左右逢源”。也就是说应用进程可以进行可靠通信，而无需受制于由 TCP拥塞控制机制而无需受制于传输速率限制。</p>
<h3 id="UDP的报文段结构"><a href="#UDP的报文段结构" class="headerlink" title="UDP的报文段结构"></a>UDP的报文段结构</h3><p>UDP首部只有4个字段，每个字段由两个字节组成。通过端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程（即执行分解功能)。长度字段指示了在UDP报文段中的字节数（首部加数据）。因为数据字段的长度在一个UDP 段中不同于在另一个段中,故需要一个明确的长度。接收方使用检验和来检查在该报文段中是否出现了差错。实际上，计算检验和时，除了UDP报文段以外还包括了iP首部的一些字段。但是我们忽略这些细节，以便能从整体上看问题。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/7.png"></p>
<h3 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h3><p>UDP检验和提供了差错检测功能。发送方的UDP对报文段中的所有16比特字的和进行反码运算,求和时遇到的任何溢出都被回卷。得到的结果被放在UDP报文段中的检验和字段。<br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/8.png"><br>注意到最后一次加法有溢出，它要被回卷。（把最高位多出来的和最低位相加）反码运算就是将所有的0换成1，所有的1转换成0。因此，该和0100101011000010的反码运算结果是1011010100111101,这变为了检验和。在接收方，全部的4个16比特字（包括检验和)加在一起。如果该分组中没有引入差错，则显然在接收方处该和将是1111111111111111。如果这些比特之一是0，那么出错了。</p>
<blockquote>
<p>one’s complement该单词直译为一的补数，这样理解就会十份直观，这个词的意思就是不管正负都按位取反，但在中文资料里将其等价为了反码(ones’ complement system or ones’ complement arithmetic)（一补数系统或算数一的补数）,意思是负数用1补数来表示，而正数保持原样，这是规定。因此而书本上明显是混淆了这两个概念，导致了理解的困难</p>
</blockquote>
<p><strong>虽然UDP提供差错检测，但它对差错恢复无能为力。UDP的某种实现只是丢弃受损的报文段;其他实现是将受损的报文段交给应用程序并给出警告。</strong></p>
<h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会受到损坏(由0变为1，或者相反)或丢失，而且所有数据都是按照其发送顺序进行交付。这恰好就是TCP向调用它的因特网应用所提供的服务模型。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/20.png"></p>
<p>我们仅考虑单向数据传输（unidirectional data transfer) 的情况，即数据传输是从发送端到接收端的。可靠的双向数据传输（bidirectional data transfer)(即全双工数据传输)情况从概念上讲不会更难,但解释起来更为单调乏味虽然我们只考虑单向数据传输，注意到下列事实是重要的:<br>我们的协议也需要在发送端和接收端两个方向上传输分组，如图3-8所示。我们很快会看到,除了交换含有待传送的数据的分组之外，rdt的发送端和接收端还需往返交换控制分组。rdt的发送端和接收端都要通过调用udt_send()发送分组给对方(其中 udt表示不可靠数据传输)。</p>
<p>❗</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">滑动窗口协议：</span><br><span class="line">发送端窗口=1：rdt协议</span><br><span class="line">发送端窗口&gt;1：流水线协议:  </span><br><span class="line">                    接受窗口=1：gbn协议</span><br><span class="line">                    接受窗口&gt;1：sr协议</span><br></pre></td></tr></table></figure>
<h3 id="构造可靠传输协议"><a href="#构造可靠传输协议" class="headerlink" title="构造可靠传输协议"></a>构造可靠传输协议</h3><h4 id="经完全可靠信道的可靠数据传输-rdt-1-0"><a href="#经完全可靠信道的可靠数据传输-rdt-1-0" class="headerlink" title="经完全可靠信道的可靠数据传输:rdt 1.0"></a>经完全可靠信道的可靠数据传输:rdt 1.0</h4><p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/11.png"></p>
<ol>
<li>上图显示了rdt 1.0发送方和接收方的有限状态机（Finite-StateMachine,FSM)的定义。</li>
<li>发送方和接收方有各自的 FSM。</li>
<li>rdt1.0中他们都只有一种状态。</li>
<li>上图中箭头表示从一种状态变成一种状态。</li>
<li>引起变化的事件显示在横线上方，动作显示在横线下方，如若没有动作便用^来辨识。</li>
</ol>
<p>rdt的发送端只通过rdt_send (data)事件接受来自较高层的数据，产生一个包含该数据的分组(经由make_pkt(data)动作),并将分组发送到信道中。实际上，rdt_send(data)事件是由较高层应用的过程调用产生的（例如，rdt_send())。</p>
<p>在接收端，rdt通过rdt_rev(packet）事件从底层信道接收一个分组，从分组中取出数据(经由extract( packet， data）动作)，并将数据上传给较高层（通过deliver_data ( data )动作)。实际上，rdt_rcv(packet）事件是由较低层协议的过程调用产生的（例如，rdt_rev())。</p>
<h4 id="经具有比特差错信道的可靠数据传输-rdt-2-0"><a href="#经具有比特差错信道的可靠数据传输-rdt-2-0" class="headerlink" title="经具有比特差错信道的可靠数据传输:rdt 2.0"></a>经具有比特差错信道的可靠数据传输:rdt 2.0</h4><p>底层信道更为实际的模型是分组中的比特可能受损。在分组的传输、传播或缓存的过程中，这种比特差错通常会出现在网络的物理部件中。我们眼下还将继续假定所有发送的分组（虽然有些比特可能受损)将按其发送的顺序被接收。</p>
<p>这些控制报文使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误并因此需要重复。在计算机网络环境中，基于这样重传机制的可靠数据传输协议称为自动重传请求 （AutomaticRepeat reQuest, ARQ)协议。</p>
<p>基本上，ARO协议中还需要另外三种协议功能来处理存在比特差错的情况:</p>
<ol>
<li>差错检测。首先，需要一种机制以使接收方检测到何时出现了比特差错。UDP使用因特网检验和字段正是为了这个目的。此刻，我们只需知道这些技术要求有额外的比特除了待发送的初始数据比特之外的比特）从发送方发送到接收方;这些比特将被汇集在rdt 2.0数据分组的分组检验和字段中。</li>
<li>接收方反馈。因为发送方和接收方通常在不同端系统上执行，可能相隔数千英里,发送方要了解接收方情况（此时为分组是否被正确接收)的唯途径就是让接收方提供明确的反馈信息给发送方。在口述报文情况下回答的“肯定确认”（ACK)和“否定确认”（NAK）就是这种反馈的例子。类似地，我们的rdt 2.0协议将从接收方向发送方回送ACK与 NAK分组。理论上，这些分组只需要一个比特长;如用0表示 NAK，用1表示 ACK。</li>
<li>重传。接收方收到有差错的分组时,发送方将重传该分组文。</li>
</ol>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/12.png"></p>
<p>rdt 2.0的发送端有两个状态。在最左边的状态中,发送端协议正等待来自上层传下来的数据。当产生rdt_send(data)事件时，发送方将产生一个包含待发送数据的组(StapKt) ,带有检验和，然后经由udt_send(sndpkt)操作发送该分组。<br>在最右边的状态中，发送方协议等待来自接收方的ACK或NAK分组。如果收到一个ACK分组(图3-10中符号rdt_rev(revpkt)&amp;&amp; isACK ( revpkt)对应该事件)，则发送方知道最近发送的分组已被正确接收，因此协议返回到等待来自上层的数据的状态。如果收到一个NAK分组，该协议重传最后一个分组并等待接收方为响应重传分组而回送的ACK 和NAK。</p>
<p><strong>注意到下列事实很重要:<br>当发送方处于等待ACK或NAK的状态时,它不能从上层获得更多的数据;这就是说,rdt_send()事件不可能出现;仅当接收到ACK并离开该状态时才能发生这样的事件。因此，发送方将不会发送一块新数据,除非发送方确信接收方已正确接收当前分组。由于这种行为，rdt 2.0这样的协议被称为停等（stop-and-wait)协议。</strong></p>
<p>rdt 2.0接收方的FSM 仍然只有一个状态。当分组到达时，接收方要么回答一个 ACK,要么回答一个 NAK,这取决于收到的分组是否受损。在图3-10中,符号rdt_rev( revpkt)&amp;&amp; corrupt( rcvpkt)对应于收到一个分组并发现有错的事件。</p>
<h4 id="经具有比特差错信道的可靠数据传输-rdt-2-1"><a href="#经具有比特差错信道的可靠数据传输-rdt-2-1" class="headerlink" title="经具有比特差错信道的可靠数据传输:rdt 2.1"></a>经具有比特差错信道的可靠数据传输:rdt 2.1</h4><p><strong>应对ack和nak受损</strong><br>rdt 2.0存在一个致命的缺陷。我们没有考虑到ACK或NAK分组受损的可能性!这里的难点在于，如果一ACK 或 NAK分组受损，发送方无法知道接收方是否正确接收了上一块发送的数据。</p>
<ol>
<li>增加足够的检验和比特，使发送方不仅可以检测差错，还可恢复差错。对于会产生差错但不丢失分组的信道，这就可以直接解决问题。</li>
<li>当发送方收到含糊不清的ACK或NAK分组时，只需重传当前数据分组即可。然而，这种方法在发送方到接收方的信道中引人了冗余分组( dupli-cate packet)。冗余分组的根本困难在于接收方不知道它上次所发送的ACK或NAK是否被发送方正确地收到。因此它无法事先知道接收到的分组是新的还是一次重传!</li>
</ol>
<p>解决这个新问题的一个简单方法（几乎所有现有的数据传输协议中，包括TCP，都采用了这种方法）是<strong>在数据分组中添加一新字段，让发送方对其数据分组编号，即将发送数据分组的序号（sequence number)放在该字段</strong>。于是，接收方只需要检查序号即可确定收到的分组是否一次重传。对于停等协议这种简单情况，1比特序号就足够了，因为它可让接收方知道发送方是否正在重传前一个发送分组（接收到的分组序号与最近收到的分组序号相同)，或是一个新分组（序号变化了，<strong>用模2运算“前向”移动</strong>)。因为目前我们假定信道不丢分组，ACK和 NAK分组本身不需要指明它们要确认的分组序号。发送方知道所接收到的 ACK 和 NAK分组(无论是否是含糊不清的是为响应其最近发送的数据分组而生成的。<br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/14.png"><br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/15.png"></p>
<h4 id="经具有比特差错信道的可靠数据传输-rdt-2-2"><a href="#经具有比特差错信道的可靠数据传输-rdt-2-2" class="headerlink" title="经具有比特差错信道的可靠数据传输:rdt 2.2"></a>经具有比特差错信道的可靠数据传输:rdt 2.2</h4><p><strong>不发nak怎么办</strong><br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/17.png"><br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/16.png"></p>
<h4 id="经具有比特差错的丢包信道的可靠数据传输-rdt-3-0"><a href="#经具有比特差错的丢包信道的可靠数据传输-rdt-3-0" class="headerlink" title="经具有比特差错的丢包信道的可靠数据传输:rdt 3.0"></a>经具有比特差错的丢包信道的可靠数据传输:rdt 3.0</h4><p><strong>丢包怎么办？</strong><br>从发送方的观点来看，重传是一种万能灵药。发送方不知道是一个数据分组丢失，还是一个 ACK丢失，或者只是该分组或ACK过度延时。在所有这些情况下，动作是同样的:重传。为了实现基于时间的重传机制，需要一个倒计数定时器（countdown timer)，在一个给定的时间量过期后，可中断发送方。因此，发送方需要能做到:①每次发送一个分组（包括第一次分组和重传分组）时，便启动一个定时器。②响应定时器中断(采取适当的动作）。③终止定时器。<br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/18.png"></p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/19.png"></p>
<h3 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h3><p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/21.png"></p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/22.png"></p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/23.png"></p>
<p>产生的问题：</p>
<ol>
<li><p>必须增加序号范围，因为每个输送中的分组（不计算重传的)必须有一个唯一的序号，而且也许有多个在输送中未确认的报文。</p>
</li>
<li><p>协议的发送方和接收方两端也许必须缓存多个分组。发送方最低限度应当能缓冲那些已发送但没有确认的分组。如下面讨论的那样，接收方或许也需要缓存那些已正确接收的分组。</p>
</li>
<li><p>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是:回退N步（Go- Back-N,GBN) 和选择重传（Selective Repeat,SR)。</p>
</li>
</ol>
<h3 id="回退N步"><a href="#回退N步" class="headerlink" title="回退N步"></a>回退N步</h3><p>在回退N步（GBN) 协议中，允许发送方发送多个分组（当有多个分组可用时）而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。<br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/24.png"></p>
<p>那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为N的窗口。随着协议的运行，该窗口在序号空间向前滑动。因此，N常被称为窗口长度（window size),GBN 协议也常被称为滑动窗口协议(sliding-window protocol)。</p>
<p>在实践中,1个分组的序号承载在分组首部的一个固定长度的字段中。如果分组序号字段的比特数是h,则该序号范围是[0,2^h -1]。在一个有限的序号范围内，所有涉及序号的运算必须使用模2^h运算。</p>
<p>下图是一个基于ACK、无NAK的GBN协议的发送方和接收方这两端的扩展FSM描述。我们称该FSM描述为扩展FSM，是因为我们已经增加了变量（类似于编程语言中的变量) base和 nextseqnum，还增加了对这些变量的操作以及与这些变量有关的条件动作。<br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/25.png" alt="?"><br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/26.png" alt="?"></p>
<p>GBN 发送方必须响应三种类型的事件:</p>
<ol>
<li><p>上层的调用。当上层调用rdt_send()时，发送方首先检查发送窗口是否已满，即是否有N个已发送但未被确认的分组。如果窗口未满，则产生一个分组并将其发送,并相应地更新变量。如果窗口已满，发送方只需将数据返回给上层，隐式地指示上层该窗口已满。然后上层可能会过一会儿再试。在实际实现中，发送方更可能缓存（并不立刻发送)这些数据，或者使用同步机制（如一个信号量或标志）允许上层在仅当窗口不满时才调用rdt_send()。</p>
</li>
<li><p>收到一个 ACK。在GBN 协议中，对序号为n的分组的确认采取累积确认 （cumu-lative acknowledgment)的方式，表明接收方已正确接收到序号为n的以前且包括n在内的所有分组。</p>
</li>
<li><p>超时事件。协议的名字“回退N步”来源于出现丢失和时延过长分组时发送方的行为。就像在停等协议中那样，定时器将再次用于恢复数据或确认分组的丢失。<br>如果出现超时,发送方重传所有已发送但还未被确认过的分组。发送方仅使用一个定时器，它可被当作是最早的已发送但未被确认的分组所使用的定时器。如果收到一个ACK，但仍有已发送但未被确认的分组，则定时器做里新后动。如果没有已发送但未被确认的分组，该定时器被终止。</p>
</li>
</ol>
<p>在GBN中，接收方的动作也很简单。如果一个序号为n的分组被正确接收到，并且按序（即上次交付给上层的数据是序号为n -1的分组)，则接收方为分组n发送一个ACK，并将该分组中的数据部分交付到上层。在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新友达AK。仕忌到内方一V人生田明和确社具CBN一个已接收并交付，则所有序号比h小的分组也已经交付。因此,使用累积确认是 GBN一个自然的选择。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/27.png" alt="?"></p>
<h3 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h3><p>顾名思义，选择重传（SR）协议通过让发送方仅重传那些它怀疑在接收方出错（即丢失或受损)的分组而避免了不必要的重传。这种个别的、按需的重传要求接收方逐个地确认正确接收的分组。再次用窗口长度N来限制流水线中未完成、未被确认的分组数。然而，与GBN 不同的是，发送方已经收到了对窗口中某些分组的ACK。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/28.png" alt="?"></p>
<ol>
<li>从上层收到数据。当从上层接收到数据后，SR 发送方检查下一个可用于该分组的序号。如果序号位于发送方的窗口内，则将数据打包并发送;否则就像在GBN中一样，要么将数据缓存，要么将其返回给上层以便以后传输。</li>
<li>超时。定时器再次被用来防止丢失分组。然而，现在每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个分组。可以使用单个硬件定时器模拟多个逻辑定时器的操作[Varghese 1997],</li>
<li>收到ACK。如果收到ACK，倘若该分组序号在窗口内,则SR发送方将那个被确认的分组标记为已接收。如果该分组的序号等于send_base，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并且有序号落在窗口内的未发送分组,则发送这些分组。</li>
</ol>
<p>SR接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直到所有丢失分组（即序号更小的分组）皆被收到为止，这时才可以将一批分组按序交付给上层。</p>
<ol>
<li>序号在[ncv_base，rev_base +N-1] 内的分组被正确接收。在此情况下，收到的分组落在接收方的窗口内，一个选择ACK被回送给发送方。如果该分组以前没收到过,则缓存该分组。如果该分组的序号等于接收窗口的基序号(图3-23中的rev_base),则该分组以及以前缓存的序号连续的(起始于rev_base的)分组交付给上层。然后，接收窗口按向前移动分组的编号向上交付这些分组。</li>
<li>序号在[rev_base -N,rev_base -1]内的分组被正确收到。在此情况下，必须产生一个 ACK,即使该分组是接收方以前已确认过的分组。</li>
</ol>
<p><strong>如果不发送ack，发送窗口会因为丢失前面的报文，不停的发送报文等待ack，导致发送窗口不能前进</strong><br>3. 其他情况。忽略该分组。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/29.png" alt="?"></p>
<p><strong>SR协议（和很多其他协议一样)的一个重要方面。对于哪些分组已经被正确接收，哪些没有，发送方和接收方并不总是能看到相同的结果。对SR协议而言，这就意味着发送方和接收方的窗口并不总是一致。</strong></p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/30.png" alt="?"></p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/31.png" alt="?"></p>
<p>我们通过考虑在底层信道模型中的一个遗留假设来结束对可靠数据传输协议的讨论。前面讲过，我们曾假定分组在发送方与接收方之间的信道中不能被重新排序。这在发送方与接收方由单段物理线路相连的情况下，通常是一个合理的假设。然而当连接两端的“信道”是一个网络时，分组重新排序是可能会发生的。分组重新排序的一个表现就是,<br>一个具有序号或确认号x的分组的旧副本可能会出现，即使发送方或接有包含x。对于分组重新排序，信道可被看成基本上是在缓存分组，并在将来任意时刻自然地释放出这些分组。由于序号可以被重新使用，那么必须小心，以免出现这样的冗余分组。实际应用中采用的方法是，确保一个序号不被重新使用，直到发送方“确信”任何先前发送的序号为x的分组都不再在网络中为止。通过假定一个分组在网络间不会超过某个固定最大时间量来做到这一点。在高速网络的TCP扩展中最长的分组寿命被假定为大约3分钟。</p>
<p>发送缓冲区和发送窗口</p>
<blockquote>
<p>发送窗口会达到到发送缓冲区的大小，但不会超过，超过了就没办法保存数据。发送缓冲区用来保存已经发送但是没有确认的分组，发送窗口用来控制发谁。他们两个都会根据网络进行调整。</p>
</blockquote>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="tcp连接"><a href="#tcp连接" class="headerlink" title="tcp连接"></a>tcp连接</h3><p>其连接状态完全保留在两个端系统中。由于TCP协议只在端系统中运行，而不在中间的网络元素(路由器和链路层交换机)中运行，所以中间的网络元素不会维持TCP连接状态。</p>
<p>TCP连接提供的是全双工服务(full-duplex service):如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可在从进程B流向进程A的同时，也从进程A流向进程B。TCP连接也总是点对点(point-to-point)的，即在单个发送方与单个接收方之间的连接。所谓“多播”(参见4.7节)，即在一次发送操作中，从一个发送方将数据传送给多个接收方，对TCP来说这是不可能的。对于TCP 而言，两台主机是一对，而3台主机则太多!</p>
<p><strong>三次握手</strong><br>客户首先发送一个特殊的TCP 报文段，服务器用另一个特殊的TCP 报文段来响应，最后，客户再用第三个特殊报文段作为响应。前两个报文段不承载“有效载荷”，也就是不包含应用层数据;而第三个报文段可以承载有效载荷由于在这两台主机之间发送了3个报文段，所以这种连接建立过程常被称为三次握手(three-way handshake)</p>
<p>客户进程通过套接字(该进程之门)传递数据流。数据一旦通过该门，它就由客户中运行的TCP控制了。TCP将这些数据引导到该连接的发送缓存(send buffer)里，发送缓存是在三次握手初期设置的缓存之一。</p>
<p>接下来TCP就会不时从发送缓存里取出一块数据。TCP 可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度(Maximum Segment Size，MSS)。</p>
<p>MSS通常根据最初确定的由本地发送主机发送的最大链路层长度(即所谓的最大传输单元MaximumTransmissionUnit，MTU))来设置。设置该MSS要保证一个TCP报文段(当封装在一个IP数据报中)加上TCP/IP首部长度(通常40字节)将适合单个链路层。以太网和PPP链路层协议都具有1500字节的MTU，因此MSS的典型值为1460字节。已经提出了多种发现路径MTU的方法，并基于路径MTU值设置MSS(路径MTU是指能在从源到目的地的所有链路上发送的最大链路层帧。注意到MSS是指在报文段里应用层数据的最大长度，而不是指包括TCP首部的TCP报文段的最大长度。</p>
<blockquote>
<p>MSS（Maximum Segment Size）是指TCP报文段中应用层数据的最大长度，也就是TCP协议可以在一次传输中携带的应用层数据的最大长度。但是，TCP报文段还包括TCP首部，TCP首部的长度通常为20字节，加上IP首部的长度通常为20字节，因此TCP报文段的总长度通常是MSS加40字节。所以，MSS并不包括TCP首部和IP首部的长度，它只是指应用层数据的最大长度。</p>
</blockquote>
<p>TCP为每块客户数据配上一个TCP首部，从而形成多个TCP报文段(TCPsegment)。这些报文段被下传给网络层，网络层将其分别封装在网络层IP 数据报中。然后这些IP数据报被发送到网络中。当TCP在另一端接收到一个报文段后，该报文段的数据就被放人该TCP连接的接收缓存中，应用程序从此缓存中读取数据流。TCP连接的每一端都有各自的发送缓存和接收缓存.</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/32.png" alt="?"></p>
<h3 id="tcp报文段"><a href="#tcp报文段" class="headerlink" title="tcp报文段"></a>tcp报文段</h3><p>TCP 报文段由首部字段和一个数据字段组成。数据字段包含一块应用数据。如前所述，MSS 限制了报文段数据字段的最大长度。当TCP发送一个大文件，例如某 Web 页面上的一个图像时，TCP通常是将该文件划分成长度为MSS的若干块(最后一块除外，它通常小于MSS)。然而，交互式应用通常传送长度小于MSS的数据块。例如，对于像Telnet这样的远程登录应用其TCP报文段的数据字段经常只有一个字节。由于TCP的首部一般是20字节(比UDP首部多12字节)，所以Telnet发送的报文段也许只有21 字节长.</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/33.png" alt="?"></p>
<p><strong>TCP报文段的结构:</strong><br>首部包括源端口号和目的端口号，它被用于多路复用/分解来自或送到上层应用的数据。另外，同UDP一样，TCP首部也包括检验和字段(checksum field)。</p>
<p>32比特的序号字段(sequencenumber field)和32比特的确认号字段(acknowl-edgmentnumberfield)。这些字段被TCP发送方和接收方用来实现可靠数据传输服务。</p>
<p>16比特的接收窗口字段(receivewindow field)，该字段用于流量控制。该字段用于指示接收方愿意接受的字节数量。</p>
<p>4比特的首部长度字段(header length feld)，该字段指示了以32比特的字为单位的TCP首部长度。由于TCP选项字段的原因，TCP首部的长度是可变的。(通常选项字段为空，所以TCP首部的典型长度就是20字节。)</p>
<p>可选与变长的选项字段(options feld)，该字段用于发送方与接收方协商最大报文段长度(MSS)时，或在高速网络环境下用作窗口调节因子时使用。首部字段中还定义了一个时间戳选项。</p>
<p>6比特的标志字段(ag eld)。<br>ACK比特用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认。<br>RST、SYN和FIN比特用于连接建立和拆除。<br>当PSH比特被设置的时候，就指示接收方应立即将数据交给上层。<br>最后，URG比特用来指示报文段里存在着被发送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由16比特的紧急数据指针字段指出。当紧急数据存在并给出指向紧急数据尾的指针的时候，TCP必须通知接收端的上层实体。<br>(在实践中，PSH、URG 和紧急数据指针并没有使用。为了完整性起见，我们才提到这些字段)</p>
<h4 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h4><p>TCP 把数据看成一个无结构的、有序的字节流。因为序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。一个报文段的序号(sequence number fora segment)因此是该报文段首字节的字节流编号。<br>举例来说，假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流。主机A中的TCP将隐式地对数据流中的每一个字节编号。假定数据流由一个包含500000字节的文件组成，其MSS为1000字节，数据流的首字节编号，该TCP将为该数据流构建500个报文段。给第一个报文段分配序号0，第二个报文段分配序号1000，第三个报文段分配序号2000，以此类推。每一个序号被填入到相应TCP报文段首部的序号字段中。<br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/34.png" alt="?"></p>
<p>TCP 是全双工的，因此主机A在向主机B发送数据的同时，也许也接收来自主机B的数据(都是同一条TCP连接的一部分)。从主机B到达的每个报文段中都有一个序号用于从B流向A的数据。主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。</p>
<p>假设主机A已收到一个来自主机B的包含字节0~535的报文段，以及另一个包含字节900~1000的报文段。由于某种原因，主机A还没有收到字节536<del>899的报文段。在这个例子中，主机A为了重新构建主机B的数据流，仍在等待字节536(和其后的字节)。因此，A到B的下一个报文段将在确认号字段中包含536。因为TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供累积确认 (cumulativeacknowledgment).<br>主机A在收到第二个报文段(字节536</del>899)之前收到第三个报文段(字节9001000)。因此，第三个报文段失序到达该微妙的问题是:当主机在一条TCP 连接中收到失序报文段时该怎么办?TCPRFC并没有为此明确规定任何规则，而是把这一问题留给实现TCP的编程人员去处理。他们有两个基本的选择:1接收方立即丢弃失序报文段(如前所述，这可以简化接收方的设计):2接收方保留失序的字节，并等待缺少的字节以填补该间隔。显然，后一种选择对网络带宽而言更为有效，是实践中采用的方法。</p>
<p>我们假设初始序号为0。事实上，一条TCP连接的双方均可随机地选择初始序号。这样做可以减少将那些仍在网络中存在的来自两台主机之间先前已终止的连接的报文段，误认为是后来这两台主机之间新建连接所产生的有效报文段的可能性.</p>
<h4 id="Telnet-序号和确认号的一个学习案例"><a href="#Telnet-序号和确认号的一个学习案例" class="headerlink" title="Telnet:序号和确认号的一个学习案例"></a>Telnet:序号和确认号的一个学习案例</h4><p>许多用户现在更愿意采用SSH协议而不是Telnet，因为在Telnet连接中发送的数据(包括口令!)是没有加密的，使得Tenet 易于受到窃听攻击。<br>假设主机A发起一个与主机B的Telnet 会话。因为是主机A发起该会话，因此它被标记为客户，而主机B被标记为服务器。(在客户端的)用户键人的每个字符都会被发送至远程主机;远程主机将回送每个字符的副本给客户，并将这些字符显示在Telnet用户的屏幕上。这种“回显”(echoback)用于确保由Telnet用户发送的字符已经被远程主机收到并在远程站点上得到处理。因此，在从用户击键到字符被显示在用户屏幕上这段时间内，每个字符在网络中传输了两次。<br>我们考察一下在客户与服务器之间发送的TCP报文段。假设客户和服务器的起始序号分别是42和79。前面讲过，<strong>一个报文段的序号就是该报文段数据字段首字节的序号</strong>。因此，客户发送的第一个报文段的序号为42，服务器发送的第一个报文段的序号为79。前面讲过，<strong>确认号就是主机正在等待的数据的下一个字节序号</strong>。在TCP连接建立后但没有发送任何数据之前，该客户等待字节79，而该服务器等待字节42。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/35.png" alt="?"></p>
<p>共发送3 个报文段。第一个报文段是由客户发往服务器，在它的数据字段里包含一字节的字符“C’的ASCI码。第一个报文段的序号字段里是42。另外，由于客户还没有接收到来自服务器的任何数据，因此该第一个报文段中的确认号字段中是79。</p>
<p>第二个报文段是由服务器发往客户。它有两个目的:首先它是为该服务器所收到数据提供一个确认。通过在确认号字段中填入43，服务器告诉客户它已经成功地收到字节42及以前的所有字节，现在正等待着字节43 的出现。该报文段的第二个目的是回显字符C’。因此，在第二个报文段的数据字段里填入的是字符“C’的ASCII码。第二个报文段的序号为79，它是该TCP 连接上从服务器到客户的数据流的起始序号，这也正是服务器要发送的第一个字节的数据。值得注意的是，对客户到服务器的数据的确认被装载在一个承载服务器到客户的数据的报文段中;这种确认被称为是被带(piggybacked)在服务器到客户的数据报文段中的。</p>
<p>第三个报文段是从客户发往服务器的。它的唯一目的是确认已从服务器收到的数据前面讲过，第二个报文段中包含的数据是字符C，是从服务器到客户的。该报文段的数据字段为空(即确认信息没有被任何从客户到服务器的数据所捎带)。该报文段的确认号字段填人的是80，因为客户已经收到了字节流中序号为79及以前的字节，它现在正等待着字节80的出现。你可能认为这有点奇怪，即使该报文段里没有数据还仍有序号这是因为TCP存在序号字段，报文段需要填入某个序号。</p>
<h3 id="往返时间的估计与超时"><a href="#往返时间的估计与超时" class="headerlink" title="往返时间的估计与超时"></a>往返时间的估计与超时</h3><p>TCP如同rdt协议一样，它采用超时/重传机制来处理报文段的丢失问题。显然，超时间隔必须大于该连接的往返时间（RTT)，即从一个报文段发出到它被确认的时间。否则会造成不必要的重传。</p>
<h4 id="估计往返时间"><a href="#估计往返时间" class="headerlink" title="估计往返时间"></a>估计往返时间</h4><p>大多数TCP的实现仅在某个时刻做一次SampleRTT测量，而不是为每个发送的报文段测量一个Samp-leRTT。这就是说，在任意时刻，仅为一个已发送的但目前尚未被确认的报文段估计 Samp-leRTT， 从而产生一个接近每个RTT的新 SampleRTT值另外，TCP决不为已被重传的报文段计算SampleRTT;它仅为传输一次的报文段测量SampleRTT </p>
<p>由于路由器的拥塞和端系统负载的变化，这些报文段的SampleRTT值会随之波动。由于这种波动，任何给定的SampleRTT值也许都是非典型的。因此，为了估计一个典型的RTT，自然要采取某种对SampleRTT取平均的办法。TCP维持一个SampleRTT 均值(称EstimatedRTT)。一旦获得一个新 SampleRTT时,TCP就会根据下列公式来更新<br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/36.png" alt="?"></p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/37.png" alt="?"></p>
<h4 id="设置和管理重传超时间隔"><a href="#设置和管理重传超时间隔" class="headerlink" title="设置和管理重传超时间隔"></a>设置和管理重传超时间隔</h4><p>假设已经给出了EstimatedRTT值和 DevRTT值,那么TCP 超时间隔应该用什么值呢?很明显，超时间隔应该大于等于 EstimatedRTT ,否则,将造成不必要的重传。但是超时间隔也不应该比EstimatedRTT 大太多，否则当报文段丢失时，TCP不能很快地重传该报文段，导致数据传输时延大。因此要求将超时间隔设为EstimatedRTT 加上一定余量。当SampleRTT值波动较大时，这个余量应该大些;当波动较小时，这个余量应该小些。因此，DevRTT值应该在这里发挥作用了。在TCP的确定重传超时间隔的方法中，所有这些因素都考虑到了:<br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/38.png" alt="?"><br>推荐的初始 TimeoutInterval 值为1秒。同样，当出现超时后，TimeoutInt-erval值将加倍，以免即将被确认的后继报文段过早出现超时。不管怎样，一旦报文段收到并更新EstimatedRTT后，TimeoutInterval就又使用上述公式计算了。</p>
<h4 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h4><p>因特网的网络层服务（iP服务）是不可靠的。iP不保证数据报的交付,不保证数据报的按序交付，也不保证数据报中数据的完整性。对于iP服务，数据报能够溢出路由器缓存而永远不能到达目的地,数据报也可能是乱序到达，而且数据报中的比特可能损坏（由0变为1或者相反)。由于运输层报文段是被IP数据报携带着在网络中传输的,所以运输层的报文段也会遇到这些问题。</p>
<p>TCP在iP不可靠的尽力而为服务之上创建了一种可靠数据传输服务（reliable datatransfer service)。TCP 的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隔、非冗余和按序的数据流;即该字节流与连接的另一方端系统发送出的字节流是完全相同。</p>
<blockquote>
<p>在比特级别上，TCP协议并没有使用纠错码来保证数据传输的可靠性。如果数据包在传输过程中出现了比特错误，TCP协议会让发送方重传整个数据包。这是因为TCP协议的可靠传输是基于数据包的，而不是基于比特的。当数据包被重传时，所有的比特都会被重新发送，这样就可以避免比特错误。另外，TCP协议还会对数据包进行校验和计算，以检测数据包是否被损坏。如果校验和不匹配，TCP协议会认为数据包出现了错误，会让发送方重传整个数据包。</p>
</blockquote>
<p>假定每一个已发送但未被确认的报文段都与一个定时器相关联，这在概念上是最简单的。虽然这在理论上很好，但定时器的管理却需要相当大的开销。因此，推荐的定时器管理过程[RFC 6298]仅使用单一的重传定时器,<strong>即使有多个已发送但还未被确认的报文段。在本节中描述的TCP协议遵循了这种单一定时器的推荐。</strong></p>
<p>我们将以两个递增的步骤来讨论TCP是如何提供可靠数据传输的。我们先给出一个TCP发送方的高度简化的描述，该发送方只用超时来恢复报文段的丢失;然后再给出一个更全面的描述，该描述中除了使用超时机制外，还使用冗余确认技术。在接下来的讨论中，我们假定数据仅向一个方向发送，即从主机A到主机B，且主机A在发送一个大文件。</p>
<p>我们看到在TCP发送方有3个与发送和重传有关的主要事件:<br>从上层应用程序接收数据;定时器超时和收到ACK。一旦第一个主要事件发生，TCP 从应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP。注意到每一个报文段都包含一个序号，这个序号就是该报文段第一个数据字节的字节流编号。还要注意到如果定时器还没有为某些其他报文段而运行，则当报文段被传给iP时，TCP就启动该定时器。(将定时器想象为与最早的未被确认的报文段相关联是有帮助的。)该定时器的过期间隔是TimeoutInterval，它是由3.5.3节中所描述的 EstimatedRTT和 DevRTT计算得出的。</p>
<p>第二个主要事件是超时。TCP通过重传引起超时的报文段来响应超时事件。然后 TCP重启定时器。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/39.png"></p>
<p><strong>讨论</strong><br>图3-34描述了第一种情况，主机A向主机B发送一个报文段。假设该报文段的序号是92，而且包含8字节数据。在发出该报文段之后，主机A等待一个来自主机B的确认号为100的报文段。虽然A发出的报文段在主机B上被收到，但从主机B发往主机A的确认报文丢失了。在这种情况下，超时事件就会发生，主机A会重传相同的报文段。当然，当主机B收到该重传的报文段时，它将通过序号发现该报文段包含了早已收到的数据。因此，主机B中的TCP将丢弃该重传的报文段中的这些字节。</p>
<p>在第二种情况中，如图3-35所示，主机A连续发回了两个报文段。第一个报文段序号是92，包含8字节数据:第二个报文段序号是100，包含20字节数据。假设两个报文段都完好无损地到达主机B,并且主机B为每一个报文段分别发送一个确认。第一个确认报文的确认号是100，第二个确认报文的确认号是120。现在假设在超时之前这两个报文段中没有一个确认报文到达主机A。当超时事件发生时，主机A重传序号92的第一个报文段，并重启定时器。只要第二个报文段的ACK在新的超时发生以前到达，则第二个报文段将不会被重传。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/40.png"></p>
<p>在第三种也是最后一种情况中，假设主机A与在第二种情况中完全一样，发送两个报文段。第一个报文段的确认报文在网络丢失，但在超时事件发生之前主机A收到一个确认号为120的确认报文。主机A因而知道主机B已经收到了序号为119及之前的所有字节;所以主机A不会重传这两个报文段中的任何一个。这种情况在图3-36中进行了图示。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/41.png"></p>
<p><strong>超时间隔</strong></p>
<p>首先关注的是在定时器时限过期后超时间隔的长度。在这种修改中,每当超时事件发生时,如前所述,TCP重传具有最小序号的还未被确认的报文段。只是每次 TCP重传时都会将下一次的超时间隔设为先前值的两倍，而不是用从 EstimatedRTT和DevRTT推算出的值。例如,假设当定时器第一次过期时，与最早的未被确认的报文段相关联的TimeoutInterval是0.75秒。TCP就会重传该报文段，并把新的过期时间设置为1.5秒。如果1.5秒后定时器又过期了，则TCP将再次重传该报文段，并把过期时间设置为3.0秒。因此，超时间隔在每次重传后会呈指数型增长。然而，每当定时器在另两个事件（即收到上层应用的数据和收到ACK）中的任意一个启动时，TimeoutInterval由最近的EstimatedRTT值与 DevRTT值推算得到。</p>
<p>定时器过期很可能是由网络拥塞引起的，即太多的分组到达源与目的地之间路径上的一台（或多台）路由器的队列中，造成分组丢失或长时间的排队时延。在拥塞的时候，如果源持续重传分组，会使拥塞更加严重。相反，TCP使用更文雅的方式，每个发送方的重传都是经过越来越长的时间间隔后进行的。</p>
<p><strong>快速重传</strong><br><strong>快速重传:在某报文段的定时器过期之前重传丢失的报文段</strong></p>
<p>超时触发重传存在的问题之一是超时周期可能相对较长。当一个报文段丢失时，这种长超时周期迫使发送方延迟重传丢失的分组，因而增加了端到端时延。幸运的是，发送方通常可在超时事件发生之前通过注意所谓冗余ACK来较好地检测到丢包情况。冗余 ACK( duplicate ACK）就是再次确认某个报文段的 ACK，而发送方先前已经收到对该报文段的确认。要理解发送方对冗余ACK的响应，</p>
<p>当TCP接收方收到一个具有这样序号的报文段时,即其序号大于下一个所期望的<br>、按序的报文段,它检测到了数据流中的一个间隔，这就是说有报文段丢失。这个间隔可能是由于在网络中报文段丢失或重新排序造成的。因为TCP不使用否定确认，所以接收方不能向发送方发回一个显式的否定确认。相反，它只是对已经接收到的最后一个按序字节数据进行重复确认（即产生一个冗余ACK)即可。(注意到在表3-2中允许接收方不丢弃失序报文段。)</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/42.png" alt="?"></p>
<p>因为发送方经常一个接一个地发送大量的报文段,如果一个报文段丢失，就很可能引起许多一个接一个的冗余ACK。如果TCP 发送方接收到对相同数据的3个冗余ACK,它把这当作一种指示，<strong>说明跟在这个已被确认过3次的报文段之后的报文段已经丢失。</strong>一旦收到3个冗余 ACK,TCP就执行快速重传（fast retransmit），即在该报文段的定时器过期之前重传丢失的报文段。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/44.png" alt="?"></p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/45.png" alt="?"></p>
<h4 id="是回退N步还是选择重传"><a href="#是回退N步还是选择重传" class="headerlink" title="是回退N步还是选择重传"></a>是回退N步还是选择重传</h4><p>TCP确认是累积式的,正确接收但失序的报文段是不会被接收方逐个确认的。因此,TCP 发送方仅需维持已发送过但未被确认的字节的最小序号(SendBase）和下一个要发送的字节的序号(NextSeqNum)。在这种意义下，TCP看起来更像一个 GBN 风格的协议。<br>但是和GBN协议之间有着一些显著的区别。许多TCP实现会将正确接收但失序的报文段缓存起来。</p>
<p>当发送方发送的一组报文段1,2，…， N,并且所有的报文段都按序无差错地到达接收方时会发生的情况。进一步假设对分组n&lt;N的确认报文丢失，但是其余N-1个确认报文在分别超时以前到达发送端，这时又会发生的情况。在该例中，GBN不仅会重传分组n,还会重传所有后继的分组n+1, n +2,…，N。在另一方面,TCP将重传至多一个报文段,即报文段n。此外，如果对报文段n +1的确认报文在报文段n超时之前到达，TCP甚至不会重传报文段n0</p>
<p>对TCP提出的一种修改意见是所谓的选择确认（selective acknowledgment)[ RFC 2018],它允许TCP接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。当将该机制与选择重传机制结合起来使用时即跳过重传那些已被接收方选择性地确认过的报文段)，TCP看起来就很像我们通常的SR协议。因此，TCP的差错恢复机制也许最好被分类为 GBN 协议与SR协议的混合体。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>一条TCP连接每一侧主机都为该连接设置了接收缓存。当该TCP连接收到正确、按序的字节后，它就将数据放入接收缓存。相关联的应用进程会从该缓存中读取数据，但不必是数据刚一到达就立即读取。事实上，接收方应用也许正忙于其他任务，甚至要过很长时间后才去读取该数据。如果某应用程序读取数据时相对缓慢，而发送方发送得太多、太快，发送的数据就会很容易地使该连接的接收缓存溢出。</p>
<p>TCP为它的应用程序提供了<strong>流量控制服务</strong>（flow- control service）以消除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配服务即发送方的发送速率与接收方应用程序的读取速率相匹配。</p>
<p>前面提到过,TCP 发送方也可能因为IP网络的拥塞而被遏制;这种形式的发送方的控制被称为**拥塞控制 **（congestion control)<br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/46.png" alt="?"></p>
<p>LastByteRead:主机B上的应用进程从缓存读出的数据流的最后一个字节的编号。<br>LastByteRcvd:从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节的编号。<br>由于TCP不允许已分配的缓存溢出,下式必须成立:<br>LastByteRcvd - LastByteRead≤RcvBuffer<br>接收窗口用 rwnd表示,根据缓存可用空间的数量来设置:<br>rwnd = RcvBuffer-LastBvteRcvd -LastByteRead </p>
<p>主机A轮流跟踪两个变量，LastByteSent和 LastByteAcked，这两个变量的意义很明显。注意到这两个变量之间的差 LastByteSent - LastByteAcked,就是主机A发送到连接中但未被确认的数据量。通过将未确认的数据量控制在值rwnd 以内，就可以保证主机A不会使主机B的接收缓存溢出。因此，主机A在该连接的整个生命周期须保证:<br>LastByteSent -LastByteAcked&lt;rwnd</p>
<p>对于这个方案还存在一个小小的技术问题。为了理解这一点，假设主机B的接收缓存已经存满，使得rwnd=0。在将rwnd =0通告给主机A之后，还要假设主机B没有任何数据要发给主机A。此时，考虑会发生什么情况。<br>因为主机B上的应用进程将缓存清<br>空，TCP并不向主机A发送带有rwnd新值的新报文段;事实上，TCP仅当在它有数据或有确认要发时才会发送报文段给主机A。这样，主机A不可能知道主机B的接收缓存已经有新的空间了，即主机A被阻塞而不能再发送数据!为了解决这个问题，TCP规范中要求:当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd 值。</p>
<h3 id="tcp连接管理"><a href="#tcp连接管理" class="headerlink" title="tcp连接管理"></a>tcp连接管理</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>第一步:客户端的TCP首先向服务器端的TCP 发送一个特殊的TCP报文段。该报文段中不包含应用层数据。但是在报文段的首部（参见图3-29）中的一个标志位（即SYN 比特）被置为1。因此，这个特殊报文段被称为SYN报文段。另外，客户会随机地选择一个初始序号（client isn)，并将此编号放置于该起始的 TCP SYN报文段的序号字段中。该报文段会被封装在一个IP数据报中，并发送给服务器。</p>
<p>第二步:一旦包含TCP SYN 报文段的IP数据报到达服务器主机（假定它的确到达了!)，服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段也不包含应用层数据。但是，在报文段的首部却包含3个重要的信息。首先，SYN 比特被置为1。其次，该TCP报文段首部的确认号字段被置为 elient _isn +1。最后，服务器选择自己的初始序号(server_isn)，并将其放置到TCP报文段首部的序号字段中。这个允许连接的报文段实际上表明了:“我收到了你发起建立连接的SYN 分组，该分组带有初始序号client isn。我同意建立该连接。我自己的初始序号是server_isn。”该允许连接的报文段有时被称为 SYNACK 报文段（SYNACK segment)</p>
<p>第三步:在收到SYNACK 报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段;这最后一个报文段对服务器的允许连接的报文段进行了确认（该客户通过将值server_isn+1放置到TCP报文段首部的确认字段中来完成此项工作)。因为连接已经建立」，所以该SYN比特被置为0。第三个阶段可以在报文段负载中携带客户到服务器的数据。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/47.png" alt="?"></p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>天下没有不散的宴席,对于 TCP连接也是这样。参与一条 TCP连接的两个进程中的任何一个都能终止该连接。当连接结束后，主机中的“资源”(（即缓存和变量)将被释放。举一个例子，假设某客户打算关闭连接，如图3-40所示。客户应用进程发出一个关闭连接命令。这会引起客户 TCP向服务器进程发送一个特殊的TCP报文段。这个特殊的报文段让其首部中的一个标志位即 FIN比特（参见图3-29）被设置为1。当服务器接收到该报文段后,就向发送方回送一个确认报文段。然后,服务器发送它自己的终止报文段,其FIN 比特被置为1。最后,该客户对这个服务器的终止报文段进行定确认。此时，在两台主机上用于该连接的所有资源都被释放了。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/48.png" alt="?"></p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/49.png" alt="?"></p>
<p>假设客户应用程序决定要关闭该连接。(注意到服务器也能选择关闭该连接。）这引起客户TCP发送一个带有FIN 比特被置为1的TCP报文段，并进入 FIN_WAIT_1状态。当处在FIN_WAIT_1状态时，客户TCP等待一个来自服务器的带有确认的TCP报文段。当它收到该报文段时，客户TCP 进入FIN_WAIT_2状态。当处在FIN_WAIT_2状态时,客户等待来自服务器的FIN 比特被置为1的另一个报文段;当收到该报文段后，客户TCP对服务器的报文段进行确认，并进入TIME_WAIT状态。假定ACK丢失，TIME_WAIT 状态使TCP客户重传最后的确认报文。在TME_WAIT状态中所消耗的时间是与具体实现有关的，而典型的值是30秒、1分钟或2分钟。经过等待后，连接就正式关闭，客户端所有资源（包括端口号)将被释放。</p>
<p><strong>SYN泛洪攻击</strong><br>这种TCP连接管理协议为经典的DoS攻去即SYN洪泛攻击（SYN flood attack)提供了环境。在这种攻击中，攻击者发送大量的TCP SYN报文段，而不完成第三次握手的步骤。随着这种SYN报文段纷至沓来，服务器不断为这些半开连接分配资源（但从未使用)，导致服务器的连接资源被消耗殆尽。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/50.png" alt="?"></p>
<p>我们上面的讨论假定了客户和服务器都准备通信，即服务器正在监听客户发送其SYN报文段的端口。我们来考虑当一台主机接收到一个 TCp报文段，其端口号或源IP地址与该主机上进行中的套接字都不匹配的情况。例如，假如一台主机接收了具有目的端口80的一个 TCP SYN 分组,但该主机在端口80不接受连接(即它不在端口80上运行 Web服务器)。则该主机将向源发送一个特殊重置报文段。<br>该 TCP报文段将 RST 标志位（参见3.5.2节）置为1。因此，当主机发送一个重置报文段时，它告诉该源“我没有那个报文段的套接字。请不要再发送该报文段了”。当一台主机接收一个UDP分组，它的目的端口与进行中的UDP套接字不匹配，该主机发送一个特殊的 ICMP 数据报，这将在第4章中讨论。</p>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><h3 id="拥塞原因与代价"><a href="#拥塞原因与代价" class="headerlink" title="拥塞原因与代价"></a>拥塞原因与代价</h3><h4 id="情况1-两个发送方和一台具有无穷大缓存的路由器"><a href="#情况1-两个发送方和一台具有无穷大缓存的路由器" class="headerlink" title="情况1:两个发送方和一台具有无穷大缓存的路由器"></a>情况1:两个发送方和一台具有无穷大缓存的路由器</h4><p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/51.png" alt="?"></p>
<p>图3-44描绘出了第一种情况下主机A的连接性能左边的图形描绘了每连接的吞吐量(per-connection throughput)(接收方每秒接收的字节数）与该连接发送速率之间的函数关系。当发送速率在0～R/2之间时，接收方的吞吐量等于发送方的发送速率，即发送方发送的所有数据经有限时延后到达接收方。然而当发送速率超过R/2时，它的吞吐量只能达R/2。这个吞吐量上限是由两条连接之间共享链路容量造成的。链路完全不能以超过R/2的稳定状态速率向接收方交付分组。无论主机A和主机B将其发送速率设置为多高,它们都不会看到超过R/2的吞吐量。<br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/52.png" alt="?"></p>
<p>取得每连接R/2的吞吐量实际上看起来可能是件好事，因为在将分组交付到目的地的过程中链路被充分利用了。但是，图3-44b的图形却显示了以接近链路容量的速率运行时产生的后果。当发送速率接近R/2时（从左至右)，平均时延就会越来越大。当发送速率超过R/2时,路由器中的平均排队分组数就会无限增长源与目的地之间的平均时延也会变成无穷大（假设这些连接以此发送速率运行无限长时间并且有无限量的缓存可用)。</p>
<h4 id="情况2-两个发送方和一台具有有限缓存的路由器"><a href="#情况2-两个发送方和一台具有有限缓存的路由器" class="headerlink" title="情况2:两个发送方和一台具有有限缓存的路由器"></a>情况2:两个发送方和一台具有有限缓存的路由器</h4><p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/53.png" alt="?"></p>
<p style="color:red;">此处略过</p>

<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><p>这里，我们指出在实践中所采用的两种主要拥塞控制方法</p>
<p>在最为宽泛的级别上，我们可根据网络层是否为运输层拥塞控制提供了显式帮助，来区分拥塞控制方法。</p>
<p>端到端拥塞控制。<br>在端到端拥塞控制方法中，网络层没有为运输层拥塞控制提供显式支持。即使网络中存在拥塞，端系统也必须通过对网络行为的观察（如分组丢失与时延）来推断之。TCP必须通过端到端的方法解决拥塞控制，因为IP层不会向端系统提供有关网络拥塞的反馈信息。TCP报文段的丢失（通过超时或3次冗余确认而得知）被认为是网络拥塞的一个迹象,TCP 会相应地减小其窗口长度。我们还将看到关于TCP拥塞控制的一些最新建议,即使用增加的往返时延值作为网络拥塞程度增加的指示.</p>
<p>网络辅助的拥塞控制。<br>在网络辅助的拥塞控制中，网络层构件（即路由器）向发送方提供关于网络中拥塞状态的显式反馈信息。这种反馈可以简单地用一个比特来指示链路中的拥塞情况。该方法在早期的IBM SNA[Schwartz 1982] 和 DECDECnet[Jain 1989: Ramakrishnan 1990] 等体系结构中被采用，近来被建议用于TCP/IP网络，而且还用在我们下面要讨论的ATM可用比特率（ABR）拥塞控制中。更复杂的网络反馈也是可能的。例如，我们很快将学习的一种 ATM ABR拥塞控制形式,它允许路由器显式地通知发送方，告知它(路由器)能在输出链路上支持的传输速率。关于源端是增加还是降低其传输速率，XCP协议对每个源提供了路由器计算的反馈，该反馈携带在分组首部中。</p>
<p>对于网络辅助的拥塞控制，拥塞信息从网络反馈到发送方通常有两种方式.第一种方式直接反馈信息可以由网络路由器发给发送方。这种方式的通知通常采用了一种阻塞分组 （choke packet）的形式（主要是说:“我拥塞了!”)。<br>第二种形式的通知是，路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生。一旦收到一个标记的分组后,接收方就会向发送方通知该网络拥塞指示注意到后一种形式的通知至少要经过一个完整的往返时间。</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/54.png" alt="?"></p>
<h3 id="网络辅助的拥塞控制例子-ATM-ABR拥塞控制"><a href="#网络辅助的拥塞控制例子-ATM-ABR拥塞控制" class="headerlink" title="网络辅助的拥塞控制例子:ATM ABR拥塞控制"></a>网络辅助的拥塞控制例子:ATM ABR拥塞控制</h3><p>ATM 基本上采用一种面向虚电路（VC）的方法来处理分组交换,这意味着从源到目的地路径上的每台交换机将维护有关源到目的地 VC的状态。逐个VC的状态允许交换机跟踪各个发送方的行为（例如,跟踪它们的平均传输速率)，并采取特定源的拥塞控制动作（例如，当交换机变得拥塞时，向发送方发显式信令以减少它的速率)。网络交换机上的这种逐VC状态使ATM非常适合执行网络辅助拥塞控制。</p>
<p>ABR 已被设计成一种弹性数据传输服务，他会充分利用带宽。</p>
<p>在下面的讨论中，我们将采用 ATM的术语(如使用术语交换机而不使用路由器;使用术语信元（cell）而不使用分组)。对于ATMABR服务，数据信元从源经过一系列中间交换机传输到目的地。在数据信元中夹杂着所谓的资源管理信元（Resource-Management cell, RM信元);这些RM信元可被用来在主机和交换机之间传递与拥塞相关的信息。当一个RM信元到达目的地时，它将被掉转方向并向发送方发送（很可能是在目的地修改了该RM信元的内容之后)。交换机也有可能自己产生一个RM信元，并将该RM信元直接发送给源。因此,RM信元可用来提供直接网络反馈和经由接收方的网络反馈，</p>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/q1.png" alt="?"></p>
<p>ATM ABR拥塞控制是一种基于速率的方法。即发送方明确地计算出它所能发送的最大速率，并据此对自己进行相应的调整。ABR 提供三种机制用于从交换机向接收方发送与拥塞相关的信令信息:<br>EFCI比特,CI和NI比特，ER设置</p>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>TCP必须使用端到端拥塞控制而不是使网络辅助的拥塞控制，因为iP层不向端系统提供显式的网络拥塞反馈。</p>
<p>TCP所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率。如果一个 TCP 发送方感知从它到目的地之间的路径上没什么拥塞,则TCP 发送方增加其发送速率;如果发送方感知沿着该路径有拥塞，则发送方就会降低其发送速率。</p>
<p><strong>TCP发送方是如何限制向其连接发送流量的?</strong></p>
<p>TCP连接的每一端都是由一个接收缓存、一个发送缓存和几个变量（LastByteRead,rwnd等）组成。运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即拥塞窗口(congestion window)。拥塞窗口表示为cwnd，它对一个TCP发送方能向网络中发送流量的速率进行了限制。特别是，在一个发送方中未被确认的数据量不会超过cwnd与 rwnd中的最小值,即  LastByteSent - LastByteAcked≤min{cwnd, rwnd}</p>
<p>为了关注拥塞控制(与流量控制形成对比)，我们后面假设TCP接收缓存足够大，以至可以忽略接收窗口的限制;因此在发送方中未被确认的数据量仅受限于cwnd。我们还假设发送方总是有数据要发送，即在拥塞窗口中的所有报文段要被发送。</p>
<p>上面的约束限制了发送方中未被确认的数据量，因此间接地限制了发送方的发送速率。为了理解这一点,我们来考虑一个丢包和发送时延均可以忽略不计的连接。因此粗略地讲,在每个往返时间（RTT)的起始点，上面的限制条件允许发送方向该连接发送 cwnd个字节的数据，在该RTT结束时发送方接收对数据的确认报文。</p>
<p><strong>因此,该发送方的发送速率大概是cwnd/RTT(字节/秒)。通过调节cwnd的值，发送方因此能调整它向连接发送数据的速率。</strong></p>
<p><strong>TCP发送方是如何感知在它与目的地之间的路径上出现拥塞的?</strong><br>要么出现超时,要么收到来自接收方的3个冗余ACK。</p>
<p><strong>TCP 发送方怎样确定它应当发送的速率呢?</strong></p>
<ol>
<li><p>一个丢失的报文段表意味着拥塞，因此当丢失报文段时应当降低TCP发送方的速率。</p>
</li>
<li><p>一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时,能够增加发送方的速率。</p>
</li>
<li><p>带宽探测。给定ACK指示源到目的地路径无拥塞，而丢包事件指示路径拥塞,TCP调节其传输速率的策略是增加其速率以响应到达的ACK,除非出现丢包事件,此时才减小传输速率。</p>
</li>
</ol>
<h3 id="TCP拥塞控制算法（TCP-con-gestion-control-algorithm"><a href="#TCP拥塞控制算法（TCP-con-gestion-control-algorithm" class="headerlink" title="TCP拥塞控制算法（TCP con-gestion control algorithm)"></a>TCP拥塞控制算法（TCP con-gestion control algorithm)</h3><p><strong>该算法包括3个主要部分:①慢启动;②拥塞避免;③快速恢复。</strong><br>慢启动和拥塞避免是TCP的强制部分，两者的差异在于对收到的ACK做出反应时增加cwnd长度的方式。慢启动比拥塞避免能更快地增加cwnd的长度（不要被名称所迷惑!)。快速恢复是推荐部分，对TCP发送方并非是必需的。</p>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p><strong>开始增长</strong></p>
<p><strong>当一条TCP连接开始时，cwnd的值通常初始置为一个 MSS 的较小值</strong>，这就使得初始发送速率大约为 MSS/RTT。由于对TCP 发送方而言，可用带宽可能比 MSS/RTT大得多，<strong>TCP发送方希望迅速找到可用带宽的数量</strong>。因此,在慢启动(slow-start）状态，cwnd的值以1个 MSS 开始并且每当传输的报文段首次被确认就增加1个 MSS。TCP向网络发送第一个报文段并等待一个确认。当该确认到达时，TCP发送方将拥塞窗口增加一个MSS，并发送出两个最大长度的报文段。这两个报文段被确认,则发送方对每个确认报文段将拥塞窗口增加一个 MSS，使得拥塞窗口变为4个 MSS，并这样下去。这一过程每过一个RTT,发送速率就翻番。因此,TCP 发送速率起始慢，但在慢启动阶段以指数增长。</p>
<p><strong>每一个mss增加一个，等于所有的翻倍，2^n</strong><br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/q2.png" alt="?"></p>
<p><strong>结束增长</strong></p>
<ol>
<li><p>如果存在一个由超时指示的丢包事件（即拥塞)，TCP发送方将cwnd设置为1并重新开始慢启动过程。它还将第二个状态变量的值ssthresh（“慢启动阈值”的速记)设置为cwnd/2,即当检测到拥塞时将ssthresh 置为拥塞窗口值的一半。</p>
</li>
<li><p>慢启动结束的第二种方式是直接与ssthresh的值相关联。因为当检测到拥塞时ssthresh 设为cwnd的值一半，当到达或超过ssthresh的值时，继续使cwnd,翻番可能有些鲁莽。因此，当cwnd的值等于ssthresh时，结束慢启动并且 TCP转移到拥塞避免模式。我们将会看到，当进入拥塞避免模式时，TCP更为谨慎地增加cwnd。</p>
</li>
<li><p>最后一种结束慢启动的方式是，如果检测到3个冗余ACK,这时TCP执行一种快速重传并进入快速恢复状态，后面将讨论相关内容。慢启动中的TCP行为总结在图3-52中的TCP拥塞控制的FSM描述中。</p>
</li>
</ol>
<p><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/q3.png" alt="?"></p>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>进入拥寒避免状态，cwnd的值大约是上次遇到拥塞时的值的一半，即距离拥塞可能并不遥远!因此，TCP 无法每过一个RTT再将cwnd的值翻番，而是采用了一种较为保守的方法，<strong>每个RTT只将cwnd的值增加一个 MSS（不是每个mss增加一个mss）</strong> 。这能够以几种方式完成。一种通用的方法是对于TCP发送方无论何时到达一个新的确认，就将cwnd增加一个MSS(MSS/cwnd）字节。例如，如果MSS是 1460字节并且cwnd是 14600字节，则在一个RTT内发送10个报文段。每个到达ACK（假定每个报文段一个 ACK）增加1/10MSS的拥塞窗口长度，因此在收到对所有10个报文段的确认后，拥塞窗口的值将增加了一个 MSS。</p>
<p>但是何时应当结束拥塞避免的线性增长（每RTT 1MSS）呢?当出现超时时,TCP的拥塞避免算法行为相同。与慢启动的情况一样，cwnd 的值被设置为1个MSS，当丢包事件出现时，ssthresh 的值被更新为 cwnd值的一半。然而，前面讲过丢包事件也能由一个三个冗余ACK事件触发。在这种情况下，网络继续从发送方向接收方交付报文段（就像由收到冗余ACK所指示的那样)。因此TCP对这种丢包事件的行为，相比于超时指示的丢包,应当不那么剧烈:TCP将cwnd的值减半（为使测量结果更好，计及已收到的3个冗余的ACK 要加上3个MSS），并且当收到3个冗余的 ACK,将ssthresh的值记录为cwnd的值的一半。接下来进入快速恢复状态。</p>
<h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p><strong>当TCP接收方收到三个冗余的ACK报文时，就会触发快速重传。</strong><br>在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余的ACK, cwnd的值增加一个MSS。最终，当对丢失报文段的一个 ACK到达时，TCP在降低cwnd后进入拥塞避免状态。如果出现超时事件，快速恢复在执行如同在慢启动和拥塞避免中相同的动作后，迁移到慢启动状态:当丢包事件出现时，cwnd 的值被设置为1个MSS，并且ssthresh的值设置为 cwnd值的一半。</p>
<p>Tahoe的TCP早期版本不管是发生超时指示的丢包事件，还是发生3个余ACK指示的丢包事件，都无条件地将其拥塞窗口减至1个MSS，并进入慢启动阶段。TCP的较新版本TCPReno，则综合了快速恢复。</p>
<p>阙值初始等于8个MSS。在前8个传输回合，Tahoe和Reno采取了相同的动作。拥塞窗口在慢启动阶段以指数速度快速爬升，在第4 轮传输时到达了值。然后拥塞窗口以线性速度爬升，直到在第8轮传输后出现3个余ACK。注意到当该丢包事件发生时，拥塞窗口值为12MSS。于是ssthresh的值被设置为0.5xcwnd=6MSS。在TCPReno下，拥塞窗口被设置为cwnd=9MSS（6加上3个ack），然后线性地增长。在TCP Taoe 下，拥塞窗口被设置为1个MSS，然后呈指数增长，直至到达ssthresh值为止，在这个点它开始线性增长。<br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/q6.png" alt="?"></p>
<p><strong>整个过程</strong><br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/q4.png" alt="?"><br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/q5.png" alt="?"></p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol>
<li>假定网络层提供了下列服务。在源主机中的网络层接受最大长度1200字节和来自运输层的目的主机地址的报文段。网络层则保证将该报文段交付给位于目的主机的运输层。假定在目的主机上能够运行许多网络应用进程。</li>
</ol>
<p>a设计可能最简单的运输层协议，该协议将使应用程序数据到达位于目的主机的所希望的进程。假设在目的主机中的操作系统已经为每个运行的应用进程分配了个4字节的端口号。</p>
<blockquote>
<p>a）将此协议称为简单传输协议(STP)。在发送⽅，STP从发送进程接受不超过1196字节的数据块、⽬标主机地址和⽬标端⼝号。STP在每个块中添加⼀个4字节的头，并将⽬标进程的端⼝号放在这个标头中。然后，STP将⽬标主机地址和结果段提供给⽹络层。⽹络层将段传送到⽬标主机上的STP。STP然后检查段中的端⼝号，从段中提取数据，并将数据传递给由端⼝号标识的进程。</p>
</blockquote>
<blockquote>
<p><strong>tcp套接字是4元组，udp套接字是2元组（目的IP地址，目的端口），这是为了维护目的套接字唯一对应，udp不是。udp和tcp报文头都有目的端口和源端口，udp由os分配源端口，经过网络层加上ip地址。</strong></p>
</blockquote>
<blockquote>
<p>b.修改这个协议，使它向目的进程提供一个的“返回地址”。</p>
</blockquote>
<blockquote>
<p>b）段现在有两个头字段：源端⼝字段和⽬标端⼝字段。在发送⽅，STP接受不超过1192字节的数据块、⽬标主机地址、源端⼝号和⽬标端⼝号。STP创建⼀个段，其中包含应⽤程序数据、源端⼝号和⽬标端⼝号。然后，它将段和⽬标主机地址提供给⽹络层。在接收到段后，接收主机上的STP给出应⽤程序的应⽤程序数据和源端⼝号</p>
</blockquote>
<p><strong>报文头中目的端口是为了和目的主机通信，源端口是为了目标主机给我们返回消息通信</strong></p>
<blockquote>
<p>在你的协议中，该运输层在计算机网络的核心中“必须做任何事”吗?</p>
</blockquote>
<blockquote>
<p>不，传输层不需要在核⼼中做任何事情；传输层“⽣命”在最终系统中。</p>
</blockquote>
<ol start="2">
<li>考虑有一个星球,每个人都属于某个六口之家，每个家庭都住在自己的房子里，每个房子都一个唯一的地址，并且某给定家庭中的每个人有一个独特的名字。假定该星球有一个从源家庭到目的家庭交付信件的邮政服务。该邮件服务要求:①在一个信封中有一封信;②在信封上消定地与上日的家庭的地址（并且没有别的东西)。假设每个家庭有一名家庭成员代表为家庭中的其他成员收集和分发信件。这些信没有必要提供任何有关信的接收者的指示。</li>
</ol>
<blockquote>
<p>寄信时，家庭成员必须将信件本⾝、⽬的地住所的地址和收件⼈的姓名交给代表。委托将收件⼈的姓名清楚地写在信函的顶部。然后，委托将信放⼊信封中，并在信封上写⼊⽬标住宅的地址。然后，代表将这封信交给地球的邮件服务部⻔。在接收⽅，委托收到来⾃邮件服务的信函，从信封中取出信件，并记下在信件顶部写的收件⼈姓名。然后，代表将这封信交给具有此名称的家庭成员。</p>
</blockquote>
<ol start="3">
<li>考虑在主机A和主机B之间有一条TCP连接。假设从主机A传送到主机B的TCP报文段具有源端口号x和目的端口号y。对于从主机B传送到主机A的报文段，源端口号和目的端口号分别是多少?</li>
</ol>
<blockquote>
<p>源端⼝号y和⽬标端⼝号x。</p>
</blockquote>
<ol start="4">
<li>描述应用程序开发者为什么可能选择在UDP上运行应用程序而不是在TCP上运行的原因。</li>
</ol>
<blockquote>
<p>应⽤程序开发⼈员可能不希望其应⽤程序使⽤TCP的拥塞控制，这会在拥塞时限制应⽤程序的发送速率。通常，IP电话和IP视频会议应⽤程序的设计者选择在UDP上运⾏他们的应⽤程序，因为他们希望避免TCP的拥塞控制。另外，有些应⽤程序不需要TCP提供的可靠数据传输。</p>
</blockquote>
<ol start="5">
<li>在今天的因特网中，为什么语音和图像流量常常是经过TCP 而不是经UDP发送。</li>
</ol>
<blockquote>
<p>由于大多数防火墙都被配置为阻止UDP通信，因此使用TCP进行视频和语音通信可以让通信通过防火墙。</p>
</blockquote>
<ol start="6">
<li>当某应用程序运行在UDP上时，该应用程序可能得到可靠数据传输吗?如果能，如何实现?</li>
</ol>
<blockquote>
<p>是的。应用程序开发人员可以将可靠的数据传输放到应用层中协议。</p>
</blockquote>
<ol start="7">
<li>假定在主机C上的一个进程有一个具有端口号6789的 UDP套接字。假定主机A和主机B都用目的端口号6789向主机C发送一个UDP报乂段。赵网日王优的A三救人区日上扰的过两人坦立段?套接字吗?如果是这样的话，在主机C的该进程将怎样知道源于两台不同主机的这两个报文段?</li>
</ol>
<blockquote>
<p>是的，两个段将指向同⼀个套接字。对于每个接收到的段，在套接字接⼝上，操作系统将为进程提供IP地址，以确定各个段的来源。</p>
</blockquote>
<ol start="8">
<li>假定在主机C端口80上运行的一个Web服务器。假定这个Web服务器使用持续连接，并且正在接收来自两台不同主机A和B的请求。被发送的所有请求都通过位于主机C的相同套接字吗?如果它们通过不同的套接字传递，这两个套接字都具有端口80吗?讨论和解释之。</li>
</ol>
<blockquote>
<p>对于每个持久连接，Web服务器创建⼀个单独的连接插座。每个连接套接字被标识为具有四个元组:(源IP地址,源端⼝号、⽬标IP地址、⽬标端⼝号)。当主机C接收和IP数据报，它检查数据报/段中的这四个字段确定哪个套接字应该通过TCP段的有效负载。因此,来⾃A和B的请求通过不同的套接字。这两个参数的标识符⽤于⽬标端⼝的套接字具有80；但是，这些套接字的标识符源IP地址的不同值。与UDP不同，传输层通过时TCP段对应⽤程序进程的有效负载，它不指定源IP地址，因为这是由套接字标识符隐式指定的。</p>
</blockquote>
<ol start="9">
<li><p>在我们的rdt协议中,为什么需要引入序号?</p>
<blockquote>
<p>接收机需要序列号来确定到达的数据包是包含新数据还是是重传。</p>
</blockquote>
</li>
<li><p>在我们的rdt协议中,为什么需要引入定时器?</p>
<blockquote>
<p>处理通道中的损失。如果在该分组的计时器持续时间内未接收到发送分组的ACK，则假定该分组(或其ACK或NACK)已丢失。因此，分组被重传。</p>
</blockquote>
</li>
<li><p>假定发送方和接收方之间的往返时延是固定的并且为发送方所知。假设分组能够丢失的话，在协议rdt3.0中一个定时器仍是必需的吗?试解释之。</p>
</li>
</ol>
<blockquote>
<p>在RDT 3.0协议中仍然需要计时器。如果知道往返时间，那么唯一的优势是，发送方肯定知道数据包或数据包的ACK(或Nack)已经丢失，而实际情况是，在计时器过期后，ACK(或Nack)可能仍在发送方的途中。然而，要检测丢失，对于每个包，一个持续时间不变的定时器仍然需要在发送者。</p>
</blockquote>
<ol start="12">
<li>在Go-Back-N(回退N步) <blockquote>
<p>a)让源发送5个分组，在这5个分组的任何一个到达目的地之前暂停该动画。然后毁掉第一个分组并继续该动画。试描述发生的情况。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>丢包造成一段时间后，所有五个包都被重传。</p>
</blockquote>
<blockquote>
<p>b)重复该实验，只是现在让第一个分组到达目的地并毁掉第一个确认。再次描述发生的情况。</p>
</blockquote>
<blockquote>
<p>由于Go-Back-N使用累积数据，ACK的丢失没有触发任何重传。</p>
</blockquote>
<blockquote>
<p>c)最后，尝试发送6个分组。发生了什么情况?</p>
</blockquote>
<blockquote>
<p>发送方无法发送第六个分组，因为发送窗口大小固定为5。</p>
</blockquote>
<ol start="13">
<li>重复复习题R12，但是现在使用 Selective Repeat（选择重传） Ja<br>小程序。选择重传和回退N步有什么不同?<blockquote>
<p>a)当分组丢失时，接收的4个分组被缓冲接收器。完成后超时，发送方重新发送丢失的数据包，接收方传送缓冲的数据包数据包以正确的顺序应用。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>发送方再次发送单个丢失报文，接收器为丢失的ACK发送了重复ACK。</p>
</blockquote>
<ol start="14">
<li>a.主机A经过一条TCP连接向主机B发送一个大文件。假设主机B没有数据发往主机A。因为主机B不能随数据捎带确认，所以主机B将不向主机A发送确认。<blockquote>
<p>错</p>
</blockquote>
</li>
</ol>
<p>b.在连接的整个过程中，TCP的rwnd的长度决不会变化。</p>
<blockquote>
<p>错</p>
</blockquote>
<p>c.假设主机A通过一条TCP连接向主机B发送一个大文件。主机A发送但未被确认的字节数不会超过接收缓存的大小。</p>
<blockquote>
<p>对</p>
</blockquote>
<p>d假设主机A通过一条TCP连接向主机B发送一个大文件。如果对于这条连接的一个报文段的序号为m,则对于后继报文段的序号将必然是m +1。</p>
<blockquote>
<p>错【这个 m 可能是重传的，重传后回归正常顺序，就不知道是不是 m+1 了】</p>
</blockquote>
<p>e. TCP报文段在它的首部中有一个rwnd字段。</p>
<blockquote>
<p>对</p>
</blockquote>
<p>f假定在一条TCP连接中最后的SampleRTT 等于1秒，那么对于该连接的TimeoutInterval 的当前值必定大于等于1秒。</p>
<blockquote>
<p>错误。【超时时间的计算与均值 RTT 有关，而均值 RTT 的计算公式中样本 RTT 是有权值的，不是大于等于的关系，具体公式和计算过程 P158、P159】</p>
</blockquote>
<p>g,假设主机A通过一条TCP连接向主机B发送一个序号为38的4个字节的报文段。在这个相同的报文段中,确认号必定是42。</p>
<blockquote>
<p>不一定。确认号应该是下一个期望接收的报文段的序号，因此如果主机 B 已经接收到序号为 38 的报文段，那么确认号应该是 42。但如果主机 B 还没有接收到序号为 38 的报文段，那么确认号应该是 37。</p>
</blockquote>
<ol start="15">
<li>假设主机A通过一条TCP 连接向主机B发送两个紧接着的’TCP 报文段。第一个报文段的序亏为少，第二个报文段序号为110。</li>
</ol>
<p>第一个报文段中有多少数据?</p>
<blockquote>
<p>20 bytes</p>
</blockquote>
<p>假设第一个报文段丢失而第二个报文段到达主机B。那么在主机B发往主机A的确认报文中确认号应该是多少?</p>
<blockquote>
<p>ack number = 90</p>
</blockquote>
<ol start="16">
<li><p>假设两条TCP连接存在于一个带宽为R bps的瓶颈链路上。它们都要发送一个很大的文件（以相同方向经过瓶颈链路)，并且两者是同时开始发送文件。那么TCP将为每条连接分配什么样的传输速率?</p>
<blockquote>
<p>R/2</p>
</blockquote>
</li>
<li><p>是非判断题。考虑TCP的拥塞控制。当发送方定时器超时时，其ssthresh的值将被设置为原来值的一半。</p>
<blockquote>
<p>false，它设置为拥塞窗⼝的当前值的⼀半。</p>
</blockquote>
</li>
</ol>
<h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><ol>
<li>假设客户A向服务器S发起一个Telnet 会话。与此同时，客户B也向服务器S发起一个Telnet 会话。给出下面报文段的源端口号和目的端口号:<br>a从A向S发送的报文段。<blockquote>
<p>A→S 467 23</p>
</blockquote>
</li>
</ol>
<p>b.从B向S发送的报文段。</p>
<blockquote>
<p>B→S 513 23</p>
</blockquote>
<p>c.从S向A发送的报文段。</p>
<blockquote>
<p>S→A 23 467</p>
</blockquote>
<p>d.从S向B发送的报文段。</p>
<blockquote>
<blockquote>
<p>S→B 23 513</p>
</blockquote>
</blockquote>
<p>e.如果A和B是不同的主机，那么从A向S发送的报文段的源端口号是否可能与从B向S发送的报文段的源端口号相同?</p>
<blockquote>
<p>是</p>
</blockquote>
<p>f如果它们是同一台主机,情况会怎么样?</p>
<blockquote>
<p>不，端口不同区分套接字</p>
</blockquote>
<ol start="2">
<li>考虑图3-5。从服务器返回客户进程的报文流中的源端口号和目的端口号是多少?在承载运输层报文段的网络层数据报中，IP地址是多少?<br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/q7.png" alt="?"></li>
</ol>
<blockquote>
<p>到主机A：源端口=80，源IP地址=b，DEST端口=26145，DESTIP地址=a<br>到主机C，左进程：源端口=80，源IP地址=b，DEST端口=7532，DESTIP地址=c</p>
</blockquote>
<p><em><strong>其实下面的反码不应该是反码，直接把01互换就行，原因见<a href="https://codecodegogogo.github.io/2023/06/01/%E8%AE%A1%E7%BD%91%E4%B8%AD%E7%9A%84%E5%8F%8D%E7%A0%81/">计网中的反码</a></strong></em></p>
<ol start="3">
<li><p>UDP和TCP使用反码来计算它们的检验和。假设你有下面3个8比特字节:01010011,01100110,01110100。这些8比特字节和的反码是多少?(注意到尽管UDP 和TCP使用16比特的字来计算检验和，但对于这个问题，你应该考虑8比特和。）写出所有工作过程。UDP为什么要用该和的反码，即为什么不直接使用该和呢?使用该反码方案，接收方如何检测出差错?1比特的差错将可能检测不出来吗?2比特的差错呢?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果溢出，请绕一圈。</span><br><span class="line">   1 0 1 1 1 0 0 1</span><br><span class="line"> + 0 1 1 0 0 1 1 0</span><br><span class="line">------------------</span><br><span class="line">   0 1 0 1 0 0 1 1</span><br><span class="line">上面没算出来</span><br><span class="line"></span><br><span class="line">   0 1 1 1 0 1 0 0</span><br><span class="line"> + 1 0 1 1 1 0 0 1</span><br><span class="line"> -----------------</span><br><span class="line">   0 0 1 0 1 1 1 0</span><br><span class="line">反码为： 1 1 0 1 0 0 0 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了检测错误，接收⽅添加四个单词(三个原始单词和校验和)。如果和包含⼀个零，接收器知道有⼀个错误。所有的⼀位错误都会被检测到，但是两位错误可以不被检测到(例如，如果第⼀个单词的最后⼀个数字被转换为0，第⼆个单词的最后⼀个数字被转换为1)。</p>
</blockquote>
</li>
<li><p>a.假定你有下列2个字节:01011100和01100101。这2个字节之和的反码是什么?</p>
<blockquote>
<p>a)将这两个字节相加得到11000001。取反码就等于00111110。</p>
</blockquote>
</li>
</ol>
<p>b.假定你有下列2个字节:11011010和01100101。这2个字节之和的反码是什么?</p>
<blockquote>
<p>把这两个字节相加，等于01000000；补码等于10111111。</p>
</blockquote>
<p>c.对于（a)中的字节，给出一个例子，使得这2个字节中的每个都在一个比特反转时,其反码不会改变。</p>
<blockquote>
<p>c)第一个字节=01010100；第二个字节=01101101。<br>没懂题目啥意思</p>
</blockquote>
<ol start="5">
<li><p>假定某UDP接收方对接收到的UDP报文段计算因特网检验和，并发现它与承载在检验和字段中的值相匹配。该接收方能够绝对确信没有出现过比特差错吗?试解释之。</p>
<blockquote>
<p>不，接收⽅不能完全确定没有发⽣任何位错误。这是因为计算数据包的校验和的⽅式。如果包中两个16位字的对应位(相加在⼀起)是0和1，那么即使这些位分别翻转到1和0，和仍然保持不变。因此，接收⽅计算的1s补码也将是相同的。这意味着，即使存在传输错误，校验和也将进⾏验证。</p>
</blockquote>
</li>
<li><p>在rdl3.0协议中，从接收方向发送方流动的ACK分组没有序号（尽管它们具有ACK字段，该字段包括了它们正在确认的分组的序号)。为什么这些ACK分组不需要序号呢?</p>
</li>
</ol>
<blockquote>
<p>要想最好地回答这个问题，⾸先考虑⼀下为什么我们需要序列号。我们看到发送⽅需要序列号，以便接收⽅能够判断数据包是否是已经接收到的数据包的副本。在ACK的情况下，发送⽅不需要这个信息(即ACK上的序列号)来判断是否检测到重复的ACK。对于rdt3.0接收器来说，⼀个重复的ACK是显⽽易⻅的，因为当它接收到原始ACK时，它会转换到下⼀个状态。重复的ACK不是发送⽅需要的ACK，因此被rdt3.0发送⽅忽略。</p>
</blockquote>
<ol start="7">
<li>考虑一个GBN协议，其发送方窗口为4,序号范围为1024。假设在时刻t,接收方期待的下一个有序分组的序号是k。假设媒体不会对报文重新排序。回答以下问题:<br>a.在t时刻，发送方窗口内的报文序号可能是多少?论证你的回答。<blockquote>
<p>有一个 N=4 的窗口大小。 假设接收器已经接收到数据包 k-1，并已将该数据包和所有其前面的数据包确认了。 如果所有这些 ACK 都被发件人收到，那么发送窗口是[k，k+N-1]。 接下来假设没有一个 ACK 被发件人收到。 在第二种情况下，发送方的窗口包含 k-1 和 N个数据包，直到并包括 k-1。 发送者的窗口因此是[k-N，k-1]。 总之，序号开始于范围[k-N，k]的某个地方，发送窗口大小 N 为 4，序号[k-N, k+N-1]都有可能出现在窗口内。</p>
</blockquote>
</li>
</ol>
<p>b.在t时刻,在当前传播回发送方的所有可能报文中,ACK字段的所有可能值是多少?论证你的回答。</p>
<blockquote>
<p>如果接收机正在等待分组k，则它已经接收(和被处理)分组k-1和N-1个分组。如果尚未收到这些N个ACK中的任何一个，发送方，然后可以传播具有[k-n,k-1]值的ACK消息由于发送方发送了数据包[k-n,k-1],所以必须是这样的情况:发送方已经接收到用于k-n-1的ACK。一旦接收机发送了ACK,对于k-n-1，它将永远不会发送小于k-n-1的ACK。因此，飞行中的ACK值的范围可以从k-n-1到k-1。</p>
</blockquote>
<ol start="8">
<li>对下面的问题判断是非，并简要地证实你的回答:<br>a.对于SR协议，发送方可能会收到落在其当前窗口之外的分组的ACK。<br>b.对于GBN 协议，发送方可能会收到落在其当前窗口之外的分组的ACK。<blockquote>
<p>真。假设发送方具有3的窗口大小并且在T0发送分组1、2、3。在T1(T1/T0)接收机ACK1、2、3。在t2(t2，t1)发送方超时，并且重新连接1、2、3。在t3,接收机接收重复并重新确认1、2,3、在T4，发送方接收到在T1发送的接收机并使其前进的ACK。窗口至4、5、6。在t5，发送方接收在T2发送的接收机的ACK1、2、3。这些棚屋在窗户外面。</p>
</blockquote>
</li>
</ol>
<p>C.当发送方和接收方窗口长度都为1时，比特交替协议与 SBR协议相同。<br>d当发送方和接收方窗口长度都为1时，比特交替协议与GBN协议相同。</p>
<blockquote>
<p>真。请注意，具有1、SR、GBN和交替位协议的窗口大小功能等同。窗口大小1排除了无序分组的可能性(在窗口内)。累积ACK仅仅是普通ACK,这种情况，因为它只能指窗口内的单个分组。</p>
</blockquote>
<ol start="9">
<li>我们曾经说过，应用程序可能选择UDP作为运输协议，因为UDP提供了(比 TCP）更好的应用层控制,以决定在报文段中发送什么数据和发送时机。<br>a.应用程序为什么对在报文段中发送什么数据有更多的控制?b.应用程序为什么对何时发送报文段有更多的控制?<blockquote>
<p>考虑在传输协议上发送应用消息。使用TCP，应用程序将数据写入连接发送缓冲区，TCP将抓取字节必须在TCP段中放置一个消息；TCP可能会或多或少地发送消息而不是在段中的单个消息。另一方面，UDP封装在无论应用程序给出什么，都会分段；因此，如果应用程序提供UDP应用消息，此消息将是UDP段的有效负载。因此,对于UDP，应用程序对数据段中的数据进行了更多控制。</p>
</blockquote>
</li>
</ol>
<p>b.应用程序为什么对何时发送报文段有更多的控制?</p>
<blockquote>
<p>由于流量控制和拥塞控制，TCP由于流量控制和拥塞控制，可能会有显著的延迟从应用程序向其发送缓冲器写入数据直到数据被指定给网络层。UDP由于流控制而没有延迟,拥塞控制。</p>
</blockquote>
<ol start="10">
<li><p>考虑从主机A向主机B传输L字节的大文件，假设MSS为536字节。<br>a为了使得TCP序号不至于用完L的最大值是多少?前面讲过TCP的序号字段为4字节</p>
<blockquote>
<p>2^32 = 4,294,967,296。序列号不随每个分组增加，相反它以发送的数据字节数递增【即 TCP 是以字节编号的】。 因此，MSS 的大小是不相关的——可以从 A 发送到 B 的最大大小文件只是可表示的字节数为2^32。</p>
</blockquote>
</li>
<li><p>主机A和B经一条TCP连接通信，并且主机B已经收到了来自A的最长为126字节的所有字节。假定主机A随后向主机B发送两个紧接着的报文段。第一个和第二个报文段分别包含了80字节和40字节的数据。在第一个报文段中，序号是127，源端口号是302，目的地端口号是80。无论何时主机B接收到来自主机A的报文段，它都会发送确认。<br>a在从主机A发往B的第二个报文段中，序号、源端口号和目的端口号各是什么?</p>
<blockquote>
<p>在从主机A到B的第二段中，序列号为207，源端口号为302，目的端口号为80。</p>
</blockquote>
</li>
</ol>
<p>b如果第一个报文段在第二个报文段之前到达，在第一个到达报文段的确认中，确认号、源端口号和目的端口号各是什么?</p>
<blockquote>
<p>如果所述第一段在所述第二到达段之前到达，则在所述第一到达段的确认中，所述确认号为207，所述源端口号为80，所述目的端口号为302</p>
</blockquote>
<p>c.如果第二个报文段在第一个报文段之前到达，在第一个到达报文段的确认中，确认号是什么?</p>
<blockquote>
<p>如果第二段到达第一段之前，在第一个到达段的确认中，确认号为127，表示它仍在等待字节127和以后</p>
</blockquote>
<p>d.假定由A发送的两个报文段按序到达B。第一个确认丢失了而<strong>第二个确认在第一个超时间隔之后</strong>到达。画出时序图，显示这些报文段和发送的所有其他报文段和确认。(假设没有其他分组丢失。)对于图上每个报文段，标出序号和数据的字节数量:对于你增加的每个应答，标出确认号。<br><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/q8.png" alt="?"><br><strong>(这种情况对应原书p165情况二，在第一段超时后，这两个才到，只需要重发第一段。如果在超时前到达就不需要发了)</strong></p>
<ol start="12">
<li><p>主机A和B直接经一条100Mbps链路连接。在这两台主机之间有一条TCP连接。主机A经这条连接向主机B发送一个大文件。主机A能够向它的TCP套接字以高达120Mbps的速率发送应用数据而主机B能够以最大50Mbps的速率从它的TCP接收缓存中读出数据。描述TCP流量控制的影响。</p>
<blockquote>
<p>由于链路容量只有100 Mbps，所以主机A的发送速率最多可达100 Mbps。不过，主机A向接收缓冲区发送数据的速度比主机B从缓冲区中删除数据的速度要快。接收缓冲区的填充速率约为40 Mbps。当缓冲区已满时，主机B通过设置RcvWindow=0向主机A发送停止发送数据的信号。然后主机A停止发送，直到接收到RcvWindow&gt;0的TCP段为止。主机A将作为RcvWindow值的函数反复停止并开始发送从主机B接收。平均而言，主机A向主机发送数据的长期速率b作为此连接的一部分，不超过60Mbps。</p>
</blockquote>
</li>
<li><p>在3.56节中讨论了SYNcookie。<br>a服务器在SYNACK中使用一个特殊的初始序号，这为什么是必要的?</p>
<blockquote>
<p>服务器使用特定的初始序列号(从源和目的地IP和端口的散列中获取)来抵御SYN洪水攻击。</p>
</blockquote>
</li>
</ol>
<p>b.假定某攻击者得知了一台目标主机使用了SYNcookie。该攻击者能够通过直接向目标发送一个ACK分组创建半开或全开连接吗?为什么?</p>
<blockquote>
<p>不，攻击者不能通过向目标发送和ACK数据包来创建半开放或完全打开的连接。半开连接是不可能的，因为在建立完整连接之前，使用SYNcookie的服务器不会维护任何连接的连接变量和缓冲区。为了建立完全开放的连接，攻击者应该从攻击者那里知道与(伪造的)源IP地址对应的特定初始序列号。这个序列号需要每个服务器使用的“秘密”编号。由于攻击者不知道这个秘密号码，她无法猜测初始序列号。</p>
</blockquote>
<p>c.假设某攻击者收集了由服务器发送的大量初始序号。该攻击者通过发送具有初始序号的ACK，能够引起服务器产生许多全开连接吗?为什么?</p>
<blockquote>
<p>不，服务器可以简单地在计算这些初始序列号时加上时间戳，并为这些序列号选择一个存活值，即使攻击者重播，也可以丢弃过期的初始序列号。</p>
<blockquote>
<p>(SendBase在发送端，代表最早未收到确认（Ack）的字节。<br>LastByteRcvd在接收端，代表最后一个收到的字节。<br>因为有Ack可能在返回信道中，暂未被发送端收到。所以LastByteRcvd应该比SendBase来的大。<br>假设所有发送的Ack均已收到，由于SendBase-1为最后一个收到确认的字节序号，那么此时在接收端的LastByteRecv应该与SendBase-1是相等的。)</p>
</blockquote>
</blockquote>
<ol start="14">
<li><p>在3.5.4节中我们看到TCP直到收到3个余ACK才执行快速重传。你对TCP设计者没有选择在收到对报文段的第一个冗余ACK后就快速重传有何看法?</p>
<blockquote>
<p>主要的考虑还是要区分包的丢失是由于链路故障还是乱序等其他因素引发。两次duplicated ACK时很可能是乱序造成的！三次duplicated ACK时很可能是丢包造成的！四次duplicated ACK更更更可能是丢包造成的！但是这样的响应策略太慢。丢包肯定会造成三次duplicated ACK!综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。</p>
</blockquote>
</li>
<li><p>比较CBN、SR和TCP(无延时的ACK)。假设对所有3个协议的超时值足够长，使得5个连续的数据报文段及其对应的ACK 能够分别由接收主机(主机B)和发送主机(主机A)收到(如果在信道中无丢失)。假设主机A向主机B发送5个数据报文段并且第二个报文段(从A发送)丢失最后，所有5个数据报文段已经被主机B正确接收。<br>a.主机A总共发送了多少报文段和主机B总共发送了多少ACK?它们的序号是什么?对所有3个协议回答这个问题。</p>
<blockquote>
<p>gbn：A总共发送9个段。它们最初被发送段1、2、3、4、5和随后重新发送段2、3、4、5。B发送8个ACK。它们是4个带有序号1和4个ACK的ACK序列号2、3、4和5。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>sr：A总共发送6个段。它们最初被发送段1、2、3、4、5和随后重新发送段2。B派5个ACK。它们是序列号1、3、4、5的4个ACK。</p>
</blockquote>
<blockquote>
<p>TCP:A总共发送6个段。它们最初被发送段1、2、3、4、5和随后重新发送段2。B派5个ACK。它们是具有序列号2的4个ACK。<strong>有一个ACK序列号6</strong>。请注意，TCP始终发送带有预期序列的ACK编号。</p>
</blockquote>
<p>b.如果对所有3个协议超时值比5RTT长得多，则哪个协议在最短的时间间隔中成功地交付所有5个数据报文段?</p>
<blockquote>
<p>TCP。这是因为TCP使用快速重传而不等待，直到超时。</p>
</blockquote>
<ol start="16">
<li><img src="/2023/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/q9.png" alt="?"></li>
</ol>
<p><strong>ssthresh的值根据cwnd一半来的，超时后cwnd为1，3次冗余cwnd为现在的一半加3（歇息人书中为一半）；阈值在这两种情况下都为cwnd的一半。在某一轮cwnd超过了ssthresh，按sstresh算</strong><br>a.指出TCP慢启动运行时的时间间隔。</p>
<blockquote>
<p>TCPSlowStart以[1,6]和[23,26]的间隔运行</p>
</blockquote>
<p>b.指出TCP拥塞避免运行时的时间间隔。</p>
<blockquote>
<p>TCP拥塞避免以间隔[6,16]和[17,22]运行</p>
</blockquote>
<p>c在第16个传输轮回之后，报文段的丢失是根据3个余ACK还是根据超时检测出来的</p>
<blockquote>
<p>第16次传输循环后，数据包丢失由三重复制识别ACK。如果超时，则拥塞窗口大小将下降到1。</p>
</blockquote>
<p>d.在第22个传输轮回之后，报文段的丢失是根据3个余ACK还是根据超时检测出来的?</p>
<blockquote>
<p>第22次传输循环后，由于超时而检测到段丢失，因此，拥塞窗口大小设置为1。</p>
</blockquote>
<p>e.在第1个传输轮回里，ssthresh的初始值设置为多少?</p>
<blockquote>
<p>阈值最初是32，因为它处于慢启动停止的窗口大小，并且拥塞避免开始。</p>
</blockquote>
<p>f在第18个传输轮回里，ssthresh的值设置为多少?</p>
<blockquote>
<p>当分组丢失时阈值被设置为拥塞窗口的值的一半。已检测到。当在传输循环16期间检测到丢失时，拥塞Windows的大小为42。因此在第18传输循环期间阈值为21。</p>
</blockquote>
<p>g在第24个传输轮回里，ssthresh的值设置为多少?</p>
<blockquote>
<p>当分组丢失时阈值被设置为拥塞窗口的值的一半。已检测到。当在传输循环22期间检测到丢失时，拥塞Windows的大小为29。因此，阈值为14（取下下限为14.5）。24号传动轮。<br>(不要看图猜位置，要从头开始 2 4 8 16 的算出点的纵坐标，另外，《自顶向下》和谢希仁版的《计算机网络》解题用的 TCP Reno 版本不一样，《自》在发现三次重复确认后阈值减半，但拥塞窗口减半再加三，《计》在发现三次重复确认后阈值和窗口都仅减半)</p>
</blockquote>
<p>h.在哪个传输轮回内发送第70个报文段?</p>
<blockquote>
<p>在第1次传输循环期间，数据包1被发送；数据包2-3在第2次发送中发送传输循环；数据包4-7在第3传输循环中发送；数据包8-15在第4个传输回合中发送；数据包16-31在第5个传输中发送,数据包32-63在第6个传输回合中发送；数据包64-96被发送在第7次传输循环中。因此，在第7发送循环中发送分组70。</p>
</blockquote>
<p>i假定在第26个传输轮回后，通过收到3个余ACK检测出有分组丢失，拥塞的窗口长度和ssthresh的值应当是多少?</p>
<blockquote>
<p>4 和 7。【注意三次重复确认时阈值减半，窗口减半加三】</p>
</blockquote>
<p>j假定使用TCPTahoe(而不是TCPReno)，并假定在第16个传输轮回收到3个余ACK。在第19个传输轮回，ssthresh和拥塞窗口长度是什么?</p>
<blockquote>
<p>21；8(16论变为1，17，2，18，4，19，8)</p>
</blockquote>
<p>k再次假设使用TCPTahoe在第22个传输轮回有一个超时事件。从第17个传输轮回到第22个传输轮回(包括这两个传输轮回)，一共发送了多少分组?</p>
<blockquote>
<p>52。【如果慢启动下 cwnd 即将超过 ssthresh，如 cwnd=16，ssthresh=21，则下一轮次 cwnd=21，然后立刻开始拥塞避免】</p>
</blockquote>
<ol start="17">
<li>在3.5.4 节中，我们讨论了在发生超时事件后将超时间隔加倍。为什么除了这种加倍超时间隔机制外，TCP还需要基于窗口的拥塞控制机制(如在37节中学习的那种机制)呢?<blockquote>
<p>如果tcp是一个停止和等待协议，那么超时间隔加倍就足够作为拥塞控制机制了。然而，TCP使用流水线(因此不是停止和等待协议)，它允许发送方有多个未确认的未确认段。超时间隔的加倍不会阻止tcp发送者向网络发送大量第一时间传输的数据包，即使端到端路径非常拥挤。因此，当出现网络拥塞的迹象时，需要一种拥塞控制机制来阻止“从上面的应用程序接收到的数据流”。</p>
</blockquote>
</li>
</ol>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2023/05/24/Markdown/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Markdown是什么？"><a href="#Markdown是什么？" class="headerlink" title="Markdown是什么？"></a>Markdown是什么？</h3><p>Markdown 是一种轻量级标记语言，使用的是纯文本的方式。诞生初期是为了简化 HTML 语法，用于编写阅读次数多、更新频率高，但内容格式相对稳定的 README 类的文档。所以 Markdown 语法支持嵌入原始的 HTML 标记语言，支持 CSS 样式。</p>
<p>我们所看到的 Markdown 网页预览的效果，其实都是将 Markdown 文档内容首先转换成 HTML 标签，再配以某些默认预定共同渲染而成的。同样的一段表格代码，在 Typora 和 VS Code 预览中的表现不同，<strong>为了让 Markdown 的表现形式稳定，我们可将 Markdown 导出成 HTML 文件。</strong></p>
<h3 id="Markdown-分级标题"><a href="#Markdown-分级标题" class="headerlink" title="Markdown 分级标题"></a>Markdown 分级标题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这是一个标题</span><br><span class="line">## 这是一个标题</span><br><span class="line">### 这是一个标题</span><br><span class="line">#### 这是一个标题</span><br><span class="line">##### 这是一个标题</span><br><span class="line">###### 这是一个标题</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/24/Markdown/1.png" alt="?"></p>
<h3 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h3><p>在 Markdown 文件中，没有任何标记的文字会被解析成正文。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 这是标题</span><br><span class="line"></span><br><span class="line">这是一段正文文字。</span><br></pre></td></tr></table></figure>
<p><img src="/2023/05/24/Markdown/2.png" alt="?"></p>
<h3 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">** 无序列表**</span><br><span class="line"></span><br><span class="line">使用星号生成无序列表</span><br><span class="line"></span><br><span class="line">* 项目1</span><br><span class="line">* 项目2</span><br><span class="line">* 项目3</span><br><span class="line"></span><br><span class="line">使用加号生成无序列表</span><br><span class="line"></span><br><span class="line">+ 项目1</span><br><span class="line">+ 项目2</span><br><span class="line">+ 项目3</span><br><span class="line"></span><br><span class="line">使用减号生成无序列表</span><br><span class="line"></span><br><span class="line">- 项目1</span><br><span class="line">- 项目2</span><br><span class="line">- 项目3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/24/Markdown/3.png" alt="?"></p>
<p><strong>有序列表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 项目1</span><br><span class="line">2. 项目2</span><br><span class="line">3. 项目3</span><br><span class="line"></span><br><span class="line">源码中的数字与渲染后的数字并不一一对应，但可以决定列表的开始序号</span><br><span class="line"></span><br><span class="line">例如，让 Markdown 渲染器自动安排序号：</span><br><span class="line"></span><br><span class="line">0. 项目1</span><br><span class="line">0. 项目2</span><br><span class="line">0. 项目3</span><br><span class="line"></span><br><span class="line">让有序列表以 “2” 开头：</span><br><span class="line"></span><br><span class="line">2. 项目1</span><br><span class="line">1. 项目2</span><br><span class="line">0. 项目3</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/24/Markdown/4.png" alt="?"></p>
<h3 id="Markdown-引用"><a href="#Markdown-引用" class="headerlink" title="Markdown 引用"></a>Markdown 引用</h3><p>在 Markdown 文件中，用「大于号」开头的行会被转换为块引用。<br>如果需要在块引用内的换行，可以在行尾增加两个连续的空格。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 一支穿云箭，千军万马来相见；  </span><br><span class="line">&gt; 两副忠义胆，刀山火海提命现。  </span><br><span class="line">&gt;</span><br><span class="line">&gt; —— 星仔</span><br></pre></td></tr></table></figure>
<p><img src="/2023/05/24/Markdown/5.png"></p>
<h3 id="Markdown-强调"><a href="#Markdown-强调" class="headerlink" title="Markdown 强调"></a>Markdown 强调</h3><figure class="highlight plaintext"><figcaption><span>斜体的演示</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  *用星号表示的斜体*</span><br><span class="line"></span><br><span class="line">  _用下划线表示的斜体_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 粗体的演示</span><br><span class="line"></span><br><span class="line">  **用星号表示的粗体**</span><br><span class="line"></span><br><span class="line">  __用下划线表示的粗体__</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/24/Markdown/6.png"></p>
<h3 id="Markdown-辅助线"><a href="#Markdown-辅助线" class="headerlink" title="Markdown 辅助线"></a>Markdown 辅助线</h3><figure class="highlight plaintext"><figcaption><span>"空格" 时，删除线效果会失效。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">~~有效的删除线~~</span><br><span class="line"></span><br><span class="line">~~失效的删除线 ~~</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/24/Markdown/7.png" alt="?"></p>
<h3 id="Markdown-代码块"><a href="#Markdown-代码块" class="headerlink" title="Markdown 代码块"></a>Markdown 代码块</h3><p>使用反引号定义代码块</p>
<p>使用反引号定义代码块，并定义高亮(在反引号后加语言名称)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pubic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Markdown-超链接"><a href="#Markdown-超链接" class="headerlink" title="Markdown 超链接"></a>Markdown 超链接</h3><p><code>一对中括号就可以将文字转换为超链接，如: [北京](www.baidu.com)，[上海]()，[广州]()，[深圳]()</code></p>
<p><img src="/2023/05/24/Markdown/8.png" alt="?"></p>
<h3 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![?](Markdown/8.png)</span><br></pre></td></tr></table></figure>

<h3 id="Markdown-注释"><a href="#Markdown-注释" class="headerlink" title="Markdown 注释"></a>Markdown 注释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一段没有被注释的文字</span><br><span class="line">&lt;!-- 这是一段被注释掉的文字 --&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/24/Markdown/9.png" alt="?"></p>
<h3 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|学号|姓名|age|</span><br><span class="line">|:---|----|---:|</span><br><span class="line">|1|张三|21|</span><br><span class="line">|2|李四|43|</span><br><span class="line">|3|王五|76|</span><br></pre></td></tr></table></figure>
<p><img src="/2023/05/24/Markdown/10.png" alt="?"></p>
<h3 id="Markdown-生成目录"><a href="#Markdown-生成目录" class="headerlink" title="Markdown 生成目录"></a>Markdown 生成目录</h3><p>在 Markdown 中，自动生成目录非常简单，只需要在恰当的位置添加 [TOC] 符号，凡是以 # 定义的标题都会被编排到目录中。</p>
]]></content>
      <tags>
        <tag>计算机工具</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-自顶向下-第二章应用层</title>
    <url>/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h3><h4 id="网络应用体系结构"><a href="#网络应用体系结构" class="headerlink" title="网络应用体系结构"></a>网络应用体系结构</h4><p><strong>客户服务器体系结构</strong><br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/1.png" alt="?"></p>
<p><strong>P2P体系结构</strong><br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/2.png" alt="?"></p>
<h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h4><p><strong>socket(套接字)</strong><br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/3.png" alt="?"><br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/4.png" alt="?"></p>
<h4 id="运输层协议的关键指标"><a href="#运输层协议的关键指标" class="headerlink" title="运输层协议的关键指标"></a>运输层协议的关键指标</h4><p>如果一个协议提供了确保数据交付服务，就认为提供了可靠数据传输。<br>具有吞吐量要求的应用程序被称为带宽敏感的应用(bandwidth-sensitive application)，许多当前的多媒体应用是带宽敏感的。<br>定时，这种服务将对交互式实时应用程序有吸引力。<br>安全性，运输协议能够为应用程序提供一种或多种安全性服务。</p>
<p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/5.png" alt="?"></p>
<p><strong>TCP:</strong><br>面向连接，可靠的网络传输</p>
<p><strong>安全套接字层（secure socket layer）ssl:</strong><br>他不是传输层上的第三种协议，而是tcp协议的加强版。<br>用 SSL 加强后的 TCP不仅能够做传统的TCP所能做的一切，而且提供了关键的进程到进程的安全性服务，包括加密、数据完整性和端点鉴别。<br>SSL有它自己的套接字API,这类似于传统的TCP套接字API。当一个应用使用SSL时，发送进程向SSL套接字传递明文数据;在发送主机中的SSL则加密该数据并将加密的数据传递给TCP套接字。加密的数据经因特网传送到接收进程中的TCP套接字。该接收套接字将加密数据传递给SSL，由其进行解密。</p>
<p><strong>UDP:</strong><br>无连接，不可靠的网络传输</p>
<h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/6.png" alt="?"></p>
<h3 id="web和http"><a href="#web和http" class="headerlink" title="web和http"></a>web和http</h3><h4 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h4><p>Web的应用层协议是超文本传输协议(HyperText Transfe Protocol,HTTP)</p>
<p>因为 Web浏览器（Web browser）（例如 Internet Explorer 和 Firefox）实现了HTTP 的客户端,所以在 Web环境中我们经常交替使用。<br>“浏览器”和“客户”这两个术语。 Web服务器（Web server）实现了HTTP的服务器端，它用于存储Web对象，每个对象由 URL寻址。流行的Web服务器有 Apache和 Microso<br>Internet Information Server。</p>
<p><strong>http的底层是tcp协议</strong><br>这里我们看到了分层体系结构最大的优点，即 HTTP 协议不用担心数据丢失，也不关注TCP 从网络的数据丢失和乱序故障中恢复的细节。那是 TCP以及协议栈较低层协议的工作。</p>
<p><strong>http协议不会保存用户的信息，所以他是无状态的。</strong></p>
<h4 id="持续响应和非持续响应"><a href="#持续响应和非持续响应" class="headerlink" title="持续响应和非持续响应"></a>持续响应和非持续响应</h4><p>对响应或者请求都使用一个tcp进行连接发送是持续响应，否则是非持续响应。</p>
<p>往返时间 （Round-Trip Time, RTT）的定义，该时间是指一个短分组从客户到服务器然后再返回客户所花费的时间。</p>
<p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/7.png" alt="?"></p>
<h4 id="http的报文格式"><a href="#http的报文格式" class="headerlink" title="http的报文格式"></a>http的报文格式</h4><p><strong>http请求报文</strong></p>
<p>请求行包括：方法字段（get、put、head、delete、post）、URL字段(请求字段)和 HTTP版本字段</p>
<p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/9.png" alt="?"><br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/10.png" alt="?"></p>
<p>通过包含 Connection:close首部行，该浏览器告诉服务器不希望麻烦地使用持续连接，它要求服务器在发送完被请求的对象后就关闭这条连接。</p>
<p>User-agent:首部行用来指明用户代理，即向服务器发送请求的浏览器的类型，这里浏览器类型是 Mozilla/5.0,即Firefox浏览器。</p>
<p>注意到了在首部行（和附加的回车和换行）后有一个实体主体（entity body）。使用GET方法时实体主体为空，而使用POST方法时才使用该实体体。当用户提交表单时，HTTP客户常常使用POST方法,例如当用户向搜索引擎提供搜索关键词时。使用 POST 报文时，用户仍可以向服务器请求一个Web页面，但Web页面的特定内容依赖于用户在表单字段中输人的内容。如果方法字段的值为POST时，则实体体中包含的就是用户在表单字段中的输入值。</p>
<p>用表单生成的请求报文不是必须使用POST方法。HTML表单经常使用GET方法，并在（表单字段中）所请求的URL中包括输入的数据。例如，一个表单使用GET方法有一个字段填写的是monkeys（<a href="https://www.baidu.com/s?wd=monkey%EF%BC%89%E3%80%82">https://www.baidu.com/s?wd=monkey）。</a></p>
<p>HEAD方法类似于GET方法。当服务器收到使用HEAD方法的请求时，将会用一个HTTP报文进行响应,但是并不返回请求对象。应用程序开发者常用HEAD方法进行调试跟踪。</p>
<p>PUT方法常与Web发行工具联合使用，它允许上传指定的路径（目录）。PUT 方法也被那些需要向Web服务器上传对象的应用程序使用。</p>
<p>DELETE方法允许用户或者应用程序删除Web服务器上的对象。</p>
<p><strong>http响应报文</strong></p>
<p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/11.png" alt="?"></p>
<p>我们仔细看一下这个响应报文。它有三个部分:<br>初始状态行（status line）,首部行（header line)，然后是实体体（entity body)。</p>
<p>实体体部分是报文的主要部分，即它包含了所请求的对象本身（表示为data data data data…)。</p>
<p>状态行有3个字段:协议版本字段、状态码和相应状态信息。在这个例子中，状态行指示服务器正在使用 HTTP/1.1,并且一切正常（即服务器已经找到并正在发送所请求的对象)。</p>
<p>我们现在来看看首部行。服务器用Connection: close首部行告诉客户，发送完报文后将关闭该TCP连接。</p>
<p>Date:首部行指示服务器产生并发送该响应报文的日期和时间。值得一提的是，这个时间不是指对象创建或者最后修改的时间，而是服务器从它的文件系统中检索到该对象，插入到响应报文，并发送该响应报文的时间。</p>
<p>Server:首部行指示该报文是由一台 Apache Web 服务器产生的,它类似于HTTP请求报文中的 User- agent:首部行。</p>
<p>Last-Modified:首部行指示了对象创建或者最后修改的日期和时间。</p>
<p>Last- Modified:首部行对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非常重要。</p>
<p>Content- Length:首部行指示了被发送对象中的字节数。</p>
<p>Content-Type:首部行指示了实体体中的对象是HTML文本。</p>
<p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/12.png" alt="?"></p>
<p><strong>响应状态码</strong><br>200 OK:请求成功,信息在返回的响应报文中。<br>301 Moved Permanently:请求的对象已经被永久转移了新的URL定义在响应报文的Location:首部行中，客户软件将自动获取新的URL。<br>400 Bad Request:一个通用差错代码，指示该请求不能被服务器理解。<br>404 Not Found:被请求的文档不在服务器上。<br>505 HTTP Version Not Supported:服务器不支持请求报<br>文使用的HTTP协议版本。</p>
<h4 id="用户与服务器的交互-cookie"><a href="#用户与服务器的交互-cookie" class="headerlink" title="用户与服务器的交互:cookie"></a>用户与服务器的交互:cookie</h4><p><strong>http是无状态的，要获取用户登录信息，故使用cookie</strong></p>
<p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/cookie.png" alt="?"></p>
<h4 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h4><p>Web 缓存器（Web cache）也叫代理服务器（proxy server）,它是能够代表初始Web服务器来满足 HTTP请求的网络实体。Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。</p>
<p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/proxy_server.png" alt="?"></p>
<p>在因特网上部署Web缓存器有两个原因。首先，Web缓存器可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽时更是如此。如果在客户与Web缓存器之间有一个高速连接（情况常常如此），并且如果用户所请求的对象在Web缓存器上，则Web缓存器可以迅速将该对象交付给用户。</p>
<p>其次，如我们马上用例子说明的那样，Web缓存器能够大大减少一个机构的接人链路到因特网的通信量。通过减少通信量，该机构（如一家公司或者一所大学）就不必急于增加带宽，因此降低了费用。此外，Web缓存器能从整体上大大减低因特网上的 Web流量，从而改善了所有应用的性能。</p>
<p>内容分发网络（Content Distri-bution Network, CDN）</p>
<h4 id="条件get"><a href="#条件get" class="headerlink" title="条件get"></a>条件get</h4><p>为了防止代理服务器上的内容是过时的，允许代理服务器使用条件get</p>
<p>如果:请求报文使用GET方法，并且请求报文中包含一个If-Modified-Since:首部行。<br>那么，这个 HTTP请求报文就是一个条件GET请求报文。</p>
<p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/if_get.png" alt="?"></p>
<h3 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议:FTP"></a>文件传输协议:FTP</h3><p>ftp是有状态的</p>
<p>用户通过FTP用户代理与FTP交互。该用户首先提供远程主机的主机名，使本地主机的FTP客户进程建立一个到远程主机FTP服务器进程的TCP连接。该用户接着提供用户标识和口令，作为FTP命令的一部分在该 TCP连接上传送。一旦该服务器向该用户授权，用户可以将存放在本地文件系统中的一个或者多个文件复制到远程文件系统（反之亦然)。</p>
<p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/ftp.png" alt="?"></p>
<p>FTP使用了两个并行的TCP连接来传输文件，一个是控制连接（control connection），一个是数据连接（data connection）。connection）。</p>
<p>控制连接用于在两主机之间传输控制信息如用户标识、口令、改变远程目录的命令以及“存放（put)”和“获取(get)”文件的命令。</p>
<p>数据连接用于实际发送一个文件。因为FTP协议使用一个独立的控制连接，所以我们也称FTP的控制信息是带外(out-of-band）传送的。<br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/ftp2.png" alt="?"></p>
<p>当用户主机与远程主机开始一个FTP会话时,FTP的客户(用户)端首先在服务器21号端口与服务器(远程主机）端发起一个用于控制的 TCP连接。FTP的客户端也通过该控制连接发送用户的标识和口令,发送改变远程目录的命令。当FTP 的服务器端从该连接上收到文件传输的命令后(无论是向还是来自远程主机)，就发起一个到客户端的TCP 数据连接。FTP在该数据连接上准确地传送一个文件，然后关闭该连接。在同一个会话期间,如果用户还需要传输另一个文件,FTP则打开另一个数据连接。因而对FTP传输而言，控制连接贯穿了整个用户会话期间,但是对会话中的每一次文件传输都需要建立一个新的数据连接（即数据连接是非持续的)。</p>
<h4 id="ftp每个命令由4个ascii码组成-n分割"><a href="#ftp每个命令由4个ascii码组成-n分割" class="headerlink" title="ftp每个命令由4个ascii码组成\n分割"></a>ftp每个命令由4个ascii码组成\n分割</h4><p>USER username:用于向服务器传送用户标识。PASS password:用于向服务器发送用户口令。</p>
<p>LIST:用于请求服务器回送当前远程目录中的所有文件列表。该文件列表是经一个（新建且非持续连接）数据连接传送的，而不是在控制TCP连接上传送。</p>
<p>RETR filename:用于从远程主机当前目录检索（即 get文件。该命令引起远程主机发起一个数据连接，并经该数据连接发送所请求的文件。</p>
<p>STOR filename:用于在远程主机的当前目录上存放（即put）文件。</p>
<h4 id="Ftp状态码"><a href="#Ftp状态码" class="headerlink" title="Ftp状态码"></a>Ftp状态码</h4><p>331 Username OK, Password required（用户名OK，需要口令).<br>125 Data connection already open;transfer starting(数据连接已经打开，开始传送)。<br>425 Can’t open data connection(无法打开数据连接)。<br>452 Error writing file（写文件差错）。</p>
<h3 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h3><p>smtp使用持续连接</p>
<p>它有3个主要组成部分:用户代理(user agent)、邮件服务器（mail server）和简单邮件传输协议(Simple Mail Transfer Protocol,SMTP)。<br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/smtp.png" alt="?"></p>
<p>SMTP是如何将一个报文从发送邮件服务器传送到接收邮件服务器的?<br>首先，客户端SMTP（运行在发送邮件服务器上）在25号端口建立一个到服务器SMTP（在按收邮件服务器上）的TCP 连接。如果服务器没有开机，客户会在稍后继续尝试连接。一旦连接建立，服务器和客户执行某些应用层的握手。SMTP的客户和服务器在传输信息前先相互介绍。在SMTP握手的阶段,SMTP 客户指示发送方的邮件地址（产生报文的那个人）和接收方的邮件地址。一旦该SMTP 客户和服务器彼此介绍之后，客户发送该报文。SMTP 能依赖TCP提供的可靠数据传输无差错地将邮件投递到接收服务器。该客户如果有另外的报文要发送到该服务器，就在该相同的TCP连接上重复这种处理;否则，它指示TCP 关闭连接。</p>
<h4 id="http和smtp"><a href="#http和smtp" class="headerlink" title="http和smtp"></a>http和smtp</h4><p>http是拉协议，从服务器往我们这里拉，smtp是推协议，从服务器往另一个服务器推。<br>smtp双方各有一个服务器，逻辑上a向b发文件，a是客户端，b是服务端，反之亦然。</p>
<h4 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h4><p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/smtp2.png" alt="?"><br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/smtp3.png" alt="?"><br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/smtp4.png" alt="?"><br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/smtp5.png" alt="?"></p>
<p>基于web的电子邮件<br>使用这种服务，用户代理就是普通的浏览器，用户和他远程邮箱之间的通信则通过HTTP进行。</p>
<p>当一个收件人，想从他的邮箱中访问一个报文时，该电子邮件报文从他邮件服务器发送到他的浏览器，使用的是HTTP而不是POP3或者IMAP协议。</p>
<p>当发件人要发送封电子邮件报文时,该电子邮件报文从他的浏览器发送到她的邮件服务器，使用的是 HTTP而不是SMTP。然而，他的邮件服务器在与其他的邮件服务器之间发送和接收邮件时，仍然使用的是SMTP。</p>
<h3 id="DNS-Domain-Name-System，-DNS）"><a href="#DNS-Domain-Name-System，-DNS）" class="headerlink" title="DNS(Domain Name System， DNS）"></a>DNS(Domain Name System， DNS）</h3><p>DNS是:<br>一个由分层的 DNS 服务器（DNSserver）实现的分布式数据库;<br>一个使得主机能够查询分布式数据库的应用层协议。<br>DNS 服务器通常是运行 BIND （Berkeley Internet Name Domain)软件[BIND 2012]的UNIX 机器。DNS协议运行在UDP之上，使用53号端口。</p>
<h4 id="dns服务"><a href="#dns服务" class="headerlink" title="dns服务"></a>dns服务</h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/dns.png" alt="?"></p>
<p>主机别名 （host aliasing）。有着复杂主机名的主机能拥有一个或者多个别名。<br>邮件服务器别名（mail server aliasing）。显而易见，人们也非常希望电子邮件地址好记忆。<br>负载分配（load distribution）。DNS也用于在冗余的服务器（如冗余的Web服务器等）之间进行负载分配。繁忙的站点（如 cnn.com)被冗余分布在多台服务器上。</p>
<h4 id="dns工作原理"><a href="#dns工作原理" class="headerlink" title="dns工作原理"></a>dns工作原理</h4><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/dns4.png" alt="?"></p>
<p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/dns2.png" alt="?"></p>
<p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/dns3.png" alt="?"></p>
<h4 id="dns缓存"><a href="#dns缓存" class="headerlink" title="dns缓存"></a>dns缓存</h4><p>为了改善时延性能并减少在因特网上到处传输的DNS报文数量,DNS 广泛使用了缓存技术。DNS 缓存的原理非常简单。在一个请求链中,当某DNS服务器接收一个DNS 回答（例如,包含主机名到IP地址的映射)时,它能将该回答中的信息缓存在本地存储器中。</p>
<p>举—个例子,假定主机 apricot. poly. edu向 dns. poly.<br>edu 查询主机名 cnn.com 的IP地址。此后，假定过了几个小时，Polytechnic理工大学的另外一台主机如 kiwi. poly. edu也向dns. poly. edu查询相同的主机名。因为有了缓存，该本地DNS服务器可以立即返回cnn.com的IP地址，而不必查询任何其他DNS服务器。本地DNS服务器也能够缓存TLD服务器的iP地址，因而允许本地DNS绕过查询链中的根DNS服务器（这经常发生)。</p>
<h4 id="dns记录和报文"><a href="#dns记录和报文" class="headerlink" title="dns记录和报文"></a>dns记录和报文</h4><p>共同实现 DNS分布式数据库的所有DNS服务器存储了资源记录（Resource Record,RR).RR提供了主机名到P地址的映射。</p>
<p>资源记录是一个包含了下列字段的4元组:(Name,Value, Type, TTL)<br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/dns5.png" alt="?"></p>
<p>设一台edu TLD服务器不是主机 gaia. cs. umass. edu的权威DNS服务器，则该服务器将包含一条包括主机 cs. umass. edu的域记录，如 （umass. edu， dns. umass. edu, NS);该eduTLD服务器还将包含一条类型A记录，如（dns. umass.edu,128.119. 40.111, A)，该记录将名字dns. umass.edu映射为一个iP地址。</p>
<p><strong>ns就是本dns服务器没有你这个主机的ip，我告诉你一个dns服务器，你去那里找，我这里还有这个dns的服务器的ip</strong></p>
<p><strong>dns的查询和回答报文相同</strong><br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/dns6.png" alt="?"></p>
<p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/dns7.png" alt="?"></p>
<h4 id="dns攻击"><a href="#dns攻击" class="headerlink" title="dns攻击"></a>dns攻击</h4><p>对DNS 的潜在更为有效的DDoS攻击将是向顶级域名服务器（例如向所有处理.com域的顶级域名服务器）发送大量的 DNS请求。过滤指向DNS服务器的 DNS 请求将更为困难，并且顶级域名服务器不像根服务器那样容易绕过。但是这种攻击的严重性通过本地 DNS 服务器中的缓存技术可将部分地被缓解。</p>
<p>DNS能够潜在地以其他方式被攻击。在中间人攻击中，攻击者截获来自主机的请求并返回伪造的回答。在DNS毒害攻击中，攻击者向一台DNS服务器发送伪造的回答，诱使服务器在它的缓存中接收伪造的记录。这些攻击中的任一种，都能够将满怀信任的Web用户重定向到攻击者的Web 站点。然而，这些攻击难以实现，因为它们要求截获分组或扼制住服务器。</p>
<p>另一种重要的DNS攻击本质上并不是一种对DNS服务的攻击，而是充分利用 DNS基础设施来对目标主机发起 DDoS攻击（例如，你所在大字的邮件服分斋)。仕这利坟击中，攻击者向许多权威DNS服务器发送DNS请求，每个请求具有目标主机的假冒源地址。这些DNS服务器则直接向目标主机发送它们的回答。如果这些请求能够精心制作成下述方式的话，即响应比请求（字节数)大得多（所谓放大)，则攻击者不必自行产生大量的流量就有可能淹没目标主机。这种利用 DNs的反射攻击至今为止只取得了有限的成功。</p>
<h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><h4 id="p2p文件分发"><a href="#p2p文件分发" class="headerlink" title="p2p文件分发"></a>p2p文件分发</h4><p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/p2p1.png" alt="?"><br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/p2p2.png" alt="?"></p>
<p>我们现在来对P2P体系结构进行简单的分析，其中每个对等方能够帮助服务器分发该文件。特别是，当一个对等方接收到某些文件数据，它能够使用自己的上载能力重新将数据分发给其他对等方。计算P2P体系结构的分发时间在某种程度上比计算客户-服务器体系结构的更为复杂，因为分发时间取决于每个对等方如何向其他对等方分发该文件的各个部分。<br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/p2p3.png" alt="?"></p>
<p><strong>具有PP体系结构的应用程序能够是自扩展的。这种扩展性的直接成因是:对等方除了是比特的消费者外还是它们的重新分发者。</strong><br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/p2p4.png" alt="?"></p>
<p>每个洪流具有一个基础设施结点，称为追踪器（tracker)。当一个对等方加人某洪流时，它向追踪器注册自己,并周期性地通知追踪器它仍在该洪流中。以这种方式,追踪器跟踪正参与在洪流中的对等方。一个给定的洪流可能在任何时刻具有数以百计或数以千计的对等方。</p>
<p>当一个新的对等方Alice加入该洪流时，追踪器随机地从参与对等方的集合中选择对等方的一个子集(为了具体起见,设有50个对等方),并将这50个对等方的P地址发送给 Alice。 Alice持有对等方的这张列表试图与该列表上的所有对等方创建并行的TCP连接。我们称所有这样与 Aliee成功地创建一个TCP 连接的对等方为“邻近对等方”（在图2-26中，Alice显示了仅有三个邻近对等方。通常，她应当有更多的对等方)。随着时间的流逝，这些对等方中的某些可能离开其他对等方(最初50个以外的)可能试图与Alice创建TCP 连接。因此一个对等方的邻近对等方将随时间而波动。</p>
<p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/p2p5.png" alt="?"></p>
<p>应当向哪些向她请求块的邻居发送?在决定请求哪些块的过程中，Alice使用一种称为最稀缺优先（rarest first)的技术。这种技术的思路是，针对她没有的块在她的邻居中决定最稀缺的块（最稀缺的块就是那些在她的邻居中副本数量最少的块)，并首先请求那些最稀缺的块。这样，最稀缺块得到更为迅速的重新分发，其目标是（大致地）均衡每个块在洪流中的副本数量。</p>
<h4 id="分布式散列表"><a href="#分布式散列表" class="headerlink" title="分布式散列表"></a>分布式散列表</h4><p>在该P2P系统中，每个对等方将保持(键，值)对仅占总体的一个小子集。我们将允许任何对等方用一个特别的键来查询该分布式数据库。分布式数据库则将定位拥有该相应（键，值）对的对等方，然后向查询的对等方返回该（键，值)对。任何对等方也将允许在数据库中插入新键-值对。这样一种分布式数据库被称为分布式散列(Distributed Hash Table DHT）。</p>
<h3 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h3><p><strong>每一个套接字会分配一个端口</strong><br>1.是否遵守RFC协议（不遵守则避开规定端口）<br>2.采用tcp还是udp</p>
<h4 id="udp套接字编程"><a href="#udp套接字编程" class="headerlink" title="udp套接字编程"></a>udp套接字编程</h4><p>运行在不同机器上的进程彼此通过向套接字发送报文来进行通信。我们说过每个进程好比是一座房子，该进程的套接字则好比是一扇门。应用程序位于房子中门的一侧;运输层位于该门朝外的另一侧。应用程序开发者在套接字的应用层一侧可以控制所有东西;然而，它几乎无法控制运输层一侧。</p>
<p>我们将使用下列简单的客户-服务器应用程序来演示对于UDP和TCP的套接字编程:<br>1）客户从其键盘读取一行字符并将数据向服务器发送。<br>2）服务器接收该数据并将这些字符转换为大写。<br>3）服务器将修改的数据发送给客户。<br>4）客户接收修改的数据并在其监视器上将该行显示出</p>
<p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/socket.png" alt="?"></p>
<p>udpclient.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span>*</span><br><span class="line">serverName = <span class="string">&quot;10.173.57.86&quot;</span></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">message = <span class="built_in">input</span>(<span class="string">&#x27;Input lowercase sentence:&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    clientSocket.sendto(message.encode(), (serverName, serverPort))</span><br><span class="line">    modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">    <span class="built_in">print</span>(modifiedMessage)</span><br><span class="line"><span class="keyword">except</span> gaierror <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    clientSocket.close()</span><br></pre></td></tr></table></figure>

<p>udpserver.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, serverPort))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The server is ready to receive&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(message) &gt; <span class="number">2048</span>:</span><br><span class="line">            <span class="keyword">raise</span> error(<span class="string">&#x27;Message too long&#x27;</span>)</span><br><span class="line">        modifiedMessage = message.decode().upper()</span><br><span class="line">        serverSocket.sendto(modifiedMessage.encode(), clientAddress)</span><br><span class="line">    <span class="keyword">except</span> error <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error:&#x27;</span>, e)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        serverSocket.close()</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h4 id="tcp套接字编程"><a href="#tcp套接字编程" class="headerlink" title="tcp套接字编程"></a>tcp套接字编程</h4><p>与UDP 不同，TCP是一个面向连接的协议。这意味着在客户和服务器能够开始互相发送数据之前,它们先要握手和创建一个 TCP连接。<br>TCP连接的一端与客户套接字相联系，另一端与服务器套接字相联系。当创建该TCP连接时，我们将其与客户套接字地址(IP地址和端口号）和服务器套接字地址(IP地址和端口号） 关联起来。使用创建的TCP连接，当一侧要向另一侧发送数据时，它只需经过其套接字将数据丢给TCP连接。UDP 服务器在将分组丢进套接字之前必须为其附上一个<br>目的地地址。</p>
<p>随着服务器进程的运行，客户进程能够向服务器发起一个TCP连接。这是由客户程序通过创建一个 TCP套接字完成的。当该客户生成其 TCP<br>套接字时,它指定了服务器中的套接字的地址，即服务器主机的P地址及其套接字的端口号。生成其套接字后，该客户发起了一个三次握手并创建与服务器的一个TCP连接。发生在运输层的三次握手，对于客户和服务器程序是完全透明的。</p>
<p>在三次握手期间，客户进程敲服务器进程的欢迎之门。当该服务器“听”到敲门时,**它将生成一扇新门(更精确地讲是一个新套接字)**，它专门用于特定的客户。在我们下面的例子中，欢迎之门是一个我们称为 serverSocket 的 TCp套接字对象;它专门对客户进行连接的新生成的套接字，称为连接套接字(connection Socket)。初次遇到TCP套接字的学生有时会混淆欢迎套接字（这是所有要与服务器通信的客户的起始接触点）和每个新生成的服务器侧的连接套接字（这是随后为与每个客户通信而生成的套接字)。</p>
<p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/tcp1.png" alt="?"></p>
<p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/tcp2.png" alt="?"></p>
<p>tcpclient.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName = <span class="string">&quot;10.173.57.86&quot;</span></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">clientSocket=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">clientSocket.connect((serverName,serverPort))</span><br><span class="line">sentence=<span class="built_in">input</span>(<span class="string">&#x27;input:&#x27;</span>)</span><br><span class="line">clientSocket.send(sentence.encode())</span><br><span class="line">modifiedSentence=clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(modifiedSentence.decode())</span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure>
<p>tcpserver.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">serverSocket=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>,serverPort))</span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    connectionSocket,addr=serverSocket.accept()</span><br><span class="line">    sentence=connectionSocket.recv(<span class="number">1024</span>)</span><br><span class="line">    capitalizedSentence=sentence.decode().upper()</span><br><span class="line">    connectionSocket.send(capitalizedSentence.encode())</span><br><span class="line">    connectionSocket.close()</span><br></pre></td></tr></table></figure>

<h3 id="复习和习题"><a href="#复习和习题" class="headerlink" title="复习和习题"></a>复习和习题</h3><ol>
<li><p>前面讲过TCP能用SSL来强化，以提供进程到进程的安全性服务，包括加密。SSL 运行在运输层还是应用层?如果某应用程序研制者想要用SSL 来强化UDP,该研制者应当做些什么工作?</p>
<blockquote>
<p>SSL在应用层运行。SSL套接字从应用层接收未加密的数据，对其进行加密，然后将其传递给TCP套接宇。如果应用程序开发人员希望使用SSL增强TCP，则必须在应用程序中包含SSL代码。</p>
</blockquote>
</li>
<li><p>为什么 HTTP、FTP、SMTP 及POP3都运行在TCP,而不是 UDP上?</p>
<blockquote>
<p>与这些协议相关联的应用程序要求以正确的顺序接收所有应用程序数据，并且不存在空白。TCP提供此服务，而UDP不提供此服务。</p>
</blockquote>
</li>
<li><p>考虑一个电子商务网站需要保留每一个客户的购买记录。描述如何使用cookie来完成该功能?</p>
<blockquote>
<p>当用户第一次访问站点时，服务器将创建一个唯一的标识号，在其后端数据库中创建一个条目，并将此标识号作为cokie编号返回。此cookie编号存储在用户的主机上，并由浏览器管理。在每次后续访问(和购买)期间，浏览器将cookie编号发送回站点。因此，站点知道这个用户(更准确地说，是这个浏览器)访问该站点的时间.</p>
</blockquote>
</li>
<li><p>假定Alice使用一个基于Web的电子邮件账户（例如Hotmail或gmail）向Bob发报文，而Bob使用POP3从他的邮件服务器访问自己的邮件。讨论是怎样从 Alice 王机到 bob王机得到以报义的。安列出在两台主机间移动该报文时所使用的各种应用层协议。</p>
<blockquote>
<p>该消息⾸先通过HTTP从Alice的主机发送到她的邮件服务器。然后，Alice的邮件服务器通过SMTP向Bob的邮件服务器发送消息。然后Bob通过POP3将消息从他的邮件服务器传输到他的主机。</p>
</blockquote>
</li>
<li><p>从用户的观点看，POP3协议中下载并删除模式和下载并保留模式有什么区别吗?</p>
<blockquote>
<p>通过下载和删除，⽤⼾从POP服务器检索其消息后，消息将被删除。这给游牧⽤⼾带来了⼀个问题，他们可能希望从许多不同的机器(办公PC、家庭PC等)访问消息。在下载和保存配置中，在⽤⼾检索消息后不会删除消息。这也可能不⽅便，因为每次⽤⼾从新机器检索存储的消息时，所有未删除的消息都将传输到新机器(包括⾮常旧的消息)。</p>
</blockquote>
</li>
<li><p>UDP服务器仅需要一个套接字，而TCP服务器需要两个套接字。<br>为什么?如果TCP 服务器支持n个并行连接，每条连接来自不同的客户主机，那么TCP服务器将需要多少个套接字?</p>
<blockquote>
<p>UDP服务器只需要一个套接字，因为UDP是无连接的，它不需要维护连接状态。而TCP服务器需要两个套接字，一个用于监听客户端连接请求，另一个用于处理与客户端的通信.如果TCP服务器支持n个并行连接，每条连接来自不同的客户主机，那么TCP服务器将需要n+1个套接字，其中一个用于监听客户端连接请求，其余n+1个用于处理与客户端的通信。</p>
</blockquote>
</li>
</ol>
<p>7.运行在 TCP之上的客户-服务器应用程序,服务器程序为什么必须先于客户程序运行?对于运行在 UDP之上的客户-服务器应用程序，客户程序为什么可以先于服务器程序运行?</p>
<blockquote>
<p>对于TCP应⽤程序，⼀旦客⼾端被执⾏，它就会尝试启动与服务器的TCP连接。如果TCP服务器没有运⾏，则客⼾端将⽆法建⽴连接。对于UDP应⽤程序，客⼾端在执⾏时不会⽴即启动连接(或尝试与UDP服务器通信)。</p>
</blockquote>
<ol start="8">
<li><p>假设用户请求由某些文本和3幅图像组成的Web页面。对于这个页面，客户将发送一个请求报文并接收4个响应报文。</p>
<blockquote>
<p>请求与响应必定成对.对于这个页面，客户端将发送一个请求报文并接收一个响应报文，该响应报文包含页面的文本内容和3幅图像的URL。之后，客户端将根据这些URL发送3个请求报文，并分别接收3个响应报文，这些响应报文包含3幅图像的内容。因此，客户端总共发送4个请求报文并接收4个响应报文。</p>
</blockquote>
</li>
<li><p>两个不同的Web页面（例如，<a href="http://www.mit/">www.mit</a>. edu/ research. html 及 <a href="http://www.mit/">www.mit</a>. edu/ students. html）可以通过同一个持续连接发送。</p>
<blockquote>
<p>是的，两个不同的Web页面可以通过同一个持续连接发送。HTTP/1.1支持持久连接（也称为持续连接或连接重用），这意味着在同一连接上可以发送多个HTTP请求和响应。当客户端通过TCP连接发送第一个HTTP请求时，它可以在请求头中指定“Connection: keep-alive”，以指示服务器在响应中保持连接打开状态。这样，客户端就可以通过同一个连接发送多个请求，而不必为每个请求都建立一个新的TCP连接。当客户端完成所有请求时，它可以在最后一个请求中发送“Connection: close”头，以指示服务器关闭连接。</p>
</blockquote>
</li>
<li><p>在浏览器和初始服务器之间使用非持续连接的话，一个TCP报文段是可能携带两个不同的 HTTP服务请求报文的。</p>
<blockquote>
<p>在非持续连接中，一个TCP报文段只能携带一个HTTP请求报文。因为在非持续连接中，每个HTTP请求都需要建立一个新的TCP连接，因此每个连接只能携带一个HTTP请求和响应。如果多个HTTP请求在短时间内发生，它们将会被分别发送到不同的TCP连接中。每个TCP连接只能处理一个HTTP请求和响应。</p>
</blockquote>
</li>
<li><p>在HTTP 响应报文中的Date:首部指出了该响应中对象最后一次修改的时间。</p>
<blockquote>
<p>在HTTP响应报文中，Date首部字段表示服务器发送响应的时间。它不指示响应中对象最后一次修改的时间。为了指示对象最后一次修改的时间，HTTP响应报文使用Last-Modified首部字段。Last-Modified首部字段表示服务器上响应对象最后一次修改的时间。当客户端再次请求同一对象时，可以使用If-Modified-Since请求首部字段将上次的Last-Modified时间发送到服务器。如果服务器上的对象自上次访问以来未被修改，则服务器将返回一个状态码为304的响应，表示客户端可以使用其本地缓存的对象。否则，服务器将返回新的对象并在响应头中更新Last-Modified时间。</p>
</blockquote>
</li>
<li><p>考虑一个HTTP客户要获取一个给定 URL的Web页面。该HTTP服务器的P地址开始时并不知道。在这种情况下，除了HTTP外，还需要什么运输层和应用层协议?</p>
<blockquote>
<p>应⽤层协议：DNS和HTTP传输层协议：UDP⽤于DNS；TCP⽤于HTTP</p>
</blockquote>
</li>
<li><p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/t1.png" alt="?"><br>由浏览器请求的文档的URL是什么?</p>
<blockquote>
<p>文档请求是<a href="http://gaia.cs.umass.edu/cs453/index.html%E3%80%82host:%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%A4%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%8D%E7%A7%B0%EF%BC%8C/cs453/index.html%E8%A1%A8%E7%A4%BA%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%82">http://gaia.cs.umass.edu/cs453/index.html。host:字段表示服务器的名称，/cs453/index.html表示文件名。</a></p>
</blockquote>
</li>
</ol>
<p>该浏览器运行的是HTTP的何种版本?</p>
<blockquote>
<p>浏览器正在运⾏HTTP1.1版本，就像第⼀对之前所指出的那样</p>
</blockquote>
<p>该浏览器请求的是一条非持续连接还是一条持续连接?</p>
<blockquote>
<p>connection 浏览器正在请求持久连接，如连接所⽰：保持-活动。</p>
</blockquote>
<p>该浏览器所运行的主机的P地址是什么?</p>
<blockquote>
<p>这是刁钻的问题。此信息不包含在任何地⽅的HTTP消息中。因此，仅看HTTP消息的交换就⽆法区分这⼀点。您需要从IP数据报(承载承载HTTPGET请求的TCP段)中获得信息来回答这个问题。</p>
</blockquote>
<p>发起该报文的浏览器的类型是什么?在一个 HTTP 请求报文中，为什么需要浏览器类型?</p>
<blockquote>
<p>Mozilla/5.0。服务器需要浏览器类型信息将同⼀对象的不同版本发送到不同类型的浏览器。</p>
</blockquote>
<p>14.<br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/t2.png" alt="?"><br>服务器能否成功地找到那个文档?该文档提供回答是什么时间?</p>
<blockquote>
<p>状态代码200和短语ok表⽰服务器能够找到⽂档成功。答复于2008年3⽉7⽇星期⼆提供格林威治标准时间12:39:45。</p>
</blockquote>
<p>该文档最后修改是什么时间?</p>
<blockquote>
<p>last-Modified  上⼀次修改index.html⽂档是在2005年12⽉10⽇星期六18:27:46 格林尼治时间。</p>
</blockquote>
<p>文档中被返回的字节有多少?</p>
<blockquote>
<p>返回的⽂档中有3874个字节。</p>
</blockquote>
<p>文档被返回的前5个字节是什么?该服务器同意一条持续连接吗?</p>
<blockquote>
<p>返回⽂件的前五个字节是：&lt;！医⽣服务器同意持久连接，如connection:Keep Alive字段所⽰</p>
</blockquote>
<p>15.<br>解释在客户和服务器之间用于指示关闭持续连接的信令机制。客户、服务器或两者都能发送信令通知连接关闭了吗?</p>
<blockquote>
<p>在RFC 2616的第8节中讨论了持久连接（这⼀点的真正⽬的问题是让你检索并阅读⼀份RFC(第8.1.2和8.1.2.1节)rfc表⽰客⼾机或服务器可以向另⼀个表明它是将关闭永久连接。它通过包含连接令牌来实现“关闭”在http请求/回复的连接头字段中</p>
</blockquote>
<p>HTTP提供了什么加密服务?</p>
<blockquote>
<p>http不提供任何加密服务。</p>
</blockquote>
<p>一个客户能够与一个给定的服务器打开3条或更多条并发连接吗?</p>
<blockquote>
<p>“使⽤持久连接的客⼾端应该限制同时维护到给定服务器的连接。单⽤⼾客⼾端与任何服务器或代理服务器的连接不应超过2个。</p>
</blockquote>
<p>如果一个服务器或一个客户检测到连接已经空闲一段时间，该服务器或客户可以关闭两者之间的传输连接。一侧开始关闭连接而另一侧通过该连接传输数据是可能的吗?请解释。</p>
<blockquote>
<p>是。(来⾃RFC 2616)“在服务器决定关闭”空闲“连接的同时，客⼾端可能已经开始发送新请求。从服务器的⻆度来看，连接是在空闲时关闭的，但从客⼾端的⻆度来看，请求正在进⾏中。“</p>
</blockquote>
<ol start="16">
<li>假定你在浏览器中点击一条超链接获得Web页面。相关联的URL 的IP地址没有缓存在本地主机上，因此必须使用 DNS lookup以获得该IP地址。如果主机从 DNS得到IP地址之前已经访问了n个 DNS服务器;相继产生的RTT依次为RTT1,、…、RTTn,。进一步假定与链路相关的Web页面只包含一个对象，即由少量的HTML文本组成。令RTT0,表示本地主机和包含对象的服务器之间的RTT值。假定该对象传输时间为零，则从客户点击该超链接到它接收到该对象需要多长时间?<blockquote>
<p>RTT1+RTT2+…+RTTn为获取ip的时间<br>总时间为2RTT0+RTT1+RTT2+…+RTTn<br>因为一个 RTT 就是一个往返的时延，因此访问 DNS 的时延是 1~n 各 1 个，接着 HTTP 采取 TCP 连接，需要在第一个 RTT 内建立连接，第二个 RTT 内发送请求并接收应答，故有两个 RTT0</p>
</blockquote>
</li>
</ol>
<ol start="17">
<li>参照上题，假定在同一服务器上某HTML文件引用了8个非常小的对象。忽略发送时间，在下列情况下需要多长时间:<br>a没有并行 TCP 连接的非持续HTTP。<blockquote>
<p>18RTT0+RTT1+RTT2+…+RTTn<br>其他部分与第七题一样，然后客户发送一个 HTTP 请求，得到基本 HTML 文件后，经过解析这个 HTML 文件得到 8 个图像的地址，再继续同样的 HTTP 请求 8 次，即在第七题基础上多了 8 个图像的建立连接、请求响应，注意非持续性连接在发送响应后，TCP 连接就立刻断开了，需要继续发送则需要重新申请建立连接</p>
</blockquote>
</li>
</ol>
<p>b.配置有5个并行连接的非持续HTTP。</p>
<blockquote>
<p>6RTT0+RTT1+…+RTTn<br>客户仍需先请求建立 TCP 连接、发送数据请求并接受 HTML基本文件，消耗 2 个 RTT0，接着解析 HTML 文件后同时申请建立 5 个 TCP 连接，消耗 1 个RTT0，请求并接收 5 个图像，消耗 1 个 RTT0，还余下 3 个 RTT0 仍需申请建立 3 个 TCP 连接、请求并接收 3 个图像</p>
</blockquote>
<p>c.持续HTTP。</p>
<blockquote>
<p>无并行） 10RTT0+RTT1+…+RTTn【持续性链接即 a 省掉后续 8 次申请 TCP 的 RTT0】<br>（5 并行） 3RTT0+RTT1+…+RTTn  (不理解，我觉得是4rtt0不是3)</p>
</blockquote>
<ol start="18">
<li><p>HTTP 响应报文绝不会具有空的报文体。</p>
<blockquote>
<p>答：错误。HTTP 调用 TCP，必定有确认报文段，如果没有消息回复则无法捎带确认，就会发送一个空内容的报文用于确认</p>
</blockquote>
</li>
<li><p>SMTP是怎样标识一个报文体结束的?HTTP是怎样做的呢?HTTP能够使用与SMTP标识一个报文体结束相同的方法吗?试解释。</p>
<blockquote>
<p>SMTP使⽤仅包含句点的⾏来标记邮件正⽂的结束。http使⽤“内容⻓度标题字段”来表⽰消息正⽂的⻓度。<br>不，HTTP不能使⽤SMTP使⽤的⽅法，因为HTTP消息可以是⼆进制数据，⽽在SMTP中，消息主体必须是7位的ASCII格式。</p>
</blockquote>
</li>
<li><p>什么是 whois数据库?</p>
<blockquote>
<p>对于给定的域名输⼊(如ccn.com)、IP地址或⽹络管理员名称，whois数据库可⽤于定位相应的注册服务器、whois服务器、DNS服务器等。</p>
</blockquote>
</li>
</ol>
<p><a href="https://whois.cloud.tencent.com/domain?domain=baidu.com">腾讯whois数据库</a></p>
<p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/t5.png" alt="?"></p>
<ol start="21">
<li><p>假设你所在系具有一台用于系里所有计算机的本地DNS服务器。你是普通用户（即你不是网络/系统管理员)。你能够确定是否在几秒钟前从你系里的一台计算机可能访问过一台外部Web站点吗?解释原因。</p>
<blockquote>
<p>是的，我们可以在本地DNS服务器中使⽤DIG查询该⽹站。例如，digCNN.com将返回查找CNN.com的查询时间。如果CNN.com⼏秒钟前刚刚被访问，那么<br>CNN.com的条⽬将缓存在本地DNS缓存中，因此查询时间为0毫秒。否则，查询时间很⻓。</p>
</blockquote>
</li>
<li><p><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/t6.png"></p>
<blockquote>
<p>不知道他是怎么按这个公式算出来的<br><img src="/2023/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/t6.1.png"></p>
</blockquote>
</li>
<li><p>在一台主机上安装编译 TCPClient 和 UDPClient 的 Python 程序，在另一台主机上安装编译TCPServer 和 UDPServer 的程序。<br>a.假设在运行 TCPServer 之前运行 TCPClient，将会发生什么现象？为什么？</p>
<blockquote>
<p>答：如果首先运行 TCPClient，那么客户端将尝试与不存在的服务器进程进行 TCP 连接。无法进行 TCP 连接。</p>
</blockquote>
</li>
</ol>
<p>b.假设在运行 UDPServer 之前运行 UDPClient，将会发生什么现象？为什么？</p>
<blockquote>
<p>答：UDPClient 没有与服务器建立 TCP 连接。 因此，如果首先运行 UDPClient，然后运行 UDPServer，然后在键盘上键入一些输入，那么一切都会正常工作</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ol>
<li><blockquote>
<p>在这个编程作业中，你将用Python语言开发一个简单的Web服务器，它仅能处理一个请求。具体而言，你的Web服务器将：<br>当一个客户（浏览器）联系时创建一个连接套接字；<br>从这个连接套接字接收HTTP请求；<br>解释该请求以确定所请求的特定文件；<br>从服务器的文件系统获得请求的文件；<br>创建一个由请求的文件组成的HTTP响应报文，报文前面有首部行；<br>经TCP连接向请求浏览器发送响应。如果浏览器请求一个在该服务器种不存在的文件，服务器应当返回一个“404 Not Found”差错报文。</p>
</blockquote>
</li>
</ol>
<p>webserver.py<br>在内网内可以进行交流</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="comment"># Prepare a sever socket</span></span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">6789</span>))  <span class="comment"># 将TCP欢迎套接字绑定到指定端口</span></span><br><span class="line">serverSocket.listen(<span class="number">1</span>)  <span class="comment"># 最大连接数为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Establish the connection</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Ready to serve...&#x27;</span>)</span><br><span class="line">    connectionSocket, addr = serverSocket.accept()  <span class="comment"># 接收到客户连接请求后，建立新的TCP连接套接字</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        message = connectionSocket.recv(<span class="number">1024</span>)  <span class="comment"># 获取客户发送的报文</span></span><br><span class="line">        filename = message.split()[<span class="number">1</span>]</span><br><span class="line">        f = <span class="built_in">open</span>(filename[<span class="number">1</span>:])</span><br><span class="line">        outputdata = f.read();</span><br><span class="line">        <span class="comment"># Send one HTTP header line into socket</span></span><br><span class="line">        header = <span class="string">&#x27; HTTP/1.1 200 OK\nConnection: close\nContent-Type: text/html\nContent-Length: %d\n\n&#x27;</span> % (</span><br><span class="line">            <span class="built_in">len</span>(outputdata))</span><br><span class="line">        connectionSocket.send(header.encode())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Send the content of the requested file to the client</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(outputdata)):</span><br><span class="line">            connectionSocket.send(outputdata[i].encode())</span><br><span class="line">        connectionSocket.close()</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="comment"># Send response message for file not found</span></span><br><span class="line">        header = <span class="string">&#x27; HTTP/1.1 404 Found&#x27;</span></span><br><span class="line">        connectionSocket.send(header.encode())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Close client socket</span></span><br><span class="line">        connectionSocket.close()</span><br><span class="line">serverSocket.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><blockquote>
<p>在这个编程作业中，你将用Python编写一个客户ping程序。该客户将发送一个简单的ping报文，接受一个从服务器返回的pong报文，并确定从该客户发送ping报文到接收到pong报文为止的时延。该时延称为往返时延（RTT）。由该客户和服务器提供的功能类似于在现代操作系统中可用的标准ping程序，然而，标准的ping使用互联网控制报文协议（ICMP）（我们将在第4章中学习ICMP）。此时我们将创建一个非标准（但简单）的基于UDP的ping程序。<br>你的ping程序经UDP向目标服务器发送10个ping报文，对于每个报文，当对应的pong报文返回时，你的客户要确定和打印RTT。因为UDP是一个不可靠协议，由客户发送的分组可能会丢失。为此，客户不能无限期地等待对ping报文的回答。客户等待服务器回答的时间至多为1秒；如果没有收到回答，客户假定该分组丢失并相应地打印一条报文。<br>UDPPinger.py</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">serverName = <span class="string">&#x27;191.101.232.165&#x27;</span> <span class="comment"># 服务器地址，本例中使用一台远程主机</span></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment"># 服务器指定的端口</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM) <span class="comment"># 创建UDP套接字，使用IPv4协议</span></span><br><span class="line">clientSocket.settimeout(<span class="number">1</span>) <span class="comment"># 设置套接字超时值1秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">	sendTime = time.time()</span><br><span class="line">	message = (<span class="string">&#x27;Ping %d %s&#x27;</span> % (i+<span class="number">1</span>, sendTime)).encode() <span class="comment"># 生成数据报，编码为bytes以便发送</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		clientSocket.sendto(message, (serverName, serverPort)) <span class="comment"># 将信息发送到服务器</span></span><br><span class="line">		modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">1024</span>) <span class="comment"># 从服务器接收信息，同时也能得到服务器地址</span></span><br><span class="line">		rtt = time.time() - sendTime <span class="comment"># 计算往返时间</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;Sequence %d: Reply from %s    RTT = %.3fs&#x27;</span> % (i+<span class="number">1</span>, serverName, rtt)) <span class="comment"># 显示信息</span></span><br><span class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;Sequence %d: Request timed out&#x27;</span> % (i+<span class="number">1</span>))</span><br><span class="line">		</span><br><span class="line">clientSocket.close() <span class="comment"># 关闭套接字</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>UDPPingerServer.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># UDPPingerServer.py</span></span><br><span class="line"><span class="comment"># We will need the following module to generate randomized lost packets import random</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a UDP socket</span></span><br><span class="line"><span class="comment"># Notice the use of SOCK_DGRAM for UDP packets</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"><span class="comment"># Assign IP address and port number to socket</span></span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">12000</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	<span class="comment"># Generate random number in the range of 0 to 10</span></span><br><span class="line">	rand = random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="comment"># Receive the client packet along with the address it is coming from</span></span><br><span class="line">	message, address = serverSocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">	<span class="comment"># Capitalize the message from the client</span></span><br><span class="line">	message = message.upper()</span><br><span class="line">	<span class="comment"># If rand is less is than 4, we consider the packet lost and do not respond</span></span><br><span class="line">	<span class="keyword">if</span> rand &lt; <span class="number">4</span>:</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	<span class="comment"># Otherwise, the server responds</span></span><br><span class="line">	serverSocket.sendto(message, address)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><blockquote>
<p>在这个编程作业中，你将研发一个简单的Web代理服务器。当你的代理服务器从一个浏览器收到某对象的HTTP请求，它生成对相同对象的一个新HTTP请求并向初始服务器发送。当该代理从初始服务器接收到具有该对象的HTTP响应时，它生成一个包括该对象的新HTTP响应，并发送给该客户。这个代理将是多线程的，使其在相同时间能够处理多个请求。</p>
</blockquote>
</li>
</ol>
<p><a href="https://gitcode.net/mirrors/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES/-/blob/master/SocketProgrammingAssignment/%E4%BD%9C%E4%B8%9A4-%E5%A4%9A%E7%BA%BF%E7%A8%8BWeb%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/%E4%BD%9C%E4%B8%9A4-%E5%A4%9A%E7%BA%BF%E7%A8%8BWeb%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8-%E8%A7%A3%E7%AD%94.md">讲解</a><br>WebProxy.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket，绑定到端口，开始监听</span></span><br><span class="line">tcpSerPort = <span class="number">8899</span></span><br><span class="line">tcpSerSock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare a server socket</span></span><br><span class="line">tcpSerSock.bind((<span class="string">&#x27;&#x27;</span>, tcpSerPort))</span><br><span class="line">tcpSerSock.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 开始从客户端接收请求</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Ready to serve...&#x27;</span>)</span><br><span class="line">    tcpCliSock, addr = tcpSerSock.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Received a connection from: &#x27;</span>, addr)</span><br><span class="line">    message = tcpCliSock.recv(<span class="number">4096</span>).decode()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从请求中解析出filename</span></span><br><span class="line">    filename = message.split()[<span class="number">1</span>].partition(<span class="string">&quot;//&quot;</span>)[<span class="number">2</span>].replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">    fileExist = <span class="string">&quot;false&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 检查缓存中是否存在该文件</span></span><br><span class="line">        f = <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">        outputdata = f.readlines()</span><br><span class="line">        fileExist = <span class="string">&quot;true&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;File Exists!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 缓存中存在该文件，把它向客户端发送</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(outputdata)):</span><br><span class="line">            tcpCliSock.send(outputdata[i].encode())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Read from cache&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 缓存中不存在该文件，异常处理</span></span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;File Exist: &#x27;</span>, fileExist)</span><br><span class="line">        <span class="keyword">if</span> fileExist == <span class="string">&quot;false&quot;</span>:</span><br><span class="line">            <span class="comment"># 在代理服务器上创建一个tcp socket</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Creating socket on proxyserver&#x27;</span>)</span><br><span class="line">            c = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">            hostn = message.split()[<span class="number">1</span>].partition(<span class="string">&quot;//&quot;</span>)[<span class="number">2</span>].partition(<span class="string">&quot;/&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Host Name: &#x27;</span>, hostn)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 连接到远程服务器80端口</span></span><br><span class="line">                c.connect((hostn, <span class="number">80</span>))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Socket connected to port 80 of the host&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                c.sendall(message.encode())</span><br><span class="line">                <span class="comment"># Read the response into buffer</span></span><br><span class="line">                buff = c.recv(<span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line">                tcpCliSock.sendall(buff)</span><br><span class="line">                <span class="comment"># Create a new file in the cache for the requested file.</span></span><br><span class="line">                <span class="comment"># Also send the response in the buffer to client socket</span></span><br><span class="line">                <span class="comment"># and the corresponding file in the cache</span></span><br><span class="line">                tmpFile = <span class="built_in">open</span>(<span class="string">&quot;./&quot;</span> + filename, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">                tmpFile.writelines(buff.decode().replace(<span class="string">&#x27;\r\n&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">                tmpFile.close()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Illegal request&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># HTTP response message for file not found</span></span><br><span class="line">            <span class="comment"># Do stuff here</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;File Not Found...Stupid Andy&#x27;</span>)</span><br><span class="line">    <span class="comment"># Close the client and the server sockets</span></span><br><span class="line">    tcpCliSock.close()</span><br><span class="line">tcpSerSock.close()</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>nslookup <a href="http://www.mit.edu/">www.mit.edu</a><br>说这个命令是说，请告诉我主机 <a href="http://www.mit.edu/">www.mit.edu</a> 的IP地址。如屏幕截图所示，此命令的响应提供两条信息：（1）提供响应的DNS服务器的名称和IP地址；（2）响应本身，即 <a href="http://www.mit.edu/">www.mit.edu</a> 的主机名和IP地址。虽然响应来自理工大学的本地DNS服务器，但本地DNS服务器很可能会迭代地联系其他几个DNS服务器来获得结果，如书中第2.4节所述。</li>
</ol>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-自顶向下_第一章总述</title>
    <url>/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><p><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/0.1.png" alt="?"></p>
<h4 id="接入网和终端设备"><a href="#接入网和终端设备" class="headerlink" title="接入网和终端设备"></a>接入网和终端设备</h4><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>频分复用只能得到1/n的带宽，时分复用可以间断的得到全部带宽。<br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.1.png" alt="1.1"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.2.png" alt="1.1"></p>
<h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>分组交换是一种在计算机网络中进行数据传输的方法。在分组交换中，数据被分为较小的数据包（也称为分组），每个数据包都带有目标地址和其他必要的控制信息。这些数据包被发送到网络中，通过路由器和交换机等设备传输到目标地址。</p>
<p>与电路交换不同，分组交换不需要在通信开始之前建立连接。它使用存储转发的方式,<strong>即在发送数据包之前，必须先将其存储在中间设备（如路由器和交换机）中，然后再转发到下一个设备。</strong> 这种方式可以提高网络的效率和可靠性。</p>
<p>分组交换的优点包括：</p>
<ol>
<li><p>可以更好地利用网络带宽，因为多个数据包可以同时传输。</p>
</li>
<li><p>可以更好地适应网络流量的变化，因为数据包可以根据网络状况进行调整。</p>
</li>
<li><p>可以更好地处理错误，因为每个数据包都带有控制信息，使得错误可以更容易地被检测和纠正。</p>
</li>
<li><p>可以更好地支持多种应用程序，因为分组交换可以同时传输不同类型的数据包，如音频、视频和数据。</p>
</li>
</ol>
<h4 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h4><p><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.3.png" alt="1.1"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.3.1.png" alt="1.1"><br>多宿（Multi-homing）是指在一个网络中使用多个互联网服务提供商（ISP）或多个网络连接，以提高网络的可用性和容错能力。多宿可以确保当一个ISP或网络连接出现故障时，网络仍然可以继续运行，并且可以通过其他可用的连接访问互联网。</p>
<p>在多宿网络中，一个网络可以同时连接多个ISP，这些ISP可以提供不同的服务等级、带宽和成本等方面的选择。多宿网络通常使用路由协议和负载均衡技术来管理不同ISP之间的数据流量，确保数据包被正确路由，并且在不同的ISP之间平衡负载，以提高网络的性能和可靠性。</p>
<p>多宿可以应用于企业网络、数据中心、云计算等场景，以确保网络的高可用性和容错能力。同时，多宿也需要考虑到成本、安全和管理等方面的问题，因此在实际应用中需要仔细评估和规划。<br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.3.2.png" alt="1.1"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.3.3.png" alt="1.1"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.3.4.png" alt="1.1"></p>
<h3 id="时延、丢包、吞吐量"><a href="#时延、丢包、吞吐量" class="headerlink" title="时延、丢包、吞吐量"></a>时延、丢包、吞吐量</h3><h4 id="分组交换网的时延"><a href="#分组交换网的时延" class="headerlink" title="分组交换网的时延"></a>分组交换网的时延</h4><p>总时延=处理时延+排队时延+传输时延+传播时延</p>
<p>时延带宽积 = 传播时延 * 带宽</p>
<p>讨论网络核心路由器交换机链路</p>
<p><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.4.png" alt="1.1"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.4.1.png" alt="1.1"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.4.2.png" alt="1.1"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.4.3.png" alt="1.1"></p>
<p>流量强度：分组平均传输速率*分组长度/比特传输速率<br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.4.5.png" alt="1.1"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.4.6.png" alt="1.1"><br>流量强度越接近于1，则排队时延越高，反之则代表分组很少<br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.4.7.png" alt="1.1"></p>
<p><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.4.8.png" alt="1.1"><br><strong>Traceroute是Linux和Mac OS等系统默认提供的路由追踪小程序，Tracert是Windows系统默认提供的路由追踪小程序。他会发送3个数据包，并记录往返时延。</strong></p>
<blockquote>
<p>Tracert <a href="http://www.baidu.com/">www.baidu.com</a><br>通过最多 30 个跃点跟踪<br>到 <a href="http://www.a.shifen.com/">www.a.shifen.com</a> [110.242.68.3] 的路由:</p>
<p> 1     *      107 ms     *     10.173.255.254<br> 2    13 ms    10 ms    12 ms  10.191.1.6<br> 3     5 ms     5 ms     7 ms  112.53.79.9<br> 4     *        *        *     请求超时。<br> 5     *        *        *     请求超时。<br> 6     *        *        *     请求超时。<br> 7    22 ms    24 ms    19 ms  221.183.94.38<br> 8     *       33 ms     *     221.183.95.62<br> 9    47 ms    21 ms    36 ms  219.158.3.65<br>10     *        *        *     请求超时。<br>11    29 ms    36 ms    31 ms  110.242.66.178<br>12    37 ms    25 ms    21 ms  221.194.45.134<br>13     *        *        *     请求超时。<br>14     *        *        *     请求超时。<br>15    39 ms    36 ms    40 ms  10.166.96.50<br>16     *        *       39 ms  10.165.1.69<br>17    33 ms    31 ms    29 ms  110.242.68.3</p>
</blockquote>
<p>跟踪完成。</p>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>吞吐量指的是在一定时间内通过网络传输的数据量，通常以每秒钟传输的数据量（比特或字节）来衡量。吞吐量通常用于评估网络性能和带宽需求。较高的吞吐量表示网络传输速度较快，可以更快地传输数据，同时也可以支持更多的用户和应用程序。</p>
<p>Rs Rc接入网和R网络核心路由器交换机链路比较<br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.5.png" alt="?"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.5.1.png" alt="?"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.5.2.png" alt="?"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.5.3.png" alt="?"></p>
<p>吞吐量在有没干扰流量时取决于源和目的地之间的最小传输速率（从边缘到核心到边缘的所有速率）</p>
<h3 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h3><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.6.1.png" alt="?"></p>
<p>应用层  (报文)</p>
<blockquote>
<p>应用层协议是指计算机网络中应用程序之间进行通信时所使用的协&gt;议。常见的应用层协议包括HTTP、FTP、SMTP、POP3、IMAP、DNS&gt;等。</p>
<p>HTTP协议是超文本传输协议，用于在Web服务器和客户端之间传输数&gt;据。</p>
<p>FTP协议是文件传输协议，用于在网络上进行文件传输。</p>
<p>SMTP协议是简单邮件传输协议，用于在网络上进行邮件的发送和接&gt;收。</p>
<p>POP3协议是邮局协议3，用于在网络上接收邮件。</p>
<p>IMAP协议是Internet邮件访问协议，用于在网络上接收和管理邮件。</p>
<p>DNS协议是域名系统协议，用于将域名转换为IP地址。</p>
</blockquote>
<p>运输层  （报文段）</p>
<blockquote>
<p>运输层协议是计算机网络中的一种协议，主要用于提供可靠的数据传&gt;输和数据分段重组。常见的运输层协议包括TCP和UDP两种。</p>
<p>TCP协议（传输控制协议）是一种面向连接的协议，它提供了可靠的数&gt;据传输服务，能够确保数据的完整性和可靠性。TCP协议通过三次握手&gt;建立连接，通过序列号和确认号来保证数据的有序传输和可靠传输。&gt;TCP协议适用于对数据传输可靠性要求较高的应用程序，如文件传输、&gt;电子邮件等。</p>
<p>UDP协议（用户数据报协议）是一种无连接的协议，它不提供可靠的数&gt;据传输服务，也不保证数据的有序传输和可靠传输。UDP协议适用于对&gt;数据传输实时性要求较高的应用程序，如音频、视频等。因为UDP协议&gt;没有建立连接的过程，所以它的数据传输速度比TCP协议快，但数据的&gt;可靠性和完整性不能得到保证。</p>
</blockquote>
<p>网络层  （数据报）</p>
<blockquote>
<p>网络层是计算机网络体系结构中的一个层次，主要负责网络间的数据&gt;传输和路由选择。常见的网络层协议包括IP协议、ICMP协议、ARP协&gt;议等。</p>
<p>IP协议（Internet协议）是网络层的核心协议，它定义了数据在网络&gt;中的传输方式和寻址方式。IP协议通过IP地址来标识网络中的主机和&gt;路由器，可以实现跨网络的数据传输。IP协议还支持分片和重组机&gt;制，可以将大数据包分割成小的数据包进行传输。</p>
<p>ICMP协议（Internet控制报文协议）是网络层的辅助协议，主要用于&gt;网络故障的诊断和控制。ICMP协议可以向网络中的主机和路由器发送&gt;控制报文，比如ping命令就是利用ICMP协议来测试网络连接状态的。</p>
<p>ARP协议（地址解析协议）是网络层的辅助协议，主要用于将IP地址转&gt;换为MAC地址。ARP协议可以通过广播的方式向网络中的主机询问某个&gt;IP地址对应的MAC地址，从而实现数据包的发送和接收。</p>
<p>网络层还包括路由选择算法，它可以根据网络拓扑和路由器之间的链&gt;路状态来选择最优的路径进行数据传输。常见的路由选择协议包括&gt;RIP、OSPF、BGP等。</p>
</blockquote>
<p>链路层  （帧）</p>
<blockquote>
<p>链路层是计算机网络体系结构中的一个层次，主要负责物理层和网络&gt;层之间的数据传输。链路层的主要功能是将网络层的数据包封装成&gt;帧，并在物理层上传输。常见的链路层协议包括以太网、Wi-Fi、PPP&gt;等。</p>
<p>以太网是一种常见的有线局域网技术，它是基于CSMA/CD（载波侦听&gt;多点接入/碰撞检测）协议的。以太网将网络层的数据包封装成帧，每&gt;个帧包含了目标MAC地址、源MAC地址、数据和校验码。以太网还支持&gt;广播和多播，可以实现数据包的广播和多播传输。</p>
<p>Wi-Fi是一种无线局域网技术，它基于IEEE 802.11协议。Wi-Fi将网&gt;络层的数据包封装成帧，每个帧包含了目标MAC地址、源MAC地址、数&gt;据和校验码。Wi-Fi还支持无线信道的管理和协调，可以实现多台无线&gt;设备之间的协同工作。</p>
<p>PPP协议（点对点协议）是一种点对点的串行通信协议，它可以在串行&gt;线路上进行数据传输。PPP协议将网络层的数据包封装成帧，每个帧包&gt;含了同步字符、地址、控制、协议和数据等字段。PPP协议还支持认证&gt;和加密，可以保证数据的安全性和可靠性。</p>
<p>链路层还包括MAC地址的管理和ARP协议的实现，它们可以实现网络设&gt;备之间的通信和地址解析。</p>
</blockquote>
<p>物理层  （比特）</p>
<blockquote>
<p>物理层是计算机网络体系结构中的最底层，主要负责将数字信号转换&gt;为模拟信号，并在物理介质上传输。物理层的主要任务是定义物理介&gt;质的传输特性，包括传输速率、数据传输距离、信号强度等。</p>
<p>常见的物理层介质包括双绞线、同轴电缆、光纤等。不同的物理介质&gt;有不同的传输特性和传输速率，可以根据应用场景的需求来选择合适&gt;的物理介质。</p>
<p>物理层还包括数字信号和模拟信号的转换，以及调制和解调技术的应&gt;用。数字信号是由0和1组成的电信号，而模拟信号是连续的电信号。&gt;在数字信号传输过程中，需要将数字信号转换为模拟信号，然后在物&gt;理介质上传输。接收端需要将接收到的模拟信号转换为数字信号，以&gt;便上层协议进行处理。</p>
<p>物理层还包括编码和解码技术的应用，用于将数字信号转换为物理介&gt;质上的电信号。常见的编码和解码技术包括曼彻斯特编码、差分曼彻&gt;斯特编码、4B/5B编码等。</p>
<p>总之，物理层是计算机网络体系结构中最基础的层次，它为上层协议&gt;提供了可靠的物理传输基础。</p>
</blockquote>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><h4 id="ddos"><a href="#ddos" class="headerlink" title="ddos"></a>ddos</h4><p><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.6.png" alt="?"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.6.2.png" alt="?"></p>
<p>分组嗅探器<br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.6.3.png" alt="/"></p>
<h3 id="复习和习题"><a href="#复习和习题" class="headerlink" title="复习和习题"></a>复习和习题</h3><p>1.<br><strong>假定在发送主机和接收主机间只有一台分组交换机。发送主机和交换机间以及交换机和接收主机间的传输速率分别是R1和R2,。假设该交换机使用存储转发分组交换方式，发送一个长度为L的分组的端到端总时延是什么?（忽略排队时延、传播时延和处理时延。）</strong></p>
<blockquote>
<p>t0时发送端主机开始传输数据,t1=L/R1时发送端完成传输并且交换机&gt;收到完整的数据包（没有传播延时）。因为交换机在t1时已收到完整&gt;包，那么t1时交换机开始传输包至接收主机。t=t1+L/R2时交换机完&gt;成输出并且接收主机收到完整包（没有传播延时）。因此，端到端总&gt;延时是L/R1＋L/R2 。</p>
</blockquote>
<p>2.<br><strong>与分组交换网络相比，电路交换网络有哪些优点?在电路交换网络中，TDM 比 FDM有哪些优点:</strong></p>
<blockquote>
<p>电路交换网络可以在响应时间内保证一定量的端到端带宽。如今大部&gt;分分组交换网络（包括因特网）无法保证端到端带宽。FDM需要复杂&gt;的模拟硬件来将信号转换为合适的频率。</p>
</blockquote>
<p>3.<br><strong>一个长度为1000字节的分组经距离为2500km的链路传播，传播速率为2.5×1000000000m/s并且传输速率为2Mbps,它需要用多长时间?更为一般地，一个长度为L的分组经距离为d的链路传播，传播速率为s并且传输速率为R bps，它需要用多长时间?该时延与传输速率相关吗?</strong></p>
<blockquote>
<p>传播时间可以通过距离除以传播速率得出：2500km / 2.5×10^8 m/&gt;s = 10s。传输时间可以通过分组长度除以传输速率得出：1000字节 &gt;* 8位/字节 / 2Mbps = 0.004s。因此，总共需要的时间为传播时间&gt;加上传输时间，即10s + 0.004s = 10.004s。</p>
<p>对于更一般的情况，可以使用以下公式来计算分组的传输时间：</p>
<p>传输时间 = 分组长度 / 传输速率</p>
<p>传播时间 = 距离 / 传播速率</p>
<p>总时延 = 传输时间 + 传播时间</p>
<p>其中，分组长度和距离都是已知量，传输速率和传播速率也是已知&gt;量。因此，可以通过这个公式来计算出任何长度的分组在任何距离下&gt;的传输时间和总时延。</p>
<p>该时延与传输速率和传播速率都有关系。传播速率越大，时延就越&gt;小；传输速率越大，时延也越小。因此，如果想要减少分组的传输时&gt;延，可以提高传播速率和传输速率。但是，时延也受到距离的影响，&gt;距离越远，时延就越大，这是无法改变的。</p>
<p>4.<br><strong>假定主机A要向主机B发送一个大文件。从主机A到主机B的路径上有&gt;3段链路，其速率分别为R,=500kbps，R,=2Mbps, R, =1Mbps 。<br>a.假定该网络中没有其他流量，该文件传送的吞吐量是多少?<br>b.假定该文件为4MB。传输该文件到主机B大致需要多长时间?<br>c.重复(a） 和(b)，只是这时R减小到100kbps</strong></p>
<p>a. 该网络中没有其他流量，则传输的吞吐量等于三个链路中最小的链&gt;路速率，即500kbps。因此，传输的吞吐量为500kbps。</p>
<p>b. 文件大小为4MB，需要将其转换为比特数，即4MB * 8 = 32Mb。&gt;传输时间可以通过以下公式计算：</p>
<p>传输时间 = 文件大小 / 传输速率</p>
<p>其中，传输速率等于三个链路速率中最小的那个，即500kbps。将传&gt;输速率转换为比特每秒（bps），即500kbps * 1000 = &gt;500000bps。因此，传输时间为32Mb / 500000bps = 64秒。</p>
<p>c. 当链路速率为100kbps时，传输的吞吐量仍然等于三个链路中最小&gt;的链路速率，即100kbps。因此，传输的吞吐量为100kbps。</p>
<p>传输时间可以通过以下公式计算：</p>
<p>传输时间 = 文件大小 / 传输速率</p>
<p>传输速率等于三个链路速率中最小的那个，即100kbps。将传输速率&gt;转换为比特每秒（bps），即100kbps * 1000 = 100000bps。因&gt;此，传输时间为32Mb / 100000bps = 320秒。</p>
<p><strong>在计算文件传输时间时，使用吞吐量（throughput）而非网速&gt;（bandwidth）的原因是，吞吐量考虑的是整个路径上的数据传输速&gt;率，而网速仅仅是链路的最大传输速率。在一条路径上传输数据时，&gt;数据的传输速率受到整个路径上最小的链路速率的限制，因此，计算&gt;文件传输时间时需要考虑整个路径上的传输速率，即吞吐量。<br>测网速实际上就是测量网络的吞吐量。网速指的是网络链路的最大传&gt;输速率，而吞吐量指的是在特定时间段内通过网络传输的数据量，即&gt;单位时间内的数据传输速率。在实际应用中，我们通常会使用吞吐量&gt;来评估网络的性能，因为吞吐量考虑的是整个网络路径上的数据传输&gt;速率，能够更加全面地反映网络的真实性能.</strong><br>5.<br><strong>病毒和蠕虫之间有什么不同?</strong><br>病毒：需要以下⼈的交互来传播。⽐如邮件病毒。<br>蠕⾍：不需要⽤⼾介⼊。受感染主机中的蠕⾍会扫描IP地址和端⼝号来查找可感染的进程。</p>
</blockquote>
<p>6.<br><strong>设计并描述在自动柜员机和银行的中央计算机之间使用的一种应用层协议。你的协议应当允许验证用户卡和口令，查询账目结算 (这些都在中央计算机系统中进行维护)，支取账目 (即向用户支付钱)。你的协议实体应当能够处理取钱时账目中钱不够的常见问题。通过列出自动柜员机和银行中央计算机在报文传输和接收过程中交换的报文和采取的动作来定义你的协议。使用类似于图1-2 所示的图，拟定在简单无差错取钱情况下该协议的操作。明确地阐述在该协议中关于底层端到端运输服务所作的假设。</strong></p>
<blockquote>
<p>协议名称：Bank ATM Protocol</p>
<p>协议实体：自动柜员机（ATM），银行中央计算机</p>
<p>协议操作：</p>
<ol>
<li>验证用户卡和口令</li>
</ol>
<p>ATM发送验证请求报文，包含用户卡号和口令。银行中央计算机接收请&gt;求报文，验证用户信息并返回验证结果报文。</p>
<ol start="2">
<li>查询账目结算</li>
</ol>
<p>ATM发送查询请求报文，包含用户卡号。银行中央计算机接收请求报&gt;文，查询用户账目结算信息并返回查询结果报文。</p>
<ol start="3">
<li>支取账目</li>
</ol>
<p>ATM发送支取请求报文，包含用户卡号和支取金额。银行中央计算机接&gt;收请求报文，检查账目余额是否充足，如果充足则更新账目余额并返&gt;回支取结果报文；如果不充足则返回支取失败报文。</p>
<ol start="4">
<li>处理账目余额不足问题</li>
</ol>
<p>如果账目余额不足，银行中央计算机将返回支取失败报文，ATM将显示&gt;错误信息并提示用户重新输入支取金额。</p>
<p>报文格式：</p>
<p>验证请求报文：CardNum, Password</p>
<p>验证结果报文：Result</p>
<p>查询请求报文：CardNum</p>
<p>查询结果报文：Balance</p>
<p>支取请求报文：CardNum, Amount</p>
<p>支取结果报文：Result</p>
<p>底层端到端运输服务假设：</p>
<p>该协议假设底层端到端运输服务是可靠的，即发送的每个报文都能够&gt;被成功接收。此外，该协议假设底层端到端运输服务提供了足够的带&gt;宽和低延迟，以确保快速响应用户请求。</p>
</blockquote>
<p>7.<br><strong>式(1-1)给出了经传输速率为R的N段链路发送长度L的一个分组的端到端时延。对于经过N段链路连续地发送P个这样的分组，一般化地表示出这个公式</strong></p>
<blockquote>
<p>对于经过N段链路连续地发送P个长度为L的分组，其端到端时延可以表示为：</p>
<p>T = N * (L / R) + (P - 1) * L / R + d</p>
<p>其中，N为链路段数，L为分组长度，R为传输速率，P为分组数，d为传输时延中的固定时延（如传播时延、处理时延等）。<br>公式中第一项 N * (L / R) 表示数据在N个链路段上的传输时延，即数据通过N个链路段所需要的时间。这里的 L / R 表示数据通过一个链路段所需要的时间，再乘以 N 就得到了数据通过 N 个链路段所需要的时间。</p>
<p>公式中第二项 (P - 1) * L / R 表示数据在链路之间等待传输的时间，即数据在每个链路段之间传输的时间。这里的 (P - 1) 表示有 P 个分组，而每个分组之间需要经过 P - 1 个链路段，因此需要等待 P - 1 个链路段的时间，再乘以 L / R 就得到了数据在链路之间等待传输的时间。</p>
<p>公式中最后一项 d 表示传输时延中的固定时延，例如传播时延、处理时延等。这些时延不随数据的大小和传输速率而改变，因此可以视为固定的时延。</p>
</blockquote>
<p>8.<br><strong>考虑一个应用程序以稳定的速率传输数据(例如，发送方每个时间单元产生一个N比特的数据单元，其中h较小且固定)。另外，当这个应用程序启动时，它将连续运行相当长的一段时间。回答下列问题，简要论证你的回答:<br>a.是分组交换网还是电路交换网更为适合这种应用?为什么?<br>b假定使用了分组交换网，并且该网中的所有流量都来自如上所述的这种应用程序。此外，假定该应用程序数据传输速率的总和小于每条链路的各自容量。需要某种形式的拥塞控制吗?为什么?</strong></p>
<blockquote>
<p>a. 对于以稳定速率传输数据的应用程序，电路交换网更适合。因为在电路交换网中，通信的两端会建立一条独占的物理通路，这条通路在通信过程中一直被保留，因此对于这种稳定的数据传输，可以通过预先建立的电路进行传输，可以保证数据传输的实时性和可靠性。而在分组交换网中，数据是以分组的形式进行传输的，每个分组独立地传输，可能会受到拥塞和延迟等因素的影响，因此不太适合对实时性要求较高的应用程序。</p>
<p>b. 在分组交换网中，对于该应用程序的数据传输速率的总和小于每条链路的各自容量的情况下，不需要采用某种形式的拥塞控制。因为在这种情况下，网络中的每条链路都有足够的带宽来容纳该应用程序的数据传输，不会出现拥塞的情况。如果采用了拥塞控制，可能会降低网络的吞吐量，而且在实际应用中实现拥塞控制也需要一定的成本和复杂性。因此，在网络中没有拥塞的情况下，不需要采用拥塞控制。</p>
</blockquote>
<p>8.<br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.7.2.png" alt="?"></p>
<p><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.7.3.png" alt="?"></p>
<p>9.<br><strong>在这个习题中，我们考虑从主机A向主机B通过分组交换网发送语音（VolP)。主机A将模拟语音转换为传输中的64kbps 数字比特流。然后主机A将这些比特分为56字节的分组。A和B之间有一条链路:它的传输速率是2Mbps，传播时延是10ms。一旦A收集了一个分组，就将它向主机B发送。一日主机B接收到一个完整的分组，它将该分组的比特转换成模拟信号。从比特产生（从位于主机的初始模拟信号起)的时刻起,到该比特被解码（在主机B上作为模拟信号的一部分)，花了多少<br>时间?</strong></p>
<blockquote>
<p>生成分组:56<em>8b/64kbps=7ms<br>传输时延:56</em>8b/2Mbps=0.224<br>总时间=10（传播时延）+7+0.224=17.224ms</p>
</blockquote>
<p>10.<br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.7.4.png" alt="?"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.7.6.png" alt="?"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.7.5.png" alt="?"></p>
<p>11.<br><strong>一台分组交换机接收一个分组并决定该分组应当转发的出链路。当某分组到达时,另一个分组正在该出链路上被发送到一半，还有4个其他分组正等待传输。这些分组以到达的次序传输。假定所有分组是1500字节并且链路速率是2Mbps。该分组的排队时延是多少?在更一般的情况下，当所有分组的长度是L,传输速率是R,当前正在传输的分组已经传输了x比特,并且已经在队列中有n个分组，其排队时延是多少?</strong></p>
<blockquote>
<p>P12.到达的数据包必须首先等待链路发送<br>4.5×1500字节=6750字节或54000比特。<br>由于这些比特是以2Mbps发送的，所以队列延迟为27毫秒。一般情况下，排队延迟为(nL(L-x))/R。<br>有一个完整分组的排队时延为1500× 8b / 2Mbps = 0.6ms<br>4.5个分组的总排队时延为4.5* 0.6ms = 2.7ms</p>
</blockquote>
<p>12.<br><strong>a.假定有N个分组同时到达一条当前没有分组传输或排队的链路<br>每个分组长为L，链路传输速率<br>为R。对N个分组而言，其平均排队时延是多少?<br>b.现在假定每隔LN/R秒有N个分组同时到达链路。一个分组的平均排队时延是多少?</strong></p>
<blockquote>
<p>a.第一个分组的排队时延为o,第二个L/R，第三个2L/R，第N个(N -1)L/R因此平均排队时延为(L/R＋2L/R＋…+(N -1)L/R)/N=(N -1)L/2Rb.<br>当下一批N个分组到达时，上一批已经传完，因此平均排队时延为(N -1)L/2R</p>
</blockquote>
<p>13.<br><strong>考虑一台路由器缓存前面的一条出链路。在这个习题中，将使用李特尔(Lile)公式，这是排队论中的一个著名公式。令N表示在缓存中的分组加上被传输的分组的平均数。令a表示到达链路的分组速率。令d表示一个分组历经的平均总时延(即排队时延加传输时延)。李特尔公式是N=axd假定该缓存平均包含10个分组，并且平均分组排队时延是10ms。该链路的传输速率是100分组秒。使用李特尔公式，在没有丢包的情况下，平均分组到达率是多少?</strong></p>
<blockquote>
<p>N应该等于缓存中的分组加上正在传输的分组数，即N=10+1=11个分组。传输时延是指一个分组在链路上传输所需的时间,传输时延是1/100秒，因为每个分组传输的时间是1/100秒，所以传输时延为1/100秒。因此，总时延d=排队时延+传输时延=10ms+1/100s=0.02s。根据李特尔公式N=axd，可以求得平均分组到达率a：</p>
<p>a = N / d = 11 / 0.02 = 550分组/秒</p>
</blockquote>
<p>14.<br><strong>考虑对应于图1-20b吞吐量的例子。现在假定有M对客户-服务器而不是10对。用Rs Rc和R分别表示服务器链路、客户链路和网络链路的速率。假设所有的其他链路都有充足容量，并且除了由这M对客户-服务器产生的流量外，网络中没有其他流量。推导出由Rs、Rc R和M表示的通用吞吐量表达式。</strong></p>
<blockquote>
<p>min{Rc,Rs,R/m}</p>
</blockquote>
<p>15.<br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.7.7.png" alt="?"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.7.8.png" alt="?"></p>
<p>16.<br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.7.9.png" alt="?"><br><img src="/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E8%BF%B0/1.7.10.png" alt="?"></p>
<p>c:在某一个传时（除了在第一个路由器），他后边的也传，时间重合了。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络疑问</title>
    <url>/2023/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%96%91%E9%97%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="网络有边缘部分主机和核心部分交换机，这些交换机是个人的路由器还是isp的路由器"><a href="#网络有边缘部分主机和核心部分交换机，这些交换机是个人的路由器还是isp的路由器" class="headerlink" title="网络有边缘部分主机和核心部分交换机，这些交换机是个人的路由器还是isp的路由器?"></a>网络有边缘部分主机和核心部分交换机，这些交换机是个人的路由器还是isp的路由器?</h4><blockquote>
<p>在互联网中，边缘部分主机指的是连接到互联网的个人电脑、手机、平板等设备，而核心部分交换机指的是连接不同网络的路由器、交换机等网络设备。这些交换机不是个人的路由器，而是由互联网服务提供商（ISP）或其他网络运营商提供和管理的。</p>
<p>ISP通常会在核心部分网络中设置大量的路由器和交换机，这些设备负责将数据包从一个网络转发到另一个网络。当一个数据包从边缘部分主机发送出去后，它会先到达本地网络中的路由器（通常是家庭路由器），然后通过ISP的网络设备转发到目标网络中的路由器，最终到达目标主机。在这个过程中，数据包会经过多个网络设备，包括ISP的路由器、交换机等。</p>
<p>因此，个人设备通过家庭路由器连接到互联网，而数据包经过的路由器和交换机是由ISP或其他网络运营商提供和管理的。</p>
</blockquote>
<h4 id="所以我在我的电脑上不能抓包别人的数据是吗"><a href="#所以我在我的电脑上不能抓包别人的数据是吗" class="headerlink" title="所以我在我的电脑上不能抓包别人的数据是吗?"></a>所以我在我的电脑上不能抓包别人的数据是吗?</h4><blockquote>
<p>一般情况下，你在自己的电脑上不能抓取其他人的数据包。这是因为，在互联网中，数据包是通过路由器进行转发的，而不是直接发送到目标主机。当一个数据包从发送端发出后，它会先到达发送端所在的本地网络，然后通过本地路由器转发到目标网络，最终到达目标主机。在这个过程中，数据包经过的路由器和交换机是由ISP或其他网络运营商提供和管理的。</p>
<p>如果你想抓取其他人的数据包，需要在数据包经过的路由器或交换机上进行抓包。这通常需要获得网络管理员的授权，并且需要使用专业的网络抓包工具。此外，抓取其他人的数据包也可能会涉及到隐私和安全等问题，因此需要谨慎处理。</p>
</blockquote>
<h4 id="那这个转发的过程不是很危险吗，截取数据怎么办"><a href="#那这个转发的过程不是很危险吗，截取数据怎么办" class="headerlink" title="那这个转发的过程不是很危险吗，截取数据怎么办?"></a>那这个转发的过程不是很危险吗，截取数据怎么办?</h4><blockquote>
<p>在互联网中，数据包的转发是通过路由器进行的，路由器会根据其路由表进行数据包的转发。在这个过程中，数据包可能会经过多个路由器进行转发，因此存在一定的安全风险，例如路由器被黑客攻击或者路由器被设置了恶意路由等。</p>
<p>为了保护数据的安全性，互联网中通常采用加密协议来保护数据的传输过程。例如，HTTPS协议可以对数据进行加密传输，从而防止数据被截取和窃听。此外，还可以使用虚拟专用网络（VPN）等技术来保护数据的安全性。VPN可以在公共互联网上建立一个加密的通道，从而保护数据在传输过程中的安全性。</p>
<p>总之，在互联网中，数据的安全性需要依靠多种技术手段来保护，而不仅仅是依赖于路由器的安全性。</p>
</blockquote>
<h4 id="链路指的是什么，网络核心的路由器交换机和线路吗"><a href="#链路指的是什么，网络核心的路由器交换机和线路吗" class="headerlink" title="链路指的是什么，网络核心的路由器交换机和线路吗"></a>链路指的是什么，网络核心的路由器交换机和线路吗</h4><p>吞吐量<br>作为最后一个例子，考虑图1-20b，其中有10台服务器和10个客户与某计算机网络核心相连。在这个例子中，同时发生10个下载，涉及10个客户-服务器对。假定这10个下载是网络中当时的唯一流量。如该图所示，在核心中有一条所有10个下载通过的链路。将这条链路R的传输速率表示为R。假定所有服务器接入链路具有相同的速率Rs，所有客户接入链路具有相同的速率Rc，并且核心中除了速率为R的一条共同链路之外的所有链路传输速率都比R、Rc和Rs大得多。现在我们要问，这种下载的吞吐量是多少?显然，如果该公共链路的速率R很大，比如说比Rc和Rs大100倍，则每个下载的吞吐量将仍然是minRs，Rc。但是如果该公共链路的速率与R和R有相同量级会怎样呢?在这种情况下其吞吐量将是多少呢?让我们观察一个特定的例子。假定Rs=2Mbps，Rc=1Mbps，R=5Mbps，并且公共链路在10个下载之间平等划分它的传输速率。这时每个下载的瓶颈不再位于接人网中，而是位于核心中的共享链路了，该瓶颈仅能为每个下载提供500kbps的吞吐量。因此每个下载的端到端吞吐量现在减少到500kbps。</p>
<blockquote>
<p>在计算机网络中，链路（Link）指的是连接两个网络设备的通信媒介，例如交换机和路由器之间的物理线路或者无线信道。链路可以是有线的或者无线的，它们可以是光纤、双绞线、无线电波等各种不同的传输媒介。在网络核心中，链路通常指的是连接路由器或交换机之间的物理线路或者光纤。因此，在题目中，所有服务器接入链路和所有客户接入链路都指的是连接服务器和客户端的物理链路，而共享链路R是连接网络核心中的路由器或交换机的物理链路。</p>
</blockquote>
<h4 id="题目中是假定他们同时下载了是吗"><a href="#题目中是假定他们同时下载了是吗" class="headerlink" title="题目中是假定他们同时下载了是吗"></a>题目中是假定他们同时下载了是吗</h4><blockquote>
<p>是的，题目中假设10个下载是同时进行的，因此它们共享同一条链路R。如果这些下载是分别进行的，那么它们之间就不存在共享链路的问题，每个下载的带宽分配将会独立计算。但是，由于10个下载是同时进行的，它们的流量将会在链路R上竞争带宽，因此链路R成为了这些下载的共同瓶颈。因此，每个下载的带宽将会受到链路R带宽的限制，因此它们的带宽是平分的。</p>
</blockquote>
<h4 id="题目中的R是指的哪里的速率？路由器推出分组的速率？还是物理介质传播的速率"><a href="#题目中的R是指的哪里的速率？路由器推出分组的速率？还是物理介质传播的速率" class="headerlink" title="题目中的R是指的哪里的速率？路由器推出分组的速率？还是物理介质传播的速率"></a>题目中的R是指的哪里的速率？路由器推出分组的速率？还是物理介质传播的速率</h4><blockquote>
<p>题目中的R指的是核心中的共享链路的传输速率，也就是物理介质传播的速率。</p>
</blockquote>
<h4 id="rs-rc是指接入网的速率吗"><a href="#rs-rc是指接入网的速率吗" class="headerlink" title="rs rc是指接入网的速率吗"></a>rs rc是指接入网的速率吗</h4><blockquote>
<p>是的，Rs和Rc指的是接入网的速率。Rs是指所有服务器接入链路的速率，Rc是指所有客户端接入链路的速率。这些速率决定了每个客户端和服务器能够传输的最大速率。</p>
</blockquote>
<h4 id="接入网和网络核心的区别"><a href="#接入网和网络核心的区别" class="headerlink" title="接入网和网络核心的区别"></a>接入网和网络核心的区别</h4><blockquote>
<p>接入网和网络核心是计算机网络中两个不同的概念。</p>
<p>接入网是指连接用户设备和互联网服务提供商(ISP)网络的物理链路或&gt;无线连接，通常包括调制解调器、路由器、交换机、光纤或电缆等设&gt;备。接入网的速率通常比核心网速率低，因为接入网需要覆盖更广泛&gt;的区域，并且需要支持更多的用户设备。</p>
<p>网络核心是指网络的中央部分，包括路由器、交换机和其他网络设&gt;备，用于转发和处理网络流量。网络核心通常具有更高的速率和更复&gt;杂的拓扑结构，用于支持大量的数据传输和流量管理。</p>
<p>因此，接入网和网络核心在计算机网络中具有不同的作用和特点。接&gt;入网连接用户设备和ISP网络，提供用户与网络之间的连接，而网络核&gt;心用于处理和转发网络流量，维护网络的正常运行。</p>
</blockquote>
<h4 id="电路交换和分组交换是不是都有复用，电路交换需要预留某个用户的带宽"><a href="#电路交换和分组交换是不是都有复用，电路交换需要预留某个用户的带宽" class="headerlink" title="电路交换和分组交换是不是都有复用，电路交换需要预留某个用户的带宽"></a>电路交换和分组交换是不是都有复用，电路交换需要预留某个用户的带宽</h4><blockquote>
<p>是的，电路交换和分组交换都有复用的概念。在电路交换中，需要预留某个用户的带宽，因此可以说是一种静态复用。而在分组交换中，带宽是动态分配的，可以根据实际需要进行动态复用。</p>
</blockquote>
<blockquote>
<p>电路交换和分组交换是计算机网络通信中的两种基本交换方式。两种交换方式的主要区别在于数据传输的方式不同。</p>
<p>电路交换是指在通信开始之前，建立一条专用的、端到端的物理连接，然后在通信过程中一直占用这条连接。在电路交换中，数据传输是连续不间断的，通常用于传输实时性要求较高的音视频数据。电路交换需要预留带宽，因此在通信过程中不允许其他用户占用这条连接，因此也称为静态复用。</p>
<p>分组交换是指将数据分成若干个大小相同的数据包（分组），然后通过网络传输。在传输过程中，每个分组都是独立处理的，可以通过不同的路径到达目的地。因此，分组交换具有更好的灵活性和可靠性，可以根据网络的实际情况进行动态分配带宽，因此也称为动态复用。</p>
<p>两种交换方式的异同点如下：</p>
<ol>
<li><p>建立连接的方式不同。电路交换需要在通信开始之前建立一条专用的、端到端的物理连接(占用资源)，而分组交换则不需要建立连接，只需要将数据包发送到网络中，然后等待接收方响应。</p>
</li>
<li><p>数据传输的方式不同。在电路交换中，数据传输是连续不间断的，而在分组交换中，数据被分成若干个数据包进行传输。</p>
</li>
<li><p>复用方式不同。电路交换需要预留带宽，因此在通信过程中不允许其他用户占用这条连接，因此也称为静态复用。而分组交换具有更好的灵活性和可靠性，可以根据网络的实际情况进行动态分配带宽，因此也称为动态复用。</p>
</li>
<li><p>传输速度不同。由于电路交换需要建立连接和预留带宽，因此传输速度比分组交换慢。而分组交换可以根据网络情况进行动态分配带宽，因此传输速度相对较快。</p>
</li>
</ol>
</blockquote>
<h4 id="电路交换的应用"><a href="#电路交换的应用" class="headerlink" title="电路交换的应用"></a>电路交换的应用</h4><blockquote>
<p>电路交换是一种传输数据的方式，通常用于传输实时性要求较高的音&gt;视频数据。以下是电路交换的一些应用：</p>
<ol>
<li><p>电话通信：传统的电话通信就是一种使用电路交换的通信方式。在&gt;通信开始之前，电话线路会建立一条专用的、端到端的物理连接，然&gt;后在通信过程中一直占用这条连接。</p>
</li>
<li><p>电视广播：电视广播也是一种使用电路交换的应用。电视信号需要&gt;连续不间断地传输，因此需要建立一条专用的、端到端的物理连接，&gt;以保证传输的稳定性和实时性。</p>
</li>
<li><p>视频会议：视频会议也是一种使用电路交换的应用。在视频会议&gt;中，参会者需要实时地传输音视频数据，因此需要建立一条专用的、&gt;端到端的物理连接，以保证传输的稳定性和实时性。</p>
</li>
<li><p>实时监控：在一些场合下，需要对现场进行实时监控，例如银行、&gt;商场、机场等。实时监控需要传输大量的视频数据，因此需要使用电&gt;路交换方式进行传输。</p>
</li>
</ol>
<p>总之，电路交换通常用于传输实时性要求较高的数据，需要建立一条&gt;专用的、端到端的物理连接，以保证传输的稳定性和实时性。</p>
</blockquote>
<h4 id="bittorrent为什么是p2p"><a href="#bittorrent为什么是p2p" class="headerlink" title="bittorrent为什么是p2p"></a>bittorrent为什么是p2p</h4><blockquote>
<p>BitTorrent是一种P2P协议，它采用P2P结构来实现文件共享和下&gt;载。BitTorrent的P2P结构可以让用户之间直接进行文件传输，而不&gt;需要通过中央服务器进行转发和管理，这样可以减少服务器的负载，&gt;提高系统的可扩展性和可靠性。</p>
<p>BitTorrent的P2P结构是通过将文件切分成多个小块来实现的，每个&gt;用户可以下载和上传不同的文件块，从而实现文件的分布式共享和下&gt;载。BitTorrent还采用了一种“种子-下载”的方式，即用户需要先下&gt;载一个种子文件，通过该种子文件来获取目标文件的元数据和下载地&gt;址，然后再通过P2P网络进行文件的下载和共享。</p>
<p>总之，BitTorrent之所以采用P2P结构，是因为它可以实现高效的文&gt;件共享和下载，同时也可以降低服务器的负载和提高系统的可靠性。</p>
</blockquote>
<h4 id="元数据是什么"><a href="#元数据是什么" class="headerlink" title="元数据是什么"></a>元数据是什么</h4><blockquote>
<p>元数据是指描述数据的数据，也叫做“中介数据”或“数据的数据”。&gt;它是对数据的描述和解释，可以包括数据的属性、结构、来源、格&gt;式、语义等信息。元数据可以帮助用户更好地理解数据，同时也可以&gt;帮助计算机系统更好地管理和利用数据。</p>
<p>例如，在数字图书馆中，每一本图书都有元数据，包括书名、作者、&gt;出版社、出版日期、ISBN号等信息。这些元数据可以帮助用户更好地&gt;了解和查找图书，也可以帮助图书管理员更好地管理和维护图书馆。</p>
<p>在计算机系统中，元数据也非常重要。例如，在文件系统中，每个文&gt;件都有元数据，包括文件名、大小、创建时间、修改时间、访问权限&gt;等信息。这些元数据可以帮助操作系统更好地管理和维护文件系统，&gt;同时也可以帮助用户更好地查找和使用文件。</p>
<p>总之，元数据是数据的描述信息，它可以帮助用户更好地理解和利用&gt;数据，同时也可以帮助计算机系统更好地管理和利用数据。</p>
</blockquote>
<h4 id="使用p2p应用时，如果没有人上载或者挂着某资源，别人就没法下载对吗"><a href="#使用p2p应用时，如果没有人上载或者挂着某资源，别人就没法下载对吗" class="headerlink" title="使用p2p应用时，如果没有人上载或者挂着某资源，别人就没法下载对吗"></a>使用p2p应用时，如果没有人上载或者挂着某资源，别人就没法下载对吗</h4><blockquote>
<p>是的，如果没有人上载某个资源，或者没有其他用户同时上传文件&gt;块，那么其他用户就无法下载该资源。P2P应用是一种点对点的文件共享方式，每个用户都可以成为文件的提供者和下载者。当用户下载文件时，他们不仅从其他用户下载文件块，也同时将自己的文件块上传给其他用户。因此，如果没有其他用户同时上传文件块，或者没有人上载某个资源，那么其他用户就无法下载该资源。</p>
<p>在P2P应用中，用户之间的文件共享是基于互相协作的，需要有足够的&gt;用户同时上传文件块，才能保证文件下载的成功率和速度。如果没有&gt;其他用户同时上传文件块，那么文件下载就会停滞或者变得非常慢。&gt;因此，P2P应用中的文件下载需要保证有其他用户同时在上传文件块。</p>
<p>总之，P2P应用中的文件下载需要保证有其他用户同时上传文件块，如果没有其他用户同时上传文件块，或者没有人上载某个资源，那么其他用户就无法下载该资源。</p>
</blockquote>
<h4 id="服务器可以主动给客户端发消息吗"><a href="#服务器可以主动给客户端发消息吗" class="headerlink" title="服务器可以主动给客户端发消息吗"></a>服务器可以主动给客户端发消息吗</h4><blockquote>
<p>一般情况下，服务器不能主动给客户端发消息。客户端需要向服务器发送请求，服务器才会响应并返回数据。但是，有些技术可以实现服务器向客户端推送消息，如WebSocket、长轮询、服务器推送事件等。这些技术可以在客户端与服务器之间建立一个持久化的连接，从而实现服务器向客户端主动发送消息。</p>
</blockquote>
<h4 id="dns底层是udp吗"><a href="#dns底层是udp吗" class="headerlink" title="dns底层是udp吗?"></a>dns底层是udp吗?</h4><blockquote>
<p>DNS协议使用UDP协议而不是TCP协议，主要是出于以下几个原因：</p>
<ol>
<li><p>UDP协议比TCP协议更轻量级，因为它不需要建立连接、保持连接&gt;状态和拆除连接等复杂的机制。这使得DNS查询可以更快地完成，因为&gt;UDP协议的开销更小。</p>
</li>
<li><p>DNS查询通常是短暂的，只需要发送一个小的查询数据包并接收一&gt;个小的响应数据包。因此，UDP协议足以满足DNS查询需求。</p>
</li>
<li><p>DNS查询通常需要进行大量的并发查询，如果使用TCP协议，每个&gt;查询都需要创建一个新的TCP连接，这将导致大量的连接开销和资源浪&gt;费。而UDP协议可以通过一个单独的端口号处理大量的并发查询，从而&gt;更加高效。</p>
</li>
</ol>
<p>尽管UDP协议没有TCP协议那么可靠，但DNS查询通常是短暂的，因此&gt;数据包在传输过程中的丢失或重复通常不会对查询产生重大影响。如&gt;果需要更可靠的DNS查询，DNS协议还支持使用TCP协议进行查询，但&gt;这通常只在DNS数据包较大或DNS查询需要更高的可靠性时使用。</p>
</blockquote>
<h4 id="CND（Content-Delivery-Network）：内容分发网络，是一种分布式服务器系统，可以加速互联网上的内容传输和访问。"><a href="#CND（Content-Delivery-Network）：内容分发网络，是一种分布式服务器系统，可以加速互联网上的内容传输和访问。" class="headerlink" title="CND（Content Delivery Network）：内容分发网络，是一种分布式服务器系统，可以加速互联网上的内容传输和访问。"></a>CND（Content Delivery Network）：内容分发网络，是一种分布式服务器系统，可以加速互联网上的内容传输和访问。</h4><blockquote>
<p>是的，您说得对。CND（Content Delivery Network）是一种分布式服务器系统，可以将内容缓存到全球各地的服务器上，从而加速互联网上的内容传输和访问。CND可以减轻源服务器的负担，提高用户访问速度和稳定性，同时也可以降低带宽成本。CND通常用于大型网站、视频、音频等流媒体内容的分发，以及在线游戏、电子商务等需要快速响应的应用场景。</p>
</blockquote>
<h4 id="cdn是提前缓存吗"><a href="#cdn是提前缓存吗" class="headerlink" title="cdn是提前缓存吗"></a>cdn是提前缓存吗</h4><blockquote>
<p>是的，CDN（Content Delivery Network）可以通过提前缓存来加速内容传输和访问。CDN将内容缓存到全球各地的服务器上，当用户请求访问这些内容时，CDN会自动选择距离用户最近的服务器进行响应，从而减少网络延迟和带宽消耗，提高访问速度和稳定性。CDN的缓存可以是静态内容（如图片、CSS、JS等），也可以是动态内容（如视频、音频、游戏等），具体缓存策略可以根据实际情况进行调整。</p>
</blockquote>
<h4 id="那网络直播cdn怎么弄的，直播怎么提前缓存"><a href="#那网络直播cdn怎么弄的，直播怎么提前缓存" class="headerlink" title="那网络直播cdn怎么弄的，直播怎么提前缓存"></a>那网络直播cdn怎么弄的，直播怎么提前缓存</h4><blockquote>
<p>网络直播CDN的实现方式与普通内容CDN有些不同。对于网络直播，CDN需要实时地接收直播源，并将其缓存到全球各地的服务器上。一般来说，网络直播CDN的实现过程如下：</p>
<ol>
<li><p>直播源推送：将直播源推送到CDN提供商的服务器上，这些服务器通常位于主要的网络骨干节点上，具有高带宽和低延迟的特点。</p>
</li>
<li><p>转码和分发：CDN将接收到的直播源进行转码和分发，生成多种不同分辨率和码率的直播流，并将其缓存到全球各地的服务器上。</p>
</li>
<li><p>用户访问：用户通过CDN提供商的域名访问直播流，CDN会自动选择距离用户最近的服务器进行响应，从而提高访问速度和稳定性。</p>
</li>
<li><p>直播结束：直播结束后，CDN会自动清空缓存，释放资源。</p>
</li>
</ol>
<p>需要注意的是，网络直播CDN需要具备高带宽、低延迟、高并发等特点，同时还需要具备实时性和可靠性。针对不同的应用场景，需要选择不同的CDN提供商，并进行合理的配置和调优，以达到最优的效果。</p>
</blockquote>
<h4 id="直播源是什么"><a href="#直播源是什么" class="headerlink" title="直播源是什么"></a>直播源是什么</h4><blockquote>
<p>直播源是指视频直播的源数据，通常是由摄像头、编码器等设备采集、编码和推送到流媒体服务器上的视频数据。直播源包含视频、音频、字幕等多种数据流，可以通过RTMP、RTSP、HLS等协议进行传输。在直播过程中，直播源是不断变化的，可以是单个摄像头的画面，也可以是多个摄像头的画面进行切换、合成等操作后的结果。</p>
</blockquote>
<h4 id="流媒体是什么"><a href="#流媒体是什么" class="headerlink" title="流媒体是什么"></a>流媒体是什么</h4><blockquote>
<p>流媒体（Streaming Media）是一种数据传输方式，可以在数据传输的同时进行实时的解码和播放，无需等待数据完全下载后再进行播放。流媒体通常用于音视频的传输，可以实现音视频的实时播放和交互。</p>
<p>流媒体的传输方式与下载方式有所不同。在下载方式中，用户需要等待数据完全下载后才能进行播放，而流媒体则是将数据分成多个小的数据包进行传输，并实时进行解码和播放。流媒体的传输速度和质量取决于网络带宽和延迟，如果网络带宽太低或延迟太高，可能会导致视频卡顿、声音不同步等问题。</p>
<p>流媒体的应用场景非常广泛，包括在线音乐、视频直播、在线教育、远程会议等等。流媒体技术的发展也在不断提高其传输速度和质量，如HTTP Live Streaming（HLS）、Dynamic Adaptive Streaming over HTTP（DASH）等技术的出现，使得流媒体的应用更加广泛和便捷。</p>
</blockquote>
<h4 id="p2p"><a href="#p2p" class="headerlink" title="p2p"></a>p2p</h4><blockquote>
<p>P2P技术的实现涉及到多种技术细节。以下是其中一些关键技术的介绍：</p>
<ol>
<li><p>节点发现：P2P网络中的节点需要能够发现其他节点，以便建立连&gt;接和进行数据传输。节点发现通常使用两种方法：基于中心化服务器&gt;的发现和分布式哈希表（DHT）发现。前者需要中心化服务器来维护节&gt;点列表，而后者则是通过哈希算法将节点信息存储在网络中，使得节&gt;点可以自行发现其他节点。</p>
</li>
<li><p>文件分割和传输：在P2P网络中，文件通常被分割成小块并分布在&gt;各个节点上。节点之间可以通过点对点连接进行数据传输，从而实现&gt;文件共享。文件分割和传输需要考虑数据完整性、传输速度和负载均&gt;衡等问题。</p>
</li>
<li><p>协议设计：P2P网络需要使用一种协议来管理节点之间的通信和数&gt;据传输。常见的P2P协议包括BitTorrent协议、eDonkey协议和&gt;Gnutella协议等。这些协议通常包括节点之间的握手、数据块请求和&gt;响应、心跳包等功能。</p>
</li>
<li><p>NAT穿透：由于大多数用户都位于NAT（网络地址转换）后面，因&gt;此P2P网络需要能够穿透NAT，使得节点之间可以直接通信。NAT穿透&gt;通常使用STUN（Simple Traversal of UDP through NATs）和&gt;TURN（Traversal Using Relays around NAT）等技术实现。</p>
</li>
<li><p>安全性保护：P2P网络容易受到恶意节点的攻击和破坏，因此需要&gt;一定的安全机制来保护网络和用户的安全。常见的安全机制包括加密&gt;通信、防止DDoS攻击、节点信任度评估等。</p>
</li>
</ol>
<p>以上是P2P技术的一些关键技术细节。不同的P2P应用可能涉及到不同&gt;的技术细节，但是它们都遵循着去中心化、分布式和点对点的基本原&gt;则，实现了高效的数据共享和通信。</p>
</blockquote>
<h4 id="心跳包"><a href="#心跳包" class="headerlink" title="心跳包"></a>心跳包</h4><blockquote>
<p>心跳包是指在计算机网络通信中，为了维持连接状态而定期发送的数据包。它通常由客户端或服务器发送，用于告知对方自己的存在和状态。在P2P网络中，节点之间需要定期发送心跳包来维护连接状态，以确保数据传输的可靠性和稳定性。</p>
<p>心跳包通常包含以下信息：</p>
<ol>
<li><p>发送方的标识符或ID：用于告知接收方发送方的身份信息。</p>
</li>
<li><p>时间戳：用于告知接收方发送方的最新状态，以便接收方根据时间&gt;戳判断发送方是否仍然在线。</p>
</li>
<li><p>其他状态信息：例如发送方的带宽、CPU利用率、内存占用率等信&gt;息。</p>
</li>
</ol>
<p>节点之间通常会约定一个心跳包的发送周期，例如每隔10秒发送一次&gt;心跳包。当接收方收到心跳包时，会根据时间戳判断发送方是否仍然&gt;在线。如果发送方长时间未发送心跳包，则接收方会认为发送方已经&gt;下线，并从节点列表中删除该节点。</p>
<p>心跳包在P2P网络中的作用非常重要，它可以帮助节点维护连接状态，&gt;避免数据传输中断，保证P2P网络的稳定性和可靠性。同时，心跳包也&gt;可以用于节点之间的状态监控和性能优化，例如通过心跳包中的其他&gt;状态信息来调整数据传输策略，提高P2P网络的效率和速度。</p>
</blockquote>
<h4 id="电脑没网卡有ip地址吗"><a href="#电脑没网卡有ip地址吗" class="headerlink" title="电脑没网卡有ip地址吗"></a>电脑没网卡有ip地址吗</h4><blockquote>
<p>没有网卡的电脑没有网络连接，因此无法获得IP地址。IP地址是由网络接口设备（如网卡）分配的，没有网卡就没有网络接口设备来分配IP地址。</p>
</blockquote>
<h4 id="电脑有网卡没有网有ip地址吗，是什么"><a href="#电脑有网卡没有网有ip地址吗，是什么" class="headerlink" title="电脑有网卡没有网有ip地址吗，是什么"></a>电脑有网卡没有网有ip地址吗，是什么</h4><blockquote>
<p>如果电脑有网卡但没有连接到网络，它仍然可以获得一个本地IP地址，称为“本地回环地址”，通常是127.0.0.1。本地回环地址是指电脑上的一个虚拟接口，用于在同一台电脑上进行网络通信。虽然这个地址不是用于连接到互联网的，但它可以用于测试网络应用程序或运行本地服务器。</p>
</blockquote>
<h4 id="电脑有网卡有网有ip地址吗"><a href="#电脑有网卡有网有ip地址吗" class="headerlink" title="电脑有网卡有网有ip地址吗"></a>电脑有网卡有网有ip地址吗</h4><blockquote>
<p>如果电脑有网卡并且已连接到网络，它将获得一个IP地址，该地址用于在网络上唯一标识该电脑。这个IP地址可以是静态的（由管理员手动配置）或动态的（由DHCP服务器自动分配）。如果电脑有多个网卡，则每个网卡都可以获得一个IP地址。</p>
</blockquote>
<h4 id="浏览器有多个标签时请求服务器，服务器怎么知道数据给那一个标签"><a href="#浏览器有多个标签时请求服务器，服务器怎么知道数据给那一个标签" class="headerlink" title="浏览器有多个标签时请求服务器，服务器怎么知道数据给那一个标签"></a>浏览器有多个标签时请求服务器，服务器怎么知道数据给那一个标签</h4><blockquote>
<p>浏览器发送请求时会在请求头中包含一些信息，例如Referer（来源页面）和User-Agent（浏览器类型和版本号）等，可以用这些信息来判断请求的来源。另外，浏览器还会在请求的URL中包含一些参数，例如session ID和token等，可以用这些参数来区分不同的标签页。服务器可以根据这些信息来判断请求的来源，然后返回相应的数据。</p>
</blockquote>
<h4 id="gbn接收方是不是收到分组后就立刻上交应用层然后发送ack"><a href="#gbn接收方是不是收到分组后就立刻上交应用层然后发送ack" class="headerlink" title="gbn接收方是不是收到分组后就立刻上交应用层然后发送ack"></a>gbn接收方是不是收到分组后就立刻上交应用层然后发送ack</h4><blockquote>
<p>GBN协议中接收方并不是在收到分组后立刻将数据上交给应用层，而是必须等到按序接收到数据才能将数据上交给应用层。具体来说，接收方会按照序号依次接收数据包，如果接收到的数据包序号不是期望的序号，接收方会将该数据包丢弃，并等待后续的数据包。当接收方按序收到数据包时，将数据上交给应用层并发送确认消息（ACK），确认消息中包含期望接收的下一个数据包的序号。因此，GBN协议中的接收方只会在按序接收到数据包时才会将数据上交给应用层并发送ACK。</p>
</blockquote>
<h4 id="gbn为什么收到ack后就代表此确认前的分组已经接受了？"><a href="#gbn为什么收到ack后就代表此确认前的分组已经接受了？" class="headerlink" title="gbn为什么收到ack后就代表此确认前的分组已经接受了？"></a>gbn为什么收到ack后就代表此确认前的分组已经接受了？</h4><blockquote>
<p>GBN（Go-Back-N）协议中的累计确认是指接收方在收到数据包后，发送一个包含期望接收的下一个数据包序号的确认消息（ACK）。例如，当接收方成功接收到序号为1、2、3的三个数据包时，它会发送一个ACK序号为4的确认消息，表示期望接收的下一个数据包的序号为4。在此之前，接收方将不会向应用层传递任何数据。<br>GBN协议中的累计确认是一种简单而有效的确认机制，可以减少网络拥塞和重传次数。发送方在收到确认消息后，就知道哪些数据已经成功传输到接收方，从而可以继续发送下一个数据包。同时，如果发送方没有收到确认消息，就会认为数据包丢失，会重新发送之前的数据包，这样就能保证数据的可靠传输。</p>
</blockquote>
<h4 id="gbn假如1234这几个包发送，发送方收到了ack1-ack1-ack1-此时1的定时器还没有超时，他是等待超时后发送234，还是直接发送234"><a href="#gbn假如1234这几个包发送，发送方收到了ack1-ack1-ack1-此时1的定时器还没有超时，他是等待超时后发送234，还是直接发送234" class="headerlink" title="gbn假如1234这几个包发送，发送方收到了ack1,ack1,ack1,此时1的定时器还没有超时，他是等待超时后发送234，还是直接发送234"></a>gbn假如1234这几个包发送，发送方收到了ack1,ack1,ack1,此时1的定时器还没有超时，他是等待超时后发送234，还是直接发送234</h4><blockquote>
<p>非常抱歉，之前的回答有误。在GBN协议中，如果发送方收到多个重复的ACK确认消息，但是对应的数据包还没有超时，那么发送方会继续等待超时后再进行重传。这是因为在GBN协议中，发送方使用定时器来等待ACK确认消息的到达，并在定时器超时后进行重传，而不是根据收到的ACK确认消息来进行重传。</p>
<p>因此，在上述情况下，如果发送方收到了多个重复的ACK1确认消息，但是数据包1还没有超时，那么发送方会继续等待定时器超时后再进行重传。当定时器超时后，发送方会重新发送数据包2、3、4，从而保证数据的可靠传输。</p>
<p>需要注意的是，如果发送方收到的重复ACK确认消息数量超过了一个阈值，通常表示网络中存在丢包或其他问题。此时，发送方可能会启动拥塞控制机制，例如减少窗口大小或进行慢启动等，以避免网络拥塞。</p>
</blockquote>
<h4 id="什么是带外通信和带内通信"><a href="#什么是带外通信和带内通信" class="headerlink" title="什么是带外通信和带内通信"></a>什么是带外通信和带内通信</h4><blockquote>
<p>带外通信（out-of-band communication）指的是在网络传输中，使用不同于正常数据传输的通道进行通信。这种通信方式通常用于控制和管理网络设备，例如发送一些命令或警告信息。带外通信能够在网络故障或攻击时保持可靠性和安全性。</p>
<p>带内通信（in-band communication）指的是在网络传输中，使用正常的数据传输通道进行通信。这种通信方式是网络中最常见的通信方式，例如发送电子邮件、浏览网页等。带内通信的缺点是在网络故障或攻击时容易受到影响，可能会导致数据传输中断或延迟。</p>
</blockquote>
<h4 id="tcp拥塞控制为什么把超时导致的丢包和3次ack的丢包分开"><a href="#tcp拥塞控制为什么把超时导致的丢包和3次ack的丢包分开" class="headerlink" title="tcp拥塞控制为什么把超时导致的丢包和3次ack的丢包分开"></a>tcp拥塞控制为什么把超时导致的丢包和3次ack的丢包分开</h4><blockquote>
<p>TCP拥塞控制把超时导致的丢包和3次ACK的丢包分开是因为它们所代表的情况不同，需要采取不同的措施。</p>
<p>超时导致的丢包通常意味着网络出现了较严重的拥塞，&gt;需要采取较为激进的措施来缓解拥塞，例如减小拥塞窗&gt;口，降低发送速率等。</p>
<p>而3次ACK的丢包通常意味着网络出现了较轻微的拥塞，&gt;可以通过快速重传和快速恢复等措施来缓解拥塞，而不&gt;必采取过于激进的措施。</p>
<p>因此，将超时导致的丢包和3次ACK的丢包分开处理可以&gt;更加精细地控制网络拥塞，提高TCP性能和可靠性。</p>
</blockquote>
<h4 id="为什么UDP是使用二元组（目标IP，目标Port）来标识套接字？"><a href="#为什么UDP是使用二元组（目标IP，目标Port）来标识套接字？" class="headerlink" title="为什么UDP是使用二元组（目标IP，目标Port）来标识套接字？"></a>为什么UDP是使用二元组（目标IP，目标Port）来标识套接字？</h4><blockquote>
<p>首先udp会由操作系统给他附上源地址和源端口。也就是说不管是udp还是tcp其实其报文段中都会有源ip地址和源端口，下面我们考虑源地址和源端口把他放在tcp套接字的作用是什么？有两个作用，第一很明显，用于作为回来的时候传输的地址。还有个作用（能回答你的疑惑）那就是用于标识目的套接字，在udp中一个udp套接字是由一个二元祖目的ip地址和目的端口全面标识的，也就是说两个源ip或者源端口不同的udp套接字是通过相同的目的套接字定位到相同的进程。但是如果你让tcp变成四元祖那上述情况就会被定位到不同目的套接字，但这是udp的一个特性，我们显然不能这样改变。</p>
</blockquote>
<h4 id="udp中只要有相同目的地址和端口的数据报都经过同一个socket，应用层怎么分辨他们呢"><a href="#udp中只要有相同目的地址和端口的数据报都经过同一个socket，应用层怎么分辨他们呢" class="headerlink" title="udp中只要有相同目的地址和端口的数据报都经过同一个socket，应用层怎么分辨他们呢?"></a>udp中只要有相同目的地址和端口的数据报都经过同一个socket，应用层怎么分辨他们呢?</h4><blockquote>
<p>UDP协议中没有提供对数据报的标识或者序号，因此在应用层无法直接分辨相同目的地址和端口的数据报。一般情况下，应用层通过在数据报中添加一些特定的标识信息或者数据头来进行区分。例如，DNS协议使用查询ID来标识不同的查询请求和响应，TFTP协议使用操作码来标识不同的操作请求和响应等。在接收到数据报后，应用层根据这些标识信息或者数据头来进行处理和解析。</p>
</blockquote>
<h4 id="tcp首部只有端口号没有ip地址，那么网络层怎么知道目的ip地址的呢？"><a href="#tcp首部只有端口号没有ip地址，那么网络层怎么知道目的ip地址的呢？" class="headerlink" title="tcp首部只有端口号没有ip地址，那么网络层怎么知道目的ip地址的呢？"></a>tcp首部只有端口号没有ip地址，那么网络层怎么知道目的ip地址的呢？</h4><blockquote>
<p>http 拿到 dns 返回的 ip 之后，会通过 tcp 建立一个长连接，建立连接需要 ip 和 port，port 放在 tcp 的 header 中，ip 则是放在下一层网络层 IP Layer 的 header 中。 传输层不负责寻址，所以和 ip 地址无关，自然不需要再 header 中存放 ip 信息。</p>
</blockquote>
<h4 id="什么是流量控制？流量控制的目的？"><a href="#什么是流量控制？流量控制的目的？" class="headerlink" title="什么是流量控制？流量控制的目的？"></a>什么是流量控制？流量控制的目的？</h4><blockquote>
<p>如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。</p>
</blockquote>
<h4 id="如何实现流量控制？"><a href="#如何实现流量控制？" class="headerlink" title="如何实现流量控制？"></a>如何实现流量控制？</h4><blockquote>
<p>由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。</p>
</blockquote>
<h4 id="流量控制引发的死锁？怎么避免死锁的发生？"><a href="#流量控制引发的死锁？怎么避免死锁的发生？" class="headerlink" title="流量控制引发的死锁？怎么避免死锁的发生？"></a>流量控制引发的死锁？怎么避免死锁的发生？</h4><blockquote>
<p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。<br>为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p>
</blockquote>
<h4 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h4><blockquote>
<p>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。</p>
</blockquote>
<blockquote>
<p>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。</p>
</blockquote>
<h4 id="同一台机器上使用同一个应用，该应用使用2000端口，现在该应用有两个进程发给同1服务器，这两个应用的套接字一样吗"><a href="#同一台机器上使用同一个应用，该应用使用2000端口，现在该应用有两个进程发给同1服务器，这两个应用的套接字一样吗" class="headerlink" title="同一台机器上使用同一个应用，该应用使用2000端口，现在该应用有两个进程发给同1服务器，这两个应用的套接字一样吗"></a>同一台机器上使用同一个应用，该应用使用2000端口，现在该应用有两个进程发给同1服务器，这两个应用的套接字一样吗</h4><blockquote>
<p>不一样，每个进程都会有自己的套接字和端口号，即使是同一个应用程序。因此，这两个进程使用的套接字是不同的。</p>
</blockquote>
<h4 id="为什么不同，他们源ip，源端口，目的ip端口都一样"><a href="#为什么不同，他们源ip，源端口，目的ip端口都一样" class="headerlink" title="为什么不同，他们源ip，源端口，目的ip端口都一样"></a>为什么不同，他们源ip，源端口，目的ip端口都一样</h4><blockquote>
<p>每个进程在运行时都会分配自己的套接字和端口号，即使是同一个应用程序，不同的进程也会使用不同的套接字。这是因为套接字是一个抽象的概念，它包括了IP地址、端口号和协议等信息，而每个进程都有自己的标识符，所以它们的套接字也是不同的。虽然源IP、源端口和目的IP、目的端口都一样，但是套接字还包括了进程标识符等其他信息，因此这两个进程使用的套接字是不同的。</p>
</blockquote>
<h4 id="tcp中，发送方发送了1，2，3，4这4个报文，2的报文丢失了，3，4发送ack2，2，发送方收到ack2，ack2后发送2的报文段，接收方收到2后，发送多少ack"><a href="#tcp中，发送方发送了1，2，3，4这4个报文，2的报文丢失了，3，4发送ack2，2，发送方收到ack2，ack2后发送2的报文段，接收方收到2后，发送多少ack" class="headerlink" title="tcp中，发送方发送了1，2，3，4这4个报文，2的报文丢失了，3，4发送ack2，2，发送方收到ack2，ack2后发送2的报文段，接收方收到2后，发送多少ack?"></a>tcp中，发送方发送了1，2，3，4这4个报文，2的报文丢失了，3，4发送ack2，2，发送方收到ack2，ack2后发送2的报文段，接收方收到2后，发送多少ack?</h4><blockquote>
<p>我认为发送ack4，表示4之前的都到了</p>
</blockquote>
<h4 id="tcp四次挥手-最后一次ack如果没有收到"><a href="#tcp四次挥手-最后一次ack如果没有收到" class="headerlink" title="tcp四次挥手 最后一次ack如果没有收到"></a>tcp四次挥手 最后一次ack如果没有收到</h4><blockquote>
<p>当第四步的A发送的确认报文，B收到时，A会等待2MSL的时间后，连接彻底关闭。(因为B收到了，所以2MSL时间内B不会重发第三步的释放报文)</p>
</blockquote>
<blockquote>
<p>当第四步的A发送的确认报文，B没有收到时，B会继续发送第三步的释放报文，A收到后会继续发送第四步的确认报文（此时会重新启动2MSL计时器，重新等待2MSL时间），若在接下来的2MSL的时间内未收到B发送的第三步的释放报文，则意味着B已经收到了A的ack确认报文，连接彻底关闭</p>
</blockquote>
<blockquote>
<p>MSL 是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
</blockquote>
<h4 id="网络中心路由器就可以做物理层、数据链路层、网络层的工作吗"><a href="#网络中心路由器就可以做物理层、数据链路层、网络层的工作吗" class="headerlink" title="网络中心路由器就可以做物理层、数据链路层、网络层的工作吗"></a>网络中心路由器就可以做物理层、数据链路层、网络层的工作吗</h4><blockquote>
<p>网络中心路由器可以做物理层、数据链路层、网络层的工作，但它也可以做更高层次的工作，如传输层、应用层等。它的主要任务是将来自不同网络的数据包转发到正确的目的地，实现网络的互联互通。在这个过程中，它需要对不同层次的协议进行解析和处理，以确保数据能够正确地传输和接收。因此，网络中心路由器是网络中非常重要的设备。</p>
</blockquote>
<h4 id="网络中心的交换机是做什么的，既然路由器都可以做"><a href="#网络中心的交换机是做什么的，既然路由器都可以做" class="headerlink" title="网络中心的交换机是做什么的，既然路由器都可以做"></a>网络中心的交换机是做什么的，既然路由器都可以做</h4><blockquote>
<p>网络中心的交换机和路由器虽然都是网络设备，但是它们的功能不同，有不同的应用场景。</p>
<p>交换机是一种数据链路层设备，主要用于在局域网中传输数据，它可以在&gt;不同设备之间进行数据的交换和转发，从而实现局域网内部的互联互通。&gt;交换机通常使用MAC地址进行寻址和转发，具有快速转发和低延迟的特点，&gt;能够提供高效的局域网数据传输服务。交换机的主要作用是在局域网内部&gt;进行数据包的转发和过滤，减少网络拥塞和冲突。</p>
<p>而路由器则是一种网络层设备，主要用于在不同网络之间进行数据的传输&gt;和转发，它能够识别不同网络之间的IP地址，并根据路由表将数据包转发&gt;到正确的目的地。路由器能够实现不同网络之间的互联互通，是实现互联&gt;网的重要设备之一。路由器的主要作用是在不同网络之间进行数据包的转&gt;发和路由选择，保证数据能够正确地传输和接收。</p>
<p>因此，交换机和路由器虽然都是网络设备，但是它们的功能和应用场景不同，各自有着自己的优势和特点。在网络中心中，交换机和路由器通常都会同时使用，以提供高效、可靠的数据传输服务。</p>
</blockquote>
<h4 id="我们局域网的路由器可以做物理层、数据链路层、网络层的工作吗"><a href="#我们局域网的路由器可以做物理层、数据链路层、网络层的工作吗" class="headerlink" title="我们局域网的路由器可以做物理层、数据链路层、网络层的工作吗"></a>我们局域网的路由器可以做物理层、数据链路层、网络层的工作吗</h4><blockquote>
<p>通常情况下，局域网的路由器可以同时做物理层、数据链路层和网络层的工作。</p>
<p>在物理层方面，路由器需要通过物理接口与局域网内的设备进行连接，以&gt;便进行数据的传输。路由器通常会提供多个物理接口，如以太网口、无线&gt;接口等，以适应不同的接入方式。</p>
<p>在数据链路层方面，路由器需要解析数据帧，进行帧头和帧尾的处理，并&gt;对MAC地址进行寻址和转发，以实现局域网内部的数据传输。</p>
<p>在网络层方面，路由器需要解析IP数据包，并根据路由表将数据包转发到&gt;正确的目的地。路由器还需要支持不同的网络协议，如TCP/IP、IPX/SPX&gt;等，以适应不同的网络环境。</p>
<p>总之，局域网的路由器需要支持物理层、数据链路层和网络层的相关功能，以实现局域网内部的数据传输和互联互通。</p>
</blockquote>
<h4 id="那么还要局域网的其他设备干什么"><a href="#那么还要局域网的其他设备干什么" class="headerlink" title="那么还要局域网的其他设备干什么"></a>那么还要局域网的其他设备干什么</h4><blockquote>
<p>除了路由器，局域网中还需要其他设备来完成不同的任务。以下是一些常见的局域网设备：</p>
<ol>
<li><p>交换机：交换机是局域网中的核心设备，主要用于在局域网内部进行数&gt;据包的转发和过滤，以实现设备之间的互联互通。交换机通常使用MAC地址&gt;进行寻址和转发，具有快速转发和低延迟的特点，能够提供高效的局域网&gt;数据传输服务。</p>
</li>
<li><p>防火墙：防火墙是一种网络安全设备，用于保护局域网内的设备免受网&gt;络攻击和恶意软件的侵害。防火墙可以对网络流量进行过滤和检测，屏蔽&gt;不安全的流量，保护局域网内部的数据安全。</p>
</li>
<li><p>无线接入点：无线接入点是一种无线局域网设备，用于提供无线接入服&gt;务。无线接入点可以将有线网络转换为无线网络，让无线设备可以接入到&gt;局域网中。无线接入点通常支持不同的无线协议和加密方式，以提供安全&gt;和高速的无线接入服务。</p>
</li>
<li><p>打印机和其他外围设备：局域网中通常还需要打印机、扫描仪、存储设&gt;备等外围设备，以方便用户进行打印、扫描、存储等操作。这些设备需要&gt;支持局域网协议和接口，以便与局域网中的其他设备进行通信和互动。</p>
</li>
</ol>
<p>总之，局域网中需要不同类型的设备来完成不同的任务，这些设备通常需要相互配合，以实现局域网的高效运行和数据传输。</p>
</blockquote>
<h4 id="交换机可以做物理层的工作还要这些设备干什么"><a href="#交换机可以做物理层的工作还要这些设备干什么" class="headerlink" title="交换机可以做物理层的工作还要这些设备干什么"></a>交换机可以做物理层的工作还要这些设备干什么</h4><blockquote>
<p>虽然交换机可以在一定程度上承担物理层的功能，但是在实际的网络中，还需要其他物理层设备来配合使用，以实现更加高效、稳定和可靠的数据传输。</p>
<ol>
<li><p>中继器：中继器是一种物理层设备，可以放大信号和延长信号传输距&gt;离。在局域网中，如果数据传输距离超过了交换机的传输范围，就需要使&gt;用中继器来扩展局域网的范围，从而实现更广泛的设备互联互通。</p>
</li>
<li><p>光纤收发器：在需要使用光纤进行数据传输的情况下，需要使用光纤收&gt;发器将数字信号转换为光信号，并在光纤中进行传输。交换机通常支持光&gt;纤接口，但是光纤收发器可以提供更高效、稳定和可靠的光纤传输服务。</p>
</li>
<li><p>网线：网线是计算机和网络设备之间连接的物理媒介，不同类型的网线&gt;可以支持不同的传输速率和距离。在局域网中，使用不同类型的网线可以&gt;适应不同的传输需求，从而实现更高效、稳定和可靠的数据传输服务。</p>
</li>
</ol>
<p>综上所述，虽然交换机可以在一定程度上承担物理层的功能，但是在实际的网络中，还需要其他物理层设备来配合使用，以实现更加高效、稳定和可靠的数据传输。</p>
</blockquote>
<h4 id="是不是高层次的设备都可以做低层次设备的工作"><a href="#是不是高层次的设备都可以做低层次设备的工作" class="headerlink" title="是不是高层次的设备都可以做低层次设备的工作"></a>是不是高层次的设备都可以做低层次设备的工作</h4><blockquote>
<p>是的，高层次的设备通常都可以完成低层次设备的工作，但是低层次设备不一定能够完成高层次设备的工作。</p>
<p>在OSI模型中，每一层都有自己的功能和任务，高层次的设备需要支持更多&gt;的协议和功能，以实现更复杂的数据处理和传输。而低层次的设备则主要&gt;负责数据的物理传输和转换，通常只支持少量的协议和功能。</p>
<p>因此，高层次的设备通常都可以完成低层次设备的工作，如路由器可以完&gt;成交换机的工作，服务器可以完成路由器的工作。但是低层次设备并不一&gt;定能够完成高层次设备的工作，如交换机不能完成路由器的工作。</p>
<p>总之，高层次的设备通常都可以完成低层次设备的工作，这也是网络设备的发展趋势之一，即设备的功能越来越集成和综合。但是不同设备之间的功能和任务也有着明显的区别，需要根据具体的应用场景进行选择和配置。</p>
</blockquote>
<h4 id="中国和美国隔着太平洋，没有光纤连接，那么怎么通信呢"><a href="#中国和美国隔着太平洋，没有光纤连接，那么怎么通信呢" class="headerlink" title="中国和美国隔着太平洋，没有光纤连接，那么怎么通信呢"></a>中国和美国隔着太平洋，没有光纤连接，那么怎么通信呢</h4><blockquote>
<p>中国和美国之间的通信主要依靠卫星通信和海底电缆两种方式。</p>
<ol>
<li><p>卫星通信：卫星通信是利用人造卫星进行通信的一种方式。中国和美国&gt;都有自己的卫星通信系统，可以通过卫星进行通信。卫星通信的优点是覆&gt;盖范围广，可以实现远距离通信，但是信号传输时延较大，容易受到天气&gt;等因素的影响。</p>
</li>
<li><p>海底电缆：海底电缆是一种在海底铺设的光纤电缆，可以实现跨越大洋&gt;的通信。中国和美国之间有多条海底电缆连接，如亚太2号、亚太3号、太&gt;平洋光缆等，可以提供高速、稳定和可靠的通信服务。海底电缆的优点是&gt;传输速度快、带宽大、时延低，适合大量数据传输和高质量的视频通信等&gt;应用。</p>
</li>
</ol>
<p>综上所述，中国和美国之间的通信主要依靠卫星通信和海底电缆两种方式。这些通信方式的选择和配置需要考虑到各种因素，如通信距离、传输速度、时延、可靠性等，以提供高效、稳定和可靠的通信服务。</p>
</blockquote>
<h4 id="如果没有这两种东西是不是就没办法通信了"><a href="#如果没有这两种东西是不是就没办法通信了" class="headerlink" title="如果没有这两种东西是不是就没办法通信了"></a>如果没有这两种东西是不是就没办法通信了</h4><blockquote>
<p>如果没有卫星通信和海底电缆，中国和美国之间的通信就会受到很大的&gt;限制，但并不是完全没有办法通信。</p>
<p>在没有卫星通信和海底电缆的情况下，可以使用其他的通信方式，如：</p>
<p>短波无线电：短波无线电可以实现远距离通信，但是信号容易受到干扰和&gt;衰减，通信质量不稳定。</p>
<p>气球通信：气球通信是一种通过高空气球搭载通信设备进行通信的方式，可以实现远距离通信，但是成本较高，通信质量不稳定。</p>
</blockquote>
<h4 id="网络重定向是怎么回事"><a href="#网络重定向是怎么回事" class="headerlink" title="网络重定向是怎么回事"></a>网络重定向是怎么回事</h4><blockquote>
<p>网络重定向是将一个网址或者一个网站的访问请求重定向到另一个网址或者网站的过程。它可以通过服务器端或者客户端进行实现。</p>
<p>服务器端的重定向是指在服务器端进行配置，当用户访问某个网址或者网&gt;站时，服务器会将请求重定向到另一个网址或者网站。这种重定向常用于&gt;网站迁移、网址更改等场景。</p>
<p>客户端的重定向是指当用户访问某个网址或者网站时，服务器会返回一个&gt;重定向指令，让客户端自动跳转到另一个网址或者网站。这种重定向常用&gt;于网站跳转、页面跳转等场景。</p>
<p>重定向可以帮助网站提高用户体验、解决网站迁移等问题，但也可能会影响网站的SEO排名和用户隐私。因此，在进行重定向操作时，需要慎重考虑。</p>
</blockquote>
<h4 id="as之间需要运行相同的域间路由选择协议，那么全世界不就只能运行一种协议了吗，不然怎么交互"><a href="#as之间需要运行相同的域间路由选择协议，那么全世界不就只能运行一种协议了吗，不然怎么交互" class="headerlink" title="as之间需要运行相同的域间路由选择协议，那么全世界不就只能运行一种协议了吗，不然怎么交互"></a>as之间需要运行相同的域间路由选择协议，那么全世界不就只能运行一种协议了吗，不然怎么交互</h4><blockquote>
<p>实际上，不同的自治域可以选择不同的域间路由选择协议，只要它们之间有一种方式来交换路由信息。这种方式可以是通过互联网交换点（IXP）或者运营商之间的互联互通（Peering）来实现。通过这些方式，不同的自治域可以交换其选择的域间路由选择协议所需的路由信息，并实现跨自治域的通信。因此，全世界可以同时运行多种不同的域间路由选择协议。</p>
</blockquote>
<h4 id="正常来说mac地址不应该是下一跳的mac地址吗"><a href="#正常来说mac地址不应该是下一跳的mac地址吗" class="headerlink" title="正常来说mac地址不应该是下一跳的mac地址吗"></a>正常来说mac地址不应该是下一跳的mac地址吗</h4><blockquote>
<p>在网络通信中，源MAC地址是发送方设备的MAC地址，目标MAC地址是接收方设备的MAC地址。当数据包经过多个路由器转发时，每个路由器都会将数据包的目标MAC地址设置为下一个路由器的MAC地址，以确保数据包能够到达下一个路由器。因此，在路由器之间传输的数据包的目标MAC地址通常是下一个路由器的MAC地址，而不是最终目的地设备的MAC地址。最终目的地设备的MAC地址只有在数据包到达最终目的地时才会被使用。</p>
</blockquote>
<h4 id="下一跳路由器通过查看ip头部来查arp表确定下一跳mac？"><a href="#下一跳路由器通过查看ip头部来查arp表确定下一跳mac？" class="headerlink" title="下一跳路由器通过查看ip头部来查arp表确定下一跳mac？"></a>下一跳路由器通过查看ip头部来查arp表确定下一跳mac？</h4><blockquote>
<p>是的，下一跳路由器通常通过查看数据包IP头部中的目标IP地址来确定下一跳的MAC地址。在进行路由转发时，路由器通常会将数据包的目标IP地址与其路由表进行匹配，以确定数据包的下一跳。下一跳路由器的MAC地址通常会存储在路由器的ARP缓存中，因为路由器需要将数据包发送到下一跳路由器的MAC地址。因此，当路由器需要将数据包转发到下一跳路由器时，它会在ARP缓存中查找下一跳路由器的MAC地址，并将其添加到数据包的目标MAC地址中，以便成功将数据包发送到下一跳路由器。</p>
</blockquote>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>linux小题</title>
    <url>/2023/05/18/linux%E5%B0%8F%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>相关文章：</p>
<blockquote>
<p><a href="https://sunnyli1024.github.io/2023/05/18/linux%E5%B0%8F%E9%A2%98/">linux小题</a><br><a href="https://sunnyli1024.github.io/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/">客制化linux</a><br><a href="https://sunnyli1024.github.io/2023/05/17/linux-shell%E7%BC%96%E7%A8%8B/">linux_shell编程</a><br><a href="https://sunnyli1024.github.io/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">linux基础</a></p>
</blockquote>
<h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>将t.txt打印出来通过管道往后传，cut以/为间隔符取第三段，进行排序（uniq只能统计连续出现的次数，所以要把相同的先合在一起），通过uniq -c统计唯一值并在首显示出现次数，最后通过sort -n按照数值排序-r顺序取反</p>
<p><img src="/2023/05/18/linux%E5%B0%8F%E9%A2%98/1.png" alt="1"></p>
<blockquote>
<p><strong>cat t.txt：将文件t.txt的内容输出到终端。<br>cut -d ‘/‘ -f 3：以“/”为分隔符，取每行的第三个字段。<br>sort：将每行的内容进行排序。<br>uniq -c：统计每个不同的字段出现的次数，并输出结果。<br>sort -nr：按照出现次数进行倒序排序。</strong></p>
</blockquote>
<blockquote>
<p><strong>sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;]</strong><br>-b 忽略每行前面开始出的空格字符。<br>-c 检查文件是否已经按照顺序排序。<br>-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。<br>-f 排序时，将小写字母视为大写字母。<br>-m 将几个排序好的文件进行合并。<br>-M 将前面3个字母依照月份的缩写进行排序。<br>-n 依照数值的大小排序。<br>-u 意味着是唯一的(unique)，输出的结果是去完重了的。<br>-o&lt;输出文件&gt; 将排序后的结果存入指定的文件。<br>-r 以相反的顺序来排序。<br>-t&lt;分隔字符&gt; 指定排序时所用的栏位分隔字符。</p>
</blockquote>
<blockquote>
<p><strong>cut  [-bn] [file]<br>cut [-c] [file]<br>cut [-df] [file]</strong><br>-d ：自定义分隔符，默认为制表符。</p>
</blockquote>
<blockquote>
<p><strong>uniq [-cdu]</strong><br>c或–count 在每列旁边显示该行重复出现的次数。<br>-d或–repeated 仅显示重复出现的行列。<br>-u或–unique 仅显示出一次的行列。</p>
</blockquote>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><blockquote>
<p><strong>netstat -an |grep ESTAB |awk -F “ “ ‘{print $5}’ |cut -d “:” -f 1 |sort |uniq -c</strong></p>
</blockquote>
<blockquote>
<p>netstat -an：列出所有网络连接的状态。<br>grep ESTAB：过滤出状态为ESTABLISHED（已建立）的连接。<br>awk -F “ “ ‘{print $5}’：以空格为分隔符，取出每行的第五个字段，即连接的本地地址和端口号和远程地址和端口号。<br>cut -d “:” -f 1：以冒号为分隔符，取出每行的第一部分，即本地地址。<br>sort：将每行的内容进行排序。<br>uniq -c：统计每个不同的本地地址出现的次数，并输出结果。</p>
</blockquote>
<p><img src="/2023/05/18/linux%E5%B0%8F%E9%A2%98/2.png" alt="2"><br><img src="/2023/05/18/linux%E5%B0%8F%E9%A2%98/2.1.png" alt="2"><br>netstat命令用于显示网络连接、路由表和网络接口等相关的信息，包括网络连接的状态、本地和远程IP地址、端口号等。它可以帮助用户识别网络连接问题和网络瓶颈。</p>
<p>ps命令用于显示当前正在运行的进程的信息，包括进程的PID、CPU和内存使用情况、运行时间等。它可以帮助用户了解系统中正在运行的进程，以便识别和解决系统性能问题。</p>
<p>Netstat -a 显示全部 -n 显示数字地址<br>Awk作用同cut -F选择分隔符  ‘{print $n}’ 打印第n段<br>注意：awk支持空格，cut不支持<br>关于awk分段 用分隔符分开后，$0代表本身，$1代表分开的第一段，如果没分，$0$1均可以代表自身</p>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p><img src="/2023/05/18/linux%E5%B0%8F%E9%A2%98/4.png" alt="4"></p>
<h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p><img src="/2023/05/18/linux%E5%B0%8F%E9%A2%98/5.png" alt="4"></p>
<h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p><img src="/2023/05/18/linux%E5%B0%8F%E9%A2%98/6.png" alt="6"></p>
<h4 id="7-linux权限划分时应注意"><a href="#7-linux权限划分时应注意" class="headerlink" title="7 linux权限划分时应注意"></a>7 linux权限划分时应注意</h4><p><img src="/2023/05/18/linux%E5%B0%8F%E9%A2%98/7.1.png" alt="7"><br><img src="/2023/05/18/linux%E5%B0%8F%E9%A2%98/7.png" alt="7"><br><strong>文件：r读文件 w修改文件 x执行权限<br>目录：r读目录 w删除、添加、修改（不是内容，是改名等表面操作）文件 x进入目录</strong><br><img src="/2023/05/18/linux%E5%B0%8F%E9%A2%98/7.2.png" alt="7"></p>
<h4 id="8-开机过程"><a href="#8-开机过程" class="headerlink" title="8 开机过程"></a>8 开机过程</h4><p><img src="/2023/05/18/linux%E5%B0%8F%E9%A2%98/8.png" alt="8"></p>
<h4 id="9查看io占用"><a href="#9查看io占用" class="headerlink" title="9查看io占用"></a>9查看io占用</h4><blockquote>
<p><strong>iotop</strong><br>-o：只显示有io操作的进程<br>-b：批量显示，无交互，主要用作记录到文件。<br>-n NUM：显示NUM次，主要用于非交互式模式。<br>-d SEC：间隔SEC秒显示一次。<br>-p PID：监控的进程pid。接进程号，监视指定进程，只会输出该进程的统计信息。<br>-u USER：监控的进程用户。<br>-k 使用千字节而不是人类友好单位</p>
</blockquote>
<h4 id="10-求和"><a href="#10-求和" class="headerlink" title="10 求和"></a>10 求和</h4><p><img src="/2023/05/18/linux%E5%B0%8F%E9%A2%98/10.png" alt="10"></p>
<p><img src="/2023/05/18/linux%E5%B0%8F%E9%A2%98/11.png" alt="11"></p>
<p>关于awk分段 用分隔符分开后，$0代表本身，$1代表分开的第一段，如果没分，$0$1均可以代表自身</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p><img src="/2023/05/18/linux%E5%B0%8F%E9%A2%98/13.png" alt="13"></p>
<h4 id="Linux面试基本100道题"><a href="#Linux面试基本100道题" class="headerlink" title="Linux面试基本100道题"></a>Linux面试基本100道题</h4><ol>
<li><p>   cron 后台常驻程序 (daemon) 用于：<br>A. 负责文件在网络中的共享<br>B. 管理打印子系统<br>C. 跟踪管理系统信息和错误<br>D. 管理系统日常任务的调度<br>答案：D</p>
</li>
<li><p>在大多数Linux发行版本中，以下哪个属于块设备 (block devices) ？<br>A. 串行口<br>B. 硬盘<br>C. 虚拟终端<br>D. 打印机<br>答案：B</p>
</li>
<li><p>下面哪个Linux命令可以一次显示一页内容？<br>A. pause<br>B. cat<br>C. more<br>D. grep<br>答案：C</p>
</li>
<li><p>怎样了解您在当前目录下还有多大空间？<br>A. Use df<br>B. Use du /<br>C. Use du .<br>D. Use df .<br>答案：C</p>
</li>
<li><p>怎样更改一个文件的权限设置？<br>A. attrib<br>B. chmod<br>C. change<br>D. file<br>答案：B</p>
</li>
<li><p>假如您需要找出 /etc/my.conf 文件属于哪个包 (package) ，您可以执行：<br>A. rpm -q /etc/my.conf<br>B. rpm -requires /etc/my.conf<br>C. rpm -qf /etc/my.conf<br>D. rpm -q | grep /etc/my.conf<br>答案：C</p>
</li>
<li><p>假如当前系统是在 level 3 运行，怎样不重启系统就可转换到 level 5 运行？<br>A. Set level = 5<br>B. telinit 5<br>C. run 5<br>D. ALT-F7-5<br>答案：B</p>
</li>
<li><p>那个命令用于改变 IDE 硬盘的设置？<br>A. hdparam<br>B. ideconfig<br>C. hdparm<br>D. hddparm<br>答案：C</p>
</li>
<li><p>下面哪个命令可以列出定义在以后特定时间运行一次的所有任务？<br>A. atq<br>B. cron<br>C. batch<br>D. at<br>答案：A</p>
</li>
</ol>
<p>10.下面命令的作用是：set PS1=”[\u\w\t]$“ ; export PS1<br>A. 改变错误信息提示<br>B. 改变命令提示符<br>C. 改变一些终端参数<br>D. 改变辅助命令提示符<br>答案：B</p>
<p>11.作为一个管理员，你希望在每一个新用户的目录下放一个文件 .bashrc ，那么你应该在哪个目录下放这个文件，以便于新用户创建主目录时自动将这个文件复制到自己的目录下。<br>A. /etc/skel/<br>B. /etc/default/<br>C. /etc/defaults/<br>D. /etc/profile.d/<br>答案：A</p>
<p>12.在bash中，export命令的作用是：<br>A. 在子shell中运行命令<br>B. 使在子shell中可以使用命令历史记录<br>C. 为其它应用程序设置环境变量<br>D. 提供NFS分区给网络中的其它系统使用<br>答案：C</p>
<p>13.在使用了shadow口令的系统中，/etc/passwd和/etc/shadow两个文件的权限正确的是：<br>A. -rw-r—– , -r——–<br>B. -rw-r–r– , -r–r–r–<br>C. -rw-r–r– , -r——–<br>D. -rw-r–rw- , -r—–r–<br>答案：C</p>
<p>14．下面哪个参数可以删除一个用户并同时删除用户的主目录？<br>A. rmuser -r<br>B. deluser -r<br>C. userdel -r<br>D. usermgr -r<br>答案：C</p>
<p>15．有一个备份程序mybackup，需要在周一至周五下午1点和晚上8点各运行一次，下面哪条crontab的项可以完成这项工作？<br>A. 0 13,20 * * 1,5 mybackup<br>B. 0 13,20 * * 1,2,3,4,5 mybackup<br>C. * 13,20 * * 1,2,3,4,5 mybackup<br>D. 0 13,20 1,5 * * mybackup<br>答案：B</p>
<p>16．如何从当前系统中卸载一个已装载的文件系统<br>A. umount<br>B. dismount<br>C. mount -u<br>D. 从 /etc/fstab 中删除这个文件系统项<br>答案：A</p>
<p>17．如果你的umask设置为022，缺省的你创建的文件的权限为：<br>A. —-w–w-<br>B. -w–w—-<br>C. r-xr-x—<br>D. rw-r–r–<br>答案：D<br>umask是一种权限掩码，用于限制新创建的文件和目录的默认权限。它是一个三位八进制数字，表示要从新文件或目录的默认权限中去除的权限位。例如，如果umask设置为022，则新创建的文件将被授予644的权限（即所有者具有读写权限，其他用户只有读权限），新创建的目录将被授予755的权限（即所有用户都有读取和执行权限，但只有所有者可以写入目录）。<br>例如，要将umask设置为022，可以执行以下命令：<br>umask 022</p>
<p>18．在一条命令中如何查找一个二进制命令 Xconfigurator 的路径？<br>A. apropos Xconfigurator<br>B. find Xconfigurator<br>C. where Xconfigurator<br>D. which Xconfigurator<br>答案：D</p>
<p>19．哪一条命令用来装载所有在 /etc/fstab 中定义的文件系统？<br>A. amount<br>B. mount -a<br>C. fmount<br>D. mount -f<br>答案：B</p>
<p>20．运行一个脚本，用户不需要什么样的权限？<br>A. read<br>B. write<br>C. execute<br>D. browse on the directory<br>答案：B</p>
<p>21．在Linux中，如何标识接在IDE0上的slave硬盘的第2个扩展分区？<br>A. /dev/hdb2<br>B. /dev/hd1b2<br>C. /dev/hdb6<br>D. /dev/hd1b6<br>答案：C</p>
<p>22．在应用程序起动时，如何设置进程的优先级？<br>A. priority<br>B. nice<br>C. renice<br>D. setpri<br>答案：B<br>在Linux系统中，可以使用nice和renice命令来设置进程的优先级。<br>nice命令<br>nice命令用于启动一个新的进程，并将其优先级降低（或提高）指定的优先级值。nice命令的语法如下：<br>nice [-n increment] command<br>其中，increment表示要增加（或减少）的优先级值。默认情况下，increment为10，表示将进程的优先级降低10个值。例如，要将进程的优先级降低为10，可以执行以下命令：<br>nice -n 10 command<br>renice命令<br>renice命令用于修改已经运行的进程的优先级。renice命令的语法如下：<br>renice [-n increment] pid<br>其中，pid表示要修改优先级的进程ID。例如，要将进程ID为1234的进程的优先级降低为10，可以执行以下命令：<br>renice -n 10 1234<br>注意，只有root用户才能将进程的优先级增加（即将increment值设为负数）。</p>
<p>23．在 bash 中, 在一条命令后加入”1&gt;&amp;2” 意味着：<br>A. 标准错误输出重定向到标准输入<br>B. 标准输入重定向到标准错误输出<br>C. 标准输出重定向到标准错误输出<br>D. 标准输出重定向到标准输入<br>答案：C<br>在bash中，1表示标准输出（stdout），2表示标准错误输出（stderr），1&gt;&amp;2表示将标准输出重定向到标准错误输出，也就是将输出内容发送到标准错误输出流中。<br>例如，如果你执行以下命令：<br>ls /path/to/nonexistent/file 1&gt;&amp;2<br>这条命令将会把错误信息输出到标准错误输出流，而不是标准输出流。如果/path/to/nonexistent/file不存在，那么会输出类似于以下的错误信息到终端：<br>ls: cannot access ‘/path/to/nonexistent/file’: No such file or directory<br>这个技巧常用于将标准输出和标准错误输出合并为一个输出流，以便更好地处理程序的输出。<br>在上述命令中，1&gt;&amp;2表示将标准输出（文件描述符1）重定向到标准错误输出（文件描述符2）。这意味着，如果命令产生了标准输出，那么它将被发送到标准错误输出流中，而不是终端上。<br>例如，如果执行以下命令：<br>ls /path/to/nonexistent/file 1&gt;&amp;2<br>如果/path/to/nonexistent/file不存在，则会输出以下错误信息到终端上：</p>
<p>ls: cannot access ‘/path/to/nonexistent/file’: No such file or directory<br>这是因为标准输出被重定向到了标准错误输出，而标准错误输出默认会输出到终端上。</p>
<p>24．下面哪条命令可以把f1.txt复制为f2.txt?<br>A. cp f1.txt | f2.txt<br>B. cat f1.txt | f2.txt<br>C. cat f1.txt &gt; f2.txt<br>D. copy f1.txt | f2.txt<br>答案：C</p>
<p>25．显示一个文件最后几行的命令是：<br>A. tac<br>B. tail<br>C. rear<br>D. last<br>答案：B</p>
<p>26.如何快速切换到用户John的主目录下？<br>A. cd @John<br>B. cd #John<br>C. cd &amp;John<br>D. cd ~John<br>答案：D</p>
<p>27.把一个流中所有字符转换成大写字符，可以使用下面哪个命令？<br>A. tr a-z A-Z<br>B. tac a-z A-Z<br>C.sed /a-z/A-Z<br>D. sed –toupper<br>答案：A<br>tr用于替换字符，可以删除字符</p>
<p>28.使用什么命令可以查看Linux的启动信息？<br>A. mesg -d<br>B. dmesg<br>C. cat /etc/mesg<br>D. cat /var/mesg<br>答案：B</p>
<p>29.运行级定义在：<br>A. in the kernel<br>B. in /etc/inittab<br>C. in /etc/runlevels<br>D. using the rl command<br>答案：B</p>
<p>30.如何装载(mount)上在 /etc/fstab 文件中定义的所有文件系统？<br>A. mount -a<br>B. mount /mnt/*<br>C. mount<br>D. mount /etc/fstab<br>答案：A</p>
<p>31.使用ln命令将生成了一个指向文件old的符号链接new，如果你将文件old删除，是否还能够访问文件中的数据？<br>A. 不可能再访问<br>B. 仍然可以访问<br>C. 能否访问取决于文件的所有者<br>D. 能否访问取决于文件的权限<br>答案：A</p>
<p>32.xt2fs文件系统中，缺省的为root用户保留多大的空间？<br>A. 3%<br>B. 5%<br>C. 10%<br>D. 15%<br>答案：C</p>
<p>33.哪个命令用来显示系统中各个分区中inode的使用情况？<br>A. df -i<br>B. df -H<br>C. free -b<br>D. du -a -c /<br>答案：A</p>
<p>34.多数Linux发行版本中，图形方式的运行级定义为？<br>A. 1<br>B. 2<br>C. 3<br>D. 5<br>答案：D</p>
<p>35.在系统文档中找到关于print这个单词的所有说明？<br>A. man print<br>B. which print<br>C. locate print<br>D. apropos print<br>答案：D<br>“which ls” 是一个命令，用于查找系统中可执行的指定命令的路径。例如，使用 “which ls” 命令可以找到系统中 ls 命令的路径。<br>“locate ls” 是另一个命令，用于在系统中查找包含指定字符串的文件。例如，使用 “locate ls” 命令可以列出所有包含 “ls” 字符串的文件路径。<br>这两个命令的作用不同，”which ls” 用于查找命令的路径，而 “locate ls” 用于查找文件路径。</p>
<p>36.man 5 passwd 含义是？<br>A. 显示 passwd 命令的使用方法<br>B. 显示 passwd 文件的结构<br>C. 显示 passwd 命令的说明的前五行<br>D. 显示关于passwd的前五处说明文档。<br>答案：A</p>
<p>37.如何在文件中查找显示所有以” * “打头的行？<br>A. find * file<br>B. wc -l * &lt; file<br>C. grep -n * file<br>D. grep ‘^*’ file<br>答案：D</p>
<p>38.在ps命令中什么参数是用来显示所有用户的进程的？<br>A. a<br>B. b<br>C. u<br>D. x<br>答案：A</p>
<p>39.显示二进制文件的命令是？<br>A. od<br>B. vil<br>C. view<br>D. binview<br>答案：A</p>
<p>40.如何显示Linux系统中注册的用户数（包含系统用户）？<br>A. account -l<br>B. nl /etc/passwd |head<br>C. wc –users /etc/passwd<br>D. wc –lines /etc/passwd<br>答案：D</p>
<p>41.在一行结束位置加上什么符号，表示未结束，下一行继续？<br>A. /<br>B. <br>C. ;<br>D. |<br>答案：B</p>
<p>42.命令 kill 9 的含义是：<br>A. kills the process whose PID is 9.<br>B. kills all processes belonging to UID 9.<br>C. sends SIGKILL to the process whose PID is 9.<br>D. sends SIGTERM to the process whose PID IS 9.<br>答案：D</p>
<p>43.如何删除一个非空子目录/tmp？<br>A. del /tmp/*<br>B. rm -rf /tmp<br>C. rm -Ra /tmp/*<br>D. rm -rf /tmp/*<br>答案：B</p>
<p>44.使用什么命令可以在今天午夜运行命令 cmd1 ？<br>A. at midnight cmd1<br>B. cron -at “00:00” cmd1<br>C. batch -t “00:00” &lt; cmd1<br>D. echo “cmd1” | at midnight<br>答案：D</p>
<p>45.你的系统使用增量备份策略，当需要恢复系统时，你需要按什么顺序恢复备份数据？<br>A. 最后一次全备份，然后从最早到最近的增量备份<br>B. 最后一次全备份，然后从最近到最早的增量备份<br>C. 最早到最近的增量备份，然后最后一次全备份<br>D. 最近到最早的增量备份，然后最后一次全备份<br>答案：B</p>
<p>46.对所有用户的变量设置，应当放在哪个文件下？<br>A. /etc/bashrc<br>B. /etc/profile<br>C. ~/.bash_profile<br>D. /etc/skel/.bashrc<br>答案：B<br>47.Linux系统中，一般把命令 ls 定义为 ls –color 的别名，以便以不同颜色来标识不同类型的文件。但是，如何能够使用原先的ls命令？<br>A. \ls<br>B. ;ls<br>C. ls $$<br>D. ls –noalias<br>答案：A</p>
<p>48.在Linux系统中的脚本文件一般以什么开头？<br>A. $/bin/sh<br>B. #!/bin/sh<br>C. use /bin/sh<br>D. set shell=/bin/sh<br>答案：B</p>
<p>49.下面哪种写法表示如果cmd1成功执行，则执行cmd2命令？<br>A. cmd1&amp;&amp;cmd2<br>B. cmd1|cmd2<br>C. cmd1;cmd2<br>D. cmd1||cmd2<br>答案：A</p>
<p>50.在哪个文件中定义网卡的I/O地址？<br>A. cat /proc/modules<br>B. cat /proc/devices<br>C. cat /proc/ioports<br>D. cat /io/dma<br>答案：C</p>
<p>51.Linux中，提供TCP/IP包过滤功能的软件叫什么？<br>A. rarp<br>B. route<br>C. iptables<br>D. filter<br>答案：C</p>
<p>52.如何暂停一个打印队列？<br>A. lpr<br>B. lpq<br>C. lpc<br>D. lpd<br>答案：C</p>
<p>53.在vi中退出不保存的命令是？<br>A. :q<br>B. :w<br>C. :wq<br>D. :q!<br>答案：D</p>
<p>54.在 XFree86 3.x 中, 缺省的字体服务器为：<br>A. xfs<br>B. xfserv<br>C. fonts<br>D. xfstt<br>答案：A</p>
<p>55.使用什么命令检测基本网络连接？<br>A. ping<br>B. route<br>C. netstat<br>D. ifconfig<br>答案：A</p>
<p>56.下面哪个协议使用了二个以上的端口？<br>A. telnet<br>B. FTP<br>C. rsh<br>D. HTTP<br>答案：B</p>
<p>57.在PPP协议中，哪个认证协议不以明文传递密码？<br>A. PAM<br>B. PAP<br>C. PGP<br>D. CHAP<br>答案：D</p>
<p>58.下面哪个文件系统应该分配最大的空间？<br>A. /usr<br>B. /lib<br>C. /root<br>D. /bin<br>答案：A</p>
<p>59.如何在Debian系统中安装rpm包？<br>A. alien pkgname.rpm<br>B. dpkg –rpm pkgname.rpm<br>C. dpkg –alien pkgname.rpm<br>D. alien pkganme.rpm ; dpkg -i pkganme.deb<br>答案：D</p>
<p>60.在安装软件时下面哪一步需要root权限？<br>A. make<br>B. make deps<br>C. make config<br>D. make install<br>答案：D</p>
<p>61.什么命令用来只更新已经安装过的rpm软件包？<br>A. rpm -U * .rpm<br>B. rpm -F * .rpm<br>C. rpm -e * .rpm<br>D. rpm -q * .rpm<br>答案：B</p>
<p>62.在 windows 与 Linux 双起动的系统中，如果要让LILO 管理引导，则 LILO 应该放在：<br>A. MBR<br>B. /<br>C. root分区的首扇区<br>D. /LILO<br>答案：D</p>
<p>63.ldconfig的配置文件是<br>A. /lib/ld.so<br>B. /etc/ld.so.conf<br>C. /etc/ld.so.cache<br>D. /etc/modules.conf<br>答案：B<br>64.下面哪个命令可以压缩部分文件：<br>A. tar -dzvf filename.tgz *<br>B. tar -tzvf filename.tgz *<br>C. tar -czvf filename.tgz *<br>D. tar -xzvf filename.tgz *<br>答案：C</p>
<p>65.网络服务的daemon是：<br>A. lpd<br>B. netd<br>C. httpd<br>D. inetd<br>答案：D</p>
<p>66.Linux与windows 的网上领居互联，需要提供什么daemon?<br>A. bind<br>B. smbd<br>C. nmbd<br>D. shard<br>答案：B</p>
<p>67.对于Apache服务器，提供的子进程的缺省的用户是：<br>A. root<br>B. apached<br>C. httpd<br>D. nobody<br>答案：D</p>
<p>68.sendmail中缺省的未发出信件的存放位置是：<br>A. /var/mail/<br>B. /var/spool/mail/<br>C. /var/spool/mqueue/<br>D. /var/mail/deliver/<br>答案：C</p>
<p>69.apache的主配置文件是：<br>A. httpd.conf<br>B. httpd.cfg<br>C. access.cfg<br>D. apache.conf<br>答案：A</p>
<p>70.关于可装载的模块，装载时的参数，如I/O地址等的存放位置是：<br>A. /etc/conf.modules<br>B. /etc/lilo.conf<br>C. /boot/System.map<br>D. /etc/sysconfig<br>答案：A</p>
<p>71.在 Linux 中，如何关闭邮件提示？<br>A. biff n<br>B. mesg n<br>C. notify off<br>D. set notify=off<br>答案：A</p>
<p>72.在 bash shell 环境下，当一命令正在执行时，按下 control-Z 会：<br>A. 中止前台任务<br>B. 给当前文件加上 EOF.<br>C. 将前台任务转入后台<br>D. 注销当前用户<br>答案：C</p>
<p>73.定义bash环境的用户文件是：<br>A. bash &amp; .bashrc<br>B. bashrc &amp; .bash_conf<br>C. bashrc &amp; bash_profile<br>D. .bashrc &amp; .bash_profile<br>答案：D</p>
<p>74.下面哪条命令用来显示一个程序所使用的库文件？<br>A. ldd<br>B. ld so<br>C. modprobe<br>D. ldconfig<br>答案：B</p>
<p>75.如何查看一个RPM软件的配置文件的存放位置？<br>A. rpm -qc rpm1<br>B. rpm -Vc rpm1<br>C. rpm –config rpm1<br>D. rpm -qa –config rpm1<br>答案：A</p>
<p>76.如何查看一个RPM软件的修改记录？<br>A. rpm -Vc postfix<br>B. rpm -qpil postfix<br>C. rpm –changelog postfix<br>D. rpm -q –changelog postfix<br>答案：D</p>
<p>77.通过Makefile来安装已编译过的代码的命令是：<br>A. make<br>B. install<br>C. make depend<br>D. make install<br>答案：D</p>
<p>78.什么命令解压缩tar文件？<br>A. tar -czvf filename.tgz<br>B. tar -xzvf filename.tgz<br>C. tar -tzvf filename.tgz<br>D. tar -dzvf filename.tgz<br>答案：B</p>
<p>79.在 XF86Config 配置文件中，哪个段用来设置字体文件？<br>A. The Fonts section.<br>B. The Files section.<br>C. The xfsCodes section.<br>D. The Graphics section.<br>答案：B</p>
<p>80.8 bit color 指的是：<br>A. 64K colors<br>B. 16K colors<br>C. 256 colors<br>D. 16M colors<br>答案：C</p>
<p>81.下面哪个文件用来设置 X window 的显示分辨率？<br>A. xinit<br>B. xinitrc<br>C. XF86Setup<br>D. XF86Config<br>答案：D</p>
<p>82.哪个变量用来指定一个远程X应用程序将输出放到哪个X server上？<br>A. DISPLAY<br>B. TERM<br>C. ECHO<br>D. OUTPUT<br>答案：A</p>
<p>83.在xdm的配置目录中，哪个文件用来设置在用户通过xdm登录后自动起动的应用程序？<br>A. The Xsession file<br>B. The Xsetup_0 file<br>C. The Xstart_up file<br>D. The GiveConsole file<br>答案：B</p>
<p>84.命令 netstat -a 停了很长时间没有响应，这可能是哪里的问题？<br>A. NFS.<br>B. DNS.<br>C. NIS.<br>D. routing.<br>答案：B</p>
<p>85.ping使用的协议是：<br>A. TCP<br>B. UDP<br>C. SMB<br>D. ICMP<br>答案：D</p>
<p>86.下面哪个命令不是用来查看网络故障的？<br>A. ping<br>B. init<br>C. telnet<br>D. netstat<br>答案：B</p>
<p>87.拨号上网使用的协议通常是：<br>A. PPP<br>B. UUCP<br>C. SLIP<br>D. Ethernet<br>答案：A</p>
<ol>
<li>   TCP/IP中，哪个协议是用来进行IP自动分配的？<br>A. ARP<br>B. NFS<br>C. DHCP<br>D. DNS<br>答案：C</li>
</ol>
<p>89.下面哪个文件定义了网络服务的端口？<br>A. /etc/netport<br>B. /etc/services<br>C. /etc/server<br>D. /etc/netconf<br>答案：B</p>
<p>90.下面哪个功能用来生成一个文件的校验码？<br>A. md5<br>B. tar<br>C. crypt<br>D. md5sum<br>答案：A</p>
<p>91.缺省的，用户邮件放在：<br>A. ~/mail/<br>B. /var/mail/<br>C. /var/mail/spool/<br>D. /var/spool/mail/<br>答案：D</p>
<p>92.下面哪个文件包含了供 NFS daemon 使用的目录列表？<br>A. /etc/nfs<br>B. /etc/nfs.conf<br>C. /etc/exports<br>D. /etc/netdir<br>答案：C</p>
<p>93.如何停止一台机器的telnet服务？<br>A. Put NONE in /etc/telnet.allow<br>B. Put a line ‘ALL:ALL’ in /etc/hosts.deny<br>C. Comment the telnet entry in /etc/inittab<br>D. Comment the telnet entry in /etc/xinetd.conf<br>答案：D</p>
<p>94.在哪个文件中保存了sendmail的别名？<br>A. /etc/aliases<br>B. /etc/mailaliases<br>C. /etc/sendmail.aliases<br>D. /etc/sendmail/aliases<br>答案：A</p>
<p>95.smbd and nmbddaemons 的配置文件是：<br>A. /etc/exports<br>B. /etc/smb.conf<br>C. /etc/samba/config<br>D. /usr/local/samba.cfg<br>答案：B</p>
<p>96.下面哪个命令用来卸载一个内核模块？<br>A. rmmod<br>B. unmod<br>C. delmod<br>D. modprobe<br>答案：A</p>
<p>97.什么情况下必须运行lilo<br>A. once a day from cron<br>B. once a week from cron<br>C. after installing a new kernel<br>D. after installing a new module<br>答案：C</p>
<p>98.什么命令显示所有装载的模块？<br>A. lsmod<br>B. dirmod<br>C. modules<br>D. modlist<br>答案：A</p>
<p>99.下面哪个命令刷新打印机队列？<br>A. lpflush<br>B. lprm -<br>C. lpclear<br>D. lprm all<br>答案：B</p>
<p>100.下面哪个命令可以查看网卡的中断？<br>A. cat /proc/ioports<br>B. cat /proc/interrupts<br>C. cat /proc/memoryinfo<br>D. which interrupts<br>答案：B</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>客制化linux</title>
    <url>/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>相关文章：</p>
<blockquote>
<p><a href="https://sunnyli1024.github.io/2023/05/18/linux%E5%B0%8F%E9%A2%98/">linux小题</a><br><a href="https://sunnyli1024.github.io/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/">客制化linux</a><br><a href="https://sunnyli1024.github.io/2023/05/17/linux-shell%E7%BC%96%E7%A8%8B/">linux_shell编程</a><br><a href="https://sunnyli1024.github.io/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">linux基础</a></p>
</blockquote>
<p><strong>客制化linux，将我们需要的功能保留，其他全部精简</strong><br><a href="https://github.com/sunnyli1024/mylinux_mini">项目地址</a><br>整体思路：<br>首先新增一块硬盘挂载，历经分配分区大小、格式化、拷贝boot、修改grud文件（引导）中uuid后完成初始化，在新建虚拟机，导入我们客制化的硬盘（移除默认硬盘）</p>
<p><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/0.png" alt="silu"></p>
<p><strong>首先添加一块硬盘</strong><br><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/4.png" alt="1"><br><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/3.png" alt="1"><br><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/5.png" alt="1"><br><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/6.png" alt="1"></p>
<p><strong>格式化硬盘</strong><br><strong>1.查看目前磁盘情况</strong></p>
<blockquote>
<p>lsblk</p>
</blockquote>
<p><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/2.png" alt="lsblk"></p>
<p><strong>2.格式化sdb</strong></p>
<blockquote>
<p>[sunnyli@sunnyli ~]$ <strong>su</strong><br>密码：<br>[root@sunnyli sunnyli]# <strong>fdisk /dev/sdb</strong> (格式化sdb)</p>
</blockquote>
<blockquote>
<p><strong>分配boot分区大小</strong><br>欢迎使用 fdisk (util-linux 2.23.2)。<br>更改将停留在内存中，直到您决定将更改写入磁盘。<br>使用写入命令前请三思。<br>Device does not contain a recognized partition table<br>使用磁盘标识符 0xd7f12385 创建新的 DOS 磁盘标签。<br>命令(输入 m 获取帮助)：<strong>n</strong> （分配磁盘）<br>Partition type:<br>   p   primary (0 primary, 0 extended, 4 free)<br>   e   extended<br>Select (default p): <strong>p</strong><br>分区号 (1-4，默认 1)：<br>起始 扇区 (2048-20971519，默认为 2048)：<br>将使用默认值 2048<br>Last 扇区, +扇区 or +size{K,M,G} (2048-20971519，默认为 20971519)：**+500M**（分配500m）<br>分区 1 已设置为 Linux 类型，大小设为 500 MiB</p>
</blockquote>
<blockquote>
<p><strong>分配主分区大小</strong><br>命令(输入 m 获取帮助)：<strong>n</strong><br>Partition type:<br>   p   primary (1 primary, 0 extended, 3 free)<br>   e   extended<br>Select (default p):<br>Using default response <strong>p</strong><br>分区号 (2-4，默认 2)：<br>起始 扇区 (1026048-20971519，默认为 1026048)：<br>将使用默认值 1026048<br>Last 扇区, +扇区 or +size{K,M,G} (1026048-20971519，默认为 20971519)：<br>将使用默认值 20971519<br>分区 2 已设置为 Linux 类型，大小设为 9.5 GiB<br>命令(输入 m 获取帮助)：<strong>w</strong> （写入退出）<br>The partition table has been altered!<br>Calling ioctl() to re-read partition table.<br>正在同步磁盘。</p>
</blockquote>
<p><strong>3.再次查看磁盘分配情况</strong><br><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/3.1.png" alt="lsblk"><br><strong>4.格式化磁盘</strong></p>
<blockquote>
<p>[root@sunnyli sunnyli]# <strong>mkfs.ext4 /dev/sdb1</strong><br>mke2fs 1.42.9 (28-Dec-2013)<br>文件系统标签=<br>OS type: Linux<br>块大小=1024 (log=0)<br>分块大小=1024 (log=0)<br>Stride=0 blocks, Stripe width=0 blocks<br>128016 inodes, 512000 blocks<br>25600 blocks (5.00%) reserved for the super user<br>第一个数据块=1<br>Maximum filesystem blocks=34078720<br>63 block groups<br>8192 blocks per group, 8192 fragments per group<br>2032 inodes per group<br>Superblock backups stored on blocks:<br>    8193, 24577, 40961, 57345, 73729, 204801, 221185, 401409<br>Allocating group tables: 完成<br>正在写入inode表: 完成<br>Creating journal (8192 blocks): 完成<br>Writing superblocks and filesystem accounting information: 完成 </p>
</blockquote>
<blockquote>
<p>[root@sunnyli sunnyli]  <strong>mkfs.ext4 /dev/sdb2</strong><br>mke2fs 1.42.9 (28-Dec-2013)<br>文件系统标签=<br>OS type: Linux<br>块大小=4096 (log=2)<br>分块大小=4096 (log=2)<br>Stride=0 blocks, Stripe width=0 blocks<br>623392 inodes, 2493184 blocks<br>124659 blocks (5.00%) reserved for the super user<br>第一个数据块=0<br>Maximum filesystem blocks=2151677952<br>77 block groups<br>32768 blocks per group, 32768 fragments per group<br>8096 inodes per group<br>Superblock backups stored on blocks:<br>    32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632<br>Allocating group tables: 完成<br>正在写入inode表: 完成<br>Creating journal (32768 blocks): 完成<br>Writing superblocks and filesystem accounting information: 完成</p>
</blockquote>
<p><strong>5.创建目录，并挂载新的磁盘</strong><br><strong>mount临时挂载，重启失效</strong><br><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/4.1.png" alt="mount"></p>
<p><strong>6.安装grub, 内核文件拷贝至目标磁盘</strong><br><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/5.1.png" alt="5.1"><br><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/5.2.png" alt="5.2"></p>
<p>q:拷贝boot分区到新的硬盘时为什么用到了grub?<br>a:Linux GRUB是一个引导加载程序，用于启动并加载Linux操作系统。它的主要功能是在计算机启动时加载操作系统，并提供一个菜单，让用户选择要启动的操作系统或系统内核。此外，GRUB还提供了一些高级功能，例如在启动时设置内核参数、在多个硬盘之间切换等。它也可以用于修复系统启动问题，例如修复损坏的引导记录或修复损坏的文件系统。<br>在拷贝boot分区到新的硬盘时使用GRUB是因为GRUB是一个引导加载程序，可以帮助您在新的硬盘上启动操作系统。当您拷贝boot分区到新的硬盘时，您需要安装GRUB并将其配置为在新硬盘上启动操作系统。这通常包括将GRUB安装到新硬盘的MBR（主引导记录）或EFI系统分区，并在GRUB配置文件中指定要启动的操作系统或内核。通过使用GRUB，您可以确保新硬盘上的操作系统可以正确启动，并且可以避免出现启动问题。</p>
<p><strong>拷贝boot分区</strong><br><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/5.3.png" alt="5.3"></p>
<p>7.修改/mnt/boot/grud2/grud.cfg文件<br><strong>lsblk -l 查看sdb分区uuid</strong><br><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/6.5.png" alt="grud"><br><strong>修改文件</strong><br><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/6.6.png" alt="grud"><br>将文件中的sdb /boot uuid替换sda /boot，主分区也替换。<br>可以使用vim查找  /关键字 按n下一个<br>在linux16开头的行最后添加selinux=0 init=/bin/bash</p>
<p><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/7.1.png" alt="7.1"></p>
<p><strong>拷贝指令</strong></p>
<blockquote>
<p>mkdir -pv /mnt/sysroot/{etc/rc.d,usr,var,proc,sys,dev,lib,lib64,bin,sbin,boot,srv,mnt,media,home,root} </p>
<blockquote>
<p>这是一个Linux命令，意思是创建一个名为/sysroot的目录，并在其中创建多个子目录，包括/etc/rc.d、/usr、/var、/proc、/sys、/dev、/lib、/lib64、/bin、/sbin、/boot、/srv、/mnt、/media、/home和/root。选项-p表示如果目录不存在，则递归创建所有父目录，选项-v表示在创建目录时显示详细信息。<br>cp /lib64/<em>.</em> /mnt/sysroot/lib64/<br>cp /bin/bash /mnt/sysroot/bin/<br>拷贝其他指令<br>cp /bin/ls /mnt/sysroot/bin/<br>cp /bin/*  /mnt/sysroot/bin/<br>cp /sbin/* /mnt/sysroot/sbin/</p>
</blockquote>
</blockquote>
<p><strong>新建虚拟机，替换磁盘为我们的sdb</strong><br><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/8.png" alt="ls"> </p>
<p>完成（没有配置环境变量用绝对路径）<br><img src="/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/9.png" alt="done"></p>
<p><strong>q</strong>:<br>我在移植linux时首先#mount /dev/sdb1 /mnt/boot #mount /dev/sdb2 /mnt/sysroot/<br>然后cp -rf /boot/* /mnt/boot/，最后修改/mnt/boot/grub2/grub.cfg文件中原来的uuid为sdb的uuid。这个过程中sdb2挂载的目录名称有要求吗？</p>
<p><strong>a:</strong><br>在移植Linux时，挂载目录的名称没有特定要求。您可以自己定义一个有意义的名称。只需确保您在使用该目录时，使用正确的路径即可。在上述命令中，/mnt/sysroot/是一个常用的目录名称，但您可以使用其他名称，只要您在使用该目录时使用正确的路径即可。</p>
<p><strong>q:</strong><br>他怎么不把boot目录识别为根目录，根目录识别为boot目录呢，是不是有什么文件</p>
<p><strong>a:</strong><br>Linux系统中的根目录通常是由启动加载程序（如GRUB）指定的。在启动时，启动加载程序会读取指定的根文件系统，并将其挂载为根目录。通常情况下，根文件系统的指定是通过修改启动加载程序配置文件（如GRUB配置文件）中的参数来实现的。</p>
<p>/boot目录通常包含启动加载程序和内核映像文件，但它不是根目录。根目录是Linux文件系统中的顶级目录，它包含了整个文件系统的层次结构。</p>
<p>因此，即使您将/boot目录复制到新的磁盘分区上并将其挂载为/boot目录，Linux系统仍然会将/sysroot目录视为根目录，因为这是由启动加载程序指定的。如果您将/boot目录挂载为根目录，则该文件系统中的所有其他目录和文件都将被挂载为/boot目录的子目录，这可能会导致系统无法正常启动。</p>
<p><strong>q:</strong><br>所以系统之所以可以识别是因为我修改了grud文件的uuid吗</p>
<p><strong>a:</strong><br>是的，如果您在新系统中使用了原始系统的文件系统，并将其挂载到/sysroot目录下，那么您需要更新GRUB的配置文件（grub.cfg）以反映新的文件系统的UUID信息。因为GRUB启动加载程序会使用该UUID信息来找到并挂载根文件系统。</p>
<p>如果您不更新GRUB的配置文件，则GRUB启动加载程序无法正确识别新的文件系统，并可能导致系统无法正常启动。所以，更新GRUB的配置文件以反映新的文件系统的UUID信息是非常必要的。</p>
<p><strong>q:</strong><br>有个问题，根目录中包含了/boot，为什么还会有boot分区，难道有两个boot吗</p>
<p><strong>a:</strong><br>在Linux系统中，/boot目录通常包含了启动加载程序和内核映像文件等文件。这些文件通常存储在根文件系统中的/boot目录中。但是，在某些情况下，/boot目录可能无法存放在根文件系统中，例如，如果根文件系统使用的是某些特殊的文件系统格式（如Btrfs），则/boot目录可能无法支持该格式，因此需要单独挂载为一个独立的分区。</p>
<p>因此，/boot分区的作用就是为了存放/boot目录中的文件。这样做的好处是，它可以使/boot目录的文件系统格式与根文件系统的格式独立，从而提高了系统的灵活性和可靠性。同时，将/boot目录单独挂载为一个分区还可以提高系统的安全性，因为/boot分区可以进行单独的加密和保护，从而增加了系统的安全性。</p>
<p><strong>q:</strong><br>那两个boot内容一样吗</p>
<p><strong>a:</strong><br>在大多数情况下，/boot分区中的内容和根文件系统中的/boot目录中的内容是相同的。因为/boot分区通常是为了存放/boot目录中的文件而存在的，所以它们的内容应该是一致的。</p>
<p>然而，在某些情况下，/boot分区中的内容可能会与根文件系统中的/boot目录中的内容不同。例如，如果您手动复制了一些文件到/boot分区中，而没有同步更新根文件系统中的/boot目录，则它们的内容将不同步。这种情况下，可能会导致系统无法正常启动或出现其他问题。</p>
<p>因此，为了确保系统的正确性和稳定性，通常建议将/boot分区和根文件系统中的/boot目录保持同步，即它们的内容应该是一致的。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_shell编程</title>
    <url>/2023/05/17/linux-shell%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>相关文章：</p>
<blockquote>
<p><a href="https://sunnyli1024.github.io/2023/05/18/linux%E5%B0%8F%E9%A2%98/">linux小题</a><br><a href="https://sunnyli1024.github.io/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/">客制化linux</a><br><a href="https://sunnyli1024.github.io/2023/05/17/linux-shell%E7%BC%96%E7%A8%8B/">linux_shell编程</a><br><a href="https://sunnyli1024.github.io/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">linux基础</a></p>
</blockquote>
<h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p>
<p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p>
<p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p>
<blockquote>
<p>#!/bin/bash<br>echo “Hello World !”</p>
</blockquote>
<p>! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</p>
<p>echo 命令用于向窗口输出文本。</p>
<p><strong>运行 Shell 脚本有两种方法：</strong></p>
<p><strong>1、作为可执行程序</strong><br>将上面的代码保存为 test.sh，并 cd 到相应目录：<br>chmod +x ./test.sh  #使脚本具有执行权限<br>./test.sh  #执行脚本<br>注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p>
<p><strong>2、作为解释器参数</strong><br>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：<br>/bin/sh test.sh<br>/bin/php test.php<br>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>
<p><strong>这种方法会产生子shell，局部变量</strong></p>
<p>Linux执行Scripts有两种方式，主要区别在于是否建立subshe</p>
<blockquote>
<ol>
<li><p>source filename or . filename<br>不创建subshell，在当前shell环境下读取并执行filename中的命令，相当于顺序执行filename里面的命令</p>
</li>
<li><p>bash filename or ./filename<br>创建subshell，在当前bash环境下再新建一个子shell执行filename中的命令<br>子shell继承父shell的变量，但子shell不能使用父shell的变量，除非使用export</p>
</li>
</ol>
</blockquote>
<p>pstree查看后：</p>
<p><img src="/2023/05/17/linux-shell%E7%BC%96%E7%A8%8B/image-20240228192155051.png" alt="image-20240228192155051"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[sunnyli@sunnyli ~]$ echo num=1 &gt; test.sh</span><br><span class="line">[sunnyli@sunnyli ~]$ num=2</span><br><span class="line">[sunnyli@sunnyli ~]$ echo $num</span><br><span class="line">2</span><br><span class="line">[sunnyli@sunnyli ~]$ chmod +x test.sh </span><br><span class="line">[sunnyli@sunnyli ~]$ ./test.sh  创建子shell执行</span><br><span class="line">[sunnyli@sunnyli ~]$ echo $num</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">[sunnyli@sunnyli ~]$ . test.sh  不创建子shell</span><br><span class="line">[sunnyli@sunnyli ~]$ echo $num</span><br><span class="line">1</span><br></pre></td></tr></table></figure>



<ul>
<li><p><code>./test.sh</code>或者<code>bash test.sh</code> 这种方式会启动一个新的子shell来执行 <code>test.sh</code> 脚本。在子shell中执行完脚本后，会返回到原来的shell环境，但是子shell无法修改父shell的变量，所以在父shell中的 <code>num</code> 仍然保持为原来的值。</p>
</li>
<li><p><code>. test.sh</code> 或者 <code>source test.sh</code> 这种方式会在当前shell环境中直接执行 <code>test.sh</code> 脚本，而不会启动一个新的子shell。因此，当脚本中对变量 <code>num</code> 进行赋值时，会影响到当前shell环境中的 <code>num</code> 变量的值，导致父shell中的 <code>num</code> 被修改为脚本中所赋的值。</p>
</li>
</ul>
<h4 id="单双反引号"><a href="#单双反引号" class="headerlink" title="单双反引号"></a>单双反引号</h4><p>单引号所见即所得，直接显示单引号里的内容。</p>
<p>双引号则是先把变量解析之后，再输出。</p>
<p>反引号用于命令替换，即先执行反引号中的语句，再把结果加入到原命令中。</p>
<h4 id="内外置命令"><a href="#内外置命令" class="headerlink" title="内外置命令"></a>内外置命令</h4><p>内置命令:在系统启动时就加载入内存，常驻内存，执行效率更高，但是占用资源</p>
<p>外置命令:系统需要从硬盘中读取程序文件，再读入内存加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[sunnyli@sunnyli ~]$ type cd</span><br><span class="line">cd 是 shell 内嵌</span><br><span class="line">[sunnyli@sunnyli ~]$ type bash</span><br><span class="line">bash 是 /usr/bin/bash</span><br></pre></td></tr></table></figure>



<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><strong>定义变量</strong><br>定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如：</p>
<blockquote>
<p>your_name=”runoob.com”</p>
</blockquote>
<p>注意，<strong>变量名和等号之间不能有空格</strong>，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：<br>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。<br>中间不能有空格，可以使用下划线 _。<br>不能使用标点符号。<br>不能使用bash里的关键字（可用help命令查看保留关键字）。</p>
<p><strong>使用变量</strong><br><strong>$在Linux shell编程中用于取变量值</strong><br>使用一个定义过的变量，只要在变量名前面 <strong>加$</strong> 即可，如：</p>
<blockquote>
<p>your_name=”qinjx”<br>echo $your_name<br>echo ${your_name}</p>
</blockquote>
<p>${变量}                                         返回变量值<br>${注释 #变量}                                       返回变量长度，字符长度<br>${变量:start}                                返回变量start数值之后的字符，且包含start的数字<br>${变量:start:length}                    提取start之后的length限制的字符，例如${name:4:1)<br>${变量#word}                             从变量开头删除最短匹配的word子串<br>${变量##word}                            从变量开头，删除最长匹配的word<br>${变量%word}                            从变量结尾删除最短的word<br>${变量//pattern/string}            用string代替所有的pattern<br>${变量%%word}                            从变量结尾开始删除最长匹配的word<br>${变量/pattern/string}                用string代替第一个的pattern</p>
<p>result=${parameter:-word}    </p>
<p>如果parameter变量值为空，返回word字符串，赋值给result变量</p>
<p>result=${parametq:=word}</p>
<p>如果para变量为空，则word替代变量值，且返回其值</p>
<p>${parameter:?word}</p>
<p>如果para变量为空，word当作stderr输出，否则输出变量值用于设置变量为空导致错误时，返回的错误信息</p>
<p>${parameter:+word}</p>
<p>如果para变量为空，什么都不做，否则word返回</p>
<p><strong>变量名外面的花括号是可选的，加不加都行</strong>，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p>
<blockquote>
<p>for skill in Ada Coffe Action Java; do<br>    echo “I am good at ${skill}Script”<br>done</p>
</blockquote>
<p>``可以带回指令的返回值，除了显式地直接赋值，还可以用语句给变量赋值，如：</p>
<blockquote>
<p>for file in <code>ls /etc</code><br>或<br>for file in $(ls /etc)</p>
</blockquote>
<p><strong>命令行参数</strong><br>以上语句将 /etc 下目录的文件名循环出来。</p>
<blockquote>
<p>$1,$2…${10}获取命令行位置参数<br>$#    传递到脚本或函数的参数个数<br>$*    以一个单字符串显示所有向脚本传递的参数<br>$$    脚本运行的当前进程ID号<br>$!    后台运行的最后一个进程的ID号<br>$@    与$<em>相同，但是使用时加引号，并在引号中返回每个参数。<br>$-    显示Shell使用的当前选项，与set命令功能相同。<br>$?    显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。*<em>函数返回值在调用该函数后通过$? 来获得。</em></em><br>这几个参数都通过命令行输入</p>
</blockquote>
<p><strong>只读变量</strong><br>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。<br>下面的例子尝试更改只读变量，结果报错：</p>
<blockquote>
<p>#!/bin/bash<br>myUrl=”<a href="https://www.google.com&quot;/">https://www.google.com&quot;</a><br>readonly myUrl<br>myUrl=”<a href="https://www.baidu.com&quot;/">https://www.baidu.com&quot;</a></p>
</blockquote>
<p>运行脚本，结果如下：</p>
<blockquote>
<p>/bin/sh: NAME: This variable is read only.</p>
</blockquote>
<p><strong>删除变量</strong><br>使用 unset 命令可以删除变量。语法：</p>
<blockquote>
<p>unset variable_name</p>
</blockquote>
<p>变量被删除后不能再次使用。unset 命令不能删除只读变量。</p>
<h4 id="环境变量的加载顺序"><a href="#环境变量的加载顺序" class="headerlink" title="环境变量的加载顺序"></a>环境变量的加载顺序</h4><p><img src="/2023/05/17/linux-shell%E7%BC%96%E7%A8%8B/image-20240229091149967.png" alt="image-20240229091149967"></p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p><strong>printf</strong><br>和c类似</p>
<blockquote>
<blockquote>
<p>printf “%d %s\n” 1 “abc”</p>
</blockquote>
</blockquote>
<p>echo</p>
<blockquote>
<blockquote>
<p>echo “\“It is a test\“”</p>
</blockquote>
</blockquote>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p><img src="/2023/05/17/linux-shell%E7%BC%96%E7%A8%8B/%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="运算符"></p>
<p>expr支持模式匹配   expr   1.jpg “:” “.* \ .jpg*”</p>
<blockquote>
<p>echo $[5*3]<br>echo $(((2+3)-3))<br>echo `expr 3+3`    </p>
</blockquote>
<blockquote>
<blockquote>
<p>15<br>2<br>3+3</p>
</blockquote>
</blockquote>
<p><strong>tr</strong></p>
<p>tr只支持单个字符替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[sunnyli@sunnyli ~]$ echo &#123;1..10&#125; |tr &quot; &quot; &quot; + &quot; </span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure>

<p><strong>seq</strong></p>
<p>生成一段序列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[sunnyli@sunnyli ~]$ seq  10</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">[sunnyli@sunnyli ~]$ seq 4  10</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">[sunnyli@sunnyli ~]$ seq  -s &quot;+&quot; 10</span><br><span class="line">#-s 指定分隔符</span><br><span class="line">1+2+3+4+5+6+7+8+9+10</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h4><p><strong>test</strong></p>
<blockquote>
<p>-eq    检测两个数是否相等，相等返回 true。    [ \$a -eq \$b ] 返回 false。<br>-ne    检测两个数是否不相等，不相等返回 true。    [ $a -ne $b ] 返回 true。<br>-gt    检测左边的数是否大于右边的，如果是，则返回 true。    [ $a -gt $b ] 返回 false。<br>-lt    检测左边的数是否小于右边的，如果是，则返回 true。    [ $a -lt $b ] 返回 true。<br>-ge    检测左边的数是否大于等于右边的，如果是，则返回 true。    [ $a -ge $b ] 返回 false。<br>-le    检测左边的数是否小于等于右边的，如果是，则返回 true。    [ $a -le $b ] 返回 true。<br>-e 文件名    如果文件存在则为真<br>-r 文件名    如果文件存在且可读则为真<br>-w 文件名    如果文件存在且可写则为真<br>-x 文件名    如果文件存在且可执行则为真<br>-s 文件名    如果文件存在且至少有一个字符则为真<br>-d 文件名    如果文件存在且为目录则为真</p>
<p>-z 字符串   判断是否为空</p>
<p>-n 字符串   判断是否有</p>
<p>-f 文件名    如果文件存在且为普通文件则为真<br>-c 文件名    如果文件存在且为字符型特殊文件则为真<br>-b 文件名    如果文件存在且为块特殊文件则为真</p>
</blockquote>
<p><strong>[]</strong></p>
<p>test和[]的作用是一样注意的点:中括号，前后的空格必须有。</p>
<p>在条件测试中使用变量，必须添加双引号[-n “$filename” ]</p>
<p><img src="/2023/05/17/linux-shell%E7%BC%96%E7%A8%8B/image-20240229145034946.png" alt="image-20240229145034946"></p>
<p><img src="/2023/05/17/linux-shell%E7%BC%96%E7%A8%8B/image-20240229150524924.png" alt="image-20240229150524924"></p>
<h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><p>所有的流程控制[ 条件 ] 条件两侧有空格<br><strong>if</strong></p>
<blockquote>
<p><strong>if condition1<br>then<br>    command1<br>elif condition2<br>then<br>    command2<br>else<br>    commandN<br>fi</strong></p>
</blockquote>
<blockquote>
<blockquote>
<p>a=10<br>b=20<br>if [ $a == $b ]<br>then<br>   echo “a 等于 b”<br>elif [ $a -gt $b ]<br>then<br>   echo “a 大于 b”<br>elif [ $a -lt $b ]<br>then<br>   echo “a 小于 b”<br>else<br>   echo “没有符合的条件”<br>fi</p>
</blockquote>
</blockquote>
<p>末尾的 fi 就是 if 倒过来拼写，后面还会遇到类似的</p>
<p><strong>case</strong></p>
<blockquote>
<p>*<em>case $变量名 in<br>“值”)<br>语句<br>;;<br>“值”)<br>语句<br>;;<br><em>)<br>语句<br>;;<br>esac</em></em></p>
</blockquote>
<blockquote>
<blockquote>
<p>case $1 in<br>“1”)<br>echo “1”<br>;;<br>*)<br>echo ‘…’<br>;;<br>esac</p>
</blockquote>
</blockquote>
<p><strong>for</strong><br>for循环一般格式为：</p>
<blockquote>
<p><strong>for var in item1 item2 … itemN<br>do<br>    command1<br>    command2<br>    …<br>    commandN<br>done</strong></p>
<blockquote>
<p>for loop in 1 2 3 4 5<br>do<br>    echo “The value is: $loop”<br>done</p>
</blockquote>
</blockquote>
<p><strong>while</strong></p>
<blockquote>
<p><strong>while condition<br>do<br>    command<br>done</strong></p>
<blockquote>
<p>#!/bin/bash<br>int=1<br>while(( $int&lt;=5 ))<br>do<br>    echo $int<br>    let “int++”<br>done</p>
</blockquote>
</blockquote>
<p>以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><blockquote>
<p>[ function ] funname [()]<br>{<br>    action;<br>    [return int;]<br>}</p>
<blockquote>
<p>funWithReturn(){<br>    echo “这个函数会对输入的两个数字进行相加运算…”<br>    echo “输入第一个数字: “<br>    read -p “我是提示信息” aNum<br>    echo “输入第二个数字: “<br>    read anotherNum<br>    echo “两个数字分别为 $aNum 和 $anotherNum !”<br>    return $(($aNum+$anotherNum))<br>}<br>funWithReturn<br>echo “输入的两个数字之和为 $? !”</p>
</blockquote>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基础</title>
    <url>/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>相关文章：</p>
<blockquote>
<p><a href="https://sunnyli1024.github.io/2023/05/18/linux%E5%B0%8F%E9%A2%98/">linux小题</a><br><a href="https://sunnyli1024.github.io/2023/05/18/%E5%AE%A2%E5%88%B6%E5%8C%96linux/">客制化linux</a><br><a href="https://sunnyli1024.github.io/2023/05/17/linux-shell%E7%BC%96%E7%A8%8B/">linux_shell编程</a><br><a href="https://sunnyli1024.github.io/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">linux基础</a></p>
</blockquote>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><blockquote>
<p>/bin 存放着经常使用的命令<br>/sbin存放管理员使用的系统管理程序<br>/home存放每一个用户的目录<br>/root管理员的主目录<br>/lib系统开机所需要的动态链接库<br>/lost+found一般是空的，存放系统非法关机的资源<br>/etc各种配置/usr存放很多应用程序和文件<br>/boot启动linux的一些核心文件<br>/proc虚拟目录，系统内存的映射【不能动】<br>/srv存放系统启动后的一些数据【不能动】<br>/sys存放2.6内核新出现的文件【不能动】<br>/tmp临时文件/dev设备管理器<br>/media系统自动识别的设备<br>/mnt临时挂载系统<br>/opt系统安装软件<br>/usr/local 給另一个主机安装软件的目录*<br>/var不断扩充的东西<br>/selinux安全子系统，控制程序访问特定的文件</p>
</blockquote>
<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><blockquote>
<p>&amp;.在Linux中，&amp;符号是一个特殊字符，用于将命令放入后台执行。当在命令末尾加上&amp;符号时，该命令将在后台运行，而不会阻塞终端。这意味着你可以继续在终端上输入其他命令，而不必等待该命令执行完毕。</p>
<p><strong>nohup命令</strong><br>在命令的末尾加个&amp;符号后，程序可以在后台运行，但是一旦当前终端关闭（即退出当前帐户），该程序就会停止运行。那假如说我们想要退出当前终端，但又想让程序在后台运行，在这种情况下，我们就可以使用nohup命令。nohup就是不挂起的意思( no hang up)。该命令的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;nohup ./test &amp;</span><br></pre></td></tr></table></figure>


</blockquote>
<blockquote>
<p>; 符号：用于将多个命令放在同一行上执行，每个命令之间用分号分隔。例如：<br>command1 ; command2 ; command3</p>
</blockquote>
<blockquote>
<p>&amp;&amp; 符号：用于将多个命令放在同一行上执行，但只有前一个命令执行成功后才会执行下一个命令。例如：<br>command1 &amp;&amp; command2 &amp;&amp; command3</p>
</blockquote>
<blockquote>
<p>|| 符号：用于将多个命令放在同一行上执行，但只有前一个命令执行失败后才会执行下一个命令。例如：<br>command1 || command2 || command3</p>
</blockquote>
<blockquote>
<p>| 符号：用于将一个命令的输出作为另一个命令的输入。例如：<br>command1 | command2<br>这将把command1的输出传递给command2作为输入。这个符号也被称为管道符号。</p>
<p>有一些特殊命令不接受管道：cp rm .通过xargs进行传递</p>
<p><code>[sunnyli@sunnyli ~]$ touch 1.txt [sunnyli@sunnyli ~]$ ll | grep 1.txt -rw-rw-r--. 1 sunnyli sunnyli    0 2月  25 20:23 1.txt [sunnyli@sunnyli ~]$ echo 1.txt |xargs  rm  [sunnyli@sunnyli ~]$ ll | grep 1.txt</code></p>
</blockquote>
<h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><p><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/vim.png" alt="vim"></p>
<p><strong>命令模式</strong> </p>
<blockquote>
<p>gg 回到第一行<br>G 最后一行<br>n+enter    n 为数字。光标向下移动 n 行<br>dd 剪切一行yy 复制一行<br>/关键字  搜索<br>方向键+数字 实现行或者字符的跳转</p>
<p>p粘贴</p>
<p>v进入可视模式，可以通过光标进行选取范围</p>
</blockquote>
<p><strong>输入模式</strong></p>
<blockquote>
<p>iIaAoOrR任意一个进入输入模式</p>
</blockquote>
<p><strong>命令行模式</strong></p>
<blockquote>
<p>:w    将编辑的数据写入硬盘档案中(常用)<br>:w!    若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！<br>:q    离开 vi (常用)<br>:q!    若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。<br>:wq    储存后离开，若为 :wq! 则为强制储存后离开 (常用)<br>:set nu    显示行号，设定之后，会在每一行的前缀显示该行的行号<br>:set nonu    与 set nu 相反，为取消行号！</p>
<p>：set paste  粘贴模式</p>
</blockquote>
<h4 id="linux开机重启注销"><a href="#linux开机重启注销" class="headerlink" title="linux开机重启注销"></a>linux开机重启注销</h4><blockquote>
<p><strong>shutdown -h now  立刻关机<br>shutdown -h 1 1分钟后关机<br>shutdown -r now 立刻重启<br>reboot  重启<br>sync 同步内存到磁盘</strong></p>
</blockquote>
<h4 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h4><blockquote>
<p><strong>init [0123456]</strong><br>0 :关机<br>1:单用户(找回丢失密码)<br>2:多用户状态没有网络服务<br>3:多用户状态有网络服务<br>4:系统未使用保留给用户<br>5:图形界面<br>6:系统重启</p>
</blockquote>
<h4 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h4><blockquote>
<p><strong>man 不懂得命令 例如：man ls</strong></p>
</blockquote>
<h4 id="目录和文件"><a href="#目录和文件" class="headerlink" title="目录和文件"></a>目录和文件</h4><p><strong>1.显示当前所在路径</strong></p>
<blockquote>
<p><strong>pwd （显示的是绝对路径）</strong></p>
</blockquote>
<p><strong>2.显示该目录的文件内容</strong></p>
<blockquote>
<p><strong>ls （隐藏文件以.开头）<br>ls -a 显示所有文件，包括隐藏<br>ls -l 列表显示<br>ls -h 用常规形式显示</strong></p>
</blockquote>
<p><strong>3.cd命令</strong></p>
<blockquote>
<p><strong>cd ~ 回到家目录<br>cd .. 回到上一层</strong></p>
</blockquote>
<p><strong>4.新建目录</strong></p>
<blockquote>
<p><strong>mkdir 目录名 （不能创建多级目录）<br>mkdir -p 目录名 (创建多级目录)</strong></p>
</blockquote>
<p><strong>5.删除目录</strong></p>
<blockquote>
<p><strong>rmdir 只能删除空目录<br>rm options name</strong><br>参数：<br>-i 删除前逐一询问确认。<br>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。<br>-r 将目录及以下之档案亦逐一删除。</p>
</blockquote>
<p><strong>6.统计字数</strong></p>
<blockquote>
<p><strong>wc [-clw][–help][–version][文件…]</strong><br>参数：<br>-c或–bytes或–chars 只显示Bytes数。<br>-l或–lines 显示行数。<br>-w或–words 只显示字数。<br>–help 在线帮助。<br>–version 显示版本信息。</p>
</blockquote>
<p><strong>7.复制</strong></p>
<blockquote>
<p><strong>cp 文件名/目录 目标路径</strong><br><strong>\cp 文件名/目录 目标路径 (强制覆盖不提醒)</strong><br>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。<br>-d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。<br>-f：覆盖已经存在的目标文件而不给出提示。<br>-i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖。<br>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。<br>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。<br>-l：不复制文件，只是生成链接文件。</p>
<blockquote>
<p>使用指令 cp 将当前目录 test/ 下的所有文件复制到新目录 newtest 下，输入如下命令：<br>$ cp –r test/ newtest </p>
</blockquote>
</blockquote>
<p><strong>8.移动</strong></p>
<blockquote>
<p><strong>mv 文件名 目标路径</strong><br>（新旧路径相同的话是重命名）</p>
<blockquote>
<p>将文件 aaa 改名为 bbb :<br>mv aaa bbb<br>将 info 目录放入 logs 目录中。注意，如果 logs 目录不存在，则该命令将 info 改名为 logs。<br>mv info/ logs<br>再如将 /usr/runoob 下的所有文件和目录移到当前目录下，命令行为：<br>$ mv /usr/runoob/*  .</p>
</blockquote>
</blockquote>
<p><strong>6.创建空文件</strong></p>
<blockquote>
<p><strong>touch 文件名</strong></p>
</blockquote>
<p><em><strong>9.查看文件</strong></em></p>
<blockquote>
<p><em><strong>cat 文件名*<br><em>cat 文件名 |more</em><br>*more 文件</strong></em><br>Enter 向下n行，需要定义。默认为1行<br>空格键 向下滚动一屏<br>Ctrl+B 返回上一屏<br>= 输出当前行的行号<br>V 调用vi编辑器<br>q 退出more<br><strong>less 文件</strong><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/less.png" alt="less"><br><strong>tail 文件（默认10行）用来实时追踪</strong><br><strong>head 文件 （默认10行）</strong></p>
</blockquote>
<p><strong>10.输入</strong></p>
<blockquote>
<p><strong>echo 选项 文字</strong></p>
</blockquote>
<p><strong>11.追加和重定向</strong><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/11.png" alt="重定向"><br><strong>12.软链接</strong></p>
<blockquote>
<p><strong>ln -s 文件名 软连接名</strong></p>
</blockquote>
<p><strong>树状显示目录 /opt</strong></p>
<blockquote>
<p><strong>tree /opt （如果没有安装使用 yum Install tree 安装）</strong></p>
</blockquote>
<p><strong>13.硬链接</strong></p>
<blockquote>
<p><strong>ln 源文件名称 链接文件名称</strong></p>
</blockquote>
<blockquote>
<p>Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。<br>软链接：<br>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式<br>2.软链接可以 跨文件系统 ，硬链接不可以<br>3.软链接可以对一个不存在的文件名进行链接<br>4.软链接可以对目录进行链接<br>硬链接：<br>1.硬链接，以文件副本的形式存在。但不占用实际空间。<br>2.不允许给目录创建硬链接<br>3.硬链接只有在同一个文件系统中才能创建</p>
</blockquote>
<p>不同的文件系统指的是不同的磁盘分区或不同的文件系统类型。在Linux中，每个磁盘分区或文件系统类型都有自己的根目录，因此不同的文件系统之间是可以存在多个根目录的。当硬链接创建在不同的文件系统之间时，它会自动转换为软链接，因为硬链接只能在同一个文件系统中才能工作。软链接可以跨越不同的文件系统，因此在这种情况下，系统会将硬链接自动转换为软链接，以保证链接的正确性。<br>一个计算机上可能会有多个硬盘或分区，每个硬盘或分区都可以格式化为不同的文件系统类型，如ext4、NTFS等。每个文件系统类型都有自己的根目录，例如，/是ext4文件系统的根目录，而D:/是NTFS文件系统的根目录。因此，在Linux系统中可以存在多个根目录，每个根目录都代表了不同的文件系统。</p>
<p><strong>权限</strong><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E6%9D%83%E9%99%901.png" alt="less"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E6%9D%83%E9%99%902.png" alt="less"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E6%9D%83%E9%99%903.png" alt="less"></p>
<p><strong>更改文件权限</strong></p>
<blockquote>
<p><strong>chmod</strong><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/chmod1.png" alt="less"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/chmod2.png" alt="less"><br>如果想要操作一个文件，必须要先可以访问文件所在的文件夹</p>
</blockquote>
<p><strong>修改文件所有者</strong></p>
<blockquote>
<p><strong>chown 用户名 文件名</strong></p>
</blockquote>
<p><strong>修改文件目录所在组</strong></p>
<blockquote>
<p><strong>chgrp 新组 文件</strong></p>
</blockquote>
<p><strong>setfacl</strong></p>
<p>setfacl命令可以用来细分linux下的文件权限。<br>chmod命令可以把文件权限分为u,g,o三个组，而setfacl可以对每一个文件或目录设置更精确的文件权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setfacl 参数</span><br><span class="line"> -m：设置后续acl参数</span><br><span class="line"> setfacl -m 对象:对象名：权限   文件</span><br><span class="line"> -x：删除后续acl参数  </span><br><span class="line"> -b：删除全部的acl参数</span><br><span class="line"> -k：删除默认的acl参数</span><br><span class="line"> -R：递归设置acl，包括子目录</span><br><span class="line"> -d：设置默认acl</span><br></pre></td></tr></table></figure>

<p><strong>getfacl</strong></p>
<blockquote>
<p>getfacl 文件</p>
</blockquote>
<p><strong>特殊位：suid进行提权，临时获得属于者权限</strong></p>
<blockquote>
<p>chmod u+s cat  进行提权</p>
</blockquote>
<p><strong>chattr 文件属性</strong></p>
<p><code>a：让文件或目录仅供附加用途。b：不更新文件或目录的最后存取时间。c：将文件或目录压缩后存放。d：将文件或目录排除在倾倒操作之外。i：不得任意更动文件或目录。s：保密性删除文件或目录。S：即时更新文件或目录。u：预防意外删除。</code></p>
<p>用chattr命令防止系统中某个关键文件被修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chattr +i /etc/resolv.conf</span><br></pre></td></tr></table></figure>



<p><strong>umask</strong></p>
<p> 在 Linux 系统中，我们创建一个新的文件或者目录的时候，这些新的文件或目录都会有默认的访问权限，umask 命令与文件和目录的默认访问权限有关。若用户创建一个文件，则文件的默认访问权限为 -rw-rw-rw-，创建目录的默认权限 drwxrwxrwx ，而 umask 值则表明了需要从默认权限中去掉哪些权限来成为最终的默认权限值。</p>
<p> umask 默认值一般都是 0002，其中第一个 0 与特殊权限有关，可以暂时不用理会，后三位 002 则与普通权限（rwx）有关，其中 002 中第一个 0 与用户（user）权限有关，表示从用户权限减 0，也就是权限不变，所以文件的创建者的权限是默认权限（rw），第二个 0 与组权限（group）有关，表示从组的权限减 0，所以群组的权限也保持默认权限（rw），最后一位 2 则与系统中其他用户（others）的权限有关，由于 w=2，所以需要从其他用户默认权限（rw）减去 2，也就是去掉写（ w ）权限，则其他人的权限为 rw - w = r，则创建文件的最终默认权限为 -rw-rw-r– 。</p>
<h4 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h4><blockquote>
<p><strong>history</strong></p>
<blockquote>
<p>history<br>案例1:显示所有的历史命令<br>history 10<br>案例2:显示最近使用过的10个指<br>!5<br>案例3:执行历史编号为5的指令 </p>
</blockquote>
</blockquote>
<h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><p><strong>查询时间</strong></p>
<blockquote>
<p><strong>date<br>date +%Y-%m-%d<br>date “+%Y-%m-%d %H:%M:%S”(不加引号的话，中间的空格会让系统认为是两段，报错)</strong></p>
</blockquote>
<p><strong>设置时间</strong></p>
<blockquote>
<p><strong>date -s “2022-5-31 12:24:45”</strong></p>
</blockquote>
<p><strong>显示日历</strong></p>
<blockquote>
<p><strong>cal</strong></p>
</blockquote>
<p><strong>实时查看</strong></p>
<blockquote>
<p>watch -n1 ‘more log.txt’</p>
<p>每隔1s查看一次log</p>
</blockquote>
<h4 id="查找和定位"><a href="#查找和定位" class="headerlink" title="查找和定位"></a>查找和定位</h4><blockquote>
<p><strong>find 范围 选项</strong><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/find.png" alt="find"><br><strong>locate 文件名（注意：执行之前需要先执行updatedb）</strong><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/locate.png" alt="find"><br><strong>which 指令名  该指令用来查找指令在什么地方<br>grep 参数 需要查找的字符串,查找的字符串所在的文件（一般需要与其他配合）<br>-i忽略大小写 -n显示行号 -v 排除此关键字</strong><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/grep.png" alt="find"></p>
</blockquote>
<p><strong>awk</strong></p>
<p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk [选项参数] &#x27;script&#x27; var=value file(s)</span><br><span class="line">或</span><br><span class="line">awk [选项参数] -f scriptfile var=value file(s)</span><br></pre></td></tr></table></figure>

<ul>
<li>-F fs or –field-separator fs<br>指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。 默认分隔符为空格</li>
<li>-v var=value or –asign var=value<br>赋值一个用户定义变量。</li>
<li>-f scripfile or –file scriptfile<br>从脚本文件中读取awk命令。</li>
</ul>
<blockquote>
<p>2 this is a test<br>3 Do you like awk<br>This’s a test<br>10 There are orange,apple,mongo</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 每行按空格或TAB分割，输出文本中的1、4项,单引号为行匹配</span><br><span class="line"> $ awk &#x27;&#123;print $1,$4&#125;&#x27; log.txt</span><br><span class="line"> ---------------------------------------------</span><br><span class="line"> 2 a</span><br><span class="line"> 3 like</span><br><span class="line"> This&#x27;s</span><br><span class="line"> 10 orange,apple,mongo</span><br><span class="line"> </span><br><span class="line"> # 使用&quot;,&quot;分割</span><br><span class="line"> $  awk -F, &#x27;&#123;print $1,$2&#125;&#x27;   log.txt</span><br><span class="line"> ---------------------------------------------</span><br><span class="line"> 2 this is a test</span><br><span class="line"> 3 Do you like awk</span><br><span class="line"> This&#x27;s a test</span><br><span class="line"> 10 There are orange apple</span><br><span class="line"> # 或者使用内建变量</span><br><span class="line"> $ awk &#x27;BEGIN&#123;FS=&quot;,&quot;&#125; &#123;print $1,$2&#125;&#x27;     log.txt</span><br><span class="line"> ---------------------------------------------</span><br><span class="line"> 2 this is a test</span><br><span class="line"> 3 Do you like awk</span><br><span class="line"> This&#x27;s a test</span><br><span class="line"> 10 There are orange apple</span><br><span class="line"> # 使用多个分隔符.先使用空格分割，然后对分割结果再使用&quot;,&quot;分割</span><br><span class="line"> $ awk -F &#x27;[ ,]&#x27;  &#x27;&#123;print $1,$2,$5&#125;&#x27;   log.txt</span><br><span class="line"> ---------------------------------------------</span><br><span class="line"> 2 this test</span><br><span class="line"> 3 Are awk</span><br><span class="line"> This&#x27;s a</span><br><span class="line"> 10 There apple</span><br></pre></td></tr></table></figure>



<h4 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h4><blockquote>
<p><strong>压缩：gzip 文件名<br>解压：gunzip 文件名.gz<br>压缩：zip [选项] 压缩成什么名字 压缩的文件<br>解压 unzip 解压的地方 解压的文件</strong><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/zip.png" alt="find"><br><strong>tar</strong></p>
<p>c:create  f:filename   z:gz压缩</p>
<p><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/tar.png" alt="find"></p>
</blockquote>
<h4 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h4><p><strong>etc/passwd文件</strong></p>
<p><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240223171747789.png" alt="image-20240223171747789"></p>
<blockquote>
<p><strong>su 切换为root用户</strong><br><strong>logout 用户注销登录(root用户会降级为普通用户)<br>who am i 查看当前用户</strong></p>
<p><strong>id查看当前用户信息</strong></p>
</blockquote>
<p><strong>添加用户</strong></p>
<blockquote>
<p><strong>useradd 选项 用户名</strong><br>选项:<br>-c comment 指定一段注释性描述。<br>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。<br>-g 用户组 指定用户所属的用户组。<br>-G 用户组，用户组 指定用户所属的附加组。<br>-s Shell文件 指定用户的登录Shell。<br>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。<br>用户名:指定新账号的登录名。</p>
<blockquote>
<p>useradd –d  /home/sam -m sam<br>此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）。<br>useradd -s /bin/sh -g group –G adm,root gem<br>此命令新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。</p>
</blockquote>
</blockquote>
<p><strong>删除用户</strong></p>
<blockquote>
<p><strong>userdel 选项 用户名</strong><br>常用的选项是 -r，它的作用是把用户的主目录一起删除。</p>
<blockquote>
<p>userdel -r sam<br>此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p>
</blockquote>
</blockquote>
<p><strong>更改用户</strong></p>
<blockquote>
<p><strong>usermod 选项 用户名</strong><br>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</p>
<blockquote>
<p>usermod -s /bin/ksh -d /home/z –g developer sam</p>
</blockquote>
</blockquote>
<p><strong>更改密码</strong></p>
<blockquote>
<p><strong>passwd 选项 用户名</strong></p>
</blockquote>
<p><strong>增加一个新的用户组</strong></p>
<blockquote>
<p><strong>groupadd 选项 用户组</strong><br>-g GID 指定新用户组的组标识号（GID）。</p>
<blockquote>
<p>groupadd -g 101 group2<br>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。</p>
</blockquote>
</blockquote>
<p><strong>删除一个已有的用户组</strong></p>
<blockquote>
<p><strong>groupdel 用户组</strong></p>
</blockquote>
<p><strong>/etc/passwd文件是用户管理工作涉及的最重要的一个文件。</strong></p>
<blockquote>
<p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。<br>这个文件对所有用户都是可读的。<br>bin:x:2:2:Owner of system commands:/bin:<br>sys:x:3:3:Owner of system files:/usr/sys:sam:x:200:50:Sam san:/home/sam:/bin/sh<br>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</p>
</blockquote>
<p><strong>查看用户</strong></p>
<blockquote>
<p><strong>cat /etc/passwd</strong></p>
</blockquote>
<p><strong>查看指定用户信息</strong></p>
<blockquote>
<p><strong>id 用户名</strong></p>
</blockquote>
<p><strong>查看用户组</strong></p>
<blockquote>
<p><strong>cat /etc/group</strong><br><strong>“用户名”是代表用户账号的字符串。</strong><br>通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。<br>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。<br><strong>“口令”一些系统中，存放着加密后的用户口令字。</strong><br>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。<br><strong>“用户标识号”是一个整数，系统内部用它来标识用户。</strong><br>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。<br>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。<br><strong>“组标识号”字段记录的是用户所属的用户组。</strong><br>它对应着/etc/group文件中的一条记录。<br><strong>“注释性描述”字段记录着用户的一些个人情况。</strong><br>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。<br><strong>“主目录”，也就是用户的起始工作目录。</strong><br>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。<br>用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。<br><strong>Shell是用户与Linux系统之间的接口。</strong><br>Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。<br>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。<br>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。<br>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。<br><strong>系统中有一类用户称为伪用户（pseudo users）。</strong><br>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。<br>常见的伪用户如下所示：<br>伪 用 户 含 义<br>bin 拥有可执行的用户命令文件<br>sys 拥有系统文件<br>adm 拥有帐户文件<br>uucp UUCP使用<br>lp lp或lpd子系统使用<br>nobody NFS使用</p>
</blockquote>
<h4 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h4><p><strong>crontab</strong></p>
<p>我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。</p>
<blockquote>
<p>/var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名<br>/etc/crontab 这个文件负责调度各种管理和维护任务。<br>/etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。<br>我们还可以把脚本放在/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期、月执行一次。</p>
</blockquote>
<blockquote>
<p><strong>crontab [-u username]</strong>　　　　//省略用户表表示操作当前用户的crontab<br>    -e      (编辑工作表)<br>    -l      (列出工作表里的命令)<br>    -r      (删除工作作)</p>
</blockquote>
<blockquote>
<p>我们用crontab -e进入当前用户的工作表编辑，是常见的vim界面。每行是一条命令。<br>crontab的命令构成为 时间+动作，其时间有分、时、日、月、周五种，操作符有<br>* 取值范围内的所有数字<br>/ 每过多少个数字<br>- 从X到Z<br>，散列数字</p>
<blockquote>
<p>实例1：每1分钟执行一次myCommand<br>* * * * * myCommand<br>实例2：每小时的第3和第15分钟执行<br>3,15 * * * * myCommand<br>实例3：在上午8点到11点的第3和第15分钟执行<br>3,15 8-11 * * * myCommand<br>实例4：每隔两天的上午8点到11点的第3和第15分钟执行<br>3,15 8-11 */2  *  * myCommand<br>实例5：每周一上午8点到11点的第3和第15分钟执行<br>3,15 8-11 * * 1 myCommand<br>实例6：每晚的21:30重启smb<br>30 21 * * * /etc/init.d/smb restart<br>实例7：每月1、10、22日的4 : 45重启smb<br>45 4 1,10,22 * * /etc/init.d/smb restart<br>实例8：每周六、周日的1 : 10重启smb<br>10 1 * * 6,0 /etc/init.d/smb restart<br>实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb<br>0,30 18-23 * * * /etc/init.d/smb restart<br>实例10：每星期六的晚上11 : 00 pm重启smb<br>0 23 * * 6 /etc/init.d/smb restart<br>实例11：每一小时重启smb<br>0 */1 * * * /etc/init.d/smb restart<br>实例12：晚上11点到早上7点之间，每隔一小时重启smb<br>0 23-7/1 * * * /etc/init.d/smb restart</p>
</blockquote>
</blockquote>
<p><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/corn.png" alt="corn"></p>
<p><strong>at</strong></p>
<blockquote>
<p><strong>at [选项] [时间]</strong><br>-m    当 at 工作完成后，无论命令是否输出，都用 E-mail 通知执行 at 命令的用户。<br>-c 工作标识号    显示该 at 工作的实际内容。<br>-t 时间    在指定时间提交工作并执行，时间格式为 [[CC]YY]MMDDhhmm。<br>-d    删除某个工作，需要提供相应的工作标识号（ID），同 atrm 命令的作用相同。<br>-l    列出当前所有等待运行的工作，和 atq 命令具有相同的额作用。<br>-f 脚本文件    指定所要提交的脚本文件。</p>
</blockquote>
<blockquote>
<p>HH:MM    比如 04:00 AM。如果时间已过，则它会在第二天的同一时间执行。<br>Midnight（midnight）    代表 12:00 AM（也就是 00:00）。<br>Noon（noon）    代表 12:00 PM（相当于 12:00）。<br>Teatime（teatime）    代表 4:00 PM（相当于 16:00）。<br>英文月名 日期 年份    比如 January 15 2018 表示 2018 年 1 月 15 号，年份可有可无。<br>MMDDYY、MM/DD/YY、MM.DD.YY    比如 011518 表示 2018 年 1 月 15 号。<br>now+时间    以 minutes、hours、days 或 weeks 为单位，例如 now+5 days 表示命令在 5 天之后的此时此刻执行。</p>
</blockquote>
<blockquote>
<p>ctrl+d保存退出  ctrl+backspace 删除</p>
<blockquote>
<p>at 02:00 2013-07-26<br>at&gt; /bin/sync<br>at&gt; /sbin/shutdown -h now<br>at&gt; <EOT><br>job 9 at 2013-07-26 02:00<br>在指定的时间关机。在一个at任务中是可以执行多个系统命令的<br><strong>atq</strong><br>9 2013-07-26 02：00 a root<br>说明root用户有一个at任务在2013年7月26日02：00执行，工作号是9<br><strong>atrm [工作号]</strong><br>删除指定的at任务<br><strong>atrm 9</strong><br><strong>atq</strong><br>删除9号at任务，再查询就没有at任务存在了</EOT></p>
</blockquote>
</blockquote>
<h4 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h4><p><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E5%88%86%E5%8C%BA.png" alt="分区"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E5%88%86%E5%8C%BA2.png" alt="分区"></p>
<p><strong>多个物理磁盘联合为一个逻辑磁盘</strong></p>
<p><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20240226094810982.png" alt="image-20240226094810982"></p>
<p><strong>查看挂载</strong></p>
<blockquote>
<p><strong>lsblk 或者 lsblk -f</strong></p>
</blockquote>
<p><strong>查询磁盘使用情况</strong></p>
<blockquote>
<p><strong>df -h</strong></p>
</blockquote>
<p><strong>查看指定目录占用</strong></p>
<blockquote>
<p><strong>du -h</strong><br>查询指定目录的磁盘占用情况，默认为当前目录-S指定目录占用大小汇总<br>-h带计量单位<br>-a含文件<br>–max-depth=1 子目录深度-列出明细的同时，增加汇总值</p>
</blockquote>
<p><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/dns.png" alt="dns"></p>
<p><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/dns2.png" alt="dns"></p>
<h4 id="Linux进程"><a href="#Linux进程" class="headerlink" title="Linux进程"></a>Linux进程</h4><blockquote>
<p><strong>ps [options] [–help]</strong><br>参数：<br>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义<br>-A 列出所有的进程<br>ps -e 会列出系统中所有的进程，包括系统进程和用户进程，但不包括无控制终端的进程。<br>ps -a 会列出当前终端下的所有进程，包括已经停止或者已经完成的进程。<br>-w 显示加宽可以显示较多的资讯<br>-au 显示较详细的资讯<br>-aux 显示所有包含其他使用者的进程</p>
<blockquote>
<p>au(x) 输出格式 :<br>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND<br>USER: 行程拥有者<br>PID: 本进程号pid<br>ppid: 子进程号<br>%CPU: 占用的 CPU 使用率<br>%MEM: 占用的记忆体使用率<br>VSZ: 占用的虚拟记忆体大小<br>RSS: 占用的记忆体大小<br>TTY: 终端的次要装置号码 (minor device number of tty)<br>STAT: 该行程的状态:<br>D: 无法中断的休眠状态 (通常 IO 的进程)<br>R: 正在执行中<br>S: 静止状态<br>T: 暂停执行<br>Z: 不存在但暂时无法消除<br>W: 没有足够的记忆体分页可分配<br>&lt;: 高优先序的行程<br>N: 低优先序的行程<br>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)<br>START: 行程开始时间<br>TIME: 执行的时间<br>COMMAND:所执行的指令</p>
</blockquote>
</blockquote>
<p><strong>kill</strong><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/kill.png" alt="kill"><br><strong>kill [-s &lt;信息名称或编号&gt;][程序]　或　kill [-l &lt;信息编号&gt;]</strong></p>
<blockquote>
<p>-l &lt;信息编号&gt; 　若不加&lt;信息编号&gt;选项，则 -l 参数会列出全部的信息名称。<br>-s &lt;信息名称或编号&gt; 　指定要送出的信息。<br>[程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。<br>使用 kill -l 命令列出所有可用信号。<br>最常用的信号是：<br>1 (HUP)：重新加载进程。<br>9 (KILL)：杀死一个进程。<br>15 (TERM)：正常停止一个进程。</p>
<blockquote>
<p>杀死进程<br> kill 12345<br>强制杀死进程<br> kill -KILL 123456<br>发送SIGHUP信号，可以使用一下信号<br> kill -HUP pid<br>彻底杀死进程<br> kill -9 123456</p>
</blockquote>
</blockquote>
<p>**&amp;后台执行程序   jobs查询后台程序   kill %1停止后台序号为1的程序 **</p>
<p><strong>pstree 进程树</strong></p>
<p><strong>服务</strong><br><strong>service</strong><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/service.png" alt="service"></p>
<p>利用 netstat 指令可让你得知整个 Linux 系统的网络情况。</p>
<blockquote>
<p><strong>netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][–ip]</strong><br>参数说明：<br>-a或–all 显示所有连线中的Socket。<br>-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。<br>-c或–continuous 持续列出网络状态。<br>-C或–cache 显示路由器配置的快取信息。<br>-e或–extend 显示网络其他相关信息。<br>-F或–fib 显示路由缓存。<br>-g或–groups 显示多重广播功能群组组员名单。<br>-h或–help 在线帮助。<br>-i或–interfaces 显示网络界面信息表单。<br>-l或–listening 显示监控中的服务器的Socket。<br>-M或–masquerade 显示伪装的网络连线。<br>-n或–numeric 直接使用IP地址，而不通过域名服务器。<br>-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。<br>-o或–timers 显示计时器。<br>-p或–programs 显示正在使用Socket的程序识别码和程序名称。<br>-r或–route 显示Routing Table。<br>-s或–statistics 显示网络工作信息统计表。<br>-t或–tcp 显示TCP传输协议的连线状况。<br>-u或–udp 显示UDP传输协议的连线状况。<br>-v或–verbose 显示指令执行过程。<br>-V或–version 显示版本信息。<br>-w或–raw 显示RAW传输协议的连线状况。<br>-x或–unix 此参数的效果和指定”-A unix”参数相同。<br>–ip或–inet 此参数的效果和指定”-A inet”参数相同。</p>
</blockquote>
<p><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB.png" alt="运行级别"></p>
<p><strong>systemctl命令</strong><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/systemctl.png" alt="sysemctl"></p>
<p><strong>firewall</strong></p>
<blockquote>
<p>打开端口::firewall-cmd –permanent –add-port=端口号/协议<br>netstat -anp | more<br>关闭端口：firewall-cmd –permanent –remove-port=端口号/协议<br>重新载入：firewall-cmd –reload<br>查询端口是否开放：firewall-cmd –permanent –query-port=端口号/协议<br>查询开放的端口：firewall-cmd  –zone=public –list-ports</p>
</blockquote>
<p><strong>top</strong><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/top.png" alt="top"></p>
<p><strong>free查看内存</strong></p>
<p>free -m awk ‘NR==2 {print $NF}</p>
<ul>
<li><p><code>free</code> 命令用于显示系统内存的使用情况和交换空间的使用情况。</p>
</li>
<li><p><code>-m</code> 选项表示以兆字节（MB）为单位显示内存使用情况。</p>
</li>
<li><pre><code>awk &#39;NR==2 &#123;print $NF&#125;&#39;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">是一个用 AWK 编写的脚本，用于处理 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
free
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> 命令的输出。在这个脚本中：</span><br><span class="line"></span><br><span class="line">- `NR==2` 表示选择 `free` 输出的第二行。</span><br><span class="line">- `&#123;print $NF&#125;` 打印该行的最后一个字段，也就是内存使用情况的值（以兆字节为单位）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
free -m | awk &#39;NR==1 &#123;print $1&#125;&#39;
</code></pre>
</li>
</ul>
<p>它会打印出<code>free</code>命令输出的第一行的第一个字段，通常是表头中的标签，例如”total”或”Mem”。</p>
<h4 id="rpm和yum"><a href="#rpm和yum" class="headerlink" title="rpm和yum"></a>rpm和yum</h4><p><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/rpm1.png" alt="rpm"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/rpm2.png" alt="rpm"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/rpm3.png" alt="rpm"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/rpm4.png" alt="rpm"></p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>保存在/var/log目录下<br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/log.png" alt="log"></p>
<p>尝试使用错误的密码登录系统 查看/var/log/secure文件<br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/login_failed.png" alt="log"></p>
<p><strong>日志管理服务rsyslogd</strong><br>CentOS7.6日志服务是rsyslogd ,CentOS6.x日志服务是syslogd 。rsyslogd 功能更强大.rsyslogd的使用、日志文件的格式，和syslogd服务兼容的。<br>查询Linux 中的rsyslogd 服务是否启动</p>
<blockquote>
<p>ps -aux | grep “rsyslog” | grep -v “grep”</p>
</blockquote>
<p>查询rsyslogd服务的自启动状态</p>
<blockquote>
<p>systemctl list-unit-files | grep rsyslog</p>
</blockquote>
<p><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/log2.png" alt="log"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/log3.png" alt="log"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/log4.png" alt="log"></p>
<p>增加自己的日志文件<br>在/etc/rsyslog.conf配置文件中加入自己的配置信息，可以根据日志类型.日志级别进行添加，添加到/var/log/目录下</p>
<p><strong>日志轮替</strong><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/log5.png" alt="log"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/log6.png" alt="log"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/log7.png" alt="log"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/log8.png" alt="log"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/log9.png" alt="log"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/log10.png" alt="log"><br><strong>查看内存日志</strong><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/log11.png" alt="log"></p>
<h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p><strong>1.直接使用tar备份压缩文件</strong><br><strong>2.使用dump和restore</strong></p>
<blockquote>
<p>安装<br><strong>yum -y install dump<br>yum -y install restore</strong></p>
</blockquote>
<p><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/dump1.png" alt="dump"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/dump2.png" alt="dump"></p>
<p>只要备份层级选择了0就会全量备份。第n次就是增量备份。<br>dump增量备份只支持分区，不支持目录，增量备份指的是1-9，不包括0，0是全部备份<br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/dump4.png" alt="dump"><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/dump3.png" alt="dump"></p>
<p><strong>Restore恢复</strong><br><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/restore1.png" alt="restore"></p>
<p>q:linux restore -C 命令怎么知道备份文件的源文件在哪里呢?<br>a:使用 linux restore -C 命令恢复备份文件时，需要指定备份文件的路径和名称。在执行命令时，需要知道备份文件的源文件在哪里，以便正确地恢复数据。通常，在备份数据时，会在备份文件名中包含源文件的路径信息，或者将备份文件保存在与源文件相同的目录中，以便在恢复数据时更容易找到备份文件。如果无法确定备份文件的源文件位置，可以尝试通过查看备份文件的元数据信息来获取相关信息。</p>
<p>q:这个对比命令是不是只能检测和原来相比少的文件?<br>a:是的，linux restore命令主要用于恢复备份文件，它只会检测和原来相比少的文件，并将其恢复到指定的目录中。如果备份文件中包含的文件数量与原始文件数量相同，那么restore命令不会执行任何操作，因为没有需要恢复的文件。如果备份文件中包含的文件数量比原始文件数量少，那么restore命令只会恢复备份文件中缺少的文件。如果备份文件中包含的文件数量比原始文件数量多，那么restore命令只会恢复备份文件中原始文件没有覆盖的部分。</p>
<p><img src="/2023/05/16/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/restore2.png" alt="restore"></p>
<h4 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h4><p>webmin<br>bt宝塔</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机通信的三种模式</title>
    <url>/2023/05/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>桥接：</strong> 这种模式下虚拟机会映射到主机网卡，使用和主机同一网段的ip<br><strong>NAT：</strong> 虚拟机会映射到主机虚拟网卡，一般不会和主机在同一网段<br><strong>仅主机：</strong> 只能和主机通信</p>
]]></content>
      <tags>
        <tag>计算机基础</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>异步和回调函数</title>
    <url>/2023/05/10/%E5%BC%82%E6%AD%A5%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>q:</strong> 假如有12345这5个步骤，3步骤依赖2步骤的返回值，可以把2给别的线程运行，把3当作回调函数一起随着2给别的线程，主线程执行完1后直接执行45。这样对吗</p>
<p><strong>a:</strong> 可以将步骤2和步骤3放在另一个线程中执行，以避免阻塞主线程。具体的执行方式可以是将步骤2和步骤3作为一个整体，一起传递给另一个线程执行，当步骤2完成后，执行步骤3，然后将结果返回给主线程。主线程可以先执行步骤1，然后将步骤2和步骤3作为回调函数传递给另一个线程执行。当另一个线程执行完步骤2和步骤3后，将结果返回给主线程，主线程再执行步骤4和步骤5。需要注意的是，步骤2和步骤3执行的顺序不能颠倒，否则会导致步骤3无法获取到步骤2的返回值。此外，步骤2和步骤3执行的时间可能会比较长，需要合理地安排线程的执行顺序和调度，以保证程序的性能和响应速度。</p>
<p><strong>q:</strong> 这算异步吗</p>
<p><strong>a:</strong> 是的，将某些步骤放在另一个线程中执行，并将回调函数传递给另一个线程执行，是一种异步操作的实现方式。异步操作是指程序在执行某些任务时，不必等待任务完成，而是可以继续执行其他任务。这样可以提高程序的性能和响应速度.在上述例子中，将某些步骤放在另一个线程中执行，可以避免阻塞主线程，提高程序的性能和响应速度。同时，将回调函数传递给另一个线程执行，也是一种异步操作的实现方式，可以让程序在执行异步操作时不必等待操作完成，而是可以继续执行其他任务。因此，这算异步操作。</p>
]]></content>
  </entry>
  <entry>
    <title>沁园春 长沙</title>
    <url>/2023/04/18/%E6%B2%81%E5%9B%AD%E6%98%A5-%E9%95%BF%E6%B2%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>独立寒秋，湘江北去，橘子洲头。<br>看万山红遍，层林尽染；漫江碧透，百舸争流。<br>鹰击长空，鱼翔浅底，万类霜天竞自由。<br>怅寥廓，问苍茫大地，谁主沉浮？</p>
<p>携来百侣曾游。忆往昔峥嵘岁月稠。<br>恰同学少年，风华正茂；书生意气，挥斥方遒。<br>指点江山，激扬文字，粪土当年万户侯。<br>曾记否，到中流击水，浪遏飞舟？</p>
]]></content>
  </entry>
  <entry>
    <title>gitee</title>
    <url>/2023/04/14/gitee/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本来想着在国内的gitee创建一个blog，一通操作完库资料都上传好了，居然要实名认证，这也就算了，还要手持身份证？？？我还是老老实实去github吧。</p>
]]></content>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>关于sizeof的一些问题</title>
    <url>/2023/04/10/%E5%85%B3%E4%BA%8Esizeof%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>原本觉的c语言学的还不错，看到求结构体大小的例子，心想这不是很简单吗，不就是把所有成员的大小加起来就行了，其实远没我想的简单。</p>
<h6 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h6><blockquote>
<p>typedef struct<br>{<br>    char c;<br>    int b;<br>    short d;<br>}A;</p>
</blockquote>
<p><strong>我做的是char占1字节，int占4字节，short占2字节，1 + 4 + 2 = 7. 总共占7字节。完全错误。</strong></p>
<blockquote>
<p>12</p>
</blockquote>
<h6 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h6><blockquote>
<p>typedef struct<br>{<br>        char c;<br>    short d;<br>    int b;<br>}B;</p>
</blockquote>
<blockquote>
<p>8</p>
</blockquote>
<p><strong>结构体每个成员相对结构体首地址的偏移量(offset)是对齐参数的整 数倍，如有需要会在成员之间填充字节。编译器在为结构体成员开辟空间时，首先检查预开辟空间的地址相对于结构体首地址的偏移量是否为对齐参数的整数倍，若是，则存放该成员；若不是，则填充若干字节，以达到整数倍的要求</strong></p>
<p><strong>结构体变量所占空间的大小是对齐参数大小的整数倍。如有需要会在最后一个成员末尾填充若干字节使得所占空间大小是对齐参数大小的整数倍。</strong></p>
<p><strong>它是取结构体中所有变量的对齐参数的最大值和系统默认对齐参数#pragma pack(n)比较，较小者作为对齐参数。举个例子假如在结构体A中先后定义了两个变量int a;double b;对于变量a，它的自身对齐参数为4，而#pragma pack(n)值默认为8，则a的对齐参数为4；b的自身对齐参数为8，而#pragma pack(n)的默认值为8，则b的对齐参数为8。即结构体内的每个遍历也要取自身的对齐参数和默认对齐参数比较，取较小者作为这个变量的对齐参数。由于a的最终对齐参数为4，b的最终对齐参数为8，那么两者较大者是8，然后再拿8和#pragma pack(n)作比较，取较小者作为对齐参数，也就是8，即意味着结构体最终的大小必须能被8整除。</strong></p>
<p><em>其实这些话叽里呱啦我也懒得看，上图吧</em></p>
<p><img src="/2023/04/10/%E5%85%B3%E4%BA%8Esizeof%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/img.png" alt="解释"></p>
<p><em><strong><center>Are you OK?</center></strong></em></p>
]]></content>
      <tags>
        <tag>code</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++:指针常量和常量指针</title>
    <url>/2023/04/09/C-%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="常量指针与指针常量的区分"><a href="#常量指针与指针常量的区分" class="headerlink" title="常量指针与指针常量的区分"></a>常量指针与指针常量的区分</h2><h4 id="常量指针-const-int-p"><a href="#常量指针-const-int-p" class="headerlink" title="常量指针(const int* p)"></a>常量指针(const int* p)</h4><p>常量指针本质上是一个指针，是一个指向“常量”的指针，即不能通过指针改变指向对象的值（不能解除引用），但可以更改指向。用法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=3,b=4;</span><br><span class="line">const int *p=&amp;a;  /初始化指向a</span><br><span class="line">p=&amp;b;  /可以更改指向，现在指向b</span><br><span class="line">*p=5; /不可以通过指针改变对象的值</span><br></pre></td></tr></table></figure>
<h4 id="指针常量-int-const-p"><a href="#指针常量-int-const-p" class="headerlink" title="指针常量(int* const p)"></a>指针常量(int* const p)</h4><p>指针常量本质上是一个常量，const是修饰p的，即指针的值自身是一个常量，不可改变，始终指向一个地址，在创建的同时必须进行初始化，用法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=3,b=4;</span><br><span class="line">int* const p=&amp;a; /初始化指向a</span><br><span class="line">*p=5; /可以进行解引用，更改指向对象的值</span><br><span class="line">p=&amp;b; /不可以更改指向</span><br></pre></td></tr></table></figure>
<h4 id="区分"><a href="#区分" class="headerlink" title="区分:"></a>区分:</h4><figure class="highlight plaintext"><figcaption><span>a</span></figcaption><table><tr><td class="code"><pre><span class="line">const int c=5; /常量，创建时就需要初始化</span><br><span class="line">const int* p1; /常量指针</span><br><span class="line">int* const p2=&amp;a; /指针常量，创建时就需要初始化，指向a</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">int *wrong=&amp;c; /错误，常量地址不能初始化普通指针，只能赋值给常量指针</span><br><span class="line">int* const p=&amp;c; /错误，报错：无法从“const int *”转换为“int *”，即必须拥有相同的底层const资格</span><br><span class="line">p1=&amp;c; /正确，只能赋值给常量指针</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">const int* const p3=&amp;a; /指向“常量”的指针常量，具有常量指针和指针常量的特点，指针内容不能改变，也不能指向其他地方，定义同时要进行初始化</span><br><span class="line">*p3=5; /错误</span><br><span class="line">p3=&amp;b; /错误</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">char* p4=&quot;abc&quot;; /&quot;abc&quot;是字符常量放在常量区，p4指向的是&quot;abc&quot;的首地址，即&#x27;a&#x27;的地址</span><br><span class="line">*p4=&#x27;b&#x27;; /错误，*p4相当于对字符&#x27;a&#x27;修改，但&quot;abc&quot;是一个字符串常量，不可修改</span><br></pre></td></tr></table></figure>


<h2 id="常量引用与引用常量区分"><a href="#常量引用与引用常量区分" class="headerlink" title="常量引用与引用常量区分"></a>常量引用与引用常量区分</h2><h4 id="常量引用-const-int-amp-a"><a href="#常量引用-const-int-amp-a" class="headerlink" title="常量引用(const int&amp; a)"></a>常量引用(const int&amp; a)</h4><p>本质上是一个引用，对常量的引用，不能通过引用改变绑定对象的值<br>注：当初始化值是一个字面值时，则只能对一个const T&amp;（常量引用）赋值。而且这个赋值是有一个过程的：首先将值隐式转换到类型T，然后将这个转换结果存放在一个临时对象里，最后用这个临时对象来初始化这个引用变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=3;</span><br><span class="line">const int&amp; reference1=a;</span><br><span class="line">const int&amp; reference2=5;/ 对常量、字面值的引用只能通过常量引用，会创建一个临时对象，用这个对象进行初始化</span><br><span class="line">reference1=5; /错误，常量引用不能改变对象的值</span><br></pre></td></tr></table></figure>
<h4 id="引用常量-int-amp-const-t"><a href="#引用常量-int-amp-const-t" class="headerlink" title="引用常量(int&amp; const t???)"></a>引用常量(int&amp; const t???)</h4><p>注意：原则上不存在引用常量（所以我使用了？？？），会报warning C4227: 使用了记时错误: 忽略引用上的限定符。</p>
]]></content>
      <tags>
        <tag>code</tag>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
